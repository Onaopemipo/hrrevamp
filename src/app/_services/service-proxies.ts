/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class GetTokenServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getToken(body: UserLoginDTO | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/GetToken/GetToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class ValidateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param key_token (optional) 
     * @return Success
     */
    validate(key_token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/Validate/Validate?";
        if (key_token !== undefined && key_token !== null)
            url_ += "key_token=" + encodeURIComponent("" + key_token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidate(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processValidate(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class ForgotPasswordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    forgotPassword(email: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ForgotPassword/ForgotPassword?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ResetPasswordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResestPasswordDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ConfirmEmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param userId (optional) 
     * @param token (optional) 
     * @return Success
     */
    confirmEmail(userId: string | null | undefined, token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/ConfirmEmail/ConfirmEmail?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmail(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmEmail(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class FetchActivityLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param id (optional) 
     * @param moduleName (optional) 
     * @param operationType (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getActivityLog(id: number | undefined, moduleName: string | null | undefined, operationType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ActivityLogIListApiResult> {
        let url_ = this.baseUrl + "/api/ActivityLog/FetchActivityLog/GetActivityLog?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (moduleName !== undefined && moduleName !== null)
            url_ += "ModuleName=" + encodeURIComponent("" + moduleName) + "&";
        if (operationType !== undefined && operationType !== null)
            url_ += "OperationType=" + encodeURIComponent("" + operationType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityLog(<any>response_);
                } catch (e) {
                    return <Observable<ActivityLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityLog(response: HttpResponseBase): Observable<ActivityLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class PostServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateIAnnouncementType(body: AnnouncementTypeDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Announcement/Post/AddUpdateIAnnouncementType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateIAnnouncementType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateIAnnouncementType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateIAnnouncementType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateAnnouncement(body: AnnouncementDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Announcement/Post/AddUpdateAnnouncement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateAnnouncement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateAnnouncement(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateAnnouncement(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create  leave plan. Note all fields are required
     * @param body (optional) 
     * @return Success
     */
    createLeavePlan(body: LeavePlanDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/Post/CreateLeavePlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLeavePlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLeavePlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLeavePlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create and edit leave type. Note all fields are required
     * @param body (optional) 
     * @return Success
     */
    createLeaveType(body: LeaveTypeCreatePayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/Post/CreateLeaveType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLeaveType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLeaveType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLeaveType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create and edit leave year. Note: all fields are required
     * @param body (optional) 
     * @return Success
     */
    createLeaveYear(body: LeaveYearCreatePayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/Post/CreateLeaveYear";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLeaveYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLeaveYear(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLeaveYear(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateOnboardingPersonnalData(body: OnboardingPersonalDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/Post/AddUpdateOnboardingPersonnalData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateOnboardingPersonnalData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateOnboardingPersonnalData(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateOnboardingPersonnalData(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateOnboardingPaymentData(body: OnboardingBankDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/Post/AddUpdateOnboardingPaymentData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateOnboardingPaymentData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateOnboardingPaymentData(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateOnboardingPaymentData(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateOnboardingWorkData(body: OnboardingWorkDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/Post/AddUpdateOnboardingWorkData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateOnboardingWorkData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateOnboardingWorkData(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateOnboardingWorkData(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateOnboardingTaxData(body: OnboardingTaxDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/Post/AddUpdateOnboardingTaxData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateOnboardingTaxData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateOnboardingTaxData(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateOnboardingTaxData(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateOnboardingMedicalDisclosureData(body: OnboardingMedicalDisclosureDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/Post/AddUpdateOnboardingMedicalDisclosureData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateOnboardingMedicalDisclosureData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateOnboardingMedicalDisclosureData(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateOnboardingMedicalDisclosureData(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAnnouncementTypeByCriteriaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param iD (optional) 
     * @param catalog (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAnnouncementTypeByCriteria(iD: number | undefined, catalog: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<AnnouncementTypeListApiResult> {
        let url_ = this.baseUrl + "/api/Announcement/GetAnnouncementTypeByCriteria/GetAnnouncementTypeByCriteria?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (catalog !== undefined && catalog !== null)
            url_ += "Catalog=" + encodeURIComponent("" + catalog) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnnouncementTypeByCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnnouncementTypeByCriteria(<any>response_);
                } catch (e) {
                    return <Observable<AnnouncementTypeListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AnnouncementTypeListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAnnouncementTypeByCriteria(response: HttpResponseBase): Observable<AnnouncementTypeListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnnouncementTypeListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnnouncementTypeListApiResult>(<any>null);
    }

    /**
     * @param iD (optional) 
     * @param announcementMessage (optional) 
     * @param catalog (optional) 
     * @param departmentId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAnnouncementByCriteria(iD: number | undefined, announcementMessage: string | null | undefined, catalog: string | null | undefined, departmentId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<AnnouncementListApiResult> {
        let url_ = this.baseUrl + "/api/Announcement/GetAnnouncementTypeByCriteria/GetAnnouncementByCriteria?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (announcementMessage !== undefined && announcementMessage !== null)
            url_ += "AnnouncementMessage=" + encodeURIComponent("" + announcementMessage) + "&";
        if (catalog !== undefined && catalog !== null)
            url_ += "Catalog=" + encodeURIComponent("" + catalog) + "&";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnnouncementByCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnnouncementByCriteria(<any>response_);
                } catch (e) {
                    return <Observable<AnnouncementListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AnnouncementListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAnnouncementByCriteria(response: HttpResponseBase): Observable<AnnouncementListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnnouncementListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnnouncementListApiResult>(<any>null);
    }
}

@Injectable()
export class SubordinateAppraisalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving all Current Appraisal for Review by Line-Managers
     * @param cycleId (optional) 
     * @return Success
     */
    subordinateAppraisalLists(cycleId: number | undefined): Observable<AppraisalReviewerListDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Appraisal/SubordinateAppraisals/SubordinateAppraisalLists?";
        if (cycleId === null)
            throw new Error("The parameter 'cycleId' cannot be null.");
        else if (cycleId !== undefined)
            url_ += "cycleId=" + encodeURIComponent("" + cycleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubordinateAppraisalLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubordinateAppraisalLists(<any>response_);
                } catch (e) {
                    return <Observable<AppraisalReviewerListDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppraisalReviewerListDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSubordinateAppraisalLists(response: HttpResponseBase): Observable<AppraisalReviewerListDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppraisalReviewerListDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppraisalReviewerListDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetEmployeePerformanceReviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving Current Employees Appraisal for Review by Reviewer
     * @param reviewerContractId (optional) 
     * @param employeeContractId (optional) 
     * @param cycleId (optional) 
     * @param kraId (optional) 
     * @return Success
     */
    getEmployeePerformanceReview(reviewerContractId: number | undefined, employeeContractId: number | undefined, cycleId: number | undefined, kraId: number | undefined): Observable<KpiReviewDTOApiResult> {
        let url_ = this.baseUrl + "/api/Appraisal/GetEmployeePerformanceReview/GetEmployeePerformanceReview?";
        if (reviewerContractId === null)
            throw new Error("The parameter 'reviewerContractId' cannot be null.");
        else if (reviewerContractId !== undefined)
            url_ += "ReviewerContractId=" + encodeURIComponent("" + reviewerContractId) + "&";
        if (employeeContractId === null)
            throw new Error("The parameter 'employeeContractId' cannot be null.");
        else if (employeeContractId !== undefined)
            url_ += "EmployeeContractId=" + encodeURIComponent("" + employeeContractId) + "&";
        if (cycleId === null)
            throw new Error("The parameter 'cycleId' cannot be null.");
        else if (cycleId !== undefined)
            url_ += "CycleId=" + encodeURIComponent("" + cycleId) + "&";
        if (kraId === null)
            throw new Error("The parameter 'kraId' cannot be null.");
        else if (kraId !== undefined)
            url_ += "KraId=" + encodeURIComponent("" + kraId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeePerformanceReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeePerformanceReview(<any>response_);
                } catch (e) {
                    return <Observable<KpiReviewDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KpiReviewDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeePerformanceReview(response: HttpResponseBase): Observable<KpiReviewDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KpiReviewDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KpiReviewDTOApiResult>(<any>null);
    }
}

@Injectable()
export class SubmitEmployeeAppraisalReviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for submitting Employee's Appraisal Performance review for
    the KPIs under the assigned KRA by Reviewer
     * @param body (optional) 
     * @return Success
     */
    submitEmployeeAppraisalReview(body: PerformanceReviewDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Appraisal/SubmitEmployeeAppraisalReview/SubmitEmployeeAppraisalReview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitEmployeeAppraisalReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitEmployeeAppraisalReview(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitEmployeeAppraisalReview(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class EmployeePerformanceReviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving Current Appraisal for Review by Employee
     * @param reviewerContractId (optional) 
     * @param employeeContractId (optional) 
     * @param cycleId (optional) 
     * @param kraId (optional) 
     * @return Success
     */
    employeePerformanceReview(reviewerContractId: number | undefined, employeeContractId: number | undefined, cycleId: number | undefined, kraId: number | undefined): Observable<KpiReviewDTOApiResult> {
        let url_ = this.baseUrl + "/api/Appraisal/EmployeePerformanceReview/EmployeePerformanceReview?";
        if (reviewerContractId === null)
            throw new Error("The parameter 'reviewerContractId' cannot be null.");
        else if (reviewerContractId !== undefined)
            url_ += "ReviewerContractId=" + encodeURIComponent("" + reviewerContractId) + "&";
        if (employeeContractId === null)
            throw new Error("The parameter 'employeeContractId' cannot be null.");
        else if (employeeContractId !== undefined)
            url_ += "EmployeeContractId=" + encodeURIComponent("" + employeeContractId) + "&";
        if (cycleId === null)
            throw new Error("The parameter 'cycleId' cannot be null.");
        else if (cycleId !== undefined)
            url_ += "CycleId=" + encodeURIComponent("" + cycleId) + "&";
        if (kraId === null)
            throw new Error("The parameter 'kraId' cannot be null.");
        else if (kraId !== undefined)
            url_ += "KraId=" + encodeURIComponent("" + kraId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeePerformanceReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeePerformanceReview(<any>response_);
                } catch (e) {
                    return <Observable<KpiReviewDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KpiReviewDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeePerformanceReview(response: HttpResponseBase): Observable<KpiReviewDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KpiReviewDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KpiReviewDTOApiResult>(<any>null);
    }
}

@Injectable()
export class SubmitPerformanceReviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for submitting Employee's Performance review for the KPIs under the assigned KRA
     * @param body (optional) 
     * @return Success
     */
    submitEmployeePerformanceReview(body: PerformanceReviewDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Appraisal/SubmitPerformanceReview/SubmitEmployeePerformanceReview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitEmployeePerformanceReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitEmployeePerformanceReview(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitEmployeePerformanceReview(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetEmployeeAppraisalHistoriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving all Past Employee Appraisal Histories
     * @param cycleId (optional) 
     * @return Success
     */
    employeeAppraisalHistories(cycleId: number | undefined): Observable<EmployeeAppraisalHistoryDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Appraisal/GetEmployeeAppraisalHistories/EmployeeAppraisalHistories?";
        if (cycleId === null)
            throw new Error("The parameter 'cycleId' cannot be null.");
        else if (cycleId !== undefined)
            url_ += "cycleId=" + encodeURIComponent("" + cycleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeAppraisalHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeAppraisalHistories(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeAppraisalHistoryDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeAppraisalHistoryDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeAppraisalHistories(response: HttpResponseBase): Observable<EmployeeAppraisalHistoryDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeAppraisalHistoryDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeAppraisalHistoryDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class AssetManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetType(body: AssetTypeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addDeperciationProfile(body: AssetDeperciationProfileDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AddDeperciationProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDeperciationProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDeperciationProfile(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddDeperciationProfile(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetSubType(body: AssetSubTypeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetSubType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetSubType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetSubType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCatergory(body: AssetCategoryDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCatergory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCatergory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCatergory(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCatergory(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetStatus(body: AssetStatusDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetStatus(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetStatus(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetMake(body: AssetMakeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetMake";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetMake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetMake(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetMake(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetModel(body: AssetModelDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetModel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetModel(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetModel(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAsset(body: AssetDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AddAsset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAsset(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddAsset(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAssetRequest(body: AssetRequestDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AddAssetRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAssetRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAssetRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddAssetRequest(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assignment(body: AssignmentDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/Assignment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssignment(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCallback(body: AssetCallbackDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCallback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCallback(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCallback(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCheckIn(body: AssetcheckInFilter | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCheckIn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCheckIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCheckIn(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCheckIn(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCheckInComfirmation(body: AssetcheckInFilter | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCheckInComfirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCheckInComfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCheckInComfirmation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCheckInComfirmation(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAssetRequest(body: UpdateAssetRequest | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/UpdateAssetRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAssetRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAssetRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAssetRequest(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetType(body: AssetTypeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetSubType(body: AssetSubTypeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetSubType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetSubType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetSubType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetCategory(body: AssetCategoryDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetCategory(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetCategory(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetMake(body: AssetMakeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetMake";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetMake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetMake(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetMake(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetModel(body: AssetModelDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetModel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetModel(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetModel(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetStatus(body: AssetStatusDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetStatus(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetStatus(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getActivateAsset(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetActivateAsset?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivateAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivateAsset(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivateAsset(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getDeactivateAsset(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetDeactivateAsset?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeactivateAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeactivateAsset(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeactivateAsset(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetType(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetType?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetType(<any>response_);
                } catch (e) {
                    return <Observable<AssetTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetType(response: HttpResponseBase): Observable<AssetTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetTypeDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetSubType(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetSubTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetSubType?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetSubType(<any>response_);
                } catch (e) {
                    return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetSubType(response: HttpResponseBase): Observable<AssetSubTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetSubTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetSubTypeDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetCategory(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetCategoryDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetCategory?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetCategory(<any>response_);
                } catch (e) {
                    return <Observable<AssetCategoryDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetCategoryDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetCategory(response: HttpResponseBase): Observable<AssetCategoryDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetCategoryDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetCategoryDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetMake(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetMakeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetMake?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetMake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetMake(<any>response_);
                } catch (e) {
                    return <Observable<AssetMakeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetMakeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetMake(response: HttpResponseBase): Observable<AssetMakeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetMakeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetMakeDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetModel(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetModelDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetModel?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetModel(<any>response_);
                } catch (e) {
                    return <Observable<AssetModelDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetModelDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetModel(response: HttpResponseBase): Observable<AssetModelDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetModelDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetModelDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetStatus(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetStatusDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetStatus?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetStatus(<any>response_);
                } catch (e) {
                    return <Observable<AssetStatusDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetStatusDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetStatus(response: HttpResponseBase): Observable<AssetStatusDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetStatusDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetStatusDTOIListApiResult>(<any>null);
    }

    /**
     * @param assetTypeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetSubTypeByAssetTypeId(assetTypeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetSubTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetSubTypeByAssetTypeId?";
        if (assetTypeId === null)
            throw new Error("The parameter 'assetTypeId' cannot be null.");
        else if (assetTypeId !== undefined)
            url_ += "AssetTypeId=" + encodeURIComponent("" + assetTypeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetSubTypeByAssetTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetSubTypeByAssetTypeId(<any>response_);
                } catch (e) {
                    return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetSubTypeByAssetTypeId(response: HttpResponseBase): Observable<AssetSubTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetSubTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetSubTypeDTOIListApiResult>(<any>null);
    }

    /**
     * @param assetSubTypeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetbyAssetSubtypeId(assetSubTypeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetbyAssetSubtypeId?";
        if (assetSubTypeId === null)
            throw new Error("The parameter 'assetSubTypeId' cannot be null.");
        else if (assetSubTypeId !== undefined)
            url_ += "AssetSubTypeId=" + encodeURIComponent("" + assetSubTypeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetbyAssetSubtypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetbyAssetSubtypeId(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetbyAssetSubtypeId(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param assetmakeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetModelByAssetMakeId(assetmakeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetModelByAssetMakeId?";
        if (assetmakeId === null)
            throw new Error("The parameter 'assetmakeId' cannot be null.");
        else if (assetmakeId !== undefined)
            url_ += "AssetmakeId=" + encodeURIComponent("" + assetmakeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetModelByAssetMakeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetModelByAssetMakeId(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetModelByAssetMakeId(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getDepreciationProfile(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDeperciationProfileDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetDepreciationProfile?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepreciationProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepreciationProfile(<any>response_);
                } catch (e) {
                    return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepreciationProfile(response: HttpResponseBase): Observable<AssetDeperciationProfileDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDeperciationProfileDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDeperciationProfileDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getActiveassetlist(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDeperciationProfileDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetActiveassetlist?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveassetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveassetlist(<any>response_);
                } catch (e) {
                    return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveassetlist(response: HttpResponseBase): Observable<AssetDeperciationProfileDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDeperciationProfileDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDeperciationProfileDTOIListApiResult>(<any>null);
    }

    /**
     * @param employeeId (optional) 
     * @param assetId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetByAssigedEmployee(employeeId: number | undefined, assetId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetHistoryDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetByAssigedEmployee?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        if (assetId === null)
            throw new Error("The parameter 'assetId' cannot be null.");
        else if (assetId !== undefined)
            url_ += "AssetId=" + encodeURIComponent("" + assetId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetByAssigedEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetByAssigedEmployee(<any>response_);
                } catch (e) {
                    return <Observable<AssetHistoryDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetHistoryDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetByAssigedEmployee(response: HttpResponseBase): Observable<AssetHistoryDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetHistoryDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetHistoryDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class AzureStorageManagerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for downloading Document in form of Base64string by passing the filename
     * @param filename (optional) 
     * @return Success
     */
    downloadMiscDocument(filename: string | null | undefined): Observable<StringApiResult> {
        let url_ = this.baseUrl + "/api/AzureStorageManager/DownloadMiscDocument?";
        if (filename !== undefined && filename !== null)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadMiscDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadMiscDocument(<any>response_);
                } catch (e) {
                    return <Observable<StringApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadMiscDocument(response: HttpResponseBase): Observable<StringApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringApiResult>(<any>null);
    }

    /**
     * @param employeeNumber (optional) 
     * @param docType (optional) 
     * @return Success
     */
    fetchEmployeeDocuments(employeeNumber: string | null | undefined, docType: string | null | undefined): Observable<AzureDocsListApiResult> {
        let url_ = this.baseUrl + "/api/AzureStorageManager/FetchEmployeeDocuments?";
        if (employeeNumber !== undefined && employeeNumber !== null)
            url_ += "employeeNumber=" + encodeURIComponent("" + employeeNumber) + "&";
        if (docType !== undefined && docType !== null)
            url_ += "docType=" + encodeURIComponent("" + docType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEmployeeDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEmployeeDocuments(<any>response_);
                } catch (e) {
                    return <Observable<AzureDocsListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AzureDocsListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEmployeeDocuments(response: HttpResponseBase): Observable<AzureDocsListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AzureDocsListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AzureDocsListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateBudgetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for add/updating Budget for a particular period
     * @param body (optional) 
     * @return Success
     */
    addUpdateBudget(body: ManageBudgetDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Budget/AddUpdateBudget/Add-Update-Budget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateBudget(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateBudget(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllBudgetsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving All Budgets for further CRUD operation
     * @return Success
     */
    getAllBudgets(): Observable<BudgetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Budget/FetchAllBudgets/GetAllBudgets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBudgets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBudgets(<any>response_);
                } catch (e) {
                    return <Observable<BudgetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BudgetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBudgets(response: HttpResponseBase): Observable<BudgetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchGetBudgetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for getting Single Budget details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getGetBudget(id: number | undefined): Observable<BudgetDTOApiResult> {
        let url_ = this.baseUrl + "/api/Budget/FetchGetBudget/GetGetBudget?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGetBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGetBudget(<any>response_);
                } catch (e) {
                    return <Observable<BudgetDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BudgetDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGetBudget(response: HttpResponseBase): Observable<BudgetDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateBudgetItemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for add/updating BudgetItem and it's Allocations
     * @param body (optional) 
     * @return Success
     */
    addUpdateBudgetItem(body: ManageBudgetItemDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Budget/AddUpdateBudgetItem/Add-Update-BudgetItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateBudgetItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateBudgetItem(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateBudgetItem(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllBudgetItemsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving All BudgetItems for further CRUD operation
     * @return Success
     */
    getAllBudgetItems(): Observable<BudgetItemDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Budget/FetchAllBudgetItems/GetAllBudgetItems";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBudgetItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBudgetItems(<any>response_);
                } catch (e) {
                    return <Observable<BudgetItemDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BudgetItemDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBudgetItems(response: HttpResponseBase): Observable<BudgetItemDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetItemDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetItemDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchBudgetItemsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for getting BudgetItems that can be use for dropdowns
     * @return Success
     */
    getBudgetItems(): Observable<DisbursementBudgetItemIListApiResult> {
        let url_ = this.baseUrl + "/api/Budget/FetchBudgetItems/GetBudgetItems";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBudgetItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBudgetItems(<any>response_);
                } catch (e) {
                    return <Observable<DisbursementBudgetItemIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DisbursementBudgetItemIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetBudgetItems(response: HttpResponseBase): Observable<DisbursementBudgetItemIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DisbursementBudgetItemIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DisbursementBudgetItemIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchGetBudgetItemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for getting Single Budget details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getGetBudgetItem(id: number | undefined): Observable<BudgetItemDTOApiResult> {
        let url_ = this.baseUrl + "/api/Budget/FetchGetBudgetItem/GetGetBudgetItem?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGetBudgetItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGetBudgetItem(<any>response_);
                } catch (e) {
                    return <Observable<BudgetItemDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BudgetItemDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGetBudgetItem(response: HttpResponseBase): Observable<BudgetItemDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetItemDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetItemDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEmployeetoNineBoxGridServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating Employee to ninebox Grid
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmployeetoNineBoxGrid(body: NineGridBoxDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/AddUpdateEmployeetoNineBoxGrid/Add-Update-EmployeetoNineBoxGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmployeetoNineBoxGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmployeetoNineBoxGrid(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmployeetoNineBoxGrid(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class MoveEmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for Moving Employee
     * @param body (optional) 
     * @return Success
     */
    moveEmployee(body: ManageMoveEmployeeFilterDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/MoveEmployee/MoveEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveEmployee(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processMoveEmployee(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RemoveEmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for Remove Employee
     * @param body (optional) 
     * @return Success
     */
    removeEmployee(body: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/RemoveEmployee/RemoveEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveEmployee(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveEmployee(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetEmployeeebyGridBoxServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to Fetch  Employee by Grid Box.
    Note: all filter are optional
     * @param gridboxID (optional) 
     * @param departmentId (optional) 
     * @return Success
     */
    getEmployeebyGridBox(gridboxID: number | undefined, departmentId: number | undefined): Observable<NineGridBoxDTOListApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/GetEmployeeebyGridBox/GetEmployeebyGridBox?";
        if (gridboxID === null)
            throw new Error("The parameter 'gridboxID' cannot be null.");
        else if (gridboxID !== undefined)
            url_ += "gridboxID=" + encodeURIComponent("" + gridboxID) + "&";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeebyGridBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeebyGridBox(<any>response_);
                } catch (e) {
                    return <Observable<NineGridBoxDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<NineGridBoxDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeebyGridBox(response: HttpResponseBase): Observable<NineGridBoxDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NineGridBoxDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NineGridBoxDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetGridBoxCountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to Fetch by Grid Box counts.
    Note: all filter are optional
     * @param user_id (optional) 
     * @param employee_id (optional) 
     * @param employee_number (optional) 
     * @param employee_contract_id (optional) 
     * @param grade_id (optional) 
     * @param confirmation_date (optional) 
     * @param serial_no (optional) 
     * @param first_name (optional) 
     * @param last_name (optional) 
     * @param full_name (optional) 
     * @param other_name (optional) 
     * @param department (optional) 
     * @param department_id (optional) 
     * @param email (optional) 
     * @param phone_number (optional) 
     * @param email_confirmed (optional) 
     * @param session_token (optional) 
     * @param jwt_token (optional) 
     * @param user_token (optional) 
     * @param company_id (optional) 
     * @param licenseUsuage (optional) 
     * @param licenseCount (optional) 
     * @param company_name (optional) 
     * @param sub_id (optional) 
     * @param isAdmin (optional) 
     * @param isSuperAdmin (optional) 
     * @param isTenantAdmin (optional) 
     * @param isActiveBySysOrAdmin (optional) 
     * @param lstPermissions (optional) 
     * @param message (optional) 
     * @param isSuccessful (optional) 
     * @param retId (optional) 
     * @param redirectUrl (optional) 
     * @param errors (optional) 
     * @return Success
     */
    getGridBoxCount(user_id: number | undefined, employee_id: number | undefined, employee_number: string | null | undefined, employee_contract_id: number | undefined, grade_id: number | null | undefined, confirmation_date: Date | null | undefined, serial_no: string | null | undefined, first_name: string | null | undefined, last_name: string | null | undefined, full_name: string | null | undefined, other_name: string | null | undefined, department: string | null | undefined, department_id: number | undefined, email: string | null | undefined, phone_number: string | null | undefined, email_confirmed: boolean | undefined, session_token: string | null | undefined, jwt_token: string | null | undefined, user_token: string | null | undefined, company_id: number | undefined, licenseUsuage: number | undefined, licenseCount: number | undefined, company_name: string | null | undefined, sub_id: number | undefined, isAdmin: boolean | undefined, isSuperAdmin: boolean | undefined, isTenantAdmin: boolean | undefined, isActiveBySysOrAdmin: boolean | undefined, lstPermissions: string[] | null | undefined, message: string | null | undefined, isSuccessful: boolean | undefined, retId: number | undefined, redirectUrl: string | null | undefined, errors: string[] | null | undefined): Observable<GridBoxCountDTOListApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/GetGridBoxCount/GetGridBoxCount?";
        if (user_id === null)
            throw new Error("The parameter 'user_id' cannot be null.");
        else if (user_id !== undefined)
            url_ += "user_id=" + encodeURIComponent("" + user_id) + "&";
        if (employee_id === null)
            throw new Error("The parameter 'employee_id' cannot be null.");
        else if (employee_id !== undefined)
            url_ += "employee_id=" + encodeURIComponent("" + employee_id) + "&";
        if (employee_number !== undefined && employee_number !== null)
            url_ += "employee_number=" + encodeURIComponent("" + employee_number) + "&";
        if (employee_contract_id === null)
            throw new Error("The parameter 'employee_contract_id' cannot be null.");
        else if (employee_contract_id !== undefined)
            url_ += "employee_contract_id=" + encodeURIComponent("" + employee_contract_id) + "&";
        if (grade_id !== undefined && grade_id !== null)
            url_ += "grade_id=" + encodeURIComponent("" + grade_id) + "&";
        if (confirmation_date !== undefined && confirmation_date !== null)
            url_ += "confirmation_date=" + encodeURIComponent(confirmation_date ? "" + confirmation_date.toJSON() : "") + "&";
        if (serial_no !== undefined && serial_no !== null)
            url_ += "serial_no=" + encodeURIComponent("" + serial_no) + "&";
        if (first_name !== undefined && first_name !== null)
            url_ += "first_name=" + encodeURIComponent("" + first_name) + "&";
        if (last_name !== undefined && last_name !== null)
            url_ += "last_name=" + encodeURIComponent("" + last_name) + "&";
        if (full_name !== undefined && full_name !== null)
            url_ += "full_name=" + encodeURIComponent("" + full_name) + "&";
        if (other_name !== undefined && other_name !== null)
            url_ += "other_name=" + encodeURIComponent("" + other_name) + "&";
        if (department !== undefined && department !== null)
            url_ += "department=" + encodeURIComponent("" + department) + "&";
        if (department_id === null)
            throw new Error("The parameter 'department_id' cannot be null.");
        else if (department_id !== undefined)
            url_ += "department_id=" + encodeURIComponent("" + department_id) + "&";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (phone_number !== undefined && phone_number !== null)
            url_ += "phone_number=" + encodeURIComponent("" + phone_number) + "&";
        if (email_confirmed === null)
            throw new Error("The parameter 'email_confirmed' cannot be null.");
        else if (email_confirmed !== undefined)
            url_ += "email_confirmed=" + encodeURIComponent("" + email_confirmed) + "&";
        if (session_token !== undefined && session_token !== null)
            url_ += "session_token=" + encodeURIComponent("" + session_token) + "&";
        if (jwt_token !== undefined && jwt_token !== null)
            url_ += "jwt_token=" + encodeURIComponent("" + jwt_token) + "&";
        if (user_token !== undefined && user_token !== null)
            url_ += "user_token=" + encodeURIComponent("" + user_token) + "&";
        if (company_id === null)
            throw new Error("The parameter 'company_id' cannot be null.");
        else if (company_id !== undefined)
            url_ += "company_id=" + encodeURIComponent("" + company_id) + "&";
        if (licenseUsuage === null)
            throw new Error("The parameter 'licenseUsuage' cannot be null.");
        else if (licenseUsuage !== undefined)
            url_ += "LicenseUsuage=" + encodeURIComponent("" + licenseUsuage) + "&";
        if (licenseCount === null)
            throw new Error("The parameter 'licenseCount' cannot be null.");
        else if (licenseCount !== undefined)
            url_ += "LicenseCount=" + encodeURIComponent("" + licenseCount) + "&";
        if (company_name !== undefined && company_name !== null)
            url_ += "company_name=" + encodeURIComponent("" + company_name) + "&";
        if (sub_id === null)
            throw new Error("The parameter 'sub_id' cannot be null.");
        else if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&";
        if (isAdmin === null)
            throw new Error("The parameter 'isAdmin' cannot be null.");
        else if (isAdmin !== undefined)
            url_ += "IsAdmin=" + encodeURIComponent("" + isAdmin) + "&";
        if (isSuperAdmin === null)
            throw new Error("The parameter 'isSuperAdmin' cannot be null.");
        else if (isSuperAdmin !== undefined)
            url_ += "IsSuperAdmin=" + encodeURIComponent("" + isSuperAdmin) + "&";
        if (isTenantAdmin === null)
            throw new Error("The parameter 'isTenantAdmin' cannot be null.");
        else if (isTenantAdmin !== undefined)
            url_ += "IsTenantAdmin=" + encodeURIComponent("" + isTenantAdmin) + "&";
        if (isActiveBySysOrAdmin === null)
            throw new Error("The parameter 'isActiveBySysOrAdmin' cannot be null.");
        else if (isActiveBySysOrAdmin !== undefined)
            url_ += "IsActiveBySysOrAdmin=" + encodeURIComponent("" + isActiveBySysOrAdmin) + "&";
        if (lstPermissions !== undefined && lstPermissions !== null)
            lstPermissions && lstPermissions.forEach(item => { url_ += "lstPermissions=" + encodeURIComponent("" + item) + "&"; });
        if (message !== undefined && message !== null)
            url_ += "Message=" + encodeURIComponent("" + message) + "&";
        if (isSuccessful === null)
            throw new Error("The parameter 'isSuccessful' cannot be null.");
        else if (isSuccessful !== undefined)
            url_ += "IsSuccessful=" + encodeURIComponent("" + isSuccessful) + "&";
        if (retId === null)
            throw new Error("The parameter 'retId' cannot be null.");
        else if (retId !== undefined)
            url_ += "RetId=" + encodeURIComponent("" + retId) + "&";
        if (redirectUrl !== undefined && redirectUrl !== null)
            url_ += "RedirectUrl=" + encodeURIComponent("" + redirectUrl) + "&";
        if (errors !== undefined && errors !== null)
            errors && errors.forEach(item => { url_ += "Errors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGridBoxCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGridBoxCount(<any>response_);
                } catch (e) {
                    return <Observable<GridBoxCountDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GridBoxCountDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGridBoxCount(response: HttpResponseBase): Observable<GridBoxCountDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GridBoxCountDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GridBoxCountDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEmployeetoTalentPoolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating Employee  to Talent Pool
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmployeetoTalentPool(body: EmployeeTalentPoolDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/AddUpdateEmployeetoTalentPool/Add-Update-EmployeetoTalentPool";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmployeetoTalentPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmployeetoTalentPool(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmployeetoTalentPool(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateRequirmentstoTalentPoolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating Requirments  to Talent Pool
     * @param talentPoolId (optional) 
     * @param requirements (optional) 
     * @return Success
     */
    addUpdateRequirmentstoTalentPool(talentPoolId: number | undefined, requirements: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/AddUpdateRequirmentstoTalentPool/Add-Update-RequirmentstoTalentPool?";
        if (talentPoolId === null)
            throw new Error("The parameter 'talentPoolId' cannot be null.");
        else if (talentPoolId !== undefined)
            url_ += "TalentPoolId=" + encodeURIComponent("" + talentPoolId) + "&";
        if (requirements !== undefined && requirements !== null)
            url_ += "Requirements=" + encodeURIComponent("" + requirements) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateRequirmentstoTalentPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateRequirmentstoTalentPool(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateRequirmentstoTalentPool(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CareerSuccessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating CareerSuccsions
     * @param body (optional) 
     * @return Success
     */
    careerSuccession(body: CareerSuccessionDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/CareerSuccession/CareerSuccession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCareerSuccession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCareerSuccession(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCareerSuccession(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CareerPoolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for Creating  Talent Pool
     * @param body (optional) 
     * @return Success
     */
    createPool(body: AddTalentPoolDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/CareerPool/CreatePool";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePool(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePool(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteEmployeefromTalentPoolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for  Delete  Employee from Talent Pool
     * @param talentPoolId (optional) 
     * @param employeeId (optional) 
     * @return Success
     */
    deleteEmployeeFromPool(talentPoolId: number | undefined, employeeId: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/DeleteEmployeefromTalentPool/DeleteEmployeeFromPool?";
        if (talentPoolId === null)
            throw new Error("The parameter 'talentPoolId' cannot be null.");
        else if (talentPoolId !== undefined)
            url_ += "TalentPoolId=" + encodeURIComponent("" + talentPoolId) + "&";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEmployeeFromPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEmployeeFromPool(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEmployeeFromPool(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetTalentPoolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to Fetch TalentPools.
    Note: all filter are optional
     * @param user_id (optional) 
     * @param employee_id (optional) 
     * @param employee_number (optional) 
     * @param employee_contract_id (optional) 
     * @param grade_id (optional) 
     * @param confirmation_date (optional) 
     * @param serial_no (optional) 
     * @param first_name (optional) 
     * @param last_name (optional) 
     * @param full_name (optional) 
     * @param other_name (optional) 
     * @param department (optional) 
     * @param department_id (optional) 
     * @param email (optional) 
     * @param phone_number (optional) 
     * @param email_confirmed (optional) 
     * @param session_token (optional) 
     * @param jwt_token (optional) 
     * @param user_token (optional) 
     * @param company_id (optional) 
     * @param licenseUsuage (optional) 
     * @param licenseCount (optional) 
     * @param company_name (optional) 
     * @param sub_id (optional) 
     * @param isAdmin (optional) 
     * @param isSuperAdmin (optional) 
     * @param isTenantAdmin (optional) 
     * @param isActiveBySysOrAdmin (optional) 
     * @param lstPermissions (optional) 
     * @param message (optional) 
     * @param isSuccessful (optional) 
     * @param retId (optional) 
     * @param redirectUrl (optional) 
     * @param errors (optional) 
     * @return Success
     */
    fetchTalentPool(user_id: number | undefined, employee_id: number | undefined, employee_number: string | null | undefined, employee_contract_id: number | undefined, grade_id: number | null | undefined, confirmation_date: Date | null | undefined, serial_no: string | null | undefined, first_name: string | null | undefined, last_name: string | null | undefined, full_name: string | null | undefined, other_name: string | null | undefined, department: string | null | undefined, department_id: number | undefined, email: string | null | undefined, phone_number: string | null | undefined, email_confirmed: boolean | undefined, session_token: string | null | undefined, jwt_token: string | null | undefined, user_token: string | null | undefined, company_id: number | undefined, licenseUsuage: number | undefined, licenseCount: number | undefined, company_name: string | null | undefined, sub_id: number | undefined, isAdmin: boolean | undefined, isSuperAdmin: boolean | undefined, isTenantAdmin: boolean | undefined, isActiveBySysOrAdmin: boolean | undefined, lstPermissions: string[] | null | undefined, message: string | null | undefined, isSuccessful: boolean | undefined, retId: number | undefined, redirectUrl: string | null | undefined, errors: string[] | null | undefined): Observable<AddTalentPoolDTOListApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/GetTalentPool/FetchTalentPool?";
        if (user_id === null)
            throw new Error("The parameter 'user_id' cannot be null.");
        else if (user_id !== undefined)
            url_ += "user_id=" + encodeURIComponent("" + user_id) + "&";
        if (employee_id === null)
            throw new Error("The parameter 'employee_id' cannot be null.");
        else if (employee_id !== undefined)
            url_ += "employee_id=" + encodeURIComponent("" + employee_id) + "&";
        if (employee_number !== undefined && employee_number !== null)
            url_ += "employee_number=" + encodeURIComponent("" + employee_number) + "&";
        if (employee_contract_id === null)
            throw new Error("The parameter 'employee_contract_id' cannot be null.");
        else if (employee_contract_id !== undefined)
            url_ += "employee_contract_id=" + encodeURIComponent("" + employee_contract_id) + "&";
        if (grade_id !== undefined && grade_id !== null)
            url_ += "grade_id=" + encodeURIComponent("" + grade_id) + "&";
        if (confirmation_date !== undefined && confirmation_date !== null)
            url_ += "confirmation_date=" + encodeURIComponent(confirmation_date ? "" + confirmation_date.toJSON() : "") + "&";
        if (serial_no !== undefined && serial_no !== null)
            url_ += "serial_no=" + encodeURIComponent("" + serial_no) + "&";
        if (first_name !== undefined && first_name !== null)
            url_ += "first_name=" + encodeURIComponent("" + first_name) + "&";
        if (last_name !== undefined && last_name !== null)
            url_ += "last_name=" + encodeURIComponent("" + last_name) + "&";
        if (full_name !== undefined && full_name !== null)
            url_ += "full_name=" + encodeURIComponent("" + full_name) + "&";
        if (other_name !== undefined && other_name !== null)
            url_ += "other_name=" + encodeURIComponent("" + other_name) + "&";
        if (department !== undefined && department !== null)
            url_ += "department=" + encodeURIComponent("" + department) + "&";
        if (department_id === null)
            throw new Error("The parameter 'department_id' cannot be null.");
        else if (department_id !== undefined)
            url_ += "department_id=" + encodeURIComponent("" + department_id) + "&";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (phone_number !== undefined && phone_number !== null)
            url_ += "phone_number=" + encodeURIComponent("" + phone_number) + "&";
        if (email_confirmed === null)
            throw new Error("The parameter 'email_confirmed' cannot be null.");
        else if (email_confirmed !== undefined)
            url_ += "email_confirmed=" + encodeURIComponent("" + email_confirmed) + "&";
        if (session_token !== undefined && session_token !== null)
            url_ += "session_token=" + encodeURIComponent("" + session_token) + "&";
        if (jwt_token !== undefined && jwt_token !== null)
            url_ += "jwt_token=" + encodeURIComponent("" + jwt_token) + "&";
        if (user_token !== undefined && user_token !== null)
            url_ += "user_token=" + encodeURIComponent("" + user_token) + "&";
        if (company_id === null)
            throw new Error("The parameter 'company_id' cannot be null.");
        else if (company_id !== undefined)
            url_ += "company_id=" + encodeURIComponent("" + company_id) + "&";
        if (licenseUsuage === null)
            throw new Error("The parameter 'licenseUsuage' cannot be null.");
        else if (licenseUsuage !== undefined)
            url_ += "LicenseUsuage=" + encodeURIComponent("" + licenseUsuage) + "&";
        if (licenseCount === null)
            throw new Error("The parameter 'licenseCount' cannot be null.");
        else if (licenseCount !== undefined)
            url_ += "LicenseCount=" + encodeURIComponent("" + licenseCount) + "&";
        if (company_name !== undefined && company_name !== null)
            url_ += "company_name=" + encodeURIComponent("" + company_name) + "&";
        if (sub_id === null)
            throw new Error("The parameter 'sub_id' cannot be null.");
        else if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&";
        if (isAdmin === null)
            throw new Error("The parameter 'isAdmin' cannot be null.");
        else if (isAdmin !== undefined)
            url_ += "IsAdmin=" + encodeURIComponent("" + isAdmin) + "&";
        if (isSuperAdmin === null)
            throw new Error("The parameter 'isSuperAdmin' cannot be null.");
        else if (isSuperAdmin !== undefined)
            url_ += "IsSuperAdmin=" + encodeURIComponent("" + isSuperAdmin) + "&";
        if (isTenantAdmin === null)
            throw new Error("The parameter 'isTenantAdmin' cannot be null.");
        else if (isTenantAdmin !== undefined)
            url_ += "IsTenantAdmin=" + encodeURIComponent("" + isTenantAdmin) + "&";
        if (isActiveBySysOrAdmin === null)
            throw new Error("The parameter 'isActiveBySysOrAdmin' cannot be null.");
        else if (isActiveBySysOrAdmin !== undefined)
            url_ += "IsActiveBySysOrAdmin=" + encodeURIComponent("" + isActiveBySysOrAdmin) + "&";
        if (lstPermissions !== undefined && lstPermissions !== null)
            lstPermissions && lstPermissions.forEach(item => { url_ += "lstPermissions=" + encodeURIComponent("" + item) + "&"; });
        if (message !== undefined && message !== null)
            url_ += "Message=" + encodeURIComponent("" + message) + "&";
        if (isSuccessful === null)
            throw new Error("The parameter 'isSuccessful' cannot be null.");
        else if (isSuccessful !== undefined)
            url_ += "IsSuccessful=" + encodeURIComponent("" + isSuccessful) + "&";
        if (retId === null)
            throw new Error("The parameter 'retId' cannot be null.");
        else if (retId !== undefined)
            url_ += "RetId=" + encodeURIComponent("" + retId) + "&";
        if (redirectUrl !== undefined && redirectUrl !== null)
            url_ += "RedirectUrl=" + encodeURIComponent("" + redirectUrl) + "&";
        if (errors !== undefined && errors !== null)
            errors && errors.forEach(item => { url_ += "Errors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchTalentPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchTalentPool(<any>response_);
                } catch (e) {
                    return <Observable<AddTalentPoolDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddTalentPoolDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchTalentPool(response: HttpResponseBase): Observable<AddTalentPoolDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddTalentPoolDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddTalentPoolDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class RemoveEmployeeFromSuccessorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for Remove Employee form Successor
     * @param successionId (optional) 
     * @param employee (optional) 
     * @return Success
     */
    removeEmployeeFromSuccessor(successionId: number | undefined, employee: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/RemoveEmployeeFromSuccessor/RemoveEmployeeFromSuccessor?";
        if (successionId === null)
            throw new Error("The parameter 'successionId' cannot be null.");
        else if (successionId !== undefined)
            url_ += "SuccessionId=" + encodeURIComponent("" + successionId) + "&";
        if (employee !== undefined && employee !== null)
            url_ += "Employee=" + encodeURIComponent("" + employee) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveEmployeeFromSuccessor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveEmployeeFromSuccessor(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveEmployeeFromSuccessor(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RemoveRequirmentfromTalentPoolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for Remove Requirment from TalentPool
     * @param requirementId (optional) 
     * @return Success
     */
    removeRequirementFromTalentPool(requirementId: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/RemoveRequirmentfromTalentPool/RemoveRequirementFromTalentPool?";
        if (requirementId === null)
            throw new Error("The parameter 'requirementId' cannot be null.");
        else if (requirementId !== undefined)
            url_ += "RequirementId=" + encodeURIComponent("" + requirementId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRequirementFromTalentPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRequirementFromTalentPool(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRequirementFromTalentPool(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for getting Payment Institutions that can be use for dropdowns
     * @return Success
     */
    getPaymentInstitutions(): Observable<PaymentInstitutionIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetPaymentInstitutions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInstitutions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInstitutions(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInstitutionIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInstitutionIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInstitutions(response: HttpResponseBase): Observable<PaymentInstitutionIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInstitutionIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInstitutionIListApiResult>(<any>null);
    }

    /**
     * API for getting Payment Elements that can be use for dropdowns
     * @return Success
     */
    getPayElements(): Observable<ElementIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetPayElements";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayElements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayElements(<any>response_);
                } catch (e) {
                    return <Observable<ElementIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ElementIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayElements(response: HttpResponseBase): Observable<ElementIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElementIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElementIListApiResult>(<any>null);
    }

    /**
     * API for getting Payroll Types that can be use for dropdowns
     * @return Success
     */
    getPayrollTypes(): Observable<PayrollTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetPayrollTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayrollTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayrollTypes(<any>response_);
                } catch (e) {
                    return <Observable<PayrollTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayrollTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayrollTypes(response: HttpResponseBase): Observable<PayrollTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayrollTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayrollTypeIListApiResult>(<any>null);
    }

    /**
     * API for getting Frequencies that can be use for dropdowns
     * @return Success
     */
    getFrequencies(): Observable<FrequencyRuleIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetFrequencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFrequencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFrequencies(<any>response_);
                } catch (e) {
                    return <Observable<FrequencyRuleIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<FrequencyRuleIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetFrequencies(response: HttpResponseBase): Observable<FrequencyRuleIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FrequencyRuleIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FrequencyRuleIListApiResult>(<any>null);
    }

    /**
     * API for getting Tenant Beneficiaries that can be use for dropdowns
    and takes searchText (i.e. account-name, account-no, bank-name, bank-code)
    for filtering
     * @param searchText (optional) 
     * @return Success
     */
    getBeneficiaries(searchText: string | null | undefined): Observable<TenantBeneficiaryIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetBeneficiaries?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBeneficiaries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBeneficiaries(<any>response_);
                } catch (e) {
                    return <Observable<TenantBeneficiaryIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantBeneficiaryIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetBeneficiaries(response: HttpResponseBase): Observable<TenantBeneficiaryIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantBeneficiaryIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantBeneficiaryIListApiResult>(<any>null);
    }

    /**
     * API for getting Locations that can be use for dropdowns
     * @return Success
     */
    getLocations(): Observable<LocationIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetLocations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocations(<any>response_);
                } catch (e) {
                    return <Observable<LocationIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocations(response: HttpResponseBase): Observable<LocationIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationIListApiResult>(<any>null);
    }

    /**
     * API for getting Departments that can be use for dropdowns
     * @return Success
     */
    getDepartments(): Observable<DepartmentIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetDepartments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartments(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartments(response: HttpResponseBase): Observable<DepartmentIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentIListApiResult>(<any>null);
    }

    /**
     * API for getting JobRoles that can be use for dropdowns
     * @return Success
     */
    getJobRoles(): Observable<JobRoleIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetJobRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobRoles(<any>response_);
                } catch (e) {
                    return <Observable<JobRoleIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobRoleIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobRoles(response: HttpResponseBase): Observable<JobRoleIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobRoleIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobRoleIListApiResult>(<any>null);
    }

    /**
     * API for getting Events that can be use for dropdowns
     * @return Success
     */
    getEvents(): Observable<EventIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetEvents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEvents(<any>response_);
                } catch (e) {
                    return <Observable<EventIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EventIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEvents(response: HttpResponseBase): Observable<EventIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventIListApiResult>(<any>null);
    }

    /**
     * API for getting Positions that can be use for dropdowns
     * @return Success
     */
    getPositions(): Observable<PositionIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetPositions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPositions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPositions(<any>response_);
                } catch (e) {
                    return <Observable<PositionIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPositions(response: HttpResponseBase): Observable<PositionIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PositionIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionIListApiResult>(<any>null);
    }

    /**
     * API for getting All Parent Positions that can be use for dropdowns
     * @return Success
     */
    getParentPositions(): Observable<PositionIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetParentPositions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParentPositions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParentPositions(<any>response_);
                } catch (e) {
                    return <Observable<PositionIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetParentPositions(response: HttpResponseBase): Observable<PositionIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PositionIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionIListApiResult>(<any>null);
    }

    /**
     * API for getting SalaryScale that can be use for dropdowns
     * @return Success
     */
    getSalaryScale(): Observable<SalaryScaleIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetSalaryScale";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalaryScale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalaryScale(<any>response_);
                } catch (e) {
                    return <Observable<SalaryScaleIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SalaryScaleIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalaryScale(response: HttpResponseBase): Observable<SalaryScaleIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryScaleIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryScaleIListApiResult>(<any>null);
    }

    /**
     * API for getting Grade that can be use for dropdowns
     * @return Success
     */
    getGrades(): Observable<GradeIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetGrades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGrades(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGrades(<any>response_);
                } catch (e) {
                    return <Observable<GradeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGrades(response: HttpResponseBase): Observable<GradeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeIListApiResult>(<any>null);
    }

    /**
     * API for getting GradeSteps that can be use for dropdowns
     * @return Success
     */
    getGradeSteps(): Observable<GradeStepIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetGradeSteps";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeSteps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeSteps(<any>response_);
                } catch (e) {
                    return <Observable<GradeStepIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeStepIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGradeSteps(response: HttpResponseBase): Observable<GradeStepIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeStepIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeStepIListApiResult>(<any>null);
    }

    /**
     * API for getting GradeLevelBenefit that can be use for dropdowns
     * @return Success
     */
    getGradeLevelBenefit(): Observable<GradeLevelBenefitIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetGradeLevelBenefit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeLevelBenefit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeLevelBenefit(<any>response_);
                } catch (e) {
                    return <Observable<GradeLevelBenefitIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeLevelBenefitIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGradeLevelBenefit(response: HttpResponseBase): Observable<GradeLevelBenefitIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeLevelBenefitIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeLevelBenefitIListApiResult>(<any>null);
    }

    /**
     * API for getting RequestTypes that can be use for dropdowns
     * @return Success
     */
    getRequestTypes(): Observable<RequestTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetRequestTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestTypes(<any>response_);
                } catch (e) {
                    return <Observable<RequestTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestTypes(response: HttpResponseBase): Observable<RequestTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestTypeIListApiResult>(<any>null);
    }

    /**
     * API for getting Positions that can be use for dropdowns
     * @return Success
     */
    getPosition(): Observable<PositionIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetPosition";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosition(<any>response_);
                } catch (e) {
                    return <Observable<PositionIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPosition(response: HttpResponseBase): Observable<PositionIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PositionIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionIListApiResult>(<any>null);
    }

    /**
     * API for getting Request that can be use for dropdowns
     * @return Success
     */
    getRequests(): Observable<RequestIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetRequests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequests(<any>response_);
                } catch (e) {
                    return <Observable<RequestIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequests(response: HttpResponseBase): Observable<RequestIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestIListApiResult>(<any>null);
    }

    /**
     * API for getting Retirement that can be use for dropdowns
     * @return Success
     */
    getRetiree(): Observable<RetirementIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetRetiree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetiree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetiree(<any>response_);
                } catch (e) {
                    return <Observable<RetirementIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirementIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetiree(response: HttpResponseBase): Observable<RetirementIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementIListApiResult>(<any>null);
    }

    /**
     * @return Success
     */
    getRetirmentType(): Observable<RetirementTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetRetirmentType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetirmentType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetirmentType(<any>response_);
                } catch (e) {
                    return <Observable<RetirementTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirementTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetirmentType(response: HttpResponseBase): Observable<RetirementTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class CreateConfirmationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createConfirmation(body: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Confirmation/CreateConfirmation/CreateConfirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateConfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateConfirmation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateConfirmation(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class SaveConfirmationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveConfirmation(body: VwConfirmationDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Confirmation/SaveConfirmation/SaveConfirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveConfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveConfirmation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSaveConfirmation(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetConfirmationsByDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param log_status (optional) 
     * @param _PageSize (optional) 
     * @return Success
     */
    getConfirmationsByDetails(startDate: Date | null | undefined, endDate: Date | null | undefined, log_status: number | undefined, _PageSize: number | undefined): Observable<VwConfirmationDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Confirmation/GetConfirmationsByDetails/GetConfirmationsByDetails?";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (log_status === null)
            throw new Error("The parameter 'log_status' cannot be null.");
        else if (log_status !== undefined)
            url_ += "log_status=" + encodeURIComponent("" + log_status) + "&";
        if (_PageSize === null)
            throw new Error("The parameter '_PageSize' cannot be null.");
        else if (_PageSize !== undefined)
            url_ += "_PageSize=" + encodeURIComponent("" + _PageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfirmationsByDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfirmationsByDetails(<any>response_);
                } catch (e) {
                    return <Observable<VwConfirmationDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwConfirmationDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfirmationsByDetails(response: HttpResponseBase): Observable<VwConfirmationDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwConfirmationDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwConfirmationDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class DataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for getting Bulk Upload Process/Types i.e.
    {'Profile': 1, 'Contract': 2, 'Qualification': 3 }
     * @return Success
     */
    employeeProfileOperation(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/EmployeeProfileOperation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeProfileOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeProfileOperation(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeProfileOperation(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Bank Account Types for dropdowns
     * @return Success
     */
    getAccountTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetAccountTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Bulk Upload Process/Types i.e.
    {'Employee Bank Upload': 2, 'Employee Records Upload': 10}
     * @return Success
     */
    getBulkUploadProcesses(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetBulkUploadProcesses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBulkUploadProcesses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBulkUploadProcesses(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetBulkUploadProcesses(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Pay Types while setting up Pay Element under Payroll for dropdowns
     * @return Success
     */
    getPayTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetPayTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Document Types while uploading document on the system for dropdowns
     * @return Success
     */
    getDocumentTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetDocumentTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Disbursement Categories enumerable that can be use for dropdowns, option button
     * @return Success
     */
    getDisbursementCategories(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetDisbursementCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDisbursementCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDisbursementCategories(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDisbursementCategories(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of different Generics/Common Dropdowns on the System by their Constant Name
    Some of the Constant names for the Dropdowns are;
    1: employment_status
    2: department
    3: bank
    4: marital_status
    8: religion
    10: title
    12: gender
     * @param dropDownName (optional) 
     * @return Success
     */
    getDropDownValues(dropDownName: string | null | undefined): Observable<DropdownValueIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetDropDownValues?";
        if (dropDownName !== undefined && dropDownName !== null)
            url_ += "dropDownName=" + encodeURIComponent("" + dropDownName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDropDownValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDropDownValues(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDropDownValues(response: HttpResponseBase): Observable<DropdownValueIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of different Generics/Common Dropdowns on the System by their Constant Value
    Some of the Constant names for the Dropdowns are;
    employment_status: 1
    department: 2
    bank: 3
    marital_status: 4
    religion: 8
    title: 10
    gender: 12
     * @param dropDownId (optional) 
     * @return Success
     */
    getDropDownValuesById(dropDownId: number | undefined): Observable<DropdownValueIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetDropDownValuesById?";
        if (dropDownId === null)
            throw new Error("The parameter 'dropDownId' cannot be null.");
        else if (dropDownId !== undefined)
            url_ += "dropDownId=" + encodeURIComponent("" + dropDownId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDropDownValuesById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDropDownValuesById(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDropDownValuesById(response: HttpResponseBase): Observable<DropdownValueIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueIListApiResult>(<any>null);
    }

    /**
     * API for getting Tenant Status enumerable that can be use for filtering parameter
     * @return Success
     */
    getTenantStatus(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetTenantStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantStatus(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantStatus(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of all Countries on the System
     * @return Success
     */
    getCountries(): Observable<CountryIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<CountryIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<CountryIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of all States on the System
     * @return Success
     */
    getStates(): Observable<StateIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetStates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStates(<any>response_);
                } catch (e) {
                    return <Observable<StateIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StateIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetStates(response: HttpResponseBase): Observable<StateIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StateIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StateIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of all Local Govts on the System
     * @return Success
     */
    getLGAs(): Observable<LGAIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetLGAs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLGAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLGAs(<any>response_);
                } catch (e) {
                    return <Observable<LGAIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LGAIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLGAs(response: HttpResponseBase): Observable<LGAIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LGAIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LGAIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of all Local Govts by State
     * @param stateId (optional) 
     * @return Success
     */
    getLGAsByState(stateId: number | undefined): Observable<LGAIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetLGAsByState?";
        if (stateId === null)
            throw new Error("The parameter 'stateId' cannot be null.");
        else if (stateId !== undefined)
            url_ += "stateId=" + encodeURIComponent("" + stateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLGAsByState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLGAsByState(<any>response_);
                } catch (e) {
                    return <Observable<LGAIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LGAIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLGAsByState(response: HttpResponseBase): Observable<LGAIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LGAIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LGAIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Unit of Measurement enumerable that can be use for dropdown values
     * @return Success
     */
    getUnitOfMeasurements(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetUnitOfMeasurements";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitOfMeasurements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitOfMeasurements(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitOfMeasurements(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Rating Types enumerable that can be use for dropdown values
     * @return Success
     */
    getRatingTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetRatingTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRatingTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRatingTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRatingTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Performance Review Purposes enumerable (Confirmation, Promotion, etc)
    that can be use for dropdown values
     * @return Success
     */
    getReviewPurposes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetReviewPurposes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReviewPurposes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReviewPurposes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetReviewPurposes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Organization Strategies enumerable(Financial, Customer, etc)
    that can be use for dropdown values
     * @return Success
     */
    getStrategyCategories(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetStrategyCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStrategyCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStrategyCategories(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetStrategyCategories(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Appraisal Types enumerable that can be use for dropdown values
     * @return Success
     */
    getAppraisalTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetAppraisalTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppraisalTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppraisalTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppraisalTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of an enumerable Employee Contract Status that can be use for dropdown values in filter
     * @return Success
     */
    getEmployeeContractStatus(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetEmployeeContractStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeContractStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeContractStatus(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeContractStatus(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Requests Types enumerable that can be use for dropdown values
     * @return Success
     */
    getRequestTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetRequestTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateDepartmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating Department
     * @param body (optional) 
     * @return Success
     */
    addUpdateDepartment(body: ManageDepartmentDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Department/AddUpdateDepartment/Add-Update-Department";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateDepartment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateDepartment(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllDepartmentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to Fetch Departments.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllDepartments(pageSize: number | undefined, pageNumber: number | undefined): Observable<DepartmentDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Department/GetAllDepartments/GetAllDepartments?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDepartments(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDepartments(response: HttpResponseBase): Observable<DepartmentDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetDepartmentByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to get Department by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getDepartment(id: number | undefined): Observable<DepartmentDTOApiResult> {
        let url_ = this.baseUrl + "/api/Department/GetDepartmentById/GetDepartment?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartment(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartment(response: HttpResponseBase): Observable<DepartmentDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchDeploymentByReferenceNoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param referenceNo (optional) 
     * @return Success
     */
    fetchDeploymentByReferenceNo(referenceNo: string | null | undefined): Observable<DeploymentLogIListApiResult> {
        let url_ = this.baseUrl + "/api/Deployment/FetchDeploymentByReferenceNo/FetchDeploymentByReferenceNo?";
        if (referenceNo !== undefined && referenceNo !== null)
            url_ += "ReferenceNo=" + encodeURIComponent("" + referenceNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchDeploymentByReferenceNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchDeploymentByReferenceNo(<any>response_);
                } catch (e) {
                    return <Observable<DeploymentLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeploymentLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchDeploymentByReferenceNo(response: HttpResponseBase): Observable<DeploymentLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeploymentLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeploymentLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchDeploymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    fetchDeployment(body: SearchDeploymentDto | undefined): Observable<CreateDeploymentViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Deployment/FetchDeployment/FetchDeployment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchDeployment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchDeployment(<any>response_);
                } catch (e) {
                    return <Observable<CreateDeploymentViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateDeploymentViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchDeployment(response: HttpResponseBase): Observable<CreateDeploymentViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateDeploymentViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateDeploymentViewModelIListApiResult>(<any>null);
    }
}

@Injectable()
export class EmployeeDeploymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @return Success
     */
    employeeDeployment(): Observable<CreateDeploymentViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Deployment/EmployeeDeployment/EmployeeDeployment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeDeployment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeDeployment(<any>response_);
                } catch (e) {
                    return <Observable<CreateDeploymentViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateDeploymentViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeDeployment(response: HttpResponseBase): Observable<CreateDeploymentViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateDeploymentViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateDeploymentViewModelIListApiResult>(<any>null);
    }
}

@Injectable()
export class SingleDisbursementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for posting/updating Single Disbursement
     * @param body (optional) 
     * @return Success
     */
    postSingleDisbursement(body: SingleDisbursementPostDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Disbursement/SingleDisbursement/PostSingleDisbursement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostSingleDisbursement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostSingleDisbursement(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostSingleDisbursement(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmailLogsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving all Email Logs by email log filtering parameter
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param emailTo (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getEmailLogs(startDate: Date | null | undefined, endDate: Date | null | undefined, emailTo: string | null | undefined, pageSize: number | undefined): Observable<EmailLogDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/EmailLog/FetchEmailLogs/GetEmailLogs?";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (emailTo !== undefined && emailTo !== null)
            url_ += "EmailTo=" + encodeURIComponent("" + emailTo) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailLogs(<any>response_);
                } catch (e) {
                    return <Observable<EmailLogDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailLogDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailLogs(response: HttpResponseBase): Observable<EmailLogDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailLogDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailLogDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmailLogByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for getting Single EmailLog Details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getEmailLogById(id: number | undefined): Observable<EmailLogDTOApiResult> {
        let url_ = this.baseUrl + "/api/EmailLog/FetchEmailLogById/GetEmailLogById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailLogById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailLogById(<any>response_);
                } catch (e) {
                    return <Observable<EmailLogDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailLogDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailLogById(response: HttpResponseBase): Observable<EmailLogDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailLogDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailLogDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmailTemplateByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for getting Email Template by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getEmailTemplateById(id: number | undefined): Observable<EmailTemplateDTOApiResult> {
        let url_ = this.baseUrl + "/api/EmailTemplate/FetchEmailTemplateById/GetEmailTemplateById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailTemplateById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailTemplateById(<any>response_);
                } catch (e) {
                    return <Observable<EmailTemplateDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailTemplateDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailTemplateById(response: HttpResponseBase): Observable<EmailTemplateDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailTemplateDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailTemplateDTOApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateEmailTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for updating Email Template
     * @param body (optional) 
     * @return Success
     */
    updateEmailTemplate(body: EmailTemplateDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/EmailTemplate/UpdateEmailTemplate/UpdateEmailTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmailTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmailTemplate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEmailTemplate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CreateEmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding a single Employee profile
     * @param body (optional) 
     * @return Success
     */
    addEmployee(body: EmployeeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Employee/CreateEmployee/AddEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEmployee(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddEmployee(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class DownloadEmployeeBulkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for downloading Sample Template for Bulk Upload
     * @return Success
     */
    downloadEmployeeBulkTemplate(): Observable<File> {
        let url_ = this.baseUrl + "/api/Employee/DownloadEmployeeBulk/DownloadEmployeeBulkTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadEmployeeBulkTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadEmployeeBulkTemplate(<any>response_);
                } catch (e) {
                    return <Observable<File>><any>_observableThrow(e);
                }
            } else
                return <Observable<File>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadEmployeeBulkTemplate(response: HttpResponseBase): Observable<File> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = File.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<File>(<any>null);
    }
}

@Injectable()
export class EmployeeBulkUploadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for Employee Bulk uploading
     * @param bulkFile (optional) 
     * @return Success
     */
    employeeBulkUpload(bulkFile: FileParameter | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Employee/EmployeeBulkUpload/EmployeeBulkUpload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (bulkFile !== null && bulkFile !== undefined)
            content_.append("bulkFile", bulkFile.data, bulkFile.fileName ? bulkFile.fileName : "bulkFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeBulkUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeBulkUpload(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeBulkUpload(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class UploadProfileImageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for uploading Employee profile picture
     * @param base64Image (optional) 
     * @param employeeId (optional) 
     * @return Success
     */
    uploadProfileImage(base64Image: string | null | undefined, employeeId: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Employee/UploadProfileImage/UploadProfileImage?";
        if (base64Image !== undefined && base64Image !== null)
            url_ += "base64Image=" + encodeURIComponent("" + base64Image) + "&";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadProfileImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadProfileImage(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUploadProfileImage(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeesDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving all Employees by Employee number (i.e. for specific Employee) or
    empty string (i.e. for all Employee
    with their few details for further CRUD operation
     * @param searchText (optional) 
     * @param contractStatus (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getEmployeesDetails(searchText: string | null | undefined, contractStatus: number | undefined, pageSize: number | undefined): Observable<DropdownValueDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeesDetails/GetEmployeesDetails?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (contractStatus === null)
            throw new Error("The parameter 'contractStatus' cannot be null.");
        else if (contractStatus !== undefined)
            url_ += "ContractStatus=" + encodeURIComponent("" + contractStatus) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesDetails(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeesDetails(response: HttpResponseBase): Observable<DropdownValueDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeesByName_IdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving all Employees with details (includes; Fullname, Id, EmpNo)
    that matches the supplied name/employee Id 
    which can be use in various part of the system for Dropdown selection for;
    Supervisor-List, Appraisal-Reviewer-List etc
     * @param nameId (optional) 
     * @return Success
     */
    getEmployeesByNameId(nameId: string | null | undefined): Observable<DropdownValueDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeesByName_Id/GetEmployeesByName-Id?";
        if (nameId !== undefined && nameId !== null)
            url_ += "nameId=" + encodeURIComponent("" + nameId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesByNameId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesByNameId(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeesByNameId(response: HttpResponseBase): Observable<DropdownValueDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving single Employee's record
     * @param employeeId (optional) 
     * @return Success
     */
    getEmployeeById(employeeId: number | undefined): Observable<EmployeeDTOApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeeById/GetEmployeeById?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeById(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeById(response: HttpResponseBase): Observable<EmployeeDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDTOApiResult>(<any>null);
    }
}

@Injectable()
export class SearchEmployeesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for Master Employees Search
     * @param pageSize (optional) 
     * @param companyId (optional) 
     * @param searchText (optional) 
     * @param peopleGroupId (optional) 
     * @param departmentId (optional) 
     * @param jobRoleId (optional) 
     * @param locationId (optional) 
     * @param salaryscaleId (optional) 
     * @param gradeId (optional) 
     * @param gradestepId (optional) 
     * @return Success
     */
    searchEmployees(pageSize: number | undefined, companyId: number | undefined, searchText: string | null | undefined, peopleGroupId: number | undefined, departmentId: number | undefined, jobRoleId: number | undefined, locationId: number | undefined, salaryscaleId: number | undefined, gradeId: number | undefined, gradestepId: number | undefined): Observable<EmployeeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Employee/SearchEmployees/SearchEmployees?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (peopleGroupId === null)
            throw new Error("The parameter 'peopleGroupId' cannot be null.");
        else if (peopleGroupId !== undefined)
            url_ += "peopleGroupId=" + encodeURIComponent("" + peopleGroupId) + "&";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (jobRoleId === null)
            throw new Error("The parameter 'jobRoleId' cannot be null.");
        else if (jobRoleId !== undefined)
            url_ += "jobRoleId=" + encodeURIComponent("" + jobRoleId) + "&";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (salaryscaleId === null)
            throw new Error("The parameter 'salaryscaleId' cannot be null.");
        else if (salaryscaleId !== undefined)
            url_ += "salaryscaleId=" + encodeURIComponent("" + salaryscaleId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (gradestepId === null)
            throw new Error("The parameter 'gradestepId' cannot be null.");
        else if (gradestepId !== undefined)
            url_ += "gradestepId=" + encodeURIComponent("" + gradestepId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchEmployees(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearchEmployees(response: HttpResponseBase): Observable<EmployeeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllEmployeesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving All Tenant's registered Employees
     * @param searchText (optional) 
     * @param contractStatus (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllEmployees(searchText: string | null | undefined, contractStatus: number | undefined, pageSize: number | undefined): Observable<EmployeeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchAllEmployees/GetAllEmployees?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (contractStatus === null)
            throw new Error("The parameter 'contractStatus' cannot be null.");
        else if (contractStatus !== undefined)
            url_ += "ContractStatus=" + encodeURIComponent("" + contractStatus) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmployees(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEmployees(response: HttpResponseBase): Observable<EmployeeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeContractByEmployeeIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving Employee's Contract profile by Employee Id
     * @param employeeId (optional) 
     * @return Success
     */
    fetchEmployeeContractByEmployeeId(employeeId: number | undefined): Observable<EmployeeContractAssignmentDTOApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeeContractByEmployeeId/FetchEmployeeContractByEmployeeId?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEmployeeContractByEmployeeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEmployeeContractByEmployeeId(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeContractAssignmentDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeContractAssignmentDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEmployeeContractByEmployeeId(response: HttpResponseBase): Observable<EmployeeContractAssignmentDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeContractAssignmentDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeContractAssignmentDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating Event
     * @param body (optional) 
     * @return Success
     */
    addUpdateEvent(body: ManageEventDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Events/AddUpdateEvents/Add-Update-Event";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEvent(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEvent(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to Fetch Events.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllEvents(pageSize: number | undefined, pageNumber: number | undefined): Observable<EventDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Events/GetAllEvents/GetAllEvents?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEvents(<any>response_);
                } catch (e) {
                    return <Observable<EventDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EventDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEvents(response: HttpResponseBase): Observable<EventDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetEventsByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to get jobroles by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getEventsById(id: number | undefined): Observable<EventDTOApiResult> {
        let url_ = this.baseUrl + "/api/Events/GetEventsById/GetEventsById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEventsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEventsById(<any>response_);
                } catch (e) {
                    return <Observable<EventDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EventDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEventsById(response: HttpResponseBase): Observable<EventDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventDTOApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used to delete JobRole
     * @param id (optional) 
     * @return Success
     */
    deleteEvents(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Events/DeleteEvents/DeleteEvents?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEvents(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEvents(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateExpenseGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateExpenseGroup(body: ExpenseGroupDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseGroup/AddUpdateExpenseGroup/AddUpdateExpenseGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateExpenseGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateExpenseGroup(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateExpenseGroup(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseGroup(encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseGroup/ToggleExpenseGroup/ToggleExpenseGroup?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseGroup(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseGroup(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseGroupsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param companyID (optional) 
     * @param subID (optional) 
     * @param name (optional) 
     * @param iD (optional) 
     * @param referenceId (optional) 
     * @param code (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getExpenseGroups(companyID: number | undefined, subID: number | undefined, name: string | null | undefined, iD: number | undefined, referenceId: string | null | undefined, code: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseGroupIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseGroup/GetExpenseGroups/GetExpenseGroups?";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        if (subID === null)
            throw new Error("The parameter 'subID' cannot be null.");
        else if (subID !== undefined)
            url_ += "SubID=" + encodeURIComponent("" + subID) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (referenceId !== undefined && referenceId !== null)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseGroups(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseGroupIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseGroupIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseGroups(response: HttpResponseBase): Observable<ExpenseGroupIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseGroupIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseGroupIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateExpenseProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateExpenseProject(body: ExpenseProjectDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseProject/AddUpdateExpenseProject/AddUpdateExpenseProject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateExpenseProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateExpenseProject(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateExpenseProject(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseProject(encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseProject/ToggleExpenseProject/ToggleExpenseProject?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseProject(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseProject(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param iD (optional) 
     * @param name (optional) 
     * @param description (optional) 
     * @param ban (optional) 
     * @param referenceId (optional) 
     * @param code (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getExpenseProject(iD: number | undefined, name: string | null | undefined, description: string | null | undefined, ban: boolean | undefined, referenceId: string | null | undefined, code: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseProject[]> {
        let url_ = this.baseUrl + "/api/ExpenseProject/GetExpenseProject/GetExpenseProject?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (ban === null)
            throw new Error("The parameter 'ban' cannot be null.");
        else if (ban !== undefined)
            url_ += "Ban=" + encodeURIComponent("" + ban) + "&";
        if (referenceId !== undefined && referenceId !== null)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseProject(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseProject[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseProject[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseProject(response: HttpResponseBase): Observable<ExpenseProject[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExpenseProject.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseProject[]>(<any>null);
    }
}

@Injectable()
export class AddUpdateExpenseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateExpense(body: ExpenseDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseRequest/AddUpdateExpense/AddUpdateExpense";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateExpense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateExpense(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateExpense(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseRequest(encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseRequest/ToggleExpenseRequest/ToggleExpenseRequest?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchExpensesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param companyID (optional) 
     * @param subID (optional) 
     * @param iD (optional) 
     * @param userid (optional) 
     * @param companyid (optional) 
     * @param searchText (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchType (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchExpenses(companyID: number | undefined, subID: number | undefined, iD: number | undefined, userid: number | undefined, companyid: number | undefined, searchText: string | null | undefined, startDate: string | null | undefined, endDate: string | null | undefined, searchType: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseRequest/FetchExpenses/FetchExpenses?";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        if (subID === null)
            throw new Error("The parameter 'subID' cannot be null.");
        else if (subID !== undefined)
            url_ += "SubID=" + encodeURIComponent("" + subID) + "&";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        if (companyid === null)
            throw new Error("The parameter 'companyid' cannot be null.");
        else if (companyid !== undefined)
            url_ += "companyid=" + encodeURIComponent("" + companyid) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "startDate=" + encodeURIComponent("" + startDate) + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "endDate=" + encodeURIComponent("" + endDate) + "&";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchExpenses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchExpenses(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchExpenses(response: HttpResponseBase): Observable<ExpenseDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchExpensesDetailedServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param projid (optional) 
     * @param expensegrpid (optional) 
     * @param expensetypeid (optional) 
     * @param locationid (optional) 
     * @param deptid (optional) 
     * @param userid (optional) 
     * @param companyid (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchType (optional) 
     * @param page (optional) 
     * @param searchText (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchExpensesDetailed(projid: number | undefined, expensegrpid: number | undefined, expensetypeid: number | undefined, locationid: number | undefined, deptid: number | undefined, userid: number | undefined, companyid: number | undefined, startDate: Date | undefined, endDate: Date | undefined, searchType: number | undefined, page: number | undefined, searchText: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseRequest/FetchExpensesDetailed/FetchExpensesDetailed?";
        if (projid === null)
            throw new Error("The parameter 'projid' cannot be null.");
        else if (projid !== undefined)
            url_ += "projid=" + encodeURIComponent("" + projid) + "&";
        if (expensegrpid === null)
            throw new Error("The parameter 'expensegrpid' cannot be null.");
        else if (expensegrpid !== undefined)
            url_ += "expensegrpid=" + encodeURIComponent("" + expensegrpid) + "&";
        if (expensetypeid === null)
            throw new Error("The parameter 'expensetypeid' cannot be null.");
        else if (expensetypeid !== undefined)
            url_ += "expensetypeid=" + encodeURIComponent("" + expensetypeid) + "&";
        if (locationid === null)
            throw new Error("The parameter 'locationid' cannot be null.");
        else if (locationid !== undefined)
            url_ += "locationid=" + encodeURIComponent("" + locationid) + "&";
        if (deptid === null)
            throw new Error("The parameter 'deptid' cannot be null.");
        else if (deptid !== undefined)
            url_ += "deptid=" + encodeURIComponent("" + deptid) + "&";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        if (companyid === null)
            throw new Error("The parameter 'companyid' cannot be null.");
        else if (companyid !== undefined)
            url_ += "companyid=" + encodeURIComponent("" + companyid) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchExpensesDetailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchExpensesDetailed(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchExpensesDetailed(response: HttpResponseBase): Observable<ExpenseDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateLoanTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateExpenseType(body: ExpenseTypeDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/AddUpdateLoanType/AddUpdateExpenseType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateExpenseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateExpenseType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateExpenseType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateLoanRequest(body: LoanRequestDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/AddUpdateLoanType/Add-Update-Loan-Request";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateLoanRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateLoanRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateLoanRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateLoanType(body: LoanTypeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/AddUpdateLoanType/Add-Update-LoanType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateLoanType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateLoanType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateLoanType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseType(encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/ToggleExpenseType/ToggleExpenseType?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param iD (optional) 
     * @param ledgerNo (optional) 
     * @param name (optional) 
     * @param description (optional) 
     * @param referenceId (optional) 
     * @param code (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getExpenseTypes(iD: number | undefined, ledgerNo: string | null | undefined, name: string | null | undefined, description: string | null | undefined, referenceId: string | null | undefined, code: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/GetExpenseTypes/GetExpenseTypes?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (ledgerNo !== undefined && ledgerNo !== null)
            url_ += "LedgerNo=" + encodeURIComponent("" + ledgerNo) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (referenceId !== undefined && referenceId !== null)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseTypes(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseTypes(response: HttpResponseBase): Observable<ExpenseTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddExpenseSubTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addExpenseSubType(body: ExpenseSubType | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/AddExpenseSubType/AddExpenseSubType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddExpenseSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddExpenseSubType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddExpenseSubType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseSubTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param typeId (optional) 
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseSubType(typeId: string | null | undefined, encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/ToggleExpenseSubType/ToggleExpenseSubType?";
        if (typeId !== undefined && typeId !== null)
            url_ += "TypeId=" + encodeURIComponent("" + typeId) + "&";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseSubType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseSubType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseTypeNameServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    getExpenseTypeName(encryptedId: string | null | undefined): Observable<ExpenseTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/GetExpenseTypeName/GetExpenseTypeName?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseTypeName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseTypeName(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseTypeName(response: HttpResponseBase): Observable<ExpenseTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseSubTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param iD (optional) 
     * @param ledgerNo (optional) 
     * @param name (optional) 
     * @param description (optional) 
     * @param referenceId (optional) 
     * @param code (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getExpenseSubTypes(iD: number | undefined, ledgerNo: string | null | undefined, name: string | null | undefined, description: string | null | undefined, referenceId: string | null | undefined, code: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/GetExpenseSubTypes/GetExpenseSubTypes?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (ledgerNo !== undefined && ledgerNo !== null)
            url_ += "LedgerNo=" + encodeURIComponent("" + ledgerNo) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (referenceId !== undefined && referenceId !== null)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseSubTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseSubTypes(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseSubTypes(response: HttpResponseBase): Observable<ExpenseTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class GradeLevelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating GradeLevel
     * @param body (optional) 
     * @return Success
     */
    addUpdateGradeLevel(body: GradeLevelCreatePayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevel/Add-Update-GradeLevel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateGradeLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateGradeLevel(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateGradeLevel(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API  for Deleting GradeLevel
     * @param body (optional) 
     * @return Success
     */
    delete_GradeLevel(body: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevel/Delete GradeLevel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete_GradeLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete_GradeLevel(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDelete_GradeLevel(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch GradeLevel.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param promotion_min_years (optional) 
     * @param promotion_min_in_days (optional) 
     * @return Success
     */
    getAllGradeLevel(pageSize: number | undefined, pageNumber: number | undefined, promotion_min_years: number | null | undefined, promotion_min_in_days: number | null | undefined): Observable<GradeLevelDTOListApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevel/GetAllGradeLevel?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (promotion_min_years !== undefined && promotion_min_years !== null)
            url_ += "promotion_min_years=" + encodeURIComponent("" + promotion_min_years) + "&";
        if (promotion_min_in_days !== undefined && promotion_min_in_days !== null)
            url_ += "promotion_min_in_days=" + encodeURIComponent("" + promotion_min_in_days) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGradeLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGradeLevel(<any>response_);
                } catch (e) {
                    return <Observable<GradeLevelDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeLevelDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGradeLevel(response: HttpResponseBase): Observable<GradeLevelDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeLevelDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeLevelDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GradeLevelBenefitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating GradeLevelBenefit
     * @param body (optional) 
     * @return Success
     */
    addUpdateGradeLevelBenefit(body: ManageGradeLevelBenefitDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevelBenefit/Add-Update-GradeLevelBenefit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateGradeLevelBenefit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateGradeLevelBenefit(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateGradeLevelBenefit(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API  for Deleting GradeLevelBenefit
     * @param id (optional) 
     * @return Success
     */
    deleteGradeLevelBenefit(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevelBenefit/DeleteGradeLevelBenefit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGradeLevelBenefit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGradeLevelBenefit(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteGradeLevelBenefit(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to get GradeLevelBenefit by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getGradeLevelBenefitById(id: number | undefined): Observable<GradeLevelBenefitDTOApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevelBenefit/GetGradeLevelBenefitById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeLevelBenefitById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeLevelBenefitById(<any>response_);
                } catch (e) {
                    return <Observable<GradeLevelBenefitDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeLevelBenefitDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGradeLevelBenefitById(response: HttpResponseBase): Observable<GradeLevelBenefitDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeLevelBenefitDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeLevelBenefitDTOApiResult>(<any>null);
    }

    /**
     * API to Fetch GradeLevelBenefit.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllGradeLevelBenefit(pageSize: number | undefined, pageNumber: number | undefined): Observable<GradeLevelBenefitDTOListApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevelBenefit/GetAllGradeLevelBenefit?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGradeLevelBenefit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGradeLevelBenefit(<any>response_);
                } catch (e) {
                    return <Observable<GradeLevelBenefitDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeLevelBenefitDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGradeLevelBenefit(response: HttpResponseBase): Observable<GradeLevelBenefitDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeLevelBenefitDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeLevelBenefitDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateJobRolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating JobRole
     * @param body (optional) 
     * @return Success
     */
    addUpdateJobRoles(body: ManageJobRoleDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/JobRoles/AddUpdateJobRoles/Add-Update-JobRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateJobRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateJobRoles(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateJobRoles(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllJobRolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to Fetch JobRoles.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllJobRoles(pageSize: number | undefined, pageNumber: number | undefined): Observable<JobRolesDTOListApiResult> {
        let url_ = this.baseUrl + "/api/JobRoles/GetAllJobRoles/GetAllJobRoles?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllJobRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllJobRoles(<any>response_);
                } catch (e) {
                    return <Observable<JobRolesDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobRolesDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllJobRoles(response: HttpResponseBase): Observable<JobRolesDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobRolesDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobRolesDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetJobRoleByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to get jobroles by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getJobRolesById(id: number | undefined): Observable<JobRolesDTOApiResult> {
        let url_ = this.baseUrl + "/api/JobRoles/GetJobRoleById/GetJobRolesById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobRolesById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobRolesById(<any>response_);
                } catch (e) {
                    return <Observable<JobRolesDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobRolesDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobRolesById(response: HttpResponseBase): Observable<JobRolesDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobRolesDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobRolesDTOApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteJobRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used to delete Jobrole
     * @param id (optional) 
     * @return Success
     */
    deleteJobRole(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/JobRoles/DeleteJobRole/DeleteJobRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteJobRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteJobRole(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteJobRole(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchKeyResultAreasServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving all Key Result Areas with filters as follows 
    'Status: for Active/InActive' Key Result Area
    'RatingType: for Open-ended/Close-ended' Key Result Area
     * @param status (optional) 
     * @param ratingType (optional) 
     * @param strategyCategoryId (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getKeyResultAreas(status: number | undefined, ratingType: number | undefined, strategyCategoryId: number | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<SectionDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/KeyResultArea/FetchKeyResultAreas/GetKeyResultAreas?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (ratingType === null)
            throw new Error("The parameter 'ratingType' cannot be null.");
        else if (ratingType !== undefined)
            url_ += "RatingType=" + encodeURIComponent("" + ratingType) + "&";
        if (strategyCategoryId === null)
            throw new Error("The parameter 'strategyCategoryId' cannot be null.");
        else if (strategyCategoryId !== undefined)
            url_ += "StrategyCategoryId=" + encodeURIComponent("" + strategyCategoryId) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyResultAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyResultAreas(<any>response_);
                } catch (e) {
                    return <Observable<SectionDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SectionDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeyResultAreas(response: HttpResponseBase): Observable<SectionDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SectionDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SectionDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchKRAsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving all Key Result Areas without filters that can be using for dropdowns
     * @return Success
     */
    getKRAs(): Observable<KPISectionIListApiResult> {
        let url_ = this.baseUrl + "/api/KeyResultArea/FetchKRAs/GetKRAs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKRAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKRAs(<any>response_);
                } catch (e) {
                    return <Observable<KPISectionIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KPISectionIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetKRAs(response: HttpResponseBase): Observable<KPISectionIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KPISectionIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KPISectionIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchKeyResultAreaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for getting Single Key Result Area Details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getKeyResultArea(id: number | undefined): Observable<SectionDTOApiResult> {
        let url_ = this.baseUrl + "/api/KeyResultArea/FetchKeyResultArea/GetKeyResultArea?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyResultArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyResultArea(<any>response_);
                } catch (e) {
                    return <Observable<SectionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SectionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeyResultArea(response: HttpResponseBase): Observable<SectionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SectionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SectionDTOApiResult>(<any>null);
    }
}

@Injectable()
export class CreateKeyResultAreaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for add/updating Key Result Areas 
    Toggle (i.e. While Updating use the property 'IsActive'
    as Radio-toggle button and pass true/false. When creating new Key Result Areas 'IsActive is by default)
     * @param body (optional) 
     * @return Success
     */
    createKeyResultArea(body: ManageSectionDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/KeyResultArea/CreateKeyResultArea/CreateKeyResultArea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateKeyResultArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateKeyResultArea(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateKeyResultArea(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AssignKRAServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for add/updating Key Result Areas 
    Toggle (i.e. While Updating use the property 'IsActive'
    as Radio-toggle button and pass true/false. When creating new Key Result Areas 'IsActive is by default)
     * @param body (optional) 
     * @return Success
     */
    assignKRA(body: AssignKraDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/KeyResultArea/AssignKRA/AssignKRA";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignKRA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignKRA(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssignKRA(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateKPIServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for add/updating Key Performance Index (KPI) by Admin/Line Managers
     * @param body (optional) 
     * @return Success
     */
    addUpdateKPI(body: ManageKpiDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/KPI/AddUpdateKPI/Add-Update-KPI";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateKPI(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateKPI(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEmployeeKPIServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for add/updating Employee's Key Performance Index (KPI)
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmployeeKPI(body: ManageKpiDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/KPI/AddUpdateEmployeeKPI/Add-Update-EmployeeKPI";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmployeeKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmployeeKPI(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmployeeKPI(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchKPIsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving All Key Performance Index (KPIs) attach to a KRA
     * @param key_area_id (optional) 
     * @return Success
     */
    getKPIs(key_area_id: number | undefined): Observable<KpiDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/KPI/FetchKPIs/GetKPIs?";
        if (key_area_id === null)
            throw new Error("The parameter 'key_area_id' cannot be null.");
        else if (key_area_id !== undefined)
            url_ += "key_area_id=" + encodeURIComponent("" + key_area_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKPIs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKPIs(<any>response_);
                } catch (e) {
                    return <Observable<KpiDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KpiDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetKPIs(response: HttpResponseBase): Observable<KpiDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KpiDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KpiDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchKPIServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for getting Single Key Performance Index (KPI) Details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getKPI(id: number | undefined): Observable<KpiDTOApiResult> {
        let url_ = this.baseUrl + "/api/KPI/FetchKPI/GetKPI?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKPI(<any>response_);
                } catch (e) {
                    return <Observable<KpiDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KpiDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetKPI(response: HttpResponseBase): Observable<KpiDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KpiDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KpiDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeKPIsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving Employee's Key Performance Index (KPI)
     * @param key_area_id (optional) 
     * @return Success
     */
    getEmployeeKPIs(key_area_id: number | undefined): Observable<KpiDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/KPI/FetchEmployeeKPIs/GetEmployeeKPIs?";
        if (key_area_id === null)
            throw new Error("The parameter 'key_area_id' cannot be null.");
        else if (key_area_id !== undefined)
            url_ += "key_area_id=" + encodeURIComponent("" + key_area_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeKPIs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeKPIs(<any>response_);
                } catch (e) {
                    return <Observable<KpiDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KpiDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeKPIs(response: HttpResponseBase): Observable<KpiDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KpiDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KpiDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class LeaveEntitlementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used to fetch all the leave entitlements. no param for now
     * @return Success
     */
    getLeaveEntitlements(): Observable<LeaveEntitlementResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/GetLeaveEntitlements";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveEntitlements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveEntitlements(<any>response_);
                } catch (e) {
                    return <Observable<LeaveEntitlementResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveEntitlementResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveEntitlements(response: HttpResponseBase): Observable<LeaveEntitlementResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveEntitlementResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveEntitlementResourceListApiResult>(<any>null);
    }

    /**
     * this method is get leave entitlement by Id. Id is required
     * @param id (optional) 
     * @return Success
     */
    getLeaveEntitlement(id: number | undefined): Observable<LeaveEntitlementResourceApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/GetLeaveEntitlement?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveEntitlement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveEntitlement(<any>response_);
                } catch (e) {
                    return <Observable<LeaveEntitlementResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveEntitlementResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveEntitlement(response: HttpResponseBase): Observable<LeaveEntitlementResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveEntitlementResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveEntitlementResourceApiResult>(<any>null);
    }

    /**
     * this method is used to used to create and edit leave entitlement. Note all fields are required.
     * @param body (optional) 
     * @return Success
     */
    addOrUpdate(body: LeaveEntitlementPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/AddOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave entitlement
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveEntitlement(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/DeleteLeaveEntitlement?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveEntitlement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveEntitlement(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveEntitlement(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to fetch all grades for a particular company. it uses authenticated user comapyid
     * @return Success
     */
    getGrades(): Observable<GradeListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/GetGrades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGrades(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGrades(<any>response_);
                } catch (e) {
                    return <Observable<GradeListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGrades(response: HttpResponseBase): Observable<GradeListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateHolidayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for add/updating Leave Holiday Date
     * @param body (optional) 
     * @return Success
     */
    addUpdateHoliday(body: ManageLeaveHolidayDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/AddUpdateHoliday/Add-Update-Holiday";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateHoliday(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateHoliday(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateHoliday(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used to fetch all or by Id. no param for now
     * @return Success
     */
    getHolidayDates(): Observable<LeaveHolidayDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/Get/GetHolidayDates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHolidayDates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHolidayDates(<any>response_);
                } catch (e) {
                    return <Observable<LeaveHolidayDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveHolidayDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetHolidayDates(response: HttpResponseBase): Observable<LeaveHolidayDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveHolidayDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveHolidayDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is get leave holiday date by Id. Id is required
     * @param id (optional) 
     * @return Success
     */
    getHolidayById(id: number | undefined): Observable<LeaveHolidayDTOApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/GetById/GetHolidayById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHolidayById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHolidayById(<any>response_);
                } catch (e) {
                    return <Observable<LeaveHolidayDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveHolidayDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetHolidayById(response: HttpResponseBase): Observable<LeaveHolidayDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveHolidayDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveHolidayDTOApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used to delete leave holiday date
     * @param id (optional) 
     * @return Success
     */
    deleteHolidayDate(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/Delete/DeleteHolidayDate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteHolidayDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHolidayDate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteHolidayDate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave plan
     * @param id (optional) 
     * @return Success
     */
    deleteLeavePlan(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/Delete/DeleteLeavePlan?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeavePlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeavePlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeavePlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete. leave request Id is required
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveRequest(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/Delete/DeleteLeaveRequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave year
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveYear(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/Delete/DeleteLeaveYear?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveYear(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveYear(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchLeavePlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used fetch leave plans. all filter are optional
     * @param isApproved (optional) 
     * @param leaveYearId (optional) 
     * @param empno (optional) 
     * @param strStartDate (optional) 
     * @param strEndDate (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchLeavePlans(isApproved: number | null | undefined, leaveYearId: number | null | undefined, empno: string | null | undefined, strStartDate: string | null | undefined, strEndDate: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<LeavePlanResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/FetchLeavePlan/FetchLeavePlans?";
        if (isApproved !== undefined && isApproved !== null)
            url_ += "IsApproved=" + encodeURIComponent("" + isApproved) + "&";
        if (leaveYearId !== undefined && leaveYearId !== null)
            url_ += "LeaveYearId=" + encodeURIComponent("" + leaveYearId) + "&";
        if (empno !== undefined && empno !== null)
            url_ += "Empno=" + encodeURIComponent("" + empno) + "&";
        if (strStartDate !== undefined && strStartDate !== null)
            url_ += "StrStartDate=" + encodeURIComponent("" + strStartDate) + "&";
        if (strEndDate !== undefined && strEndDate !== null)
            url_ += "StrEndDate=" + encodeURIComponent("" + strEndDate) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchLeavePlans(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchLeavePlans(<any>response_);
                } catch (e) {
                    return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchLeavePlans(response: HttpResponseBase): Observable<LeavePlanResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeavePlanResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeavePlanResourceListApiResult>(<any>null);
    }
}

@Injectable()
export class LeavePlanEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used fetch events using calender type.calender type include: LeavePlan, ActiveLeaveRequests
     * @param calenderType (optional) 
     * @return Success
     */
    getLeavePlanEvents(calenderType: string | null | undefined): Observable<LeavePlanResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/LeavePlanEvents/GetLeavePlanEvents?";
        if (calenderType !== undefined && calenderType !== null)
            url_ += "calenderType=" + encodeURIComponent("" + calenderType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeavePlanEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeavePlanEvents(<any>response_);
                } catch (e) {
                    return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeavePlanEvents(response: HttpResponseBase): Observable<LeavePlanResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeavePlanResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeavePlanResourceListApiResult>(<any>null);
    }
}

@Injectable()
export class ApproveOrRejectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used to approve or reject leave plan. Note all fields are requiered except companyId
    it uses Enum Leaveplan status : Approved = 1, Reject = 2, Pending =3
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectLeavePlan(body: ApproveOrRejectPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/ApproveOrReject/ApproveOrRejectLeavePlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectLeavePlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectLeavePlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectLeavePlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class PostReviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used to review leave plan. Note all fields are requiered except companyId
    it uses Enum Leaveplan status : Approved = 1, Reject = 2, Pending =3
     * @param body (optional) 
     * @return Success
     */
    postReview(body: ApproveOrRejectPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/PostReview/postReview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostReview(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostReview(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CreateLeaveByAdminServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used to create and edit leave by admin.
     * @param body (optional) 
     * @return Success
     */
    createLeaveByAdmin(body: ManageLeaveRequestDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/CreateLeaveByAdmin/CreateLeaveByAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLeaveByAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLeaveByAdmin(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLeaveByAdmin(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used to get leave report.
    all filter is optional
     * @param departmentId (optional) 
     * @param leaveYearId (optional) 
     * @param leaveTypeId (optional) 
     * @param locationId (optional) 
     * @return Success
     */
    getLeaveReports(departmentId: string | null | undefined, leaveYearId: string | null | undefined, leaveTypeId: string | null | undefined, locationId: string | null | undefined): Observable<LeaveReportListDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/GetLeaveRequest/GetLeaveReports?";
        if (departmentId !== undefined && departmentId !== null)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (leaveYearId !== undefined && leaveYearId !== null)
            url_ += "LeaveYearId=" + encodeURIComponent("" + leaveYearId) + "&";
        if (leaveTypeId !== undefined && leaveTypeId !== null)
            url_ += "LeaveTypeId=" + encodeURIComponent("" + leaveTypeId) + "&";
        if (locationId !== undefined && locationId !== null)
            url_ += "LocationId=" + encodeURIComponent("" + locationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveReports(<any>response_);
                } catch (e) {
                    return <Observable<LeaveReportListDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveReportListDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveReports(response: HttpResponseBase): Observable<LeaveReportListDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveReportListDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveReportListDTOListApiResult>(<any>null);
    }

    /**
     * this method is used to get leave by Id.
    Id is required
     * @param id (optional) 
     * @return Success
     */
    getLeaveRequestById(id: number | undefined): Observable<LeaveRequestApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/GetLeaveRequest/GetLeaveRequestById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveRequestById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveRequestById(<any>response_);
                } catch (e) {
                    return <Observable<LeaveRequestApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveRequestApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveRequestById(response: HttpResponseBase): Observable<LeaveRequestApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveRequestApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveRequestApiResult>(<any>null);
    }
}

@Injectable()
export class CancelLeaveRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used to cancel leave request by initiator. leave request Id is required
     * @param id (optional) 
     * @return Success
     */
    cancelLeaveRequest(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/CancelLeaveRequest/CancelLeaveRequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelLeaveRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelLeaveRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCancelLeaveRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * fetch LeaveTypes.
    Note: all filter are optional
     * @param isAnnualLeave (optional) 
     * @param maxDays (optional) 
     * @param isGradeDependent (optional) 
     * @param minDays (optional) 
     * @return Success
     */
    getLeaveTypes(isAnnualLeave: boolean | undefined, maxDays: number | null | undefined, isGradeDependent: boolean | undefined, minDays: number | null | undefined): Observable<LeaveTypeDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/GetLeaveTypes/GetLeaveTypes?";
        if (isAnnualLeave === null)
            throw new Error("The parameter 'isAnnualLeave' cannot be null.");
        else if (isAnnualLeave !== undefined)
            url_ += "IsAnnualLeave=" + encodeURIComponent("" + isAnnualLeave) + "&";
        if (maxDays !== undefined && maxDays !== null)
            url_ += "MaxDays=" + encodeURIComponent("" + maxDays) + "&";
        if (isGradeDependent === null)
            throw new Error("The parameter 'isGradeDependent' cannot be null.");
        else if (isGradeDependent !== undefined)
            url_ += "IsGradeDependent=" + encodeURIComponent("" + isGradeDependent) + "&";
        if (minDays !== undefined && minDays !== null)
            url_ += "MinDays=" + encodeURIComponent("" + minDays) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveTypes(<any>response_);
                } catch (e) {
                    return <Observable<LeaveTypeDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveTypeDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveTypes(response: HttpResponseBase): Observable<LeaveTypeDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveTypeDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveTypeDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteLeaveTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used to delete leave type
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveType(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/DeleteLeaveType/DeleteLeaveType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * This method is used to get leave type by id
     * @param id (optional) 
     * @return Success
     */
    getLeaveType(id: number | undefined): Observable<LeaveTypeDTOApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/GetLeaveType/GetLeaveType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveType(<any>response_);
                } catch (e) {
                    return <Observable<LeaveTypeDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveTypeDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveType(response: HttpResponseBase): Observable<LeaveTypeDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveTypeDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveTypeDTOApiResult>(<any>null);
    }
}

@Injectable()
export class LeaveWorkFlowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used to fetch all the leave workflow. no param for now
     * @return Success
     */
    get(): Observable<LeaveWorkFlowResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LeaveWorkFlowResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveWorkFlowResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LeaveWorkFlowResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveWorkFlowResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveWorkFlowResourceListApiResult>(<any>null);
    }

    /**
     * this method is get leave workflow by Id. Id is required
     * @param id (optional) 
     * @return Success
     */
    getLeaveWorkFlowById(id: number | undefined): Observable<LeaveWorkFlowResourceApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/GetLeaveWorkFlowById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveWorkFlowById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveWorkFlowById(<any>response_);
                } catch (e) {
                    return <Observable<LeaveWorkFlowResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveWorkFlowResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveWorkFlowById(response: HttpResponseBase): Observable<LeaveWorkFlowResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveWorkFlowResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveWorkFlowResourceApiResult>(<any>null);
    }

    /**
     * this method is used to used to create and edit leave workflow. Note all fields are requiered.
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateWorkflow(body: LeaveworkFlowPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/AddOrUpdateWorkflow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateWorkflow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateWorkflow(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateWorkflow(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave workflow
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveWorkFlow(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/DeleteLeaveWorkFlow?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveWorkFlow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveWorkFlow(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveWorkFlow(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveYearsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * Gets leave years
     * @param yearStartDate (optional) 
     * @param yearName (optional) 
     * @param yearEndDate (optional) 
     * @param companyID (optional) 
     * @return Success
     */
    getLeaveYears(yearStartDate: Date | null | undefined, yearName: string | null | undefined, yearEndDate: Date | null | undefined, companyID: number | undefined): Observable<LeaveYearDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/GetLeaveYears/GetLeaveYears?";
        if (yearStartDate !== undefined && yearStartDate !== null)
            url_ += "YearStartDate=" + encodeURIComponent(yearStartDate ? "" + yearStartDate.toJSON() : "") + "&";
        if (yearName !== undefined && yearName !== null)
            url_ += "YearName=" + encodeURIComponent("" + yearName) + "&";
        if (yearEndDate !== undefined && yearEndDate !== null)
            url_ += "YearEndDate=" + encodeURIComponent(yearEndDate ? "" + yearEndDate.toJSON() : "") + "&";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveYears(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveYears(<any>response_);
                } catch (e) {
                    return <Observable<LeaveYearDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveYearDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveYears(response: HttpResponseBase): Observable<LeaveYearDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveYearDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveYearDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveYearServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used to delete leave year
     * @param id (optional) 
     * @return Success
     */
    getLeaveYear(id: number | undefined): Observable<LeaveYearDTOApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/GetLeaveYear/GetLeaveYear?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveYear(<any>response_);
                } catch (e) {
                    return <Observable<LeaveYearDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveYearDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveYear(response: HttpResponseBase): Observable<LeaveYearDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveYearDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveYearDTOApiResult>(<any>null);
    }
}

@Injectable()
export class PostFullRepaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postFullRepayment(body: PostLoanDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/PostFullRepayment/Post-Full-Repayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostFullRepayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostFullRepayment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostFullRepayment(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class SimulatePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param principal (optional) 
     * @param interestType (optional) 
     * @param tenor (optional) 
     * @param interestRate (optional) 
     * @param effectiveDate (optional) 
     * @return Success
     */
    simulatePayment(principal: number | undefined, interestType: number | undefined, tenor: number | undefined, interestRate: number | undefined, effectiveDate: string | null | undefined): Observable<LoanRepaymentLogIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/SimulatePayment/SimulatePayment?";
        if (principal === null)
            throw new Error("The parameter 'principal' cannot be null.");
        else if (principal !== undefined)
            url_ += "principal=" + encodeURIComponent("" + principal) + "&";
        if (interestType === null)
            throw new Error("The parameter 'interestType' cannot be null.");
        else if (interestType !== undefined)
            url_ += "interestType=" + encodeURIComponent("" + interestType) + "&";
        if (tenor === null)
            throw new Error("The parameter 'tenor' cannot be null.");
        else if (tenor !== undefined)
            url_ += "tenor=" + encodeURIComponent("" + tenor) + "&";
        if (interestRate === null)
            throw new Error("The parameter 'interestRate' cannot be null.");
        else if (interestRate !== undefined)
            url_ += "interestRate=" + encodeURIComponent("" + interestRate) + "&";
        if (effectiveDate !== undefined && effectiveDate !== null)
            url_ += "effectiveDate=" + encodeURIComponent("" + effectiveDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimulatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimulatePayment(<any>response_);
                } catch (e) {
                    return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSimulatePayment(response: HttpResponseBase): Observable<LoanRepaymentLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRepaymentLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRepaymentLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanRequestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param userid (optional) 
     * @param companyid (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchType (optional) 
     * @param page (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getLoanRequests(userid: number | undefined, companyid: number | undefined, startDate: Date | undefined, endDate: Date | undefined, searchType: number | undefined, page: number | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<LoanRequestDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/GetLoanRequests/GetLoanRequests?";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        if (companyid === null)
            throw new Error("The parameter 'companyid' cannot be null.");
        else if (companyid !== undefined)
            url_ += "companyid=" + encodeURIComponent("" + companyid) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanRequests(<any>response_);
                } catch (e) {
                    return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanRequests(response: HttpResponseBase): Observable<LoanRequestDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRequestDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRequestDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanSummaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param loanId (optional) 
     * @return Success
     */
    getLoanSummary(loanId: string | null | undefined): Observable<IdNameObjIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/GetLoanSummary/GetLoanSummary?";
        if (loanId !== undefined && loanId !== null)
            url_ += "LoanId=" + encodeURIComponent("" + loanId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanSummary(<any>response_);
                } catch (e) {
                    return <Observable<IdNameObjIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameObjIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanSummary(response: HttpResponseBase): Observable<IdNameObjIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdNameObjIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameObjIListApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateLoanRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLoanRequest(body: UpdateLoadRequestDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/UpdateLoanRequest/UpdateLoanRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLoanRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLoanRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLoanRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class LoadRepaymentScheduleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param loanId (optional) 
     * @param recompute (optional) 
     * @return Success
     */
    loadRepaymentSchedule(loanId: number | undefined, recompute: number | undefined): Observable<LoanRepaymentLogIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/LoadRepaymentSchedule/LoadRepaymentSchedule?";
        if (loanId === null)
            throw new Error("The parameter 'loanId' cannot be null.");
        else if (loanId !== undefined)
            url_ += "loanId=" + encodeURIComponent("" + loanId) + "&";
        if (recompute === null)
            throw new Error("The parameter 'recompute' cannot be null.");
        else if (recompute !== undefined)
            url_ += "recompute=" + encodeURIComponent("" + recompute) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadRepaymentSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadRepaymentSchedule(<any>response_);
                } catch (e) {
                    return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processLoadRepaymentSchedule(response: HttpResponseBase): Observable<LoanRepaymentLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRepaymentLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRepaymentLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchLoanRequestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param userid (optional) 
     * @param companyid (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchType (optional) 
     * @param page (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchLoanRequests(userid: number | undefined, companyid: number | undefined, startDate: Date | undefined, endDate: Date | undefined, searchType: number | undefined, page: number | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<LoanRequestDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/FetchLoanRequests/FetchLoanRequests?";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        if (companyid === null)
            throw new Error("The parameter 'companyid' cannot be null.");
        else if (companyid !== undefined)
            url_ += "companyid=" + encodeURIComponent("" + companyid) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchLoanRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchLoanRequests(<any>response_);
                } catch (e) {
                    return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchLoanRequests(response: HttpResponseBase): Observable<LoanRequestDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRequestDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRequestDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param companyId (optional) 
     * @param loanreqId (optional) 
     * @param userid (optional) 
     * @return Success
     */
    getLoanRequest(companyId: number | undefined, loanreqId: number | undefined, userid: number | undefined): Observable<LoanRequestApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/GetLoanRequest/GetLoanRequest?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (loanreqId === null)
            throw new Error("The parameter 'loanreqId' cannot be null.");
        else if (loanreqId !== undefined)
            url_ += "loanreqId=" + encodeURIComponent("" + loanreqId) + "&";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanRequest(<any>response_);
                } catch (e) {
                    return <Observable<LoanRequestApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRequestApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanRequest(response: HttpResponseBase): Observable<LoanRequestApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRequestApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRequestApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleLoanTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    toggleLoanType(body: LoadTypeById | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/ToggleLoanType/Toggle-Loan-Type";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleLoanType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleLoanType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleLoanType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanTypesByCriteriaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param iD (optional) 
     * @param code (optional) 
     * @param ledgerNo (optional) 
     * @param name (optional) 
     * @param minTenor (optional) 
     * @param maxTenor (optional) 
     * @param minAmount (optional) 
     * @param maxAmount (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getLoanTypesByCriteria(iD: number | undefined, code: string | null | undefined, ledgerNo: string | null | undefined, name: string | null | undefined, minTenor: number | undefined, maxTenor: number | undefined, minAmount: number | undefined, maxAmount: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<LoanTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/GetLoanTypesByCriteria/GetLoanTypesByCriteria?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (ledgerNo !== undefined && ledgerNo !== null)
            url_ += "LedgerNo=" + encodeURIComponent("" + ledgerNo) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (minTenor === null)
            throw new Error("The parameter 'minTenor' cannot be null.");
        else if (minTenor !== undefined)
            url_ += "MinTenor=" + encodeURIComponent("" + minTenor) + "&";
        if (maxTenor === null)
            throw new Error("The parameter 'maxTenor' cannot be null.");
        else if (maxTenor !== undefined)
            url_ += "MaxTenor=" + encodeURIComponent("" + maxTenor) + "&";
        if (minAmount === null)
            throw new Error("The parameter 'minAmount' cannot be null.");
        else if (minAmount !== undefined)
            url_ += "MinAmount=" + encodeURIComponent("" + minAmount) + "&";
        if (maxAmount === null)
            throw new Error("The parameter 'maxAmount' cannot be null.");
        else if (maxAmount !== undefined)
            url_ += "MaxAmount=" + encodeURIComponent("" + maxAmount) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanTypesByCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanTypesByCriteria(<any>response_);
                } catch (e) {
                    return <Observable<LoanTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanTypesByCriteria(response: HttpResponseBase): Observable<LoanTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchLoanTypeByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param iD (optional) 
     * @param companyID (optional) 
     * @return Success
     */
    fetchLoanTypeById(iD: number | undefined, companyID: number | undefined): Observable<LoanTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/FetchLoanTypeById/FetchLoanTypeById?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchLoanTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchLoanTypeById(<any>response_);
                } catch (e) {
                    return <Observable<LoanTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchLoanTypeById(response: HttpResponseBase): Observable<LoanTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateLocationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating Location
     * @param body (optional) 
     * @return Success
     */
    addUpdateLocation(body: ManageLocationDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Location/AddUpdateLocation/Add-Update-Location";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateLocation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateLocation(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllLocationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to Fetch Locations.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param lga_id (optional) 
     * @param state_id (optional) 
     * @return Success
     */
    getAllLocations(pageSize: number | undefined, pageNumber: number | undefined, lga_id: number | undefined, state_id: number | undefined): Observable<LocationDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Location/GetAllLocations/GetAllLocations?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (lga_id === null)
            throw new Error("The parameter 'lga_id' cannot be null.");
        else if (lga_id !== undefined)
            url_ += "lga_id=" + encodeURIComponent("" + lga_id) + "&";
        if (state_id === null)
            throw new Error("The parameter 'state_id' cannot be null.");
        else if (state_id !== undefined)
            url_ += "state_id=" + encodeURIComponent("" + state_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLocations(<any>response_);
                } catch (e) {
                    return <Observable<LocationDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLocations(response: HttpResponseBase): Observable<LocationDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLocationByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to get Location by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getLocation(id: number | undefined): Observable<LocationDTOApiResult> {
        let url_ = this.baseUrl + "/api/Location/GetLocationById/GetLocation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocation(<any>response_);
                } catch (e) {
                    return <Observable<LocationDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocation(response: HttpResponseBase): Observable<LocationDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchOnboardingPersonnalDataByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param id (optional) 
     * @param companyId (optional) 
     * @param subId (optional) 
     * @return Success
     */
    fetchOnboardingPersonnalDataById(id: number | undefined, companyId: number | undefined, subId: number | undefined): Observable<OnboardingPersonalInfoApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/FetchOnboardingPersonnalDataById/FetchOnboardingPersonnalDataById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "SubId=" + encodeURIComponent("" + subId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchOnboardingPersonnalDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchOnboardingPersonnalDataById(<any>response_);
                } catch (e) {
                    return <Observable<OnboardingPersonalInfoApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OnboardingPersonalInfoApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchOnboardingPersonnalDataById(response: HttpResponseBase): Observable<OnboardingPersonalInfoApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingPersonalInfoApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OnboardingPersonalInfoApiResult>(<any>null);
    }
}

@Injectable()
export class FetchOnboardingDocummentDataByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param id (optional) 
     * @param onboardingId (optional) 
     * @param companyId (optional) 
     * @param subId (optional) 
     * @return Success
     */
    fetchOnboardingDocummentDataById(id: number | undefined, onboardingId: number | undefined, companyId: number | undefined, subId: number | undefined): Observable<OnboardingDocumentInfoApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/FetchOnboardingDocummentDataById/FetchOnboardingDocummentDataById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (onboardingId === null)
            throw new Error("The parameter 'onboardingId' cannot be null.");
        else if (onboardingId !== undefined)
            url_ += "OnboardingId=" + encodeURIComponent("" + onboardingId) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "SubId=" + encodeURIComponent("" + subId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchOnboardingDocummentDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchOnboardingDocummentDataById(<any>response_);
                } catch (e) {
                    return <Observable<OnboardingDocumentInfoApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OnboardingDocumentInfoApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchOnboardingDocummentDataById(response: HttpResponseBase): Observable<OnboardingDocumentInfoApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingDocumentInfoApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OnboardingDocumentInfoApiResult>(<any>null);
    }
}

@Injectable()
export class FetchOnboardingMedicalDisclosureDataByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param id (optional) 
     * @param onboardingId (optional) 
     * @param companyId (optional) 
     * @param subId (optional) 
     * @return Success
     */
    fetchOnboardingMedicalDisclosureDataById(id: number | undefined, onboardingId: number | undefined, companyId: number | undefined, subId: number | undefined): Observable<OnboardingMedicalDisclosureInfoApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/FetchOnboardingMedicalDisclosureDataById/FetchOnboardingMedicalDisclosureDataById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (onboardingId === null)
            throw new Error("The parameter 'onboardingId' cannot be null.");
        else if (onboardingId !== undefined)
            url_ += "OnboardingId=" + encodeURIComponent("" + onboardingId) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "SubId=" + encodeURIComponent("" + subId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchOnboardingMedicalDisclosureDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchOnboardingMedicalDisclosureDataById(<any>response_);
                } catch (e) {
                    return <Observable<OnboardingMedicalDisclosureInfoApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OnboardingMedicalDisclosureInfoApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchOnboardingMedicalDisclosureDataById(response: HttpResponseBase): Observable<OnboardingMedicalDisclosureInfoApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingMedicalDisclosureInfoApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OnboardingMedicalDisclosureInfoApiResult>(<any>null);
    }
}

@Injectable()
export class FetchOnboardingPaymentDataByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param id (optional) 
     * @param onboardingId (optional) 
     * @param companyId (optional) 
     * @param subId (optional) 
     * @return Success
     */
    fetchOnboardingPaymentDataById(id: number | undefined, onboardingId: number | undefined, companyId: number | undefined, subId: number | undefined): Observable<OnboardingMedicalDisclosureInfoApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/FetchOnboardingPaymentDataById/FetchOnboardingPaymentDataById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (onboardingId === null)
            throw new Error("The parameter 'onboardingId' cannot be null.");
        else if (onboardingId !== undefined)
            url_ += "OnboardingId=" + encodeURIComponent("" + onboardingId) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "SubId=" + encodeURIComponent("" + subId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchOnboardingPaymentDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchOnboardingPaymentDataById(<any>response_);
                } catch (e) {
                    return <Observable<OnboardingMedicalDisclosureInfoApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OnboardingMedicalDisclosureInfoApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchOnboardingPaymentDataById(response: HttpResponseBase): Observable<OnboardingMedicalDisclosureInfoApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingMedicalDisclosureInfoApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OnboardingMedicalDisclosureInfoApiResult>(<any>null);
    }
}

@Injectable()
export class FetchOnboardingTaxDataByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param id (optional) 
     * @param onboardingId (optional) 
     * @param companyId (optional) 
     * @param subId (optional) 
     * @return Success
     */
    fetchOnboardingTaxDataById(id: number | undefined, onboardingId: number | undefined, companyId: number | undefined, subId: number | undefined): Observable<OnboardingTaxInfoApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/FetchOnboardingTaxDataById/FetchOnboardingTaxDataById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (onboardingId === null)
            throw new Error("The parameter 'onboardingId' cannot be null.");
        else if (onboardingId !== undefined)
            url_ += "OnboardingId=" + encodeURIComponent("" + onboardingId) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "SubId=" + encodeURIComponent("" + subId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchOnboardingTaxDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchOnboardingTaxDataById(<any>response_);
                } catch (e) {
                    return <Observable<OnboardingTaxInfoApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OnboardingTaxInfoApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchOnboardingTaxDataById(response: HttpResponseBase): Observable<OnboardingTaxInfoApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingTaxInfoApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OnboardingTaxInfoApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeOnboardingDataDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param onboardingId (optional) 
     * @param companyId (optional) 
     * @return Success
     */
    fetchEmployeeOnboardingDataDetails(onboardingId: number | undefined, companyId: number | undefined): Observable<EmployeeOnboardingPersonalDataListApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/FetchEmployeeOnboardingDataDetails/FetchEmployeeOnboardingDataDetails?";
        if (onboardingId === null)
            throw new Error("The parameter 'onboardingId' cannot be null.");
        else if (onboardingId !== undefined)
            url_ += "OnboardingId=" + encodeURIComponent("" + onboardingId) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEmployeeOnboardingDataDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEmployeeOnboardingDataDetails(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeOnboardingPersonalDataListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeOnboardingPersonalDataListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEmployeeOnboardingDataDetails(response: HttpResponseBase): Observable<EmployeeOnboardingPersonalDataListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeOnboardingPersonalDataListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeOnboardingPersonalDataListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdatePayElementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating Pay Element
     * @param body (optional) 
     * @return Success
     */
    addUpdatePayElement(body: ManagePayElementDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/PayElement/AddUpdatePayElement/Add-Update-PayElement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdatePayElement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdatePayElement(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdatePayElement(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllPayElementsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to Fetch Payment Elements.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param payTypeId (optional) 
     * @param paymentInstitutionId (optional) 
     * @param elementTypeId (optional) 
     * @param elementCategoryId (optional) 
     * @return Success
     */
    getAllPayElements(pageSize: number | undefined, pageNumber: number | undefined, payTypeId: number | undefined, paymentInstitutionId: number | undefined, elementTypeId: number | undefined, elementCategoryId: number | undefined): Observable<PayElementDTOListApiResult> {
        let url_ = this.baseUrl + "/api/PayElement/GetAllPayElements/GetAllPayElements?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (payTypeId === null)
            throw new Error("The parameter 'payTypeId' cannot be null.");
        else if (payTypeId !== undefined)
            url_ += "PayTypeId=" + encodeURIComponent("" + payTypeId) + "&";
        if (paymentInstitutionId === null)
            throw new Error("The parameter 'paymentInstitutionId' cannot be null.");
        else if (paymentInstitutionId !== undefined)
            url_ += "PaymentInstitutionId=" + encodeURIComponent("" + paymentInstitutionId) + "&";
        if (elementTypeId === null)
            throw new Error("The parameter 'elementTypeId' cannot be null.");
        else if (elementTypeId !== undefined)
            url_ += "ElementTypeId=" + encodeURIComponent("" + elementTypeId) + "&";
        if (elementCategoryId === null)
            throw new Error("The parameter 'elementCategoryId' cannot be null.");
        else if (elementCategoryId !== undefined)
            url_ += "ElementCategoryId=" + encodeURIComponent("" + elementCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPayElements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPayElements(<any>response_);
                } catch (e) {
                    return <Observable<PayElementDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayElementDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPayElements(response: HttpResponseBase): Observable<PayElementDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayElementDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayElementDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetPayElementByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to get Payment Element by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getPayElement(id: number | undefined): Observable<PayElementDTOApiResult> {
        let url_ = this.baseUrl + "/api/PayElement/GetPayElementById/GetPayElement?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayElement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayElement(<any>response_);
                } catch (e) {
                    return <Observable<PayElementDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayElementDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayElement(response: HttpResponseBase): Observable<PayElementDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayElementDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayElementDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdatePaymentInstitutionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating Payment Institution
     * @param body (optional) 
     * @return Success
     */
    addUpdatePaymentInstitution(body: ManagePayInstitutionDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/PaymentInstitution/AddUpdatePaymentInstitution/Add-Update-PaymentInstitution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdatePaymentInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdatePaymentInstitution(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdatePaymentInstitution(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllPaymentInstitutionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to Fetch Payment Institutions.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param categoryId (optional) 
     * @return Success
     */
    getAllPaymentInstitutions(pageSize: number | undefined, pageNumber: number | undefined, categoryId: number | undefined): Observable<PayInstitutionDTOListApiResult> {
        let url_ = this.baseUrl + "/api/PaymentInstitution/GetAllPaymentInstitutions/GetAllPaymentInstitutions?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPaymentInstitutions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPaymentInstitutions(<any>response_);
                } catch (e) {
                    return <Observable<PayInstitutionDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayInstitutionDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPaymentInstitutions(response: HttpResponseBase): Observable<PayInstitutionDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayInstitutionDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayInstitutionDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetPaymentInstitutionByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to get Payment Institution by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getPaymentInstitution(id: number | undefined): Observable<PayInstitutionDTOApiResult> {
        let url_ = this.baseUrl + "/api/PaymentInstitution/GetPaymentInstitutionById/GetPaymentInstitution?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInstitution(<any>response_);
                } catch (e) {
                    return <Observable<PayInstitutionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayInstitutionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInstitution(response: HttpResponseBase): Observable<PayInstitutionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayInstitutionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayInstitutionDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdatePayScaleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating Payroll Type (Pay Scale)
     * @param body (optional) 
     * @return Success
     */
    addUpdatePayScale(body: ManagePayrollTypeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/PayrollType/AddUpdatePayScale/Add-Update-PayScale";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdatePayScale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdatePayScale(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdatePayScale(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllPayrollTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to Fetch Payroll Types.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param frequencyRuleId (optional) 
     * @return Success
     */
    getAllPayrollTypes(pageSize: number | undefined, pageNumber: number | undefined, frequencyRuleId: number | undefined): Observable<PayrollTypeDTOListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollType/GetAllPayrollTypes/GetAllPayrollTypes?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (frequencyRuleId === null)
            throw new Error("The parameter 'frequencyRuleId' cannot be null.");
        else if (frequencyRuleId !== undefined)
            url_ += "FrequencyRuleId=" + encodeURIComponent("" + frequencyRuleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPayrollTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPayrollTypes(<any>response_);
                } catch (e) {
                    return <Observable<PayrollTypeDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayrollTypeDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPayrollTypes(response: HttpResponseBase): Observable<PayrollTypeDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayrollTypeDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayrollTypeDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetPayrollTypeByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to get Payroll Type by id and can be used for update, details and also
    includes; No. of Employees and Employee list that are attached to this PayScale etc
     * @param id (optional) 
     * @return Success
     */
    getPayrollType(id: number | undefined): Observable<PayrollTypeDTOApiResult> {
        let url_ = this.baseUrl + "/api/PayrollType/GetPayrollTypeById/GetPayrollType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayrollType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayrollType(<any>response_);
                } catch (e) {
                    return <Observable<PayrollTypeDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayrollTypeDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayrollType(response: HttpResponseBase): Observable<PayrollTypeDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayrollTypeDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayrollTypeDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchPerformanceCyclesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving all Performance Cycles with filters as follows 
    'Status: for Active, Pending_Approval, Approved, Ongoing, Closed
    'RatingType: for Open-ended/Close-ended'
     * @param status (optional) 
     * @param departmentId (optional) 
     * @param locationId (optional) 
     * @param unitId (optional) 
     * @param ratingType (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getPerformanceCycles(status: number | undefined, departmentId: number | undefined, locationId: number | undefined, unitId: number | undefined, ratingType: number | undefined, pageSize: number | undefined): Observable<CycleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/PerformanceCycle/FetchPerformanceCycles/GetPerformanceCycles?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "LocationId=" + encodeURIComponent("" + locationId) + "&";
        if (unitId === null)
            throw new Error("The parameter 'unitId' cannot be null.");
        else if (unitId !== undefined)
            url_ += "UnitId=" + encodeURIComponent("" + unitId) + "&";
        if (ratingType === null)
            throw new Error("The parameter 'ratingType' cannot be null.");
        else if (ratingType !== undefined)
            url_ += "RatingType=" + encodeURIComponent("" + ratingType) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformanceCycles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformanceCycles(<any>response_);
                } catch (e) {
                    return <Observable<CycleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CycleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformanceCycles(response: HttpResponseBase): Observable<CycleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CycleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CycleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchPerformanceCycleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for getting Single Performance Cycle Details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getPerformanceCycle(id: number | undefined): Observable<CycleDTOApiResult> {
        let url_ = this.baseUrl + "/api/PerformanceCycle/FetchPerformanceCycle/GetPerformanceCycle?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformanceCycle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformanceCycle(<any>response_);
                } catch (e) {
                    return <Observable<CycleDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CycleDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformanceCycle(response: HttpResponseBase): Observable<CycleDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CycleDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CycleDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdatePerformanceCycleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for add/updating Performance Cycle
    Toggle (i.e. While Updating use the property 'IsActive'
    as Radio-toggle button and pass true/false. When creating new Performance Cycle 'IsActive is by default)
     * @param body (optional) 
     * @return Success
     */
    addUpdatePerformanceCycle(body: ManageCycleDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/PerformanceCycle/AddUpdatePerformanceCycle/Add-Update-PerformanceCycle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdatePerformanceCycle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdatePerformanceCycle(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdatePerformanceCycle(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdatePositionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating Position
     * @param body (optional) 
     * @return Success
     */
    addUpdatePosition(body: ManagePositionDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Position/AddUpdatePosition/Add-Update-Position";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdatePosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdatePosition(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdatePosition(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllPositionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to Fetch Positions.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param parentPositionId (optional) 
     * @param nextPositionId (optional) 
     * @param basicSalary (optional) 
     * @return Success
     */
    getAllPositions(pageSize: number | undefined, pageNumber: number | undefined, parentPositionId: number | undefined, nextPositionId: number | undefined, basicSalary: number | undefined): Observable<PositionDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Position/GetAllPositions/GetAllPositions?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (parentPositionId === null)
            throw new Error("The parameter 'parentPositionId' cannot be null.");
        else if (parentPositionId !== undefined)
            url_ += "ParentPositionId=" + encodeURIComponent("" + parentPositionId) + "&";
        if (nextPositionId === null)
            throw new Error("The parameter 'nextPositionId' cannot be null.");
        else if (nextPositionId !== undefined)
            url_ += "NextPositionId=" + encodeURIComponent("" + nextPositionId) + "&";
        if (basicSalary === null)
            throw new Error("The parameter 'basicSalary' cannot be null.");
        else if (basicSalary !== undefined)
            url_ += "BasicSalary=" + encodeURIComponent("" + basicSalary) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPositions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPositions(<any>response_);
                } catch (e) {
                    return <Observable<PositionDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPositions(response: HttpResponseBase): Observable<PositionDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PositionDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetPositionByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to get Position by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getPosition(id: number | undefined): Observable<PositionDTOApiResult> {
        let url_ = this.baseUrl + "/api/Position/GetPositionById/GetPosition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosition(<any>response_);
                } catch (e) {
                    return <Observable<PositionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPosition(response: HttpResponseBase): Observable<PositionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PositionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEligibleBucketServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateEligibleBucket(body: PromotionEligibilityViewModel | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Promotion/AddUpdateEligibleBucket/AddUpdateEligibleBucket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEligibleBucket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEligibleBucket(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEligibleBucket(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class PromotionListServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param _PageSize (optional) 
     * @param eligiblility_id (optional) 
     * @return Success
     */
    promotionList(_PageSize: number | undefined, eligiblility_id: number | undefined): Observable<Sp_FetchEligibleEmployeesIListApiResult> {
        let url_ = this.baseUrl + "/api/Promotion/PromotionList/PromotionList?";
        if (_PageSize === null)
            throw new Error("The parameter '_PageSize' cannot be null.");
        else if (_PageSize !== undefined)
            url_ += "_PageSize=" + encodeURIComponent("" + _PageSize) + "&";
        if (eligiblility_id === null)
            throw new Error("The parameter 'eligiblility_id' cannot be null.");
        else if (eligiblility_id !== undefined)
            url_ += "eligiblility_id=" + encodeURIComponent("" + eligiblility_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromotionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromotionList(<any>response_);
                } catch (e) {
                    return <Observable<Sp_FetchEligibleEmployeesIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<Sp_FetchEligibleEmployeesIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPromotionList(response: HttpResponseBase): Observable<Sp_FetchEligibleEmployeesIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sp_FetchEligibleEmployeesIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sp_FetchEligibleEmployeesIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchPromotionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @return Success
     */
    fetchPromotions(): Observable<Sp_FetchEligibleEmployeesIListApiResult> {
        let url_ = this.baseUrl + "/api/Promotion/FetchPromotions/FetchPromotions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchPromotions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchPromotions(<any>response_);
                } catch (e) {
                    return <Observable<Sp_FetchEligibleEmployeesIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<Sp_FetchEligibleEmployeesIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchPromotions(response: HttpResponseBase): Observable<Sp_FetchEligibleEmployeesIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sp_FetchEligibleEmployeesIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sp_FetchEligibleEmployeesIListApiResult>(<any>null);
    }
}

@Injectable()
export class PromotionSchedule_SearchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param _eligibilityId (optional) 
     * @param _action (optional) 
     * @param _selected (optional) 
     * @param waive_rule (optional) 
     * @param promotionCategoryId (optional) 
     * @param parentPositionId (optional) 
     * @return Success
     */
    promotionSchedule_Search(_eligibilityId: number | undefined, _action: string | null | undefined, _selected: string | null | undefined, waive_rule: number | undefined, promotionCategoryId: number | undefined, parentPositionId: number | undefined): Observable<VwPromotionScheduleApiResult> {
        let url_ = this.baseUrl + "/api/Promotion/PromotionSchedule_Search/PromotionSchedule_Search?";
        if (_eligibilityId === null)
            throw new Error("The parameter '_eligibilityId' cannot be null.");
        else if (_eligibilityId !== undefined)
            url_ += "_eligibilityId=" + encodeURIComponent("" + _eligibilityId) + "&";
        if (_action !== undefined && _action !== null)
            url_ += "_action=" + encodeURIComponent("" + _action) + "&";
        if (_selected !== undefined && _selected !== null)
            url_ += "_selected=" + encodeURIComponent("" + _selected) + "&";
        if (waive_rule === null)
            throw new Error("The parameter 'waive_rule' cannot be null.");
        else if (waive_rule !== undefined)
            url_ += "waive_rule=" + encodeURIComponent("" + waive_rule) + "&";
        if (promotionCategoryId === null)
            throw new Error("The parameter 'promotionCategoryId' cannot be null.");
        else if (promotionCategoryId !== undefined)
            url_ += "promotionCategoryId=" + encodeURIComponent("" + promotionCategoryId) + "&";
        if (parentPositionId === null)
            throw new Error("The parameter 'parentPositionId' cannot be null.");
        else if (parentPositionId !== undefined)
            url_ += "parentPositionId=" + encodeURIComponent("" + parentPositionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromotionSchedule_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromotionSchedule_Search(<any>response_);
                } catch (e) {
                    return <Observable<VwPromotionScheduleApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwPromotionScheduleApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPromotionSchedule_Search(response: HttpResponseBase): Observable<VwPromotionScheduleApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwPromotionScheduleApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwPromotionScheduleApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRatingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving all Ratings
     * @return Success
     */
    getRatings(): Observable<RatingDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Rating/FetchRatings/GetRatings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRatings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRatings(<any>response_);
                } catch (e) {
                    return <Observable<RatingDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RatingDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRatings(response: HttpResponseBase): Observable<RatingDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RatingDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RatingDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateRatingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for add/updating Rating
     * @param payloads (optional) 
     * @return Success
     */
    addUpdateRating(payloads: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Rating/AddUpdateRating/Add-Update-Rating?";
        if (payloads !== undefined && payloads !== null)
            url_ += "payloads=" + encodeURIComponent("" + payloads) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateRating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateRating(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateRating(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteRatingRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for deleting Rating
     * @param id (optional) 
     * @return Success
     */
    deleteRating(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Rating/DeleteRatingRecord/DeleteRating?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRating(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRating(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating Request
     * @param body (optional) 
     * @return Success
     */
    addUpdateRequest(body: ManageRequestDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RequestandComplaint/AddUpdateRequest/Add-Update-Request";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to Fetch Requests.
    Note: all filter are optional
     * @param departmentId (optional) 
     * @param requestStatusId (optional) 
     * @param log_status (optional) 
     * @param requestTypeId (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllRequest(departmentId: number | undefined, requestStatusId: number | undefined, log_status: number | undefined, requestTypeId: number | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<RequestDTOListApiResult> {
        let url_ = this.baseUrl + "/api/RequestandComplaint/GetAllRequest/GetAllRequest?";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (requestStatusId === null)
            throw new Error("The parameter 'requestStatusId' cannot be null.");
        else if (requestStatusId !== undefined)
            url_ += "RequestStatusId=" + encodeURIComponent("" + requestStatusId) + "&";
        if (log_status === null)
            throw new Error("The parameter 'log_status' cannot be null.");
        else if (log_status !== undefined)
            url_ += "log_status=" + encodeURIComponent("" + log_status) + "&";
        if (requestTypeId === null)
            throw new Error("The parameter 'requestTypeId' cannot be null.");
        else if (requestTypeId !== undefined)
            url_ += "RequestTypeId=" + encodeURIComponent("" + requestTypeId) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRequest(<any>response_);
                } catch (e) {
                    return <Observable<RequestDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRequest(response: HttpResponseBase): Observable<RequestDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetRequestByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to get Department by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getRequestById(id: number | undefined): Observable<RequestDTOApiResult> {
        let url_ = this.baseUrl + "/api/RequestandComplaint/GetRequestById/GetRequestById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestById(<any>response_);
                } catch (e) {
                    return <Observable<RequestDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestById(response: HttpResponseBase): Observable<RequestDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateRequestTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating RequestType
     * @param body (optional) 
     * @return Success
     */
    addUpdateRequestTypeRequest(body: ManageRequestTypeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RequestType/AddUpdateRequestType/Add-Update-RequestType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateRequestTypeRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateRequestTypeRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateRequestTypeRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateRequestType(body: AddRequestViewModel | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RewardDisciplinary/AddUpdateRequestType/AddUpdateRequestType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateRequestType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateRequestType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateRequestType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllRequestTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to Fetch RequestType.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllRequestType(pageSize: number | undefined, pageNumber: number | undefined): Observable<RequestTypeDTOListApiResult> {
        let url_ = this.baseUrl + "/api/RequestType/GetAllRequestType/GetAllRequestType?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRequestType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRequestType(<any>response_);
                } catch (e) {
                    return <Observable<RequestTypeDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestTypeDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRequestType(response: HttpResponseBase): Observable<RequestTypeDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestTypeDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestTypeDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetRequestTypeByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API to get RequestType by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getRequestTypeById(id: number | undefined): Observable<RequestTypeDTOApiResult> {
        let url_ = this.baseUrl + "/api/RequestType/GetRequestTypeById/GetRequestTypeById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestTypeById(<any>response_);
                } catch (e) {
                    return <Observable<RequestTypeDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestTypeDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestTypeById(response: HttpResponseBase): Observable<RequestTypeDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestTypeDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestTypeDTOApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteRequestTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRequestType(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RequestType/DeleteRequestType/Delete-RequestType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRequestType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRequestType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRequestType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RetirementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating Post Retirement
     * @param iD (optional) 
     * @param retirementLogId (optional) 
     * @param retirementTypeId (optional) 
     * @param retirementType (optional) 
     * @param age (optional) 
     * @param strAge (optional) 
     * @param yearsOfService (optional) 
     * @param strYearsOfService (optional) 
     * @param employeeId (optional) 
     * @param employeeContractId (optional) 
     * @param staffNo (optional) 
     * @param fullName (optional) 
     * @param dOB (optional) 
     * @param appointmentDate (optional) 
     * @param effectiveDate (optional) 
     * @param strEffectiveDate (optional) 
     * @param refNo (optional) 
     * @param causeOfLeaving (optional) 
     * @param otherComments (optional) 
     * @param submittedBy (optional) 
     * @param dateSubmitted (optional) 
     * @param reviewedBy (optional) 
     * @param reviewerComment (optional) 
     * @param dateReviewed (optional) 
     * @param isAccepted (optional) 
     * @param log_status (optional) 
     * @param adminMode (optional) 
     * @param saveNsubmit (optional) 
     * @return Success
     */
    postRetireee(iD: number | undefined, retirementLogId: number | undefined, retirementTypeId: number | undefined, retirementType: string | null | undefined, age: number | undefined, strAge: string | null | undefined, yearsOfService: number | undefined, strYearsOfService: string | null | undefined, employeeId: number | undefined, employeeContractId: number | undefined, staffNo: string | null | undefined, fullName: string | null | undefined, dOB: Date | null | undefined, appointmentDate: Date | null | undefined, effectiveDate: Date | null | undefined, strEffectiveDate: string | null | undefined, refNo: string | null | undefined, causeOfLeaving: string | null | undefined, otherComments: string | null | undefined, submittedBy: string | null | undefined, dateSubmitted: Date | null | undefined, reviewedBy: string | null | undefined, reviewerComment: string | null | undefined, dateReviewed: Date | null | undefined, isAccepted: boolean | null | undefined, log_status: number | undefined, adminMode: number | undefined, saveNsubmit: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/PostRetireee?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (retirementLogId === null)
            throw new Error("The parameter 'retirementLogId' cannot be null.");
        else if (retirementLogId !== undefined)
            url_ += "RetirementLogId=" + encodeURIComponent("" + retirementLogId) + "&";
        if (retirementTypeId === null)
            throw new Error("The parameter 'retirementTypeId' cannot be null.");
        else if (retirementTypeId !== undefined)
            url_ += "RetirementTypeId=" + encodeURIComponent("" + retirementTypeId) + "&";
        if (retirementType !== undefined && retirementType !== null)
            url_ += "RetirementType=" + encodeURIComponent("" + retirementType) + "&";
        if (age === null)
            throw new Error("The parameter 'age' cannot be null.");
        else if (age !== undefined)
            url_ += "Age=" + encodeURIComponent("" + age) + "&";
        if (strAge !== undefined && strAge !== null)
            url_ += "strAge=" + encodeURIComponent("" + strAge) + "&";
        if (yearsOfService === null)
            throw new Error("The parameter 'yearsOfService' cannot be null.");
        else if (yearsOfService !== undefined)
            url_ += "YearsOfService=" + encodeURIComponent("" + yearsOfService) + "&";
        if (strYearsOfService !== undefined && strYearsOfService !== null)
            url_ += "strYearsOfService=" + encodeURIComponent("" + strYearsOfService) + "&";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        if (employeeContractId === null)
            throw new Error("The parameter 'employeeContractId' cannot be null.");
        else if (employeeContractId !== undefined)
            url_ += "EmployeeContractId=" + encodeURIComponent("" + employeeContractId) + "&";
        if (staffNo !== undefined && staffNo !== null)
            url_ += "StaffNo=" + encodeURIComponent("" + staffNo) + "&";
        if (fullName !== undefined && fullName !== null)
            url_ += "FullName=" + encodeURIComponent("" + fullName) + "&";
        if (dOB !== undefined && dOB !== null)
            url_ += "DOB=" + encodeURIComponent(dOB ? "" + dOB.toJSON() : "") + "&";
        if (appointmentDate !== undefined && appointmentDate !== null)
            url_ += "AppointmentDate=" + encodeURIComponent(appointmentDate ? "" + appointmentDate.toJSON() : "") + "&";
        if (effectiveDate !== undefined && effectiveDate !== null)
            url_ += "EffectiveDate=" + encodeURIComponent(effectiveDate ? "" + effectiveDate.toJSON() : "") + "&";
        if (strEffectiveDate !== undefined && strEffectiveDate !== null)
            url_ += "strEffectiveDate=" + encodeURIComponent("" + strEffectiveDate) + "&";
        if (refNo !== undefined && refNo !== null)
            url_ += "RefNo=" + encodeURIComponent("" + refNo) + "&";
        if (causeOfLeaving !== undefined && causeOfLeaving !== null)
            url_ += "CauseOfLeaving=" + encodeURIComponent("" + causeOfLeaving) + "&";
        if (otherComments !== undefined && otherComments !== null)
            url_ += "OtherComments=" + encodeURIComponent("" + otherComments) + "&";
        if (submittedBy !== undefined && submittedBy !== null)
            url_ += "SubmittedBy=" + encodeURIComponent("" + submittedBy) + "&";
        if (dateSubmitted !== undefined && dateSubmitted !== null)
            url_ += "DateSubmitted=" + encodeURIComponent(dateSubmitted ? "" + dateSubmitted.toJSON() : "") + "&";
        if (reviewedBy !== undefined && reviewedBy !== null)
            url_ += "ReviewedBy=" + encodeURIComponent("" + reviewedBy) + "&";
        if (reviewerComment !== undefined && reviewerComment !== null)
            url_ += "ReviewerComment=" + encodeURIComponent("" + reviewerComment) + "&";
        if (dateReviewed !== undefined && dateReviewed !== null)
            url_ += "DateReviewed=" + encodeURIComponent(dateReviewed ? "" + dateReviewed.toJSON() : "") + "&";
        if (isAccepted !== undefined && isAccepted !== null)
            url_ += "IsAccepted=" + encodeURIComponent("" + isAccepted) + "&";
        if (log_status === null)
            throw new Error("The parameter 'log_status' cannot be null.");
        else if (log_status !== undefined)
            url_ += "log_status=" + encodeURIComponent("" + log_status) + "&";
        if (adminMode === null)
            throw new Error("The parameter 'adminMode' cannot be null.");
        else if (adminMode !== undefined)
            url_ += "adminMode=" + encodeURIComponent("" + adminMode) + "&";
        if (saveNsubmit === null)
            throw new Error("The parameter 'saveNsubmit' cannot be null.");
        else if (saveNsubmit !== undefined)
            url_ += "saveNsubmit=" + encodeURIComponent("" + saveNsubmit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostRetireee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostRetireee(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostRetireee(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Retireee.
    Note: all filter are optional
     * @param startdte (optional) 
     * @param enddte (optional) 
     * @param searchText (optional) 
     * @param searchType (optional) 
     * @param page (optional) 
     * @param _selected (optional) 
     * @param startdate (optional) 
     * @param endate (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllRetire(startdte: string | null | undefined, enddte: string | null | undefined, searchText: string | null | undefined, searchType: number | null | undefined, page: number | null | undefined, _selected: string | null | undefined, startdate: Date | null | undefined, endate: Date | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<RetirmentDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/GetAllRetire?";
        if (startdte !== undefined && startdte !== null)
            url_ += "startdte=" + encodeURIComponent("" + startdte) + "&";
        if (enddte !== undefined && enddte !== null)
            url_ += "enddte=" + encodeURIComponent("" + enddte) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (_selected !== undefined && _selected !== null)
            url_ += "_selected=" + encodeURIComponent("" + _selected) + "&";
        if (startdate !== undefined && startdate !== null)
            url_ += "startdate=" + encodeURIComponent(startdate ? "" + startdate.toJSON() : "") + "&";
        if (endate !== undefined && endate !== null)
            url_ += "endate=" + encodeURIComponent(endate ? "" + endate.toJSON() : "") + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetire(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetire(<any>response_);
                } catch (e) {
                    return <Observable<RetirmentDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirmentDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetire(response: HttpResponseBase): Observable<RetirmentDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirmentDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirmentDTOListApiResult>(<any>null);
    }

    /**
     * API to Fetch Retireee.
    Note: all filter are optional
     * @param startdte (optional) 
     * @param enddte (optional) 
     * @param searchText (optional) 
     * @param searchType (optional) 
     * @param page (optional) 
     * @param _selected (optional) 
     * @param startdate (optional) 
     * @param endate (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getRetirees(startdte: string | null | undefined, enddte: string | null | undefined, searchText: string | null | undefined, searchType: number | null | undefined, page: number | null | undefined, _selected: string | null | undefined, startdate: Date | null | undefined, endate: Date | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<RetirmentDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/GetRetirees?";
        if (startdte !== undefined && startdte !== null)
            url_ += "startdte=" + encodeURIComponent("" + startdte) + "&";
        if (enddte !== undefined && enddte !== null)
            url_ += "enddte=" + encodeURIComponent("" + enddte) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (_selected !== undefined && _selected !== null)
            url_ += "_selected=" + encodeURIComponent("" + _selected) + "&";
        if (startdate !== undefined && startdate !== null)
            url_ += "startdate=" + encodeURIComponent(startdate ? "" + startdate.toJSON() : "") + "&";
        if (endate !== undefined && endate !== null)
            url_ += "endate=" + encodeURIComponent(endate ? "" + endate.toJSON() : "") + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetirees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetirees(<any>response_);
                } catch (e) {
                    return <Observable<RetirmentDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirmentDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetirees(response: HttpResponseBase): Observable<RetirmentDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirmentDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirmentDTOListApiResult>(<any>null);
    }

    /**
     * API to Fetch Retireee.
    Note: all filter are optional
     * @param startdte (optional) 
     * @param enddte (optional) 
     * @param searchText (optional) 
     * @param searchType (optional) 
     * @param page (optional) 
     * @param _selected (optional) 
     * @param startdate (optional) 
     * @param endate (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    searchRetiree(startdte: string | null | undefined, enddte: string | null | undefined, searchText: string | null | undefined, searchType: number | null | undefined, page: number | null | undefined, _selected: string | null | undefined, startdate: Date | null | undefined, endate: Date | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<RetirmentDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/SearchRetiree?";
        if (startdte !== undefined && startdte !== null)
            url_ += "startdte=" + encodeURIComponent("" + startdte) + "&";
        if (enddte !== undefined && enddte !== null)
            url_ += "enddte=" + encodeURIComponent("" + enddte) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (_selected !== undefined && _selected !== null)
            url_ += "_selected=" + encodeURIComponent("" + _selected) + "&";
        if (startdate !== undefined && startdate !== null)
            url_ += "startdate=" + encodeURIComponent(startdate ? "" + startdate.toJSON() : "") + "&";
        if (endate !== undefined && endate !== null)
            url_ += "endate=" + encodeURIComponent(endate ? "" + endate.toJSON() : "") + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchRetiree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchRetiree(<any>response_);
                } catch (e) {
                    return <Observable<RetirmentDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirmentDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearchRetiree(response: HttpResponseBase): Observable<RetirmentDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirmentDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirmentDTOListApiResult>(<any>null);
    }

    /**
     * API to Fetch Retirement by Id.
    Note: all filter are optional
     * @param id (optional) 
     * @return Success
     */
    getRetirmentByid(id: number | undefined): Observable<RetirmentDTOApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/GetRetirmentByid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetirmentByid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetirmentByid(<any>response_);
                } catch (e) {
                    return <Observable<RetirmentDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirmentDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetirmentByid(response: HttpResponseBase): Observable<RetirmentDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirmentDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirmentDTOApiResult>(<any>null);
    }

    /**
     * API to Fetch Retirement by Employee Id.
    Note: all filter are optional
     * @param user_id (optional) 
     * @param employee_id (optional) 
     * @param employee_number (optional) 
     * @param employee_contract_id (optional) 
     * @param grade_id (optional) 
     * @param confirmation_date (optional) 
     * @param serial_no (optional) 
     * @param first_name (optional) 
     * @param last_name (optional) 
     * @param full_name (optional) 
     * @param other_name (optional) 
     * @param department (optional) 
     * @param department_id (optional) 
     * @param email (optional) 
     * @param phone_number (optional) 
     * @param email_confirmed (optional) 
     * @param session_token (optional) 
     * @param jwt_token (optional) 
     * @param user_token (optional) 
     * @param company_id (optional) 
     * @param licenseUsuage (optional) 
     * @param licenseCount (optional) 
     * @param company_name (optional) 
     * @param sub_id (optional) 
     * @param isAdmin (optional) 
     * @param isSuperAdmin (optional) 
     * @param isTenantAdmin (optional) 
     * @param isActiveBySysOrAdmin (optional) 
     * @param lstPermissions (optional) 
     * @param message (optional) 
     * @param isSuccessful (optional) 
     * @param retId (optional) 
     * @param redirectUrl (optional) 
     * @param errors (optional) 
     * @return Success
     */
    getRetirmentByEmployeeId(user_id: number | undefined, employee_id: number | undefined, employee_number: string | null | undefined, employee_contract_id: number | undefined, grade_id: number | null | undefined, confirmation_date: Date | null | undefined, serial_no: string | null | undefined, first_name: string | null | undefined, last_name: string | null | undefined, full_name: string | null | undefined, other_name: string | null | undefined, department: string | null | undefined, department_id: number | undefined, email: string | null | undefined, phone_number: string | null | undefined, email_confirmed: boolean | undefined, session_token: string | null | undefined, jwt_token: string | null | undefined, user_token: string | null | undefined, company_id: number | undefined, licenseUsuage: number | undefined, licenseCount: number | undefined, company_name: string | null | undefined, sub_id: number | undefined, isAdmin: boolean | undefined, isSuperAdmin: boolean | undefined, isTenantAdmin: boolean | undefined, isActiveBySysOrAdmin: boolean | undefined, lstPermissions: string[] | null | undefined, message: string | null | undefined, isSuccessful: boolean | undefined, retId: number | undefined, redirectUrl: string | null | undefined, errors: string[] | null | undefined): Observable<RetirementApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/GetRetirmentByEmployeeId?";
        if (user_id === null)
            throw new Error("The parameter 'user_id' cannot be null.");
        else if (user_id !== undefined)
            url_ += "user_id=" + encodeURIComponent("" + user_id) + "&";
        if (employee_id === null)
            throw new Error("The parameter 'employee_id' cannot be null.");
        else if (employee_id !== undefined)
            url_ += "employee_id=" + encodeURIComponent("" + employee_id) + "&";
        if (employee_number !== undefined && employee_number !== null)
            url_ += "employee_number=" + encodeURIComponent("" + employee_number) + "&";
        if (employee_contract_id === null)
            throw new Error("The parameter 'employee_contract_id' cannot be null.");
        else if (employee_contract_id !== undefined)
            url_ += "employee_contract_id=" + encodeURIComponent("" + employee_contract_id) + "&";
        if (grade_id !== undefined && grade_id !== null)
            url_ += "grade_id=" + encodeURIComponent("" + grade_id) + "&";
        if (confirmation_date !== undefined && confirmation_date !== null)
            url_ += "confirmation_date=" + encodeURIComponent(confirmation_date ? "" + confirmation_date.toJSON() : "") + "&";
        if (serial_no !== undefined && serial_no !== null)
            url_ += "serial_no=" + encodeURIComponent("" + serial_no) + "&";
        if (first_name !== undefined && first_name !== null)
            url_ += "first_name=" + encodeURIComponent("" + first_name) + "&";
        if (last_name !== undefined && last_name !== null)
            url_ += "last_name=" + encodeURIComponent("" + last_name) + "&";
        if (full_name !== undefined && full_name !== null)
            url_ += "full_name=" + encodeURIComponent("" + full_name) + "&";
        if (other_name !== undefined && other_name !== null)
            url_ += "other_name=" + encodeURIComponent("" + other_name) + "&";
        if (department !== undefined && department !== null)
            url_ += "department=" + encodeURIComponent("" + department) + "&";
        if (department_id === null)
            throw new Error("The parameter 'department_id' cannot be null.");
        else if (department_id !== undefined)
            url_ += "department_id=" + encodeURIComponent("" + department_id) + "&";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (phone_number !== undefined && phone_number !== null)
            url_ += "phone_number=" + encodeURIComponent("" + phone_number) + "&";
        if (email_confirmed === null)
            throw new Error("The parameter 'email_confirmed' cannot be null.");
        else if (email_confirmed !== undefined)
            url_ += "email_confirmed=" + encodeURIComponent("" + email_confirmed) + "&";
        if (session_token !== undefined && session_token !== null)
            url_ += "session_token=" + encodeURIComponent("" + session_token) + "&";
        if (jwt_token !== undefined && jwt_token !== null)
            url_ += "jwt_token=" + encodeURIComponent("" + jwt_token) + "&";
        if (user_token !== undefined && user_token !== null)
            url_ += "user_token=" + encodeURIComponent("" + user_token) + "&";
        if (company_id === null)
            throw new Error("The parameter 'company_id' cannot be null.");
        else if (company_id !== undefined)
            url_ += "company_id=" + encodeURIComponent("" + company_id) + "&";
        if (licenseUsuage === null)
            throw new Error("The parameter 'licenseUsuage' cannot be null.");
        else if (licenseUsuage !== undefined)
            url_ += "LicenseUsuage=" + encodeURIComponent("" + licenseUsuage) + "&";
        if (licenseCount === null)
            throw new Error("The parameter 'licenseCount' cannot be null.");
        else if (licenseCount !== undefined)
            url_ += "LicenseCount=" + encodeURIComponent("" + licenseCount) + "&";
        if (company_name !== undefined && company_name !== null)
            url_ += "company_name=" + encodeURIComponent("" + company_name) + "&";
        if (sub_id === null)
            throw new Error("The parameter 'sub_id' cannot be null.");
        else if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&";
        if (isAdmin === null)
            throw new Error("The parameter 'isAdmin' cannot be null.");
        else if (isAdmin !== undefined)
            url_ += "IsAdmin=" + encodeURIComponent("" + isAdmin) + "&";
        if (isSuperAdmin === null)
            throw new Error("The parameter 'isSuperAdmin' cannot be null.");
        else if (isSuperAdmin !== undefined)
            url_ += "IsSuperAdmin=" + encodeURIComponent("" + isSuperAdmin) + "&";
        if (isTenantAdmin === null)
            throw new Error("The parameter 'isTenantAdmin' cannot be null.");
        else if (isTenantAdmin !== undefined)
            url_ += "IsTenantAdmin=" + encodeURIComponent("" + isTenantAdmin) + "&";
        if (isActiveBySysOrAdmin === null)
            throw new Error("The parameter 'isActiveBySysOrAdmin' cannot be null.");
        else if (isActiveBySysOrAdmin !== undefined)
            url_ += "IsActiveBySysOrAdmin=" + encodeURIComponent("" + isActiveBySysOrAdmin) + "&";
        if (lstPermissions !== undefined && lstPermissions !== null)
            lstPermissions && lstPermissions.forEach(item => { url_ += "lstPermissions=" + encodeURIComponent("" + item) + "&"; });
        if (message !== undefined && message !== null)
            url_ += "Message=" + encodeURIComponent("" + message) + "&";
        if (isSuccessful === null)
            throw new Error("The parameter 'isSuccessful' cannot be null.");
        else if (isSuccessful !== undefined)
            url_ += "IsSuccessful=" + encodeURIComponent("" + isSuccessful) + "&";
        if (retId === null)
            throw new Error("The parameter 'retId' cannot be null.");
        else if (retId !== undefined)
            url_ += "RetId=" + encodeURIComponent("" + retId) + "&";
        if (redirectUrl !== undefined && redirectUrl !== null)
            url_ += "RedirectUrl=" + encodeURIComponent("" + redirectUrl) + "&";
        if (errors !== undefined && errors !== null)
            errors && errors.forEach(item => { url_ += "Errors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetirmentByEmployeeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetirmentByEmployeeId(<any>response_);
                } catch (e) {
                    return <Observable<RetirementApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirementApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetirmentByEmployeeId(response: HttpResponseBase): Observable<RetirementApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementApiResult>(<any>null);
    }

    /**
     * API for adding/updating RetirementType
     * @param iD (optional) 
     * @param name (optional) 
     * @param requirments (optional) 
     * @param isEntitledToBenefits (optional) 
     * @return Success
     */
    addUpdateRetirementype(iD: number | undefined, name: string | null | undefined, requirments: string | null | undefined, isEntitledToBenefits: boolean | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/Add-Update-Retirementype?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (requirments !== undefined && requirments !== null)
            url_ += "Requirments=" + encodeURIComponent("" + requirments) + "&";
        if (isEntitledToBenefits === null)
            throw new Error("The parameter 'isEntitledToBenefits' cannot be null.");
        else if (isEntitledToBenefits !== undefined)
            url_ += "IsEntitledToBenefits=" + encodeURIComponent("" + isEntitledToBenefits) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateRetirementype(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateRetirementype(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateRetirementype(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllRequestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param _PageSize (optional) 
     * @param log_status (optional) 
     * @return Success
     */
    getAllRequests(startDate: Date | null | undefined, endDate: Date | null | undefined, _PageSize: number | undefined, log_status: number | undefined): Observable<RequestViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/RewardDisciplinary/GetAllRequests/GetAllRequests?";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (_PageSize === null)
            throw new Error("The parameter '_PageSize' cannot be null.");
        else if (_PageSize !== undefined)
            url_ += "_PageSize=" + encodeURIComponent("" + _PageSize) + "&";
        if (log_status === null)
            throw new Error("The parameter 'log_status' cannot be null.");
        else if (log_status !== undefined)
            url_ += "log_status=" + encodeURIComponent("" + log_status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRequests(<any>response_);
                } catch (e) {
                    return <Observable<RequestViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRequests(response: HttpResponseBase): Observable<RequestViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestViewModelIListApiResult>(<any>null);
    }
}

@Injectable()
export class RequestDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    requestDetails(id: number | null | undefined): Observable<RequestFileDtoIListApiResult> {
        let url_ = this.baseUrl + "/api/RewardDisciplinary/RequestDetails/RequestDetails?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestDetails(<any>response_);
                } catch (e) {
                    return <Observable<RequestFileDtoIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestFileDtoIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRequestDetails(response: HttpResponseBase): Observable<RequestFileDtoIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestFileDtoIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestFileDtoIListApiResult>(<any>null);
    }
}

@Injectable()
export class RequestTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @return Success
     */
    requestTypes(): Observable<RequestTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/RewardDisciplinary/RequestTypes/RequestTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestTypes(<any>response_);
                } catch (e) {
                    return <Observable<RequestTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRequestTypes(response: HttpResponseBase): Observable<RequestTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for getting all Roles for creating/updating Admin User as a Tenant Admin
     * @return Success
     */
    getRoles(): Observable<ApplicationRoleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchRoles/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ApplicationRoleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllRolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for getting all Roles for CRUD operation as a Super Admin that possesses
    'Role Management' Privilege
     * @return Success
     */
    getAllRoles(): Observable<ApplicationRoleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchAllRoles/GetAllRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<ApplicationRoleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for getting single Role for CRUD operation as a Super Admin that possesses
    'Role Management' Privilege
     * @param id (optional) 
     * @return Success
     */
    getRole(id: number | undefined): Observable<ApplicationRoleDTOApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchRole/GetRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRole(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRole(response: HttpResponseBase): Observable<ApplicationRoleDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOApiResult>(<any>null);
    }
}

@Injectable()
export class CreateRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for Adding/Updating Roles as a Super Admin that possesses
    'Role Management' Privilege
     * @param body (optional) 
     * @return Success
     */
    createRole(body: ApplicationRoleDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Role/CreateRole/CreateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolePermissionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @return Success
     */
    getRolePermissions(): Observable<RolePermissionDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/FetchRolePermissions/GetRolePermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermissions(<any>response_);
                } catch (e) {
                    return <Observable<RolePermissionDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RolePermissionDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolePermissions(response: HttpResponseBase): Observable<RolePermissionDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermissionDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RolePermissionDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolePermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param roleId (optional) 
     * @return Success
     */
    getRolePermission(roleId: number | undefined): Observable<RolePermissionDTOApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/FetchRolePermission/GetRolePermission?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermission(<any>response_);
                } catch (e) {
                    return <Observable<RolePermissionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RolePermissionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolePermission(response: HttpResponseBase): Observable<RolePermissionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermissionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RolePermissionDTOApiResult>(<any>null);
    }
}

@Injectable()
export class RolePermissionMappingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolePermissionMapping(body: RolePermissionMappingDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/RolePermissionMapping/RolePermissionMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePermissionMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePermissionMapping(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRolePermissionMapping(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class SalaryscaleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for adding/updating Salaryscale
     * @param body (optional) 
     * @return Success
     */
    addUpdateSalaryscale(body: ManageSalaryscaleDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Salaryscale/Add-Update-Salaryscale";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateSalaryscale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateSalaryscale(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateSalaryscale(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Salaryscale.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllSalaryscale(pageSize: number | undefined, pageNumber: number | undefined): Observable<SalaryscaleDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Salaryscale/GetAllSalaryscale?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSalaryscale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSalaryscale(<any>response_);
                } catch (e) {
                    return <Observable<SalaryscaleDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SalaryscaleDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSalaryscale(response: HttpResponseBase): Observable<SalaryscaleDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryscaleDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryscaleDTOListApiResult>(<any>null);
    }

    /**
     * API to get Salaryscale by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getSalarybyId(id: number | undefined): Observable<SalaryscaleDTOApiResult> {
        let url_ = this.baseUrl + "/api/Salaryscale/GetSalarybyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalarybyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalarybyId(<any>response_);
                } catch (e) {
                    return <Observable<SalaryscaleDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SalaryscaleDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalarybyId(response: HttpResponseBase): Observable<SalaryscaleDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryscaleDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryscaleDTOApiResult>(<any>null);
    }

    /**
     * this method is used to delete Salaryscale
     * @param id (optional) 
     * @return Success
     */
    deleteSalaryscale(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Salaryscale/DeleteSalaryscale?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSalaryscale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSalaryscale(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSalaryscale(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CreateSubscriptionPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSubscriptionPlan(body: SubscriptionPlan | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/CreateSubscriptionPlan/CreateSubscriptionPlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubscriptionPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubscriptionPlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubscriptionPlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchSubscriptionPlansServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @return Success
     */
    getSubscriptionPlans(): Observable<SubscriptionPlanIListApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/FetchSubscriptionPlans/GetSubscriptionPlans";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionPlans(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionPlans(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPlanIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPlanIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionPlans(response: HttpResponseBase): Observable<SubscriptionPlanIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPlanIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchSubscriptionPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param planId (optional) 
     * @return Success
     */
    getSubscriptionPlan(planId: number | undefined): Observable<SubscriptionPlanApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/FetchSubscriptionPlan/GetSubscriptionPlan?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionPlan(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPlanApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPlanApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionPlan(response: HttpResponseBase): Observable<SubscriptionPlanApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPlanApiResult>(<any>null);
    }
}

@Injectable()
export class FetchSubscriptionPlanModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param planId (optional) 
     * @return Success
     */
    getSubscriptionPlanModules(planId: number | undefined): Observable<SubscriptionPlanModuleIListApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/FetchSubscriptionPlanModules/GetSubscriptionPlanModules?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionPlanModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionPlanModules(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPlanModuleIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPlanModuleIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionPlanModules(response: HttpResponseBase): Observable<SubscriptionPlanModuleIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanModuleIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPlanModuleIListApiResult>(<any>null);
    }
}

@Injectable()
export class VerifySubscriptionPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for verifying and updating Tenant's Subscription Payment
    with payment reference and userid
     * @param reference (optional) 
     * @param userId (optional) 
     * @return Success
     */
    verifySubscriptionPayment(reference: string | null | undefined, userId: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/VerifySubscriptionPayment/VerifySubscriptionPayment?";
        if (reference !== undefined && reference !== null)
            url_ += "reference=" + encodeURIComponent("" + reference) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySubscriptionPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySubscriptionPayment(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySubscriptionPayment(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class TenantSignUpServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for signing up Tenant's account on the system
     * @param body (optional) 
     * @return Success
     */
    tenantSignUp(body: CompanySignUpDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/TenantSignUp/TenantSignUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSignUp(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processTenantSignUp(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ConfirmTenantEmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for confirming Tenant's email account by providing the two querystring inside
    the Confirmation link ('userid' and 'token')
     * @param userId (optional) 
     * @param token (optional) 
     * @return Success
     */
    confirmTenantEmail(userId: string | null | undefined, token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/ConfirmTenantEmail/ConfirmTenantEmail?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmTenantEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmTenantEmail(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmTenantEmail(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class RegisterCompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerCompany(body: CompanyDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/RegisterCompany/RegisterCompany";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterCompany(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterCompany(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllTenantsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving All Tenant on the system with filtering parameters
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchText (optional) 
     * @param status (optional) 
     * @return Success
     */
    getAllTenants(startDate: Date | undefined, endDate: Date | undefined, searchText: string | null | undefined, status: number | undefined): Observable<CompanyIListApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/FetchAllTenants/GetAllTenants?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTenants(<any>response_);
                } catch (e) {
                    return <Observable<CompanyIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTenants(response: HttpResponseBase): Observable<CompanyIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchTenantModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for retrieving Tenant's registered modules based on their subscription plan
     * @return Success
     */
    getTenantModules(): Observable<CompanyModuleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/FetchTenantModules/GetTenantModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantModules(<any>response_);
                } catch (e) {
                    return <Observable<CompanyModuleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyModuleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantModules(response: HttpResponseBase): Observable<CompanyModuleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyModuleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyModuleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateTenantModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for updating Tenant's Modules
     * @param payload (optional) 
     * @return Success
     */
    updateTenantModules(payload: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/UpdateTenantModules/UpdateTenantModules?";
        if (payload !== undefined && payload !== null)
            url_ += "payload=" + encodeURIComponent("" + payload) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantModules(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantModules(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddTenantModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * API for creating Tenant's Modules
     * @param payload (optional) 
     * @return Success
     */
    createTenantModules(payload: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/AddTenantModules/CreateTenantModules?";
        if (payload !== undefined && payload !== null)
            url_ += "payload=" + encodeURIComponent("" + payload) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenantModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenantModules(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenantModules(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class TrainingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * this method is used to create  or update  training vendor.  if it is update, training vendor Id is required
     * @param body (optional) 
     * @return Success
     */
    createvendor(body: TrainingVendorPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/createvendor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatevendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatevendor(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreatevendor(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training vendor. all filter are optional
     * @param name (optional) 
     * @param trainingSpecializationId (optional) 
     * @param trainingTag (optional) 
     * @return Success
     */
    vendors(name: string | null | undefined, trainingSpecializationId: number | null | undefined, trainingTag: string | null | undefined): Observable<TrainingVendorResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/vendors?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (trainingSpecializationId !== undefined && trainingSpecializationId !== null)
            url_ += "TrainingSpecializationId=" + encodeURIComponent("" + trainingSpecializationId) + "&";
        if (trainingTag !== undefined && trainingTag !== null)
            url_ += "TrainingTag=" + encodeURIComponent("" + trainingTag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVendors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVendors(<any>response_);
                } catch (e) {
                    return <Observable<TrainingVendorResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingVendorResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processVendors(response: HttpResponseBase): Observable<TrainingVendorResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingVendorResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingVendorResourceListApiResult>(<any>null);
    }

    /**
     * this method is used get training vendor by Id.
     * @param id (optional) 
     * @return Success
     */
    getVendor(id: number | undefined): Observable<TrainingVendorResourceApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetVendor?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendor(<any>response_);
                } catch (e) {
                    return <Observable<TrainingVendorResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingVendorResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendor(response: HttpResponseBase): Observable<TrainingVendorResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingVendorResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingVendorResourceApiResult>(<any>null);
    }

    /**
     * this method is used to delete training vendor
     * @param id (optional) 
     * @return Success
     */
    deleteVendor(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteVendor?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVendor(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteVendor(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to upload excel file of vendors. accepted file format ".xlsx", ".xls"
     * @param file (optional) 
     * @return Success
     */
    uploadVendor(file: FileParameter | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/UploadVendor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadVendor(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUploadVendor(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create  or update  training type.  if it is update, training vendour Id is required
     * @param body (optional) 
     * @return Success
     */
    createtype(body: TrainingTypePayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/createtype";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatetype(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatetype(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreatetype(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training types. all filter are optional
     * @param name (optional) 
     * @param trainingVendorId (optional) 
     * @param trainingSpecializationId (optional) 
     * @param trainingCategoryId (optional) 
     * @return Success
     */
    types(name: string | null | undefined, trainingVendorId: number | null | undefined, trainingSpecializationId: number | null | undefined, trainingCategoryId: number | null | undefined): Observable<TrainingTypeResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/types?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (trainingVendorId !== undefined && trainingVendorId !== null)
            url_ += "TrainingVendorId=" + encodeURIComponent("" + trainingVendorId) + "&";
        if (trainingSpecializationId !== undefined && trainingSpecializationId !== null)
            url_ += "TrainingSpecializationId=" + encodeURIComponent("" + trainingSpecializationId) + "&";
        if (trainingCategoryId !== undefined && trainingCategoryId !== null)
            url_ += "TrainingCategoryId=" + encodeURIComponent("" + trainingCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTypes(<any>response_);
                } catch (e) {
                    return <Observable<TrainingTypeResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingTypeResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processTypes(response: HttpResponseBase): Observable<TrainingTypeResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingTypeResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingTypeResourceListApiResult>(<any>null);
    }

    /**
     * this method is used get training type by Id.
     * @param id (optional) 
     * @return Success
     */
    getTrainingType(id: number | undefined): Observable<TrainingTypeResourceApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetTrainingType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingType(<any>response_);
                } catch (e) {
                    return <Observable<TrainingTypeResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingTypeResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingType(response: HttpResponseBase): Observable<TrainingTypeResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingTypeResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingTypeResourceApiResult>(<any>null);
    }

    /**
     * this method is use to change training type status. Note:  if status false, it means inactive while true means active
     * @param body (optional) 
     * @return Success
     */
    changetypestatus(body: ToggleTrainingType | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/changetypestatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangetypestatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangetypestatus(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processChangetypestatus(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete training type
     * @param id (optional) 
     * @return Success
     */
    deleteTrainingType(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteTrainingType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTrainingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTrainingType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTrainingType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create  or update  training Category.  if it is update, training Category Id is required
     * @param body (optional) 
     * @return Success
     */
    createorupdatecategory(body: TrainingCategoryPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/createorupdatecategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdatecategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdatecategory(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateorupdatecategory(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training categories.
     * @return Success
     */
    categories(): Observable<TrainingCategoryResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategories(<any>response_);
                } catch (e) {
                    return <Observable<TrainingCategoryResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingCategoryResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCategories(response: HttpResponseBase): Observable<TrainingCategoryResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingCategoryResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingCategoryResourceListApiResult>(<any>null);
    }

    /**
     * this method is used get training Category by Id.
     * @param id (optional) 
     * @return Success
     */
    getCategory(id: number | undefined): Observable<TrainingCategoryResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategory(<any>response_);
                } catch (e) {
                    return <Observable<TrainingCategoryResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingCategoryResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategory(response: HttpResponseBase): Observable<TrainingCategoryResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingCategoryResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingCategoryResourceListApiResult>(<any>null);
    }

    /**
     * this method is used to delete training category
     * @param id (optional) 
     * @return Success
     */
    deleteCategory(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create  or update  training Specialization/Expertise.  if it is update, training specialization Id is required
     * @param body (optional) 
     * @return Success
     */
    addUpdateSpecialization(body: TrainingSpecializationPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/AddUpdateSpecialization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateSpecialization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateSpecialization(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateSpecialization(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training Specialization/Expertise.
     * @return Success
     */
    getTrainingSpecializations(): Observable<TrainingSpecializationDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetTrainingSpecializations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainingSpecializations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingSpecializations(<any>response_);
                } catch (e) {
                    return <Observable<TrainingSpecializationDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingSpecializationDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingSpecializations(response: HttpResponseBase): Observable<TrainingSpecializationDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSpecializationDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingSpecializationDTOListApiResult>(<any>null);
    }

    /**
     * this method is used get training Specialization by Id.
     * @param id (optional) 
     * @return Success
     */
    getSpecializationById(id: number | undefined): Observable<TrainingSpecializationDTOApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetSpecializationById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpecializationById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpecializationById(<any>response_);
                } catch (e) {
                    return <Observable<TrainingSpecializationDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingSpecializationDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSpecializationById(response: HttpResponseBase): Observable<TrainingSpecializationDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSpecializationDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingSpecializationDTOApiResult>(<any>null);
    }

    /**
     * this method is used to delete training Specialization
     * @param id (optional) 
     * @return Success
     */
    deleteSpecialization(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteSpecialization?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSpecialization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSpecialization(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSpecialization(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API for adding/updating Training Plan.
     * @param body (optional) 
     * @return Success
     */
    addUpdateTrainingPlan(body: ManageTrainingDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/Add-Update-TrainingPlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateTrainingPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateTrainingPlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateTrainingPlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training plan. Note filters are optional
     * @param body (optional) 
     * @return Success
     */
    getAllTrainingPlans(body: TrainingFilterDTO | undefined): Observable<TrainingDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetAllTrainingPlans";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTrainingPlans(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrainingPlans(<any>response_);
                } catch (e) {
                    return <Observable<TrainingDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTrainingPlans(response: HttpResponseBase): Observable<TrainingDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingDTOListApiResult>(<any>null);
    }

    /**
     * API to get Training Plan by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getTrainingPlan(id: number | undefined): Observable<TrainingDTOApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetTrainingPlan?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainingPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingPlan(<any>response_);
                } catch (e) {
                    return <Observable<TrainingDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingPlan(response: HttpResponseBase): Observable<TrainingDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingDTOApiResult>(<any>null);
    }

    /**
     * this method is used to change Training Plan status. if training status: false = inactive, true = active
     * @param id (optional) 
     * @return Success
     */
    toggleTrainingPlan(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/ToggleTrainingPlan?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleTrainingPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleTrainingPlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleTrainingPlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete Training Plan
     * @param id (optional) 
     * @return Success
     */
    deleteTrainingPlan(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteTrainingPlan?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTrainingPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTrainingPlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTrainingPlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create or update  training Criteria. if it is update, training specialization Id is required
     * @param body (optional) 
     * @return Success
     */
    createUpdateCriteria(body: TrainingCriteriaPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/Create-Update-Criteria";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUpdateCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUpdateCriteria(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUpdateCriteria(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training criteria.
     * @param name (optional) 
     * @param min_Age (optional) 
     * @param min_LengthOfService (optional) 
     * @return Success
     */
    getCriterias(trainingTypeId: number, name: string | null | undefined, min_Age: number | undefined, min_LengthOfService: number | undefined): Observable<TrainingCriteriaResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetCriterias?";
        if (trainingTypeId === undefined || trainingTypeId === null)
            throw new Error("The parameter 'trainingTypeId' must be defined and cannot be null.");
        else
            url_ += "TrainingTypeId=" + encodeURIComponent("" + trainingTypeId) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (min_Age === null)
            throw new Error("The parameter 'min_Age' cannot be null.");
        else if (min_Age !== undefined)
            url_ += "Min_Age=" + encodeURIComponent("" + min_Age) + "&";
        if (min_LengthOfService === null)
            throw new Error("The parameter 'min_LengthOfService' cannot be null.");
        else if (min_LengthOfService !== undefined)
            url_ += "Min_LengthOfService=" + encodeURIComponent("" + min_LengthOfService) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCriterias(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCriterias(<any>response_);
                } catch (e) {
                    return <Observable<TrainingCriteriaResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingCriteriaResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCriterias(response: HttpResponseBase): Observable<TrainingCriteriaResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingCriteriaResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingCriteriaResourceListApiResult>(<any>null);
    }

    /**
     * this method is used get training criteria by Id.
     * @param id (optional) 
     * @return Success
     */
    getCriteria(id: number | undefined): Observable<TrainingCriteriaResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetCriteria?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCriteria(<any>response_);
                } catch (e) {
                    return <Observable<TrainingCriteriaResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingCriteriaResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCriteria(response: HttpResponseBase): Observable<TrainingCriteriaResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingCriteriaResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingCriteriaResourceListApiResult>(<any>null);
    }

    /**
     * this method is used to delete training Criteria
     * @param id (optional) 
     * @return Success
     */
    deleteCriteria(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteCriteria?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCriteria(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCriteria(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to asign training to employees.  Note: file is not required
     * @param body (optional) 
     * @return Success
     */
    addEmployeeToTraining(body: AssignTrainingToEmpPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/AddEmployeeToTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEmployeeToTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEmployeeToTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddEmployeeToTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training assigned to employee. all filter are optional
     * @param specializationName (optional) 
     * @param trainingTypeName (optional) 
     * @param name (optional) 
     * @param trainingVendorName (optional) 
     * @return Success
     */
    getEmployeeTrainings(specializationName: string | null | undefined, trainingTypeName: string | null | undefined, name: string | null | undefined, trainingVendorName: string | null | undefined): Observable<EmpTrainingResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetEmployeeTrainings?";
        if (specializationName !== undefined && specializationName !== null)
            url_ += "SpecializationName=" + encodeURIComponent("" + specializationName) + "&";
        if (trainingTypeName !== undefined && trainingTypeName !== null)
            url_ += "TrainingTypeName=" + encodeURIComponent("" + trainingTypeName) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (trainingVendorName !== undefined && trainingVendorName !== null)
            url_ += "TrainingVendorName=" + encodeURIComponent("" + trainingVendorName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeTrainings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeTrainings(<any>response_);
                } catch (e) {
                    return <Observable<EmpTrainingResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmpTrainingResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeTrainings(response: HttpResponseBase): Observable<EmpTrainingResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpTrainingResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmpTrainingResourceListApiResult>(<any>null);
    }

    /**
     * this method is used send training for approval.
     * @param id (optional) 
     * @return Success
     */
    sendTrainingForApproval(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/SendTrainingForApproval?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTrainingForApproval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTrainingForApproval(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSendTrainingForApproval(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to notify employee for assigned training.
     * @param id (optional) 
     * @return Success
     */
    notifyEmployee(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/NotifyEmployee?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotifyEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotifyEmployee(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processNotifyEmployee(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to remove employees from training.
     * @param body (optional) 
     * @return Success
     */
    removeBulkEmployeeFromTraining(body: AssignTrainingToEmpPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/RemoveBulkEmployeeFromTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBulkEmployeeFromTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBulkEmployeeFromTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBulkEmployeeFromTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to remove employee from training
     * @param body (optional) 
     * @return Success
     */
    removeEmployeeFromTraining(body: AssignTrainingToOneEmpPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/RemoveEmployeeFromTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveEmployeeFromTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveEmployeeFromTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveEmployeeFromTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete employee added to training
     * @param id (optional) 
     * @return Success
     */
    deleteEmployeeTraining(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteEmployeeTraining?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEmployeeTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEmployeeTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEmployeeTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used get emp training by Id.
     * @param id (optional) 
     * @return Success
     */
    getEmpTraining(id: number | undefined): Observable<EmpTrainingResourceApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetEmpTraining?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmpTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmpTraining(<any>response_);
                } catch (e) {
                    return <Observable<EmpTrainingResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmpTrainingResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmpTraining(response: HttpResponseBase): Observable<EmpTrainingResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpTrainingResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmpTrainingResourceApiResult>(<any>null);
    }

    /**
     * this method is used to  save employee feedback after training.
     * @param body (optional) 
     * @return Success
     */
    employeeTrainingFeedback(body: EmpFeedBack | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/EmployeeTrainingFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeTrainingFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeTrainingFeedback(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeTrainingFeedback(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to upload excel file of vendors. accepted file format ".xlsx", ".xls"
     * @param body (optional) 
     * @return Success
     */
    postEmployeeTraining(body: EmployeeTrainingDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/PostEmployeeTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostEmployeeTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostEmployeeTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostEmployeeTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to update emp training
     * @param body (optional) 
     * @return Success
     */
    updateEmployeeTraining(body: EmployeeTrainingDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/UpdateEmployeeTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmployeeTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmployeeTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEmployeeTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RegisterUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerUser(body: RegisterUserDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/RegisterUser/RegisterUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body: RegisterUserDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/UpdateUser/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllUsersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://51.124.39.23:8008";
    }

    /**
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param email (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllUsers(firstName: string | null | undefined, lastName: string | null | undefined, email: string | null | undefined, pageSize: number | undefined): Observable<ApplicationUserDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/FetchAllUsers/GetAllUsers?";
        if (firstName !== undefined && firstName !== null)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName !== undefined && lastName !== null)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationUserDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationUserDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<ApplicationUserDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUserDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUserDTOIListApiResult>(<any>null);
    }
}

export class UserLoginDTO implements IUserLoginDTO {
    email!: string | undefined;
    password!: string | undefined;

    constructor(data?: IUserLoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UserLoginDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }

    clone(): UserLoginDTO {
        const json = this.toJSON();
        let result = new UserLoginDTO();
        result.init(json);
        return result;
    }
}

export interface IUserLoginDTO {
    email: string | undefined;
    password: string | undefined;
}

export class VwUserObj implements IVwUserObj {
    user_id!: number;
    employee_id!: number;
    employee_number!: string | undefined;
    employee_contract_id!: number;
    grade_id!: number | undefined;
    confirmation_date!: Date | undefined;
    serial_no!: string | undefined;
    first_name!: string | undefined;
    last_name!: string | undefined;
    readonly full_name!: string | undefined;
    other_name!: string | undefined;
    department!: string | undefined;
    department_id!: number;
    email!: string | undefined;
    phone_number!: string | undefined;
    email_confirmed!: boolean;
    session_token!: string | undefined;
    jwt_token!: string | undefined;
    user_token!: string | undefined;
    company_id!: number;
    licenseUsuage!: number;
    licenseCount!: number;
    company_name!: string | undefined;
    sub_id!: number;
    isAdmin!: boolean;
    isSuperAdmin!: boolean;
    isTenantAdmin!: boolean;
    isActiveBySysOrAdmin!: boolean;
    lstPermissions!: string[] | undefined;
    message!: string | undefined;
    isSuccessful!: boolean;
    retId!: number;
    redirectUrl!: string | undefined;
    errors!: string[] | undefined;

    constructor(data?: IVwUserObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user_id = _data["user_id"];
            this.employee_id = _data["employee_id"];
            this.employee_number = _data["employee_number"];
            this.employee_contract_id = _data["employee_contract_id"];
            this.grade_id = _data["grade_id"];
            this.confirmation_date = _data["confirmation_date"] ? new Date(_data["confirmation_date"].toString()) : <any>undefined;
            this.serial_no = _data["serial_no"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            (<any>this).full_name = _data["full_name"];
            this.other_name = _data["other_name"];
            this.department = _data["department"];
            this.department_id = _data["department_id"];
            this.email = _data["email"];
            this.phone_number = _data["phone_number"];
            this.email_confirmed = _data["email_confirmed"];
            this.session_token = _data["session_token"];
            this.jwt_token = _data["jwt_token"];
            this.user_token = _data["user_token"];
            this.company_id = _data["company_id"];
            this.licenseUsuage = _data["licenseUsuage"];
            this.licenseCount = _data["licenseCount"];
            this.company_name = _data["company_name"];
            this.sub_id = _data["sub_id"];
            this.isAdmin = _data["isAdmin"];
            this.isSuperAdmin = _data["isSuperAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.isActiveBySysOrAdmin = _data["isActiveBySysOrAdmin"];
            if (Array.isArray(_data["lstPermissions"])) {
                this.lstPermissions = [] as any;
                for (let item of _data["lstPermissions"])
                    this.lstPermissions!.push(item);
            }
            this.message = _data["message"];
            this.isSuccessful = _data["isSuccessful"];
            this.retId = _data["retId"];
            this.redirectUrl = _data["redirectUrl"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): VwUserObj {
        data = typeof data === 'object' ? data : {};
        let result = new VwUserObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_id"] = this.user_id;
        data["employee_id"] = this.employee_id;
        data["employee_number"] = this.employee_number;
        data["employee_contract_id"] = this.employee_contract_id;
        data["grade_id"] = this.grade_id;
        data["confirmation_date"] = this.confirmation_date ? this.confirmation_date.toISOString() : <any>undefined;
        data["serial_no"] = this.serial_no;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["full_name"] = this.full_name;
        data["other_name"] = this.other_name;
        data["department"] = this.department;
        data["department_id"] = this.department_id;
        data["email"] = this.email;
        data["phone_number"] = this.phone_number;
        data["email_confirmed"] = this.email_confirmed;
        data["session_token"] = this.session_token;
        data["jwt_token"] = this.jwt_token;
        data["user_token"] = this.user_token;
        data["company_id"] = this.company_id;
        data["licenseUsuage"] = this.licenseUsuage;
        data["licenseCount"] = this.licenseCount;
        data["company_name"] = this.company_name;
        data["sub_id"] = this.sub_id;
        data["isAdmin"] = this.isAdmin;
        data["isSuperAdmin"] = this.isSuperAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["isActiveBySysOrAdmin"] = this.isActiveBySysOrAdmin;
        if (Array.isArray(this.lstPermissions)) {
            data["lstPermissions"] = [];
            for (let item of this.lstPermissions)
                data["lstPermissions"].push(item);
        }
        data["message"] = this.message;
        data["isSuccessful"] = this.isSuccessful;
        data["retId"] = this.retId;
        data["redirectUrl"] = this.redirectUrl;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }

    clone(): VwUserObj {
        const json = this.toJSON();
        let result = new VwUserObj();
        result.init(json);
        return result;
    }
}

export interface IVwUserObj {
    user_id: number;
    employee_id: number;
    employee_number: string | undefined;
    employee_contract_id: number;
    grade_id: number | undefined;
    confirmation_date: Date | undefined;
    serial_no: string | undefined;
    first_name: string | undefined;
    last_name: string | undefined;
    full_name: string | undefined;
    other_name: string | undefined;
    department: string | undefined;
    department_id: number;
    email: string | undefined;
    phone_number: string | undefined;
    email_confirmed: boolean;
    session_token: string | undefined;
    jwt_token: string | undefined;
    user_token: string | undefined;
    company_id: number;
    licenseUsuage: number;
    licenseCount: number;
    company_name: string | undefined;
    sub_id: number;
    isAdmin: boolean;
    isSuperAdmin: boolean;
    isTenantAdmin: boolean;
    isActiveBySysOrAdmin: boolean;
    lstPermissions: string[] | undefined;
    message: string | undefined;
    isSuccessful: boolean;
    retId: number;
    redirectUrl: string | undefined;
    errors: string[] | undefined;
}

export class VwUserObjApiResult implements IVwUserObjApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwUserObj;
    totalCount!: number;

    constructor(data?: IVwUserObjApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? VwUserObj.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VwUserObjApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwUserObjApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VwUserObjApiResult {
        const json = this.toJSON();
        let result = new VwUserObjApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwUserObjApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwUserObj;
    totalCount: number;
}

export class MessageOut implements IMessageOut {
    message!: string | undefined;
    isSuccessful!: boolean;
    retId!: number;
    redirectUrl!: string | undefined;
    errors!: string[] | undefined;

    constructor(data?: IMessageOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.isSuccessful = _data["isSuccessful"];
            this.retId = _data["retId"];
            this.redirectUrl = _data["redirectUrl"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MessageOut {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["isSuccessful"] = this.isSuccessful;
        data["retId"] = this.retId;
        data["redirectUrl"] = this.redirectUrl;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }

    clone(): MessageOut {
        const json = this.toJSON();
        let result = new MessageOut();
        result.init(json);
        return result;
    }
}

export interface IMessageOut {
    message: string | undefined;
    isSuccessful: boolean;
    retId: number;
    redirectUrl: string | undefined;
    errors: string[] | undefined;
}

export class MessageOutApiResult implements IMessageOutApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MessageOut;
    totalCount!: number;

    constructor(data?: IMessageOutApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? MessageOut.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MessageOutApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOutApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): MessageOutApiResult {
        const json = this.toJSON();
        let result = new MessageOutApiResult();
        result.init(json);
        return result;
    }
}

export interface IMessageOutApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MessageOut;
    totalCount: number;
}

export class ResestPasswordDTO implements IResestPasswordDTO {
    token!: string | undefined;
    email!: string;
    password!: string;
    confirmPassword!: string | undefined;

    constructor(data?: IResestPasswordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResestPasswordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResestPasswordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }

    clone(): ResestPasswordDTO {
        const json = this.toJSON();
        let result = new ResestPasswordDTO();
        result.init(json);
        return result;
    }
}

export interface IResestPasswordDTO {
    token: string | undefined;
    email: string;
    password: string;
    confirmPassword: string | undefined;
}

export class ActivityLog implements IActivityLog {
    userId!: number | undefined;
    moduleName!: string | undefined;
    moduleAction!: string | undefined;
    description!: string | undefined;
    record!: string | undefined;
    ipAdress!: string | undefined;
    operationType!: string | undefined;
    employeeId!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IActivityLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.moduleName = _data["moduleName"];
            this.moduleAction = _data["moduleAction"];
            this.description = _data["description"];
            this.record = _data["record"];
            this.ipAdress = _data["ipAdress"];
            this.operationType = _data["operationType"];
            this.employeeId = _data["employeeId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ActivityLog {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["moduleName"] = this.moduleName;
        data["moduleAction"] = this.moduleAction;
        data["description"] = this.description;
        data["record"] = this.record;
        data["ipAdress"] = this.ipAdress;
        data["operationType"] = this.operationType;
        data["employeeId"] = this.employeeId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ActivityLog {
        const json = this.toJSON();
        let result = new ActivityLog();
        result.init(json);
        return result;
    }
}

export interface IActivityLog {
    userId: number | undefined;
    moduleName: string | undefined;
    moduleAction: string | undefined;
    description: string | undefined;
    record: string | undefined;
    ipAdress: string | undefined;
    operationType: string | undefined;
    employeeId: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ActivityLogIListApiResult implements IActivityLogIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ActivityLog[] | undefined;
    totalCount!: number;

    constructor(data?: IActivityLogIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ActivityLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ActivityLogIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLogIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ActivityLogIListApiResult {
        const json = this.toJSON();
        let result = new ActivityLogIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IActivityLogIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ActivityLog[] | undefined;
    totalCount: number;
}

export class AnnouncementTypeDto implements IAnnouncementTypeDto {
    id!: number;
    catalog!: string;
    companyId!: number;
    subId!: number;
    departmentId!: number;

    constructor(data?: IAnnouncementTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.catalog = _data["catalog"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.departmentId = _data["departmentId"];
        }
    }

    static fromJS(data: any): AnnouncementTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnnouncementTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["catalog"] = this.catalog;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["departmentId"] = this.departmentId;
        return data; 
    }

    clone(): AnnouncementTypeDto {
        const json = this.toJSON();
        let result = new AnnouncementTypeDto();
        result.init(json);
        return result;
    }
}

export interface IAnnouncementTypeDto {
    id: number;
    catalog: string;
    companyId: number;
    subId: number;
    departmentId: number;
}

export class AnnouncementType implements IAnnouncementType {
    catalog!: string | undefined;
    departmentId!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IAnnouncementType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalog = _data["catalog"];
            this.departmentId = _data["departmentId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): AnnouncementType {
        data = typeof data === 'object' ? data : {};
        let result = new AnnouncementType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalog"] = this.catalog;
        data["departmentId"] = this.departmentId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): AnnouncementType {
        const json = this.toJSON();
        let result = new AnnouncementType();
        result.init(json);
        return result;
    }
}

export interface IAnnouncementType {
    catalog: string | undefined;
    departmentId: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class AnnouncementTypeListApiResult implements IAnnouncementTypeListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AnnouncementType[] | undefined;
    totalCount!: number;

    constructor(data?: IAnnouncementTypeListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AnnouncementType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AnnouncementTypeListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AnnouncementTypeListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AnnouncementTypeListApiResult {
        const json = this.toJSON();
        let result = new AnnouncementTypeListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAnnouncementTypeListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AnnouncementType[] | undefined;
    totalCount: number;
}

export class AnnouncementDto implements IAnnouncementDto {
    id!: number;
    announcementTypeId!: number;
    announcementMessage!: string | undefined;
    departmentId!: number;
    externalUrl!: string | undefined;
    startDate!: Date;
    closeDate!: Date;
    companyId!: number;
    subId!: number;

    constructor(data?: IAnnouncementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.announcementTypeId = _data["announcementTypeId"];
            this.announcementMessage = _data["announcementMessage"];
            this.departmentId = _data["departmentId"];
            this.externalUrl = _data["externalUrl"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.closeDate = _data["closeDate"] ? new Date(_data["closeDate"].toString()) : <any>undefined;
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
        }
    }

    static fromJS(data: any): AnnouncementDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnnouncementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["announcementTypeId"] = this.announcementTypeId;
        data["announcementMessage"] = this.announcementMessage;
        data["departmentId"] = this.departmentId;
        data["externalUrl"] = this.externalUrl;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["closeDate"] = this.closeDate ? this.closeDate.toISOString() : <any>undefined;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        return data; 
    }

    clone(): AnnouncementDto {
        const json = this.toJSON();
        let result = new AnnouncementDto();
        result.init(json);
        return result;
    }
}

export interface IAnnouncementDto {
    id: number;
    announcementTypeId: number;
    announcementMessage: string | undefined;
    departmentId: number;
    externalUrl: string | undefined;
    startDate: Date;
    closeDate: Date;
    companyId: number;
    subId: number;
}

export class Announcement implements IAnnouncement {
    announcementTypeId!: number;
    announcementMessage!: string | undefined;
    departmentId!: number;
    externalUrl!: string | undefined;
    startDate!: Date;
    closeDate!: Date;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IAnnouncement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.announcementTypeId = _data["announcementTypeId"];
            this.announcementMessage = _data["announcementMessage"];
            this.departmentId = _data["departmentId"];
            this.externalUrl = _data["externalUrl"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.closeDate = _data["closeDate"] ? new Date(_data["closeDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Announcement {
        data = typeof data === 'object' ? data : {};
        let result = new Announcement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["announcementTypeId"] = this.announcementTypeId;
        data["announcementMessage"] = this.announcementMessage;
        data["departmentId"] = this.departmentId;
        data["externalUrl"] = this.externalUrl;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["closeDate"] = this.closeDate ? this.closeDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Announcement {
        const json = this.toJSON();
        let result = new Announcement();
        result.init(json);
        return result;
    }
}

export interface IAnnouncement {
    announcementTypeId: number;
    announcementMessage: string | undefined;
    departmentId: number;
    externalUrl: string | undefined;
    startDate: Date;
    closeDate: Date;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class AnnouncementListApiResult implements IAnnouncementListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Announcement[] | undefined;
    totalCount!: number;

    constructor(data?: IAnnouncementListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Announcement.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AnnouncementListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AnnouncementListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AnnouncementListApiResult {
        const json = this.toJSON();
        let result = new AnnouncementListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAnnouncementListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Announcement[] | undefined;
    totalCount: number;
}

export class AppraisalReviewerListDTO implements IAppraisalReviewerListDTO {
    contractId!: number;
    employeeId!: number;
    firstName!: string | undefined;
    otherNames!: string | undefined;
    lastName!: string | undefined;
    fullName!: string | undefined;
    employeeNumber!: string | undefined;
    departmentId!: number;
    department!: string | undefined;
    supervisorId!: number | undefined;
    supervisorContractId!: number;
    periodId!: number;
    period!: string | undefined;
    assignedKra!: number;
    assignedKpi!: number;
    cycleStatus!: number;
    startDate!: Date | undefined;
    isSubmitted!: boolean;
    supervisorFullName!: string | undefined;
    reviewStatus!: number;
    isApproved!: boolean;
    isReviewerSubmitted!: boolean | undefined;
    isReviewerStartedAppraisal!: boolean | undefined;
    readonly employeeStatus!: string | undefined;
    readonly reviewerStatus!: string | undefined;

    constructor(data?: IAppraisalReviewerListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.employeeId = _data["employeeId"];
            this.firstName = _data["firstName"];
            this.otherNames = _data["otherNames"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.employeeNumber = _data["employeeNumber"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"];
            this.supervisorId = _data["supervisorId"];
            this.supervisorContractId = _data["supervisorContractId"];
            this.periodId = _data["periodId"];
            this.period = _data["period"];
            this.assignedKra = _data["assignedKra"];
            this.assignedKpi = _data["assignedKpi"];
            this.cycleStatus = _data["cycleStatus"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.isSubmitted = _data["isSubmitted"];
            this.supervisorFullName = _data["supervisorFullName"];
            this.reviewStatus = _data["reviewStatus"];
            this.isApproved = _data["isApproved"];
            this.isReviewerSubmitted = _data["isReviewerSubmitted"];
            this.isReviewerStartedAppraisal = _data["isReviewerStartedAppraisal"];
            (<any>this).employeeStatus = _data["employeeStatus"];
            (<any>this).reviewerStatus = _data["reviewerStatus"];
        }
    }

    static fromJS(data: any): AppraisalReviewerListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AppraisalReviewerListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["employeeId"] = this.employeeId;
        data["firstName"] = this.firstName;
        data["otherNames"] = this.otherNames;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["employeeNumber"] = this.employeeNumber;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department;
        data["supervisorId"] = this.supervisorId;
        data["supervisorContractId"] = this.supervisorContractId;
        data["periodId"] = this.periodId;
        data["period"] = this.period;
        data["assignedKra"] = this.assignedKra;
        data["assignedKpi"] = this.assignedKpi;
        data["cycleStatus"] = this.cycleStatus;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["isSubmitted"] = this.isSubmitted;
        data["supervisorFullName"] = this.supervisorFullName;
        data["reviewStatus"] = this.reviewStatus;
        data["isApproved"] = this.isApproved;
        data["isReviewerSubmitted"] = this.isReviewerSubmitted;
        data["isReviewerStartedAppraisal"] = this.isReviewerStartedAppraisal;
        data["employeeStatus"] = this.employeeStatus;
        data["reviewerStatus"] = this.reviewerStatus;
        return data; 
    }

    clone(): AppraisalReviewerListDTO {
        const json = this.toJSON();
        let result = new AppraisalReviewerListDTO();
        result.init(json);
        return result;
    }
}

export interface IAppraisalReviewerListDTO {
    contractId: number;
    employeeId: number;
    firstName: string | undefined;
    otherNames: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    employeeNumber: string | undefined;
    departmentId: number;
    department: string | undefined;
    supervisorId: number | undefined;
    supervisorContractId: number;
    periodId: number;
    period: string | undefined;
    assignedKra: number;
    assignedKpi: number;
    cycleStatus: number;
    startDate: Date | undefined;
    isSubmitted: boolean;
    supervisorFullName: string | undefined;
    reviewStatus: number;
    isApproved: boolean;
    isReviewerSubmitted: boolean | undefined;
    isReviewerStartedAppraisal: boolean | undefined;
    employeeStatus: string | undefined;
    reviewerStatus: string | undefined;
}

export class AppraisalReviewerListDTOIListApiResult implements IAppraisalReviewerListDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AppraisalReviewerListDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAppraisalReviewerListDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AppraisalReviewerListDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AppraisalReviewerListDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AppraisalReviewerListDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AppraisalReviewerListDTOIListApiResult {
        const json = this.toJSON();
        let result = new AppraisalReviewerListDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAppraisalReviewerListDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AppraisalReviewerListDTO[] | undefined;
    totalCount: number;
}

export class AssignedKPIs implements IAssignedKPIs {
    title!: string | undefined;
    responseId!: number;
    appraisalId!: number;
    employeeComment!: string | undefined;
    employeeScore!: number;
    reviewerComment!: string | undefined;
    reviewerScore!: number;
    averageScore!: number;
    kraId!: number;
    kpiId!: number;

    constructor(data?: IAssignedKPIs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.responseId = _data["responseId"];
            this.appraisalId = _data["appraisalId"];
            this.employeeComment = _data["employeeComment"];
            this.employeeScore = _data["employeeScore"];
            this.reviewerComment = _data["reviewerComment"];
            this.reviewerScore = _data["reviewerScore"];
            this.averageScore = _data["averageScore"];
            this.kraId = _data["kraId"];
            this.kpiId = _data["kpiId"];
        }
    }

    static fromJS(data: any): AssignedKPIs {
        data = typeof data === 'object' ? data : {};
        let result = new AssignedKPIs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["responseId"] = this.responseId;
        data["appraisalId"] = this.appraisalId;
        data["employeeComment"] = this.employeeComment;
        data["employeeScore"] = this.employeeScore;
        data["reviewerComment"] = this.reviewerComment;
        data["reviewerScore"] = this.reviewerScore;
        data["averageScore"] = this.averageScore;
        data["kraId"] = this.kraId;
        data["kpiId"] = this.kpiId;
        return data; 
    }

    clone(): AssignedKPIs {
        const json = this.toJSON();
        let result = new AssignedKPIs();
        result.init(json);
        return result;
    }
}

export interface IAssignedKPIs {
    title: string | undefined;
    responseId: number;
    appraisalId: number;
    employeeComment: string | undefined;
    employeeScore: number;
    reviewerComment: string | undefined;
    reviewerScore: number;
    averageScore: number;
    kraId: number;
    kpiId: number;
}

export class KpiReviewDTO implements IKpiReviewDTO {
    cycleId!: number;
    kraId!: number;
    reviewerContractId!: number;
    reviewerName!: string | undefined;
    reviewerTitle!: string | undefined;
    employeeId!: number;
    employeeContractId!: number;
    employeeName!: string | undefined;
    department!: string | undefined;
    position!: string | undefined;
    appraisalTypeId!: number;
    lastAppraisedDate!: string | undefined;
    periodUnderReview!: string | undefined;
    dueDate!: Date;
    appraisalType!: string | undefined;
    assignedKPIs!: AssignedKPIs[] | undefined;

    constructor(data?: IKpiReviewDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cycleId = _data["cycleId"];
            this.kraId = _data["kraId"];
            this.reviewerContractId = _data["reviewerContractId"];
            this.reviewerName = _data["reviewerName"];
            this.reviewerTitle = _data["reviewerTitle"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
            this.employeeName = _data["employeeName"];
            this.department = _data["department"];
            this.position = _data["position"];
            this.appraisalTypeId = _data["appraisalTypeId"];
            this.lastAppraisedDate = _data["lastAppraisedDate"];
            this.periodUnderReview = _data["periodUnderReview"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.appraisalType = _data["appraisalType"];
            if (Array.isArray(_data["assignedKPIs"])) {
                this.assignedKPIs = [] as any;
                for (let item of _data["assignedKPIs"])
                    this.assignedKPIs!.push(AssignedKPIs.fromJS(item));
            }
        }
    }

    static fromJS(data: any): KpiReviewDTO {
        data = typeof data === 'object' ? data : {};
        let result = new KpiReviewDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cycleId"] = this.cycleId;
        data["kraId"] = this.kraId;
        data["reviewerContractId"] = this.reviewerContractId;
        data["reviewerName"] = this.reviewerName;
        data["reviewerTitle"] = this.reviewerTitle;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        data["employeeName"] = this.employeeName;
        data["department"] = this.department;
        data["position"] = this.position;
        data["appraisalTypeId"] = this.appraisalTypeId;
        data["lastAppraisedDate"] = this.lastAppraisedDate;
        data["periodUnderReview"] = this.periodUnderReview;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["appraisalType"] = this.appraisalType;
        if (Array.isArray(this.assignedKPIs)) {
            data["assignedKPIs"] = [];
            for (let item of this.assignedKPIs)
                data["assignedKPIs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): KpiReviewDTO {
        const json = this.toJSON();
        let result = new KpiReviewDTO();
        result.init(json);
        return result;
    }
}

export interface IKpiReviewDTO {
    cycleId: number;
    kraId: number;
    reviewerContractId: number;
    reviewerName: string | undefined;
    reviewerTitle: string | undefined;
    employeeId: number;
    employeeContractId: number;
    employeeName: string | undefined;
    department: string | undefined;
    position: string | undefined;
    appraisalTypeId: number;
    lastAppraisedDate: string | undefined;
    periodUnderReview: string | undefined;
    dueDate: Date;
    appraisalType: string | undefined;
    assignedKPIs: AssignedKPIs[] | undefined;
}

export class KpiReviewDTOApiResult implements IKpiReviewDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: KpiReviewDTO;
    totalCount!: number;

    constructor(data?: IKpiReviewDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? KpiReviewDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): KpiReviewDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new KpiReviewDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): KpiReviewDTOApiResult {
        const json = this.toJSON();
        let result = new KpiReviewDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IKpiReviewDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: KpiReviewDTO;
    totalCount: number;
}

export class PerformanceReviewDTO implements IPerformanceReviewDTO {
    appraisalId!: number;
    employeeId!: number;
    employeeContractId!: number;
    reviewerContractId!: number;
    cycleId!: number;
    kraId!: number;
    employeeComment!: string | undefined;
    reviewerComment!: string | undefined;
    assignedKPIs!: string | undefined;

    constructor(data?: IPerformanceReviewDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appraisalId = _data["appraisalId"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
            this.reviewerContractId = _data["reviewerContractId"];
            this.cycleId = _data["cycleId"];
            this.kraId = _data["kraId"];
            this.employeeComment = _data["employeeComment"];
            this.reviewerComment = _data["reviewerComment"];
            this.assignedKPIs = _data["assignedKPIs"];
        }
    }

    static fromJS(data: any): PerformanceReviewDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PerformanceReviewDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appraisalId"] = this.appraisalId;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        data["reviewerContractId"] = this.reviewerContractId;
        data["cycleId"] = this.cycleId;
        data["kraId"] = this.kraId;
        data["employeeComment"] = this.employeeComment;
        data["reviewerComment"] = this.reviewerComment;
        data["assignedKPIs"] = this.assignedKPIs;
        return data; 
    }

    clone(): PerformanceReviewDTO {
        const json = this.toJSON();
        let result = new PerformanceReviewDTO();
        result.init(json);
        return result;
    }
}

export interface IPerformanceReviewDTO {
    appraisalId: number;
    employeeId: number;
    employeeContractId: number;
    reviewerContractId: number;
    cycleId: number;
    kraId: number;
    employeeComment: string | undefined;
    reviewerComment: string | undefined;
    assignedKPIs: string | undefined;
}

export class EmployeeAppraisalHistoryDTO implements IEmployeeAppraisalHistoryDTO {
    appraisalId!: number;
    cycleId!: number;
    cycle!: string | undefined;
    appraisalTypeId!: number;
    appraisalType!: string | undefined;
    ratingTypeId!: number;
    ratingType!: string | undefined;
    periodUnderReview!: string | undefined;
    totalPercentageScore!: number;
    grade!: string | undefined;
    recommendationId!: number;
    recommendation!: string | undefined;

    constructor(data?: IEmployeeAppraisalHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appraisalId = _data["appraisalId"];
            this.cycleId = _data["cycleId"];
            this.cycle = _data["cycle"];
            this.appraisalTypeId = _data["appraisalTypeId"];
            this.appraisalType = _data["appraisalType"];
            this.ratingTypeId = _data["ratingTypeId"];
            this.ratingType = _data["ratingType"];
            this.periodUnderReview = _data["periodUnderReview"];
            this.totalPercentageScore = _data["totalPercentageScore"];
            this.grade = _data["grade"];
            this.recommendationId = _data["recommendationId"];
            this.recommendation = _data["recommendation"];
        }
    }

    static fromJS(data: any): EmployeeAppraisalHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeAppraisalHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appraisalId"] = this.appraisalId;
        data["cycleId"] = this.cycleId;
        data["cycle"] = this.cycle;
        data["appraisalTypeId"] = this.appraisalTypeId;
        data["appraisalType"] = this.appraisalType;
        data["ratingTypeId"] = this.ratingTypeId;
        data["ratingType"] = this.ratingType;
        data["periodUnderReview"] = this.periodUnderReview;
        data["totalPercentageScore"] = this.totalPercentageScore;
        data["grade"] = this.grade;
        data["recommendationId"] = this.recommendationId;
        data["recommendation"] = this.recommendation;
        return data; 
    }

    clone(): EmployeeAppraisalHistoryDTO {
        const json = this.toJSON();
        let result = new EmployeeAppraisalHistoryDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeAppraisalHistoryDTO {
    appraisalId: number;
    cycleId: number;
    cycle: string | undefined;
    appraisalTypeId: number;
    appraisalType: string | undefined;
    ratingTypeId: number;
    ratingType: string | undefined;
    periodUnderReview: string | undefined;
    totalPercentageScore: number;
    grade: string | undefined;
    recommendationId: number;
    recommendation: string | undefined;
}

export class EmployeeAppraisalHistoryDTOIListApiResult implements IEmployeeAppraisalHistoryDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeAppraisalHistoryDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IEmployeeAppraisalHistoryDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmployeeAppraisalHistoryDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmployeeAppraisalHistoryDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeAppraisalHistoryDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmployeeAppraisalHistoryDTOIListApiResult {
        const json = this.toJSON();
        let result = new EmployeeAppraisalHistoryDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeAppraisalHistoryDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeAppraisalHistoryDTO[] | undefined;
    totalCount: number;
}

export class AssetTypeDTO implements IAssetTypeDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetTypeDTO {
        const json = this.toJSON();
        let result = new AssetTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetTypeDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class MessageOutIListApiResult implements IMessageOutIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MessageOut[] | undefined;
    totalCount!: number;

    constructor(data?: IMessageOutIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MessageOut.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MessageOutIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOutIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): MessageOutIListApiResult {
        const json = this.toJSON();
        let result = new MessageOutIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IMessageOutIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MessageOut[] | undefined;
    totalCount: number;
}

export class AssetDeperciationProfileDTO implements IAssetDeperciationProfileDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    code!: number;
    deperciationDate!: Date | undefined;
    purchaseYear!: number | undefined;
    depriciationType!: string | undefined;
    peroidicity!: Date | undefined;
    deperciationPercentage!: number | undefined;

    constructor(data?: IAssetDeperciationProfileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
            this.deperciationDate = _data["deperciationDate"] ? new Date(_data["deperciationDate"].toString()) : <any>undefined;
            this.purchaseYear = _data["purchaseYear"];
            this.depriciationType = _data["depriciationType"];
            this.peroidicity = _data["peroidicity"] ? new Date(_data["peroidicity"].toString()) : <any>undefined;
            this.deperciationPercentage = _data["deperciationPercentage"];
        }
    }

    static fromJS(data: any): AssetDeperciationProfileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDeperciationProfileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        data["deperciationDate"] = this.deperciationDate ? this.deperciationDate.toISOString() : <any>undefined;
        data["purchaseYear"] = this.purchaseYear;
        data["depriciationType"] = this.depriciationType;
        data["peroidicity"] = this.peroidicity ? this.peroidicity.toISOString() : <any>undefined;
        data["deperciationPercentage"] = this.deperciationPercentage;
        return data; 
    }

    clone(): AssetDeperciationProfileDTO {
        const json = this.toJSON();
        let result = new AssetDeperciationProfileDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetDeperciationProfileDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    code: number;
    deperciationDate: Date | undefined;
    purchaseYear: number | undefined;
    depriciationType: string | undefined;
    peroidicity: Date | undefined;
    deperciationPercentage: number | undefined;
}

export class AssetSubTypeDTO implements IAssetSubTypeDTO {
    id!: number;
    assetTypeId!: number;
    assetid!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    code!: number;

    constructor(data?: IAssetSubTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetTypeId = _data["assetTypeId"];
            this.assetid = _data["assetid"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): AssetSubTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetSubTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetTypeId"] = this.assetTypeId;
        data["assetid"] = this.assetid;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        return data; 
    }

    clone(): AssetSubTypeDTO {
        const json = this.toJSON();
        let result = new AssetSubTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetSubTypeDTO {
    id: number;
    assetTypeId: number;
    assetid: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    code: number;
}

export class AssetCategoryDTO implements IAssetCategoryDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetCategoryDTO {
        const json = this.toJSON();
        let result = new AssetCategoryDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetCategoryDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetStatusDTO implements IAssetStatusDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    assetid!: number;
    statusName!: string | undefined;
    subID!: number;
    description!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetStatusDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.assetid = _data["assetid"];
            this.statusName = _data["statusName"];
            this.subID = _data["subID"];
            this.description = _data["description"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetStatusDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetStatusDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["assetid"] = this.assetid;
        data["statusName"] = this.statusName;
        data["subID"] = this.subID;
        data["description"] = this.description;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetStatusDTO {
        const json = this.toJSON();
        let result = new AssetStatusDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetStatusDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    assetid: number;
    statusName: string | undefined;
    subID: number;
    description: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetMakeDTO implements IAssetMakeDTO {
    id!: number;
    companyID!: number;
    brandModel!: string | undefined;
    makeName!: string | undefined;
    assetid!: number;
    depreciation!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetMakeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.brandModel = _data["brandModel"];
            this.makeName = _data["makeName"];
            this.assetid = _data["assetid"];
            this.depreciation = _data["depreciation"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetMakeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetMakeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["brandModel"] = this.brandModel;
        data["makeName"] = this.makeName;
        data["assetid"] = this.assetid;
        data["depreciation"] = this.depreciation;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetMakeDTO {
        const json = this.toJSON();
        let result = new AssetMakeDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetMakeDTO {
    id: number;
    companyID: number;
    brandModel: string | undefined;
    makeName: string | undefined;
    assetid: number;
    depreciation: string | undefined;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetModelDTO implements IAssetModelDTO {
    id!: number;
    assetMakeId!: number | undefined;
    companyID!: number;
    description!: string | undefined;
    modelname!: string | undefined;
    assetid!: number;
    name!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetModelDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetMakeId = _data["assetMakeId"];
            this.companyID = _data["companyID"];
            this.description = _data["description"];
            this.modelname = _data["modelname"];
            this.assetid = _data["assetid"];
            this.name = _data["name"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetModelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetModelDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetMakeId"] = this.assetMakeId;
        data["companyID"] = this.companyID;
        data["description"] = this.description;
        data["modelname"] = this.modelname;
        data["assetid"] = this.assetid;
        data["name"] = this.name;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetModelDTO {
        const json = this.toJSON();
        let result = new AssetModelDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetModelDTO {
    id: number;
    assetMakeId: number | undefined;
    companyID: number;
    description: string | undefined;
    modelname: string | undefined;
    assetid: number;
    name: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetDTO implements IAssetDTO {
    referenceNumber!: string | undefined;
    employeeFullName!: string | undefined;
    modelName!: string | undefined;
    depreciationName!: string | undefined;
    assetTypeName!: string | undefined;
    assetSubTypeName!: string | undefined;
    statusName!: string | undefined;
    locationName!: string | undefined;
    makeName!: string | undefined;
    assetid!: number;
    assignedEmployeeid!: number;
    name!: string | undefined;
    assetNumber!: string | undefined;
    serialNumber!: string | undefined;
    custodianDepartmentId!: number;
    custodianId!: number;
    assetStatusId!: number;
    assetCategoryId!: number;
    assetSubTypeId!: number;
    deperciationMethod!: number;
    depreciationFrequency!: number;
    createdBy!: string | undefined;
    assetTypeId!: number;
    assetModelId!: number;
    assetModelName!: string | undefined;
    assetDepreciationProfileId!: number;
    assetMakeId!: number;
    assetMakeName!: string | undefined;
    locationId!: number;
    manufactureDate!: Date | undefined;
    purchaseDate!: Date | undefined;
    purchaseAmount!: number;
    description!: string | undefined;
    barCode!: string | undefined;
    qrCode!: string | undefined;
    depreciationDate!: Date | undefined;
    lostAsset!: boolean | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date | undefined;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.referenceNumber = _data["referenceNumber"];
            this.employeeFullName = _data["employeeFullName"];
            this.modelName = _data["modelName"];
            this.depreciationName = _data["depreciationName"];
            this.assetTypeName = _data["assetTypeName"];
            this.assetSubTypeName = _data["assetSubTypeName"];
            this.statusName = _data["statusName"];
            this.locationName = _data["locationName"];
            this.makeName = _data["makeName"];
            this.assetid = _data["assetid"];
            this.assignedEmployeeid = _data["assignedEmployeeid"];
            this.name = _data["name"];
            this.assetNumber = _data["assetNumber"];
            this.serialNumber = _data["serialNumber"];
            this.custodianDepartmentId = _data["custodianDepartmentId"];
            this.custodianId = _data["custodianId"];
            this.assetStatusId = _data["assetStatusId"];
            this.assetCategoryId = _data["assetCategoryId"];
            this.assetSubTypeId = _data["assetSubTypeId"];
            this.deperciationMethod = _data["deperciationMethod"];
            this.depreciationFrequency = _data["depreciationFrequency"];
            this.createdBy = _data["createdBy"];
            this.assetTypeId = _data["assetTypeId"];
            this.assetModelId = _data["assetModelId"];
            this.assetModelName = _data["assetModelName"];
            this.assetDepreciationProfileId = _data["assetDepreciationProfileId"];
            this.assetMakeId = _data["assetMakeId"];
            this.assetMakeName = _data["assetMakeName"];
            this.locationId = _data["locationId"];
            this.manufactureDate = _data["manufactureDate"] ? new Date(_data["manufactureDate"].toString()) : <any>undefined;
            this.purchaseDate = _data["purchaseDate"] ? new Date(_data["purchaseDate"].toString()) : <any>undefined;
            this.purchaseAmount = _data["purchaseAmount"];
            this.description = _data["description"];
            this.barCode = _data["barCode"];
            this.qrCode = _data["qrCode"];
            this.depreciationDate = _data["depreciationDate"] ? new Date(_data["depreciationDate"].toString()) : <any>undefined;
            this.lostAsset = _data["lostAsset"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceNumber"] = this.referenceNumber;
        data["employeeFullName"] = this.employeeFullName;
        data["modelName"] = this.modelName;
        data["depreciationName"] = this.depreciationName;
        data["assetTypeName"] = this.assetTypeName;
        data["assetSubTypeName"] = this.assetSubTypeName;
        data["statusName"] = this.statusName;
        data["locationName"] = this.locationName;
        data["makeName"] = this.makeName;
        data["assetid"] = this.assetid;
        data["assignedEmployeeid"] = this.assignedEmployeeid;
        data["name"] = this.name;
        data["assetNumber"] = this.assetNumber;
        data["serialNumber"] = this.serialNumber;
        data["custodianDepartmentId"] = this.custodianDepartmentId;
        data["custodianId"] = this.custodianId;
        data["assetStatusId"] = this.assetStatusId;
        data["assetCategoryId"] = this.assetCategoryId;
        data["assetSubTypeId"] = this.assetSubTypeId;
        data["deperciationMethod"] = this.deperciationMethod;
        data["depreciationFrequency"] = this.depreciationFrequency;
        data["createdBy"] = this.createdBy;
        data["assetTypeId"] = this.assetTypeId;
        data["assetModelId"] = this.assetModelId;
        data["assetModelName"] = this.assetModelName;
        data["assetDepreciationProfileId"] = this.assetDepreciationProfileId;
        data["assetMakeId"] = this.assetMakeId;
        data["assetMakeName"] = this.assetMakeName;
        data["locationId"] = this.locationId;
        data["manufactureDate"] = this.manufactureDate ? this.manufactureDate.toISOString() : <any>undefined;
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>undefined;
        data["purchaseAmount"] = this.purchaseAmount;
        data["description"] = this.description;
        data["barCode"] = this.barCode;
        data["qrCode"] = this.qrCode;
        data["depreciationDate"] = this.depreciationDate ? this.depreciationDate.toISOString() : <any>undefined;
        data["lostAsset"] = this.lostAsset;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetDTO {
        const json = this.toJSON();
        let result = new AssetDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetDTO {
    referenceNumber: string | undefined;
    employeeFullName: string | undefined;
    modelName: string | undefined;
    depreciationName: string | undefined;
    assetTypeName: string | undefined;
    assetSubTypeName: string | undefined;
    statusName: string | undefined;
    locationName: string | undefined;
    makeName: string | undefined;
    assetid: number;
    assignedEmployeeid: number;
    name: string | undefined;
    assetNumber: string | undefined;
    serialNumber: string | undefined;
    custodianDepartmentId: number;
    custodianId: number;
    assetStatusId: number;
    assetCategoryId: number;
    assetSubTypeId: number;
    deperciationMethod: number;
    depreciationFrequency: number;
    createdBy: string | undefined;
    assetTypeId: number;
    assetModelId: number;
    assetModelName: string | undefined;
    assetDepreciationProfileId: number;
    assetMakeId: number;
    assetMakeName: string | undefined;
    locationId: number;
    manufactureDate: Date | undefined;
    purchaseDate: Date | undefined;
    purchaseAmount: number;
    description: string | undefined;
    barCode: string | undefined;
    qrCode: string | undefined;
    depreciationDate: Date | undefined;
    lostAsset: boolean | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date | undefined;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetRequestDTO implements IAssetRequestDTO {
    assetid!: number | undefined;
    assetTypeid!: number | undefined;
    assetName!: string | undefined;
    employeeid!: number;
    employeeName!: string | undefined;
    assetSubTypeName!: string | undefined;
    expectedusedate!: Date | undefined;
    assetSubTypeid!: number;
    returndate!: Date | undefined;
    purpose!: string | undefined;
    decisionComment!: string | undefined;
    departmentId!: number;
    location!: number;
    prioity!: number;
    justification!: string | undefined;
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    status!: number;
    assignedbyId!: number;
    approvedId!: number;
    statusName!: string | undefined;
    assignedbyName!: string | undefined;
    approveedbyName!: string | undefined;
    dateCreated!: Date | undefined;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assetid = _data["assetid"];
            this.assetTypeid = _data["assetTypeid"];
            this.assetName = _data["assetName"];
            this.employeeid = _data["employeeid"];
            this.employeeName = _data["employeeName"];
            this.assetSubTypeName = _data["assetSubTypeName"];
            this.expectedusedate = _data["expectedusedate"] ? new Date(_data["expectedusedate"].toString()) : <any>undefined;
            this.assetSubTypeid = _data["assetSubTypeid"];
            this.returndate = _data["returndate"] ? new Date(_data["returndate"].toString()) : <any>undefined;
            this.purpose = _data["purpose"];
            this.decisionComment = _data["decisionComment"];
            this.departmentId = _data["departmentId"];
            this.location = _data["location"];
            this.prioity = _data["prioity"];
            this.justification = _data["justification"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.status = _data["status"];
            this.assignedbyId = _data["assignedbyId"];
            this.approvedId = _data["approvedId"];
            this.statusName = _data["statusName"];
            this.assignedbyName = _data["assignedbyName"];
            this.approveedbyName = _data["approveedbyName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetid"] = this.assetid;
        data["assetTypeid"] = this.assetTypeid;
        data["assetName"] = this.assetName;
        data["employeeid"] = this.employeeid;
        data["employeeName"] = this.employeeName;
        data["assetSubTypeName"] = this.assetSubTypeName;
        data["expectedusedate"] = this.expectedusedate ? this.expectedusedate.toISOString() : <any>undefined;
        data["assetSubTypeid"] = this.assetSubTypeid;
        data["returndate"] = this.returndate ? this.returndate.toISOString() : <any>undefined;
        data["purpose"] = this.purpose;
        data["decisionComment"] = this.decisionComment;
        data["departmentId"] = this.departmentId;
        data["location"] = this.location;
        data["prioity"] = this.prioity;
        data["justification"] = this.justification;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["status"] = this.status;
        data["assignedbyId"] = this.assignedbyId;
        data["approvedId"] = this.approvedId;
        data["statusName"] = this.statusName;
        data["assignedbyName"] = this.assignedbyName;
        data["approveedbyName"] = this.approveedbyName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetRequestDTO {
        const json = this.toJSON();
        let result = new AssetRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetRequestDTO {
    assetid: number | undefined;
    assetTypeid: number | undefined;
    assetName: string | undefined;
    employeeid: number;
    employeeName: string | undefined;
    assetSubTypeName: string | undefined;
    expectedusedate: Date | undefined;
    assetSubTypeid: number;
    returndate: Date | undefined;
    purpose: string | undefined;
    decisionComment: string | undefined;
    departmentId: number;
    location: number;
    prioity: number;
    justification: string | undefined;
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    status: number;
    assignedbyId: number;
    approvedId: number;
    statusName: string | undefined;
    assignedbyName: string | undefined;
    approveedbyName: string | undefined;
    dateCreated: Date | undefined;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssignmentDTO implements IAssignmentDTO {
    id!: number;
    assetid!: number;
    comment!: string | undefined;

    constructor(data?: IAssignmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetid = _data["assetid"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): AssignmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssignmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetid"] = this.assetid;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): AssignmentDTO {
        const json = this.toJSON();
        let result = new AssignmentDTO();
        result.init(json);
        return result;
    }
}

export interface IAssignmentDTO {
    id: number;
    assetid: number;
    comment: string | undefined;
}

export class AssetCallbackDTO implements IAssetCallbackDTO {
    companyID!: number;
    message!: string | undefined;
    processcode!: number;
    itemId!: number;
    approvalProcessId!: number;
    isapproved!: boolean;

    constructor(data?: IAssetCallbackDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyID = _data["companyID"];
            this.message = _data["message"];
            this.processcode = _data["processcode"];
            this.itemId = _data["itemId"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.isapproved = _data["isapproved"];
        }
    }

    static fromJS(data: any): AssetCallbackDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCallbackDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyID"] = this.companyID;
        data["message"] = this.message;
        data["processcode"] = this.processcode;
        data["itemId"] = this.itemId;
        data["approvalProcessId"] = this.approvalProcessId;
        data["isapproved"] = this.isapproved;
        return data; 
    }

    clone(): AssetCallbackDTO {
        const json = this.toJSON();
        let result = new AssetCallbackDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetCallbackDTO {
    companyID: number;
    message: string | undefined;
    processcode: number;
    itemId: number;
    approvalProcessId: number;
    isapproved: boolean;
}

export class AssetcheckInFilter implements IAssetcheckInFilter {
    id!: number;
    pageNumber!: number;
    pageSize!: number;
    name!: string | undefined;
    isFilter!: boolean;
    isActive!: boolean | undefined;

    constructor(data?: IAssetcheckInFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.name = _data["name"];
            this.isFilter = _data["isFilter"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetcheckInFilter {
        data = typeof data === 'object' ? data : {};
        let result = new AssetcheckInFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["name"] = this.name;
        data["isFilter"] = this.isFilter;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetcheckInFilter {
        const json = this.toJSON();
        let result = new AssetcheckInFilter();
        result.init(json);
        return result;
    }
}

export interface IAssetcheckInFilter {
    id: number;
    pageNumber: number;
    pageSize: number;
    name: string | undefined;
    isFilter: boolean;
    isActive: boolean | undefined;
}

export class UpdateAssetRequest implements IUpdateAssetRequest {
    id!: number;
    assetid!: number;
    assetRequestDTO!: AssetRequestDTO;
    pageNumber!: number;
    pageSize!: number;
    name!: string | undefined;
    isFilter!: boolean;
    isActive!: boolean | undefined;

    constructor(data?: IUpdateAssetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetid = _data["assetid"];
            this.assetRequestDTO = _data["assetRequestDTO"] ? AssetRequestDTO.fromJS(_data["assetRequestDTO"]) : <any>undefined;
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.name = _data["name"];
            this.isFilter = _data["isFilter"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateAssetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAssetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetid"] = this.assetid;
        data["assetRequestDTO"] = this.assetRequestDTO ? this.assetRequestDTO.toJSON() : <any>undefined;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["name"] = this.name;
        data["isFilter"] = this.isFilter;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): UpdateAssetRequest {
        const json = this.toJSON();
        let result = new UpdateAssetRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateAssetRequest {
    id: number;
    assetid: number;
    assetRequestDTO: AssetRequestDTO;
    pageNumber: number;
    pageSize: number;
    name: string | undefined;
    isFilter: boolean;
    isActive: boolean | undefined;
}

export class AssetDTOIListApiResult implements IAssetDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetDTO[] | undefined;
    totalCount: number;
}

export class AssetTypeDTOIListApiResult implements IAssetTypeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetTypeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetTypeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetTypeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetTypeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetTypeDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetTypeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetTypeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetTypeDTO[] | undefined;
    totalCount: number;
}

export class AssetSubTypeDTOIListApiResult implements IAssetSubTypeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetSubTypeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetSubTypeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetSubTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetSubTypeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetSubTypeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetSubTypeDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetSubTypeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetSubTypeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetSubTypeDTO[] | undefined;
    totalCount: number;
}

export class AssetCategoryDTOIListApiResult implements IAssetCategoryDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetCategoryDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetCategoryDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetCategoryDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetCategoryDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCategoryDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetCategoryDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetCategoryDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetCategoryDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetCategoryDTO[] | undefined;
    totalCount: number;
}

export class AssetMakeDTOIListApiResult implements IAssetMakeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetMakeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetMakeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetMakeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetMakeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetMakeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetMakeDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetMakeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetMakeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetMakeDTO[] | undefined;
    totalCount: number;
}

export class AssetModelDTOIListApiResult implements IAssetModelDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetModelDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetModelDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetModelDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetModelDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetModelDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetModelDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetModelDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetModelDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetModelDTO[] | undefined;
    totalCount: number;
}

export class AssetStatusDTOIListApiResult implements IAssetStatusDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetStatusDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetStatusDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetStatusDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetStatusDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetStatusDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetStatusDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetStatusDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetStatusDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetStatusDTO[] | undefined;
    totalCount: number;
}

export class AssetDeperciationProfileDTOIListApiResult implements IAssetDeperciationProfileDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetDeperciationProfileDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetDeperciationProfileDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetDeperciationProfileDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetDeperciationProfileDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDeperciationProfileDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetDeperciationProfileDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetDeperciationProfileDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetDeperciationProfileDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetDeperciationProfileDTO[] | undefined;
    totalCount: number;
}

export class AssetHistoryDTO implements IAssetHistoryDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    assignedEmployeeName!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    assetId!: number;
    status!: number;
    assignedEmployeeid!: number;
    assetName!: string | undefined;
    statusName!: string | undefined;
    employeeId!: number;
    employeeName!: string | undefined;
    departmentAssignedTo!: number;
    departmentNameAssignedTo!: string | undefined;
    assignedDate!: Date;
    employeelocationName!: string | undefined;

    constructor(data?: IAssetHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.assignedEmployeeName = _data["assignedEmployeeName"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.assetId = _data["assetId"];
            this.status = _data["status"];
            this.assignedEmployeeid = _data["assignedEmployeeid"];
            this.assetName = _data["assetName"];
            this.statusName = _data["statusName"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.departmentAssignedTo = _data["departmentAssignedTo"];
            this.departmentNameAssignedTo = _data["departmentNameAssignedTo"];
            this.assignedDate = _data["assignedDate"] ? new Date(_data["assignedDate"].toString()) : <any>undefined;
            this.employeelocationName = _data["employeelocationName"];
        }
    }

    static fromJS(data: any): AssetHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["assignedEmployeeName"] = this.assignedEmployeeName;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["assetId"] = this.assetId;
        data["status"] = this.status;
        data["assignedEmployeeid"] = this.assignedEmployeeid;
        data["assetName"] = this.assetName;
        data["statusName"] = this.statusName;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["departmentAssignedTo"] = this.departmentAssignedTo;
        data["departmentNameAssignedTo"] = this.departmentNameAssignedTo;
        data["assignedDate"] = this.assignedDate ? this.assignedDate.toISOString() : <any>undefined;
        data["employeelocationName"] = this.employeelocationName;
        return data; 
    }

    clone(): AssetHistoryDTO {
        const json = this.toJSON();
        let result = new AssetHistoryDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetHistoryDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    assignedEmployeeName: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    assetId: number;
    status: number;
    assignedEmployeeid: number;
    assetName: string | undefined;
    statusName: string | undefined;
    employeeId: number;
    employeeName: string | undefined;
    departmentAssignedTo: number;
    departmentNameAssignedTo: string | undefined;
    assignedDate: Date;
    employeelocationName: string | undefined;
}

export class AssetHistoryDTOIListApiResult implements IAssetHistoryDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetHistoryDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetHistoryDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetHistoryDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetHistoryDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetHistoryDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetHistoryDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetHistoryDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetHistoryDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetHistoryDTO[] | undefined;
    totalCount: number;
}

export class StringApiResult implements IStringApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: string | undefined;
    totalCount!: number;

    constructor(data?: IStringApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StringApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new StringApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): StringApiResult {
        const json = this.toJSON();
        let result = new StringApiResult();
        result.init(json);
        return result;
    }
}

export interface IStringApiResult {
    hasError: boolean;
    message: string | undefined;
    result: string | undefined;
    totalCount: number;
}

export class AzureDocs implements IAzureDocs {
    name!: string | undefined;
    directory!: string | undefined;
    lastModifiedDate!: string | undefined;
    url!: string | undefined;
    size!: string | undefined;

    constructor(data?: IAzureDocs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.directory = _data["directory"];
            this.lastModifiedDate = _data["lastModifiedDate"];
            this.url = _data["url"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): AzureDocs {
        data = typeof data === 'object' ? data : {};
        let result = new AzureDocs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["directory"] = this.directory;
        data["lastModifiedDate"] = this.lastModifiedDate;
        data["url"] = this.url;
        data["size"] = this.size;
        return data; 
    }

    clone(): AzureDocs {
        const json = this.toJSON();
        let result = new AzureDocs();
        result.init(json);
        return result;
    }
}

export interface IAzureDocs {
    name: string | undefined;
    directory: string | undefined;
    lastModifiedDate: string | undefined;
    url: string | undefined;
    size: string | undefined;
}

export class AzureDocsListApiResult implements IAzureDocsListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AzureDocs[] | undefined;
    totalCount!: number;

    constructor(data?: IAzureDocsListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AzureDocs.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AzureDocsListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AzureDocsListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AzureDocsListApiResult {
        const json = this.toJSON();
        let result = new AzureDocsListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAzureDocsListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AzureDocs[] | undefined;
    totalCount: number;
}

export class ManageBudgetDTO implements IManageBudgetDTO {
    id!: number;
    startDate!: Date;
    endDate!: Date;
    totalBudgetAmount!: number;

    constructor(data?: IManageBudgetDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.totalBudgetAmount = _data["totalBudgetAmount"];
        }
    }

    static fromJS(data: any): ManageBudgetDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageBudgetDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["totalBudgetAmount"] = this.totalBudgetAmount;
        return data; 
    }

    clone(): ManageBudgetDTO {
        const json = this.toJSON();
        let result = new ManageBudgetDTO();
        result.init(json);
        return result;
    }
}

export interface IManageBudgetDTO {
    id: number;
    startDate: Date;
    endDate: Date;
    totalBudgetAmount: number;
}

export class BudgetDTO implements IBudgetDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    startDate!: Date;
    endDate!: Date;
    totalBudgetAmount!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IBudgetDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.totalBudgetAmount = _data["totalBudgetAmount"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): BudgetDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["totalBudgetAmount"] = this.totalBudgetAmount;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): BudgetDTO {
        const json = this.toJSON();
        let result = new BudgetDTO();
        result.init(json);
        return result;
    }
}

export interface IBudgetDTO {
    id: number;
    companyID: number;
    subID: number;
    startDate: Date;
    endDate: Date;
    totalBudgetAmount: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class BudgetDTOIListApiResult implements IBudgetDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: BudgetDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IBudgetDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(BudgetDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BudgetDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): BudgetDTOIListApiResult {
        const json = this.toJSON();
        let result = new BudgetDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IBudgetDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: BudgetDTO[] | undefined;
    totalCount: number;
}

export class BudgetDTOApiResult implements IBudgetDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: BudgetDTO;
    totalCount!: number;

    constructor(data?: IBudgetDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? BudgetDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BudgetDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): BudgetDTOApiResult {
        const json = this.toJSON();
        let result = new BudgetDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IBudgetDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: BudgetDTO;
    totalCount: number;
}

export class ManageBudgetItemDTO implements IManageBudgetItemDTO {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    totalBudget!: number;
    budgetAllocations!: string | undefined;

    constructor(data?: IManageBudgetItemDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.totalBudget = _data["totalBudget"];
            this.budgetAllocations = _data["budgetAllocations"];
        }
    }

    static fromJS(data: any): ManageBudgetItemDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageBudgetItemDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["totalBudget"] = this.totalBudget;
        data["budgetAllocations"] = this.budgetAllocations;
        return data; 
    }

    clone(): ManageBudgetItemDTO {
        const json = this.toJSON();
        let result = new ManageBudgetItemDTO();
        result.init(json);
        return result;
    }
}

export interface IManageBudgetItemDTO {
    id: number;
    name: string | undefined;
    code: string | undefined;
    totalBudget: number;
    budgetAllocations: string | undefined;
}

export class Department implements IDepartment {
    name!: string;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    headOfDepartment!: number;
    scheduleOfDuties!: string | undefined;
    disbursementBudgetItemAllocations!: DisbursementBudgetItemAllocation[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDepartment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.headOfDepartment = _data["headOfDepartment"];
            this.scheduleOfDuties = _data["scheduleOfDuties"];
            if (Array.isArray(_data["disbursementBudgetItemAllocations"])) {
                this.disbursementBudgetItemAllocations = [] as any;
                for (let item of _data["disbursementBudgetItemAllocations"])
                    this.disbursementBudgetItemAllocations!.push(DisbursementBudgetItemAllocation.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Department {
        data = typeof data === 'object' ? data : {};
        let result = new Department();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["headOfDepartment"] = this.headOfDepartment;
        data["scheduleOfDuties"] = this.scheduleOfDuties;
        if (Array.isArray(this.disbursementBudgetItemAllocations)) {
            data["disbursementBudgetItemAllocations"] = [];
            for (let item of this.disbursementBudgetItemAllocations)
                data["disbursementBudgetItemAllocations"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Department {
        const json = this.toJSON();
        let result = new Department();
        result.init(json);
        return result;
    }
}

export interface IDepartment {
    name: string;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    headOfDepartment: number;
    scheduleOfDuties: string | undefined;
    disbursementBudgetItemAllocations: DisbursementBudgetItemAllocation[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ProjectActivity implements IProjectActivity {
    projectId!: number;
    name!: string | undefined;
    description!: string | undefined;
    typeId!: number;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    expectedDuration!: number;
    startingTime!: Date | undefined;
    expectedCompletionTime!: Date | undefined;
    completionDate!: Date;
    employeeId!: number | undefined;
    inApproval!: boolean;
    priority!: number;
    status!: number;
    referenceId!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    project!: Project;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IProjectActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.typeId = _data["typeId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.expectedDuration = _data["expectedDuration"];
            this.startingTime = _data["startingTime"] ? new Date(_data["startingTime"].toString()) : <any>undefined;
            this.expectedCompletionTime = _data["expectedCompletionTime"] ? new Date(_data["expectedCompletionTime"].toString()) : <any>undefined;
            this.completionDate = _data["completionDate"] ? new Date(_data["completionDate"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.inApproval = _data["inApproval"];
            this.priority = _data["priority"];
            this.status = _data["status"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ProjectActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["typeId"] = this.typeId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["expectedDuration"] = this.expectedDuration;
        data["startingTime"] = this.startingTime ? this.startingTime.toISOString() : <any>undefined;
        data["expectedCompletionTime"] = this.expectedCompletionTime ? this.expectedCompletionTime.toISOString() : <any>undefined;
        data["completionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["inApproval"] = this.inApproval;
        data["priority"] = this.priority;
        data["status"] = this.status;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ProjectActivity {
        const json = this.toJSON();
        let result = new ProjectActivity();
        result.init(json);
        return result;
    }
}

export interface IProjectActivity {
    projectId: number;
    name: string | undefined;
    description: string | undefined;
    typeId: number;
    startDate: Date | undefined;
    endDate: Date | undefined;
    expectedDuration: number;
    startingTime: Date | undefined;
    expectedCompletionTime: Date | undefined;
    completionDate: Date;
    employeeId: number | undefined;
    inApproval: boolean;
    priority: number;
    status: number;
    referenceId: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    project: Project;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Project implements IProject {
    name!: string | undefined;
    departmentId!: number;
    supervisorId!: number;
    description!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    completionDate!: Date | undefined;
    status!: number;
    inApproval!: boolean;
    postApprovalStage!: number;
    referenceId!: string | undefined;
    code!: string | undefined;
    isClosedEnded!: boolean;
    projectActivities!: ProjectActivity[] | undefined;
    fundDisbursements!: FundDisbursement[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.departmentId = _data["departmentId"];
            this.supervisorId = _data["supervisorId"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.completionDate = _data["completionDate"] ? new Date(_data["completionDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.inApproval = _data["inApproval"];
            this.postApprovalStage = _data["postApprovalStage"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isClosedEnded = _data["isClosedEnded"];
            if (Array.isArray(_data["projectActivities"])) {
                this.projectActivities = [] as any;
                for (let item of _data["projectActivities"])
                    this.projectActivities!.push(ProjectActivity.fromJS(item));
            }
            if (Array.isArray(_data["fundDisbursements"])) {
                this.fundDisbursements = [] as any;
                for (let item of _data["fundDisbursements"])
                    this.fundDisbursements!.push(FundDisbursement.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["departmentId"] = this.departmentId;
        data["supervisorId"] = this.supervisorId;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["completionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["inApproval"] = this.inApproval;
        data["postApprovalStage"] = this.postApprovalStage;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isClosedEnded"] = this.isClosedEnded;
        if (Array.isArray(this.projectActivities)) {
            data["projectActivities"] = [];
            for (let item of this.projectActivities)
                data["projectActivities"].push(item.toJSON());
        }
        if (Array.isArray(this.fundDisbursements)) {
            data["fundDisbursements"] = [];
            for (let item of this.fundDisbursements)
                data["fundDisbursements"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Project {
        const json = this.toJSON();
        let result = new Project();
        result.init(json);
        return result;
    }
}

export interface IProject {
    name: string | undefined;
    departmentId: number;
    supervisorId: number;
    description: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    completionDate: Date | undefined;
    status: number;
    inApproval: boolean;
    postApprovalStage: number;
    referenceId: string | undefined;
    code: string | undefined;
    isClosedEnded: boolean;
    projectActivities: ProjectActivity[] | undefined;
    fundDisbursements: FundDisbursement[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class FundDisbursement implements IFundDisbursement {
    categoryId!: number;
    disbursementBudgetItemId!: number | undefined;
    projectId!: number | undefined;
    channelId!: number;
    isRecurring!: boolean;
    frequencyId!: number | undefined;
    addHasBeneficiary!: boolean;
    amount!: number;
    accountNumber!: string | undefined;
    accountName!: string | undefined;
    bankCode!: string | undefined;
    bankName!: string | undefined;
    bankId!: number;
    disbursementDate!: Date;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    description!: string | undefined;
    comment!: string | undefined;
    mode!: number | undefined;
    transferStatus!: number;
    refNo!: string | undefined;
    fundType!: number;
    isPicked!: boolean;
    log_status!: number;
    isAutoGenerated!: boolean;
    initiatedById!: number;
    initiatedBy!: string | undefined;
    secretKey!: string | undefined;
    reasonFailed!: string | undefined;
    failRunCount!: number;
    disbursementBudgetItem!: DisbursementBudgetItem;
    project!: Project;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IFundDisbursement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.disbursementBudgetItemId = _data["disbursementBudgetItemId"];
            this.projectId = _data["projectId"];
            this.channelId = _data["channelId"];
            this.isRecurring = _data["isRecurring"];
            this.frequencyId = _data["frequencyId"];
            this.addHasBeneficiary = _data["addHasBeneficiary"];
            this.amount = _data["amount"];
            this.accountNumber = _data["accountNumber"];
            this.accountName = _data["accountName"];
            this.bankCode = _data["bankCode"];
            this.bankName = _data["bankName"];
            this.bankId = _data["bankId"];
            this.disbursementDate = _data["disbursementDate"] ? new Date(_data["disbursementDate"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.comment = _data["comment"];
            this.mode = _data["mode"];
            this.transferStatus = _data["transferStatus"];
            this.refNo = _data["refNo"];
            this.fundType = _data["fundType"];
            this.isPicked = _data["isPicked"];
            this.log_status = _data["log_status"];
            this.isAutoGenerated = _data["isAutoGenerated"];
            this.initiatedById = _data["initiatedById"];
            this.initiatedBy = _data["initiatedBy"];
            this.secretKey = _data["secretKey"];
            this.reasonFailed = _data["reasonFailed"];
            this.failRunCount = _data["failRunCount"];
            this.disbursementBudgetItem = _data["disbursementBudgetItem"] ? DisbursementBudgetItem.fromJS(_data["disbursementBudgetItem"]) : <any>undefined;
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): FundDisbursement {
        data = typeof data === 'object' ? data : {};
        let result = new FundDisbursement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["disbursementBudgetItemId"] = this.disbursementBudgetItemId;
        data["projectId"] = this.projectId;
        data["channelId"] = this.channelId;
        data["isRecurring"] = this.isRecurring;
        data["frequencyId"] = this.frequencyId;
        data["addHasBeneficiary"] = this.addHasBeneficiary;
        data["amount"] = this.amount;
        data["accountNumber"] = this.accountNumber;
        data["accountName"] = this.accountName;
        data["bankCode"] = this.bankCode;
        data["bankName"] = this.bankName;
        data["bankId"] = this.bankId;
        data["disbursementDate"] = this.disbursementDate ? this.disbursementDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["comment"] = this.comment;
        data["mode"] = this.mode;
        data["transferStatus"] = this.transferStatus;
        data["refNo"] = this.refNo;
        data["fundType"] = this.fundType;
        data["isPicked"] = this.isPicked;
        data["log_status"] = this.log_status;
        data["isAutoGenerated"] = this.isAutoGenerated;
        data["initiatedById"] = this.initiatedById;
        data["initiatedBy"] = this.initiatedBy;
        data["secretKey"] = this.secretKey;
        data["reasonFailed"] = this.reasonFailed;
        data["failRunCount"] = this.failRunCount;
        data["disbursementBudgetItem"] = this.disbursementBudgetItem ? this.disbursementBudgetItem.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): FundDisbursement {
        const json = this.toJSON();
        let result = new FundDisbursement();
        result.init(json);
        return result;
    }
}

export interface IFundDisbursement {
    categoryId: number;
    disbursementBudgetItemId: number | undefined;
    projectId: number | undefined;
    channelId: number;
    isRecurring: boolean;
    frequencyId: number | undefined;
    addHasBeneficiary: boolean;
    amount: number;
    accountNumber: string | undefined;
    accountName: string | undefined;
    bankCode: string | undefined;
    bankName: string | undefined;
    bankId: number;
    disbursementDate: Date;
    startDate: Date | undefined;
    endDate: Date | undefined;
    description: string | undefined;
    comment: string | undefined;
    mode: number | undefined;
    transferStatus: number;
    refNo: string | undefined;
    fundType: number;
    isPicked: boolean;
    log_status: number;
    isAutoGenerated: boolean;
    initiatedById: number;
    initiatedBy: string | undefined;
    secretKey: string | undefined;
    reasonFailed: string | undefined;
    failRunCount: number;
    disbursementBudgetItem: DisbursementBudgetItem;
    project: Project;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DisbursementBudgetItem implements IDisbursementBudgetItem {
    name!: string | undefined;
    code!: string | undefined;
    totalBudget!: number;
    disbursementBudgetItemAllocations!: DisbursementBudgetItemAllocation[] | undefined;
    fundDisbursements!: FundDisbursement[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDisbursementBudgetItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.totalBudget = _data["totalBudget"];
            if (Array.isArray(_data["disbursementBudgetItemAllocations"])) {
                this.disbursementBudgetItemAllocations = [] as any;
                for (let item of _data["disbursementBudgetItemAllocations"])
                    this.disbursementBudgetItemAllocations!.push(DisbursementBudgetItemAllocation.fromJS(item));
            }
            if (Array.isArray(_data["fundDisbursements"])) {
                this.fundDisbursements = [] as any;
                for (let item of _data["fundDisbursements"])
                    this.fundDisbursements!.push(FundDisbursement.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DisbursementBudgetItem {
        data = typeof data === 'object' ? data : {};
        let result = new DisbursementBudgetItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["totalBudget"] = this.totalBudget;
        if (Array.isArray(this.disbursementBudgetItemAllocations)) {
            data["disbursementBudgetItemAllocations"] = [];
            for (let item of this.disbursementBudgetItemAllocations)
                data["disbursementBudgetItemAllocations"].push(item.toJSON());
        }
        if (Array.isArray(this.fundDisbursements)) {
            data["fundDisbursements"] = [];
            for (let item of this.fundDisbursements)
                data["fundDisbursements"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DisbursementBudgetItem {
        const json = this.toJSON();
        let result = new DisbursementBudgetItem();
        result.init(json);
        return result;
    }
}

export interface IDisbursementBudgetItem {
    name: string | undefined;
    code: string | undefined;
    totalBudget: number;
    disbursementBudgetItemAllocations: DisbursementBudgetItemAllocation[] | undefined;
    fundDisbursements: FundDisbursement[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DisbursementBudgetItemAllocation implements IDisbursementBudgetItemAllocation {
    disbursementBudgetItemId!: number;
    departmentId!: number;
    allocatedAmount!: number;
    department!: Department;
    disbursementBudgetItem!: DisbursementBudgetItem;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDisbursementBudgetItemAllocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disbursementBudgetItemId = _data["disbursementBudgetItemId"];
            this.departmentId = _data["departmentId"];
            this.allocatedAmount = _data["allocatedAmount"];
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.disbursementBudgetItem = _data["disbursementBudgetItem"] ? DisbursementBudgetItem.fromJS(_data["disbursementBudgetItem"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DisbursementBudgetItemAllocation {
        data = typeof data === 'object' ? data : {};
        let result = new DisbursementBudgetItemAllocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disbursementBudgetItemId"] = this.disbursementBudgetItemId;
        data["departmentId"] = this.departmentId;
        data["allocatedAmount"] = this.allocatedAmount;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["disbursementBudgetItem"] = this.disbursementBudgetItem ? this.disbursementBudgetItem.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DisbursementBudgetItemAllocation {
        const json = this.toJSON();
        let result = new DisbursementBudgetItemAllocation();
        result.init(json);
        return result;
    }
}

export interface IDisbursementBudgetItemAllocation {
    disbursementBudgetItemId: number;
    departmentId: number;
    allocatedAmount: number;
    department: Department;
    disbursementBudgetItem: DisbursementBudgetItem;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class BudgetItemDTO implements IBudgetItemDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    code!: string | undefined;
    totalBudget!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    budgetItemAllocations!: DisbursementBudgetItemAllocation[] | undefined;

    constructor(data?: IBudgetItemDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.totalBudget = _data["totalBudget"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            if (Array.isArray(_data["budgetItemAllocations"])) {
                this.budgetItemAllocations = [] as any;
                for (let item of _data["budgetItemAllocations"])
                    this.budgetItemAllocations!.push(DisbursementBudgetItemAllocation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BudgetItemDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetItemDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["totalBudget"] = this.totalBudget;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        if (Array.isArray(this.budgetItemAllocations)) {
            data["budgetItemAllocations"] = [];
            for (let item of this.budgetItemAllocations)
                data["budgetItemAllocations"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BudgetItemDTO {
        const json = this.toJSON();
        let result = new BudgetItemDTO();
        result.init(json);
        return result;
    }
}

export interface IBudgetItemDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    code: string | undefined;
    totalBudget: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    budgetItemAllocations: DisbursementBudgetItemAllocation[] | undefined;
}

export class BudgetItemDTOIListApiResult implements IBudgetItemDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: BudgetItemDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IBudgetItemDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(BudgetItemDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BudgetItemDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetItemDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): BudgetItemDTOIListApiResult {
        const json = this.toJSON();
        let result = new BudgetItemDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IBudgetItemDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: BudgetItemDTO[] | undefined;
    totalCount: number;
}

export class DisbursementBudgetItemIListApiResult implements IDisbursementBudgetItemIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DisbursementBudgetItem[] | undefined;
    totalCount!: number;

    constructor(data?: IDisbursementBudgetItemIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DisbursementBudgetItem.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DisbursementBudgetItemIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DisbursementBudgetItemIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DisbursementBudgetItemIListApiResult {
        const json = this.toJSON();
        let result = new DisbursementBudgetItemIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDisbursementBudgetItemIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DisbursementBudgetItem[] | undefined;
    totalCount: number;
}

export class BudgetItemDTOApiResult implements IBudgetItemDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: BudgetItemDTO;
    totalCount!: number;

    constructor(data?: IBudgetItemDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? BudgetItemDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BudgetItemDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetItemDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): BudgetItemDTOApiResult {
        const json = this.toJSON();
        let result = new BudgetItemDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IBudgetItemDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: BudgetItemDTO;
    totalCount: number;
}

export class NineGridBoxMovementDTO implements INineGridBoxMovementDTO {
    id!: number;
    companyID!: number;
    gridboxId!: number;
    employeeId!: number;
    employeeName!: string | undefined;
    employeeDepartment!: string | undefined;
    justification!: string | undefined;
    departmentId!: number;
    fromGridBoxId!: number | undefined;
    movementType!: string | undefined;
    loggedDate!: Date | undefined;
    loggedByUserId!: number;
    loggedByUserName!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: INineGridBoxMovementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.gridboxId = _data["gridboxId"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.employeeDepartment = _data["employeeDepartment"];
            this.justification = _data["justification"];
            this.departmentId = _data["departmentId"];
            this.fromGridBoxId = _data["fromGridBoxId"];
            this.movementType = _data["movementType"];
            this.loggedDate = _data["loggedDate"] ? new Date(_data["loggedDate"].toString()) : <any>undefined;
            this.loggedByUserId = _data["loggedByUserId"];
            this.loggedByUserName = _data["loggedByUserName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): NineGridBoxMovementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NineGridBoxMovementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["gridboxId"] = this.gridboxId;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["employeeDepartment"] = this.employeeDepartment;
        data["justification"] = this.justification;
        data["departmentId"] = this.departmentId;
        data["fromGridBoxId"] = this.fromGridBoxId;
        data["movementType"] = this.movementType;
        data["loggedDate"] = this.loggedDate ? this.loggedDate.toISOString() : <any>undefined;
        data["loggedByUserId"] = this.loggedByUserId;
        data["loggedByUserName"] = this.loggedByUserName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): NineGridBoxMovementDTO {
        const json = this.toJSON();
        let result = new NineGridBoxMovementDTO();
        result.init(json);
        return result;
    }
}

export interface INineGridBoxMovementDTO {
    id: number;
    companyID: number;
    gridboxId: number;
    employeeId: number;
    employeeName: string | undefined;
    employeeDepartment: string | undefined;
    justification: string | undefined;
    departmentId: number;
    fromGridBoxId: number | undefined;
    movementType: string | undefined;
    loggedDate: Date | undefined;
    loggedByUserId: number;
    loggedByUserName: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class NineGridBoxDTO implements INineGridBoxDTO {
    id!: number;
    companyID!: number;
    gridboxId!: number;
    employeeId!: number;
    employeeName!: string | undefined;
    employeeDepartment!: string | undefined;
    justification!: string;
    departmentId!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    movementHistory!: NineGridBoxMovementDTO[] | undefined;

    constructor(data?: INineGridBoxDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.gridboxId = _data["gridboxId"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.employeeDepartment = _data["employeeDepartment"];
            this.justification = _data["justification"];
            this.departmentId = _data["departmentId"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["movementHistory"])) {
                this.movementHistory = [] as any;
                for (let item of _data["movementHistory"])
                    this.movementHistory!.push(NineGridBoxMovementDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NineGridBoxDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NineGridBoxDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["gridboxId"] = this.gridboxId;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["employeeDepartment"] = this.employeeDepartment;
        data["justification"] = this.justification;
        data["departmentId"] = this.departmentId;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.movementHistory)) {
            data["movementHistory"] = [];
            for (let item of this.movementHistory)
                data["movementHistory"].push(item.toJSON());
        }
        return data; 
    }

    clone(): NineGridBoxDTO {
        const json = this.toJSON();
        let result = new NineGridBoxDTO();
        result.init(json);
        return result;
    }
}

export interface INineGridBoxDTO {
    id: number;
    companyID: number;
    gridboxId: number;
    employeeId: number;
    employeeName: string | undefined;
    employeeDepartment: string | undefined;
    justification: string;
    departmentId: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    movementHistory: NineGridBoxMovementDTO[] | undefined;
}

export class ManageMoveEmployeeFilterDTO implements IManageMoveEmployeeFilterDTO {
    togridboxId!: number;
    fromgridboxId!: number;
    employeeId!: number;
    justification!: string | undefined;

    constructor(data?: IManageMoveEmployeeFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.togridboxId = _data["togridboxId"];
            this.fromgridboxId = _data["fromgridboxId"];
            this.employeeId = _data["employeeId"];
            this.justification = _data["justification"];
        }
    }

    static fromJS(data: any): ManageMoveEmployeeFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageMoveEmployeeFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["togridboxId"] = this.togridboxId;
        data["fromgridboxId"] = this.fromgridboxId;
        data["employeeId"] = this.employeeId;
        data["justification"] = this.justification;
        return data; 
    }

    clone(): ManageMoveEmployeeFilterDTO {
        const json = this.toJSON();
        let result = new ManageMoveEmployeeFilterDTO();
        result.init(json);
        return result;
    }
}

export interface IManageMoveEmployeeFilterDTO {
    togridboxId: number;
    fromgridboxId: number;
    employeeId: number;
    justification: string | undefined;
}

export class NineGridBoxDTOListApiResult implements INineGridBoxDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: NineGridBoxDTO[] | undefined;
    totalCount!: number;

    constructor(data?: INineGridBoxDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(NineGridBoxDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): NineGridBoxDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new NineGridBoxDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): NineGridBoxDTOListApiResult {
        const json = this.toJSON();
        let result = new NineGridBoxDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface INineGridBoxDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: NineGridBoxDTO[] | undefined;
    totalCount: number;
}

export class GridBoxCountDTO implements IGridBoxCountDTO {
    gridboxId!: number;
    gridboxCount!: number;

    constructor(data?: IGridBoxCountDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gridboxId = _data["gridboxId"];
            this.gridboxCount = _data["gridboxCount"];
        }
    }

    static fromJS(data: any): GridBoxCountDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GridBoxCountDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gridboxId"] = this.gridboxId;
        data["gridboxCount"] = this.gridboxCount;
        return data; 
    }

    clone(): GridBoxCountDTO {
        const json = this.toJSON();
        let result = new GridBoxCountDTO();
        result.init(json);
        return result;
    }
}

export interface IGridBoxCountDTO {
    gridboxId: number;
    gridboxCount: number;
}

export class GridBoxCountDTOListApiResult implements IGridBoxCountDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: GridBoxCountDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IGridBoxCountDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GridBoxCountDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GridBoxCountDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GridBoxCountDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): GridBoxCountDTOListApiResult {
        const json = this.toJSON();
        let result = new GridBoxCountDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGridBoxCountDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: GridBoxCountDTO[] | undefined;
    totalCount: number;
}

export class EmployeeTalentPoolHistoryDTO implements IEmployeeTalentPoolHistoryDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    employeeTalentPoolId!: number;
    talentPoolId!: number;
    fromTalentPoolId!: number;
    employeeId!: number;
    comment!: string | undefined;
    employeePoints!: number;
    talentPoints!: number;
    recommendations!: string | undefined;
    actionType!: string | undefined;
    loggedByUserId!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IEmployeeTalentPoolHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.employeeTalentPoolId = _data["employeeTalentPoolId"];
            this.talentPoolId = _data["talentPoolId"];
            this.fromTalentPoolId = _data["fromTalentPoolId"];
            this.employeeId = _data["employeeId"];
            this.comment = _data["comment"];
            this.employeePoints = _data["employeePoints"];
            this.talentPoints = _data["talentPoints"];
            this.recommendations = _data["recommendations"];
            this.actionType = _data["actionType"];
            this.loggedByUserId = _data["loggedByUserId"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): EmployeeTalentPoolHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTalentPoolHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["employeeTalentPoolId"] = this.employeeTalentPoolId;
        data["talentPoolId"] = this.talentPoolId;
        data["fromTalentPoolId"] = this.fromTalentPoolId;
        data["employeeId"] = this.employeeId;
        data["comment"] = this.comment;
        data["employeePoints"] = this.employeePoints;
        data["talentPoints"] = this.talentPoints;
        data["recommendations"] = this.recommendations;
        data["actionType"] = this.actionType;
        data["loggedByUserId"] = this.loggedByUserId;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): EmployeeTalentPoolHistoryDTO {
        const json = this.toJSON();
        let result = new EmployeeTalentPoolHistoryDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeTalentPoolHistoryDTO {
    id: number;
    companyID: number;
    subID: number;
    employeeTalentPoolId: number;
    talentPoolId: number;
    fromTalentPoolId: number;
    employeeId: number;
    comment: string | undefined;
    employeePoints: number;
    talentPoints: number;
    recommendations: string | undefined;
    actionType: string | undefined;
    loggedByUserId: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class EmployeeTalentPoolDTO implements IEmployeeTalentPoolDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    talentPoolId!: number;
    talentPoolName!: string | undefined;
    employeeId!: number;
    comment!: string | undefined;
    employeePoints!: number;
    talentPoints!: number;
    recommendations!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    employeeTalentPoolHistory!: EmployeeTalentPoolHistoryDTO[] | undefined;

    constructor(data?: IEmployeeTalentPoolDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.talentPoolId = _data["talentPoolId"];
            this.talentPoolName = _data["talentPoolName"];
            this.employeeId = _data["employeeId"];
            this.comment = _data["comment"];
            this.employeePoints = _data["employeePoints"];
            this.talentPoints = _data["talentPoints"];
            this.recommendations = _data["recommendations"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["employeeTalentPoolHistory"])) {
                this.employeeTalentPoolHistory = [] as any;
                for (let item of _data["employeeTalentPoolHistory"])
                    this.employeeTalentPoolHistory!.push(EmployeeTalentPoolHistoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmployeeTalentPoolDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTalentPoolDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["talentPoolId"] = this.talentPoolId;
        data["talentPoolName"] = this.talentPoolName;
        data["employeeId"] = this.employeeId;
        data["comment"] = this.comment;
        data["employeePoints"] = this.employeePoints;
        data["talentPoints"] = this.talentPoints;
        data["recommendations"] = this.recommendations;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.employeeTalentPoolHistory)) {
            data["employeeTalentPoolHistory"] = [];
            for (let item of this.employeeTalentPoolHistory)
                data["employeeTalentPoolHistory"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EmployeeTalentPoolDTO {
        const json = this.toJSON();
        let result = new EmployeeTalentPoolDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeTalentPoolDTO {
    id: number;
    companyID: number;
    subID: number;
    talentPoolId: number;
    talentPoolName: string | undefined;
    employeeId: number;
    comment: string | undefined;
    employeePoints: number;
    talentPoints: number;
    recommendations: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    employeeTalentPoolHistory: EmployeeTalentPoolHistoryDTO[] | undefined;
}

export class SuccessorcompetencyDTO implements ISuccessorcompetencyDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    careerSuccessorId!: number;
    requirementCategory!: string;
    skillId!: number | undefined;
    skillName!: string | undefined;
    trainingId!: number | undefined;
    trainingName!: string | undefined;
    certificationId!: number | undefined;
    certificationName!: string | undefined;
    qualificationId!: number | undefined;
    qualificationName!: string | undefined;
    abilityId!: number | undefined;
    abilityName!: string | undefined;
    experience!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: ISuccessorcompetencyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.careerSuccessorId = _data["careerSuccessorId"];
            this.requirementCategory = _data["requirementCategory"];
            this.skillId = _data["skillId"];
            this.skillName = _data["skillName"];
            this.trainingId = _data["trainingId"];
            this.trainingName = _data["trainingName"];
            this.certificationId = _data["certificationId"];
            this.certificationName = _data["certificationName"];
            this.qualificationId = _data["qualificationId"];
            this.qualificationName = _data["qualificationName"];
            this.abilityId = _data["abilityId"];
            this.abilityName = _data["abilityName"];
            this.experience = _data["experience"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SuccessorcompetencyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SuccessorcompetencyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["careerSuccessorId"] = this.careerSuccessorId;
        data["requirementCategory"] = this.requirementCategory;
        data["skillId"] = this.skillId;
        data["skillName"] = this.skillName;
        data["trainingId"] = this.trainingId;
        data["trainingName"] = this.trainingName;
        data["certificationId"] = this.certificationId;
        data["certificationName"] = this.certificationName;
        data["qualificationId"] = this.qualificationId;
        data["qualificationName"] = this.qualificationName;
        data["abilityId"] = this.abilityId;
        data["abilityName"] = this.abilityName;
        data["experience"] = this.experience;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): SuccessorcompetencyDTO {
        const json = this.toJSON();
        let result = new SuccessorcompetencyDTO();
        result.init(json);
        return result;
    }
}

export interface ISuccessorcompetencyDTO {
    id: number;
    companyID: number;
    subID: number;
    careerSuccessorId: number;
    requirementCategory: string;
    skillId: number | undefined;
    skillName: string | undefined;
    trainingId: number | undefined;
    trainingName: string | undefined;
    certificationId: number | undefined;
    certificationName: string | undefined;
    qualificationId: number | undefined;
    qualificationName: string | undefined;
    abilityId: number | undefined;
    abilityName: string | undefined;
    experience: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class CareerSuccessorDTO implements ICareerSuccessorDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    employeeId!: number;
    employeeName!: string | undefined;
    growthDuration!: number;
    currentPositionId!: number;
    currentPositionName!: string | undefined;
    currentJobPositionName!: string | undefined;
    targetPositionId!: number;
    positionHolderId!: number;
    positionHolderName!: string | undefined;
    comment!: string | undefined;
    careerSuccessionId!: number;
    isNotification!: boolean;
    successionCompetency!: SuccessorcompetencyDTO[] | undefined;
    successionAdditionalCompetency!: SuccessorcompetencyDTO[] | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: ICareerSuccessorDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.growthDuration = _data["growthDuration"];
            this.currentPositionId = _data["currentPositionId"];
            this.currentPositionName = _data["currentPositionName"];
            this.currentJobPositionName = _data["currentJobPositionName"];
            this.targetPositionId = _data["targetPositionId"];
            this.positionHolderId = _data["positionHolderId"];
            this.positionHolderName = _data["positionHolderName"];
            this.comment = _data["comment"];
            this.careerSuccessionId = _data["careerSuccessionId"];
            this.isNotification = _data["isNotification"];
            if (Array.isArray(_data["successionCompetency"])) {
                this.successionCompetency = [] as any;
                for (let item of _data["successionCompetency"])
                    this.successionCompetency!.push(SuccessorcompetencyDTO.fromJS(item));
            }
            if (Array.isArray(_data["successionAdditionalCompetency"])) {
                this.successionAdditionalCompetency = [] as any;
                for (let item of _data["successionAdditionalCompetency"])
                    this.successionAdditionalCompetency!.push(SuccessorcompetencyDTO.fromJS(item));
            }
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CareerSuccessorDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CareerSuccessorDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["growthDuration"] = this.growthDuration;
        data["currentPositionId"] = this.currentPositionId;
        data["currentPositionName"] = this.currentPositionName;
        data["currentJobPositionName"] = this.currentJobPositionName;
        data["targetPositionId"] = this.targetPositionId;
        data["positionHolderId"] = this.positionHolderId;
        data["positionHolderName"] = this.positionHolderName;
        data["comment"] = this.comment;
        data["careerSuccessionId"] = this.careerSuccessionId;
        data["isNotification"] = this.isNotification;
        if (Array.isArray(this.successionCompetency)) {
            data["successionCompetency"] = [];
            for (let item of this.successionCompetency)
                data["successionCompetency"].push(item.toJSON());
        }
        if (Array.isArray(this.successionAdditionalCompetency)) {
            data["successionAdditionalCompetency"] = [];
            for (let item of this.successionAdditionalCompetency)
                data["successionAdditionalCompetency"].push(item.toJSON());
        }
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CareerSuccessorDTO {
        const json = this.toJSON();
        let result = new CareerSuccessorDTO();
        result.init(json);
        return result;
    }
}

export interface ICareerSuccessorDTO {
    id: number;
    companyID: number;
    subID: number;
    employeeId: number;
    employeeName: string | undefined;
    growthDuration: number;
    currentPositionId: number;
    currentPositionName: string | undefined;
    currentJobPositionName: string | undefined;
    targetPositionId: number;
    positionHolderId: number;
    positionHolderName: string | undefined;
    comment: string | undefined;
    careerSuccessionId: number;
    isNotification: boolean;
    successionCompetency: SuccessorcompetencyDTO[] | undefined;
    successionAdditionalCompetency: SuccessorcompetencyDTO[] | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class CareerSuccessionDTO implements ICareerSuccessionDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    categoryType!: string;
    planJustification!: string;
    stringSuccessionEmployee!: string | undefined;
    successionEmployee!: CareerSuccessorDTO[] | undefined;
    holderId!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: ICareerSuccessionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.categoryType = _data["categoryType"];
            this.planJustification = _data["planJustification"];
            this.stringSuccessionEmployee = _data["stringSuccessionEmployee"];
            if (Array.isArray(_data["successionEmployee"])) {
                this.successionEmployee = [] as any;
                for (let item of _data["successionEmployee"])
                    this.successionEmployee!.push(CareerSuccessorDTO.fromJS(item));
            }
            this.holderId = _data["holderId"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CareerSuccessionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CareerSuccessionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["categoryType"] = this.categoryType;
        data["planJustification"] = this.planJustification;
        data["stringSuccessionEmployee"] = this.stringSuccessionEmployee;
        if (Array.isArray(this.successionEmployee)) {
            data["successionEmployee"] = [];
            for (let item of this.successionEmployee)
                data["successionEmployee"].push(item.toJSON());
        }
        data["holderId"] = this.holderId;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CareerSuccessionDTO {
        const json = this.toJSON();
        let result = new CareerSuccessionDTO();
        result.init(json);
        return result;
    }
}

export interface ICareerSuccessionDTO {
    id: number;
    companyID: number;
    subID: number;
    categoryType: string;
    planJustification: string;
    stringSuccessionEmployee: string | undefined;
    successionEmployee: CareerSuccessorDTO[] | undefined;
    holderId: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class TalentpoolrequirementDTO implements ITalentpoolrequirementDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    requirementCategory!: string;
    skillId!: number | undefined;
    skillName!: string | undefined;
    trainingId!: number | undefined;
    trainingName!: string | undefined;
    certificationId!: number | undefined;
    certificationName!: string | undefined;
    qualificationId!: number | undefined;
    qualificationName!: string | undefined;
    abilityId!: number | undefined;
    abilityName!: string | undefined;
    experience!: string | undefined;
    yearsofExperience!: number;
    experienceWeight!: number | undefined;
    skillWeight!: number | undefined;
    points!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: ITalentpoolrequirementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.requirementCategory = _data["requirementCategory"];
            this.skillId = _data["skillId"];
            this.skillName = _data["skillName"];
            this.trainingId = _data["trainingId"];
            this.trainingName = _data["trainingName"];
            this.certificationId = _data["certificationId"];
            this.certificationName = _data["certificationName"];
            this.qualificationId = _data["qualificationId"];
            this.qualificationName = _data["qualificationName"];
            this.abilityId = _data["abilityId"];
            this.abilityName = _data["abilityName"];
            this.experience = _data["experience"];
            this.yearsofExperience = _data["yearsofExperience"];
            this.experienceWeight = _data["experienceWeight"];
            this.skillWeight = _data["skillWeight"];
            this.points = _data["points"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TalentpoolrequirementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TalentpoolrequirementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["requirementCategory"] = this.requirementCategory;
        data["skillId"] = this.skillId;
        data["skillName"] = this.skillName;
        data["trainingId"] = this.trainingId;
        data["trainingName"] = this.trainingName;
        data["certificationId"] = this.certificationId;
        data["certificationName"] = this.certificationName;
        data["qualificationId"] = this.qualificationId;
        data["qualificationName"] = this.qualificationName;
        data["abilityId"] = this.abilityId;
        data["abilityName"] = this.abilityName;
        data["experience"] = this.experience;
        data["yearsofExperience"] = this.yearsofExperience;
        data["experienceWeight"] = this.experienceWeight;
        data["skillWeight"] = this.skillWeight;
        data["points"] = this.points;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): TalentpoolrequirementDTO {
        const json = this.toJSON();
        let result = new TalentpoolrequirementDTO();
        result.init(json);
        return result;
    }
}

export interface ITalentpoolrequirementDTO {
    id: number;
    companyID: number;
    subID: number;
    requirementCategory: string;
    skillId: number | undefined;
    skillName: string | undefined;
    trainingId: number | undefined;
    trainingName: string | undefined;
    certificationId: number | undefined;
    certificationName: string | undefined;
    qualificationId: number | undefined;
    qualificationName: string | undefined;
    abilityId: number | undefined;
    abilityName: string | undefined;
    experience: string | undefined;
    yearsofExperience: number;
    experienceWeight: number | undefined;
    skillWeight: number | undefined;
    points: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AddTalentPoolDTO implements IAddTalentPoolDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    talentPoolName!: string;
    employeeCount!: number;
    description!: string;
    loggedByUserId!: number;
    loggedByUserName!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    stringtalentPoolRequirement!: string | undefined;
    talentPoolRequirement!: TalentpoolrequirementDTO[] | undefined;

    constructor(data?: IAddTalentPoolDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.talentPoolName = _data["talentPoolName"];
            this.employeeCount = _data["employeeCount"];
            this.description = _data["description"];
            this.loggedByUserId = _data["loggedByUserId"];
            this.loggedByUserName = _data["loggedByUserName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.stringtalentPoolRequirement = _data["stringtalentPoolRequirement"];
            if (Array.isArray(_data["talentPoolRequirement"])) {
                this.talentPoolRequirement = [] as any;
                for (let item of _data["talentPoolRequirement"])
                    this.talentPoolRequirement!.push(TalentpoolrequirementDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddTalentPoolDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AddTalentPoolDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["talentPoolName"] = this.talentPoolName;
        data["employeeCount"] = this.employeeCount;
        data["description"] = this.description;
        data["loggedByUserId"] = this.loggedByUserId;
        data["loggedByUserName"] = this.loggedByUserName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["stringtalentPoolRequirement"] = this.stringtalentPoolRequirement;
        if (Array.isArray(this.talentPoolRequirement)) {
            data["talentPoolRequirement"] = [];
            for (let item of this.talentPoolRequirement)
                data["talentPoolRequirement"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AddTalentPoolDTO {
        const json = this.toJSON();
        let result = new AddTalentPoolDTO();
        result.init(json);
        return result;
    }
}

export interface IAddTalentPoolDTO {
    id: number;
    companyID: number;
    subID: number;
    talentPoolName: string;
    employeeCount: number;
    description: string;
    loggedByUserId: number;
    loggedByUserName: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    stringtalentPoolRequirement: string | undefined;
    talentPoolRequirement: TalentpoolrequirementDTO[] | undefined;
}

export class AddTalentPoolDTOListApiResult implements IAddTalentPoolDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AddTalentPoolDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAddTalentPoolDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AddTalentPoolDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AddTalentPoolDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AddTalentPoolDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AddTalentPoolDTOListApiResult {
        const json = this.toJSON();
        let result = new AddTalentPoolDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAddTalentPoolDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AddTalentPoolDTO[] | undefined;
    totalCount: number;
}

export class PayslipCategory implements IPayslipCategory {
    name!: string | undefined;
    elements!: Element[] | undefined;
    id!: number;
    company_id!: number;
    sub_id!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    row_version!: string | undefined;

    constructor(data?: IPayslipCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["elements"])) {
                this.elements = [] as any;
                for (let item of _data["elements"])
                    this.elements!.push(Element.fromJS(item));
            }
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            this.row_version = _data["row_version"];
        }
    }

    static fromJS(data: any): PayslipCategory {
        data = typeof data === 'object' ? data : {};
        let result = new PayslipCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.elements)) {
            data["elements"] = [];
            for (let item of this.elements)
                data["elements"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        data["row_version"] = this.row_version;
        return data; 
    }

    clone(): PayslipCategory {
        const json = this.toJSON();
        let result = new PayslipCategory();
        result.init(json);
        return result;
    }
}

export interface IPayslipCategory {
    name: string | undefined;
    elements: Element[] | undefined;
    id: number;
    company_id: number;
    sub_id: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    row_version: string | undefined;
}

export class ElementClassification implements IElementClassification {
    name!: string | undefined;
    type!: string | undefined;
    priority_id!: number;
    is_earning!: boolean;
    is_tax_relief!: boolean;
    elements!: Element[] | undefined;
    id!: number;
    company_id!: number;
    sub_id!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    row_version!: string | undefined;

    constructor(data?: IElementClassification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.priority_id = _data["priority_id"];
            this.is_earning = _data["is_earning"];
            this.is_tax_relief = _data["is_tax_relief"];
            if (Array.isArray(_data["elements"])) {
                this.elements = [] as any;
                for (let item of _data["elements"])
                    this.elements!.push(Element.fromJS(item));
            }
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            this.row_version = _data["row_version"];
        }
    }

    static fromJS(data: any): ElementClassification {
        data = typeof data === 'object' ? data : {};
        let result = new ElementClassification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["priority_id"] = this.priority_id;
        data["is_earning"] = this.is_earning;
        data["is_tax_relief"] = this.is_tax_relief;
        if (Array.isArray(this.elements)) {
            data["elements"] = [];
            for (let item of this.elements)
                data["elements"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        data["row_version"] = this.row_version;
        return data; 
    }

    clone(): ElementClassification {
        const json = this.toJSON();
        let result = new ElementClassification();
        result.init(json);
        return result;
    }
}

export interface IElementClassification {
    name: string | undefined;
    type: string | undefined;
    priority_id: number;
    is_earning: boolean;
    is_tax_relief: boolean;
    elements: Element[] | undefined;
    id: number;
    company_id: number;
    sub_id: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    row_version: string | undefined;
}

export class Element implements IElement {
    payrollItemId!: number;
    payTypeId!: number;
    paymentInstitutionId!: number;
    name!: string | undefined;
    proirity_id!: number;
    report_name!: string | undefined;
    description!: string | undefined;
    element_classification_id!: number;
    payslipCategoryId!: number;
    currency!: string | undefined;
    is_reoccuring!: boolean;
    is_variable!: boolean;
    is_system_default!: boolean;
    amount!: number | undefined;
    ratio!: number | undefined;
    isTaxDeduct!: boolean;
    taxPercentage!: number | undefined;
    hourlyPay!: number | undefined;
    noOfWorkHours!: number | undefined;
    short_text!: string | undefined;
    effective_start_date!: Date | undefined;
    termination_end_date!: Date | undefined;
    sys_Code!: string | undefined;
    paymentInstitution!: PaymentInstitution;
    payslipCategory!: PayslipCategory;
    elementClassification!: ElementClassification;
    id!: number;
    company_id!: number;
    sub_id!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    row_version!: string | undefined;

    constructor(data?: IElement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.payrollItemId = _data["payrollItemId"];
            this.payTypeId = _data["payTypeId"];
            this.paymentInstitutionId = _data["paymentInstitutionId"];
            this.name = _data["name"];
            this.proirity_id = _data["proirity_id"];
            this.report_name = _data["report_name"];
            this.description = _data["description"];
            this.element_classification_id = _data["element_classification_id"];
            this.payslipCategoryId = _data["payslipCategoryId"];
            this.currency = _data["currency"];
            this.is_reoccuring = _data["is_reoccuring"];
            this.is_variable = _data["is_variable"];
            this.is_system_default = _data["is_system_default"];
            this.amount = _data["amount"];
            this.ratio = _data["ratio"];
            this.isTaxDeduct = _data["isTaxDeduct"];
            this.taxPercentage = _data["taxPercentage"];
            this.hourlyPay = _data["hourlyPay"];
            this.noOfWorkHours = _data["noOfWorkHours"];
            this.short_text = _data["short_text"];
            this.effective_start_date = _data["effective_start_date"] ? new Date(_data["effective_start_date"].toString()) : <any>undefined;
            this.termination_end_date = _data["termination_end_date"] ? new Date(_data["termination_end_date"].toString()) : <any>undefined;
            this.sys_Code = _data["sys_Code"];
            this.paymentInstitution = _data["paymentInstitution"] ? PaymentInstitution.fromJS(_data["paymentInstitution"]) : <any>undefined;
            this.payslipCategory = _data["payslipCategory"] ? PayslipCategory.fromJS(_data["payslipCategory"]) : <any>undefined;
            this.elementClassification = _data["elementClassification"] ? ElementClassification.fromJS(_data["elementClassification"]) : <any>undefined;
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            this.row_version = _data["row_version"];
        }
    }

    static fromJS(data: any): Element {
        data = typeof data === 'object' ? data : {};
        let result = new Element();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payrollItemId"] = this.payrollItemId;
        data["payTypeId"] = this.payTypeId;
        data["paymentInstitutionId"] = this.paymentInstitutionId;
        data["name"] = this.name;
        data["proirity_id"] = this.proirity_id;
        data["report_name"] = this.report_name;
        data["description"] = this.description;
        data["element_classification_id"] = this.element_classification_id;
        data["payslipCategoryId"] = this.payslipCategoryId;
        data["currency"] = this.currency;
        data["is_reoccuring"] = this.is_reoccuring;
        data["is_variable"] = this.is_variable;
        data["is_system_default"] = this.is_system_default;
        data["amount"] = this.amount;
        data["ratio"] = this.ratio;
        data["isTaxDeduct"] = this.isTaxDeduct;
        data["taxPercentage"] = this.taxPercentage;
        data["hourlyPay"] = this.hourlyPay;
        data["noOfWorkHours"] = this.noOfWorkHours;
        data["short_text"] = this.short_text;
        data["effective_start_date"] = this.effective_start_date ? this.effective_start_date.toISOString() : <any>undefined;
        data["termination_end_date"] = this.termination_end_date ? this.termination_end_date.toISOString() : <any>undefined;
        data["sys_Code"] = this.sys_Code;
        data["paymentInstitution"] = this.paymentInstitution ? this.paymentInstitution.toJSON() : <any>undefined;
        data["payslipCategory"] = this.payslipCategory ? this.payslipCategory.toJSON() : <any>undefined;
        data["elementClassification"] = this.elementClassification ? this.elementClassification.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        data["row_version"] = this.row_version;
        return data; 
    }

    clone(): Element {
        const json = this.toJSON();
        let result = new Element();
        result.init(json);
        return result;
    }
}

export interface IElement {
    payrollItemId: number;
    payTypeId: number;
    paymentInstitutionId: number;
    name: string | undefined;
    proirity_id: number;
    report_name: string | undefined;
    description: string | undefined;
    element_classification_id: number;
    payslipCategoryId: number;
    currency: string | undefined;
    is_reoccuring: boolean;
    is_variable: boolean;
    is_system_default: boolean;
    amount: number | undefined;
    ratio: number | undefined;
    isTaxDeduct: boolean;
    taxPercentage: number | undefined;
    hourlyPay: number | undefined;
    noOfWorkHours: number | undefined;
    short_text: string | undefined;
    effective_start_date: Date | undefined;
    termination_end_date: Date | undefined;
    sys_Code: string | undefined;
    paymentInstitution: PaymentInstitution;
    payslipCategory: PayslipCategory;
    elementClassification: ElementClassification;
    id: number;
    company_id: number;
    sub_id: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    row_version: string | undefined;
}

export class PaymentInstitution implements IPaymentInstitution {
    categoryId!: number;
    name!: string | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    bankId!: number;
    elements!: Element[] | undefined;
    id!: number;
    company_id!: number;
    sub_id!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    row_version!: string | undefined;

    constructor(data?: IPaymentInstitution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.accountName = _data["accountName"];
            this.accountNumber = _data["accountNumber"];
            this.bankId = _data["bankId"];
            if (Array.isArray(_data["elements"])) {
                this.elements = [] as any;
                for (let item of _data["elements"])
                    this.elements!.push(Element.fromJS(item));
            }
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            this.row_version = _data["row_version"];
        }
    }

    static fromJS(data: any): PaymentInstitution {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInstitution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["bankId"] = this.bankId;
        if (Array.isArray(this.elements)) {
            data["elements"] = [];
            for (let item of this.elements)
                data["elements"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        data["row_version"] = this.row_version;
        return data; 
    }

    clone(): PaymentInstitution {
        const json = this.toJSON();
        let result = new PaymentInstitution();
        result.init(json);
        return result;
    }
}

export interface IPaymentInstitution {
    categoryId: number;
    name: string | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    bankId: number;
    elements: Element[] | undefined;
    id: number;
    company_id: number;
    sub_id: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    row_version: string | undefined;
}

export class PaymentInstitutionIListApiResult implements IPaymentInstitutionIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PaymentInstitution[] | undefined;
    totalCount!: number;

    constructor(data?: IPaymentInstitutionIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PaymentInstitution.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PaymentInstitutionIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInstitutionIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PaymentInstitutionIListApiResult {
        const json = this.toJSON();
        let result = new PaymentInstitutionIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPaymentInstitutionIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PaymentInstitution[] | undefined;
    totalCount: number;
}

export class ElementIListApiResult implements IElementIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Element[] | undefined;
    totalCount!: number;

    constructor(data?: IElementIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Element.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ElementIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ElementIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ElementIListApiResult {
        const json = this.toJSON();
        let result = new ElementIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IElementIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Element[] | undefined;
    totalCount: number;
}

export class EmployeeContractAssignment implements IEmployeeContractAssignment {
    assignmentNumber!: string;
    employeeId!: number;
    supervisorId!: number | undefined;
    departmentId!: number | undefined;
    payRollTypeId!: number | undefined;
    jobId!: number | undefined;
    gradeId!: number | undefined;
    gradeStepId!: number | undefined;
    locationId!: number | undefined;
    positionId!: number | undefined;
    ministryId!: number | undefined;
    employmentTypeId!: number;
    contractEndDate!: Date | undefined;
    salaryScaleId!: number;
    dateofPresentAppointment!: Date;
    dateOfAppointment!: Date;
    dateOfLastDeployment!: Date | undefined;
    dateOfConversion!: Date | undefined;
    dateOfConfirmation!: Date | undefined;
    dateDeployed!: Date | undefined;
    datePromotion!: Date | undefined;
    dateOfRetirement!: Date | undefined;
    retirementTypeId!: number | undefined;
    isContractActive!: boolean;
    isDefaultContract!: boolean;
    noOfLeaveDays!: number | undefined;
    peopleGroupId!: number | undefined;
    lastPromotionDate!: Date | undefined;
    schoolId!: number | undefined;
    unitId!: number | undefined;
    cadreID!: number | undefined;
    directorateID!: number | undefined;
    lcdaID!: number | undefined;
    isOffPayrolled!: number | undefined;
    payrollType!: PayrollType;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeContractAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assignmentNumber = _data["assignmentNumber"];
            this.employeeId = _data["employeeId"];
            this.supervisorId = _data["supervisorId"];
            this.departmentId = _data["departmentId"];
            this.payRollTypeId = _data["payRollTypeId"];
            this.jobId = _data["jobId"];
            this.gradeId = _data["gradeId"];
            this.gradeStepId = _data["gradeStepId"];
            this.locationId = _data["locationId"];
            this.positionId = _data["positionId"];
            this.ministryId = _data["ministryId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.contractEndDate = _data["contractEndDate"] ? new Date(_data["contractEndDate"].toString()) : <any>undefined;
            this.salaryScaleId = _data["salaryScaleId"];
            this.dateofPresentAppointment = _data["dateofPresentAppointment"] ? new Date(_data["dateofPresentAppointment"].toString()) : <any>undefined;
            this.dateOfAppointment = _data["dateOfAppointment"] ? new Date(_data["dateOfAppointment"].toString()) : <any>undefined;
            this.dateOfLastDeployment = _data["dateOfLastDeployment"] ? new Date(_data["dateOfLastDeployment"].toString()) : <any>undefined;
            this.dateOfConversion = _data["dateOfConversion"] ? new Date(_data["dateOfConversion"].toString()) : <any>undefined;
            this.dateOfConfirmation = _data["dateOfConfirmation"] ? new Date(_data["dateOfConfirmation"].toString()) : <any>undefined;
            this.dateDeployed = _data["dateDeployed"] ? new Date(_data["dateDeployed"].toString()) : <any>undefined;
            this.datePromotion = _data["datePromotion"] ? new Date(_data["datePromotion"].toString()) : <any>undefined;
            this.dateOfRetirement = _data["dateOfRetirement"] ? new Date(_data["dateOfRetirement"].toString()) : <any>undefined;
            this.retirementTypeId = _data["retirementTypeId"];
            this.isContractActive = _data["isContractActive"];
            this.isDefaultContract = _data["isDefaultContract"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.peopleGroupId = _data["peopleGroupId"];
            this.lastPromotionDate = _data["lastPromotionDate"] ? new Date(_data["lastPromotionDate"].toString()) : <any>undefined;
            this.schoolId = _data["schoolId"];
            this.unitId = _data["unitId"];
            this.cadreID = _data["cadreID"];
            this.directorateID = _data["directorateID"];
            this.lcdaID = _data["lcdaID"];
            this.isOffPayrolled = _data["isOffPayrolled"];
            this.payrollType = _data["payrollType"] ? PayrollType.fromJS(_data["payrollType"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeContractAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeContractAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assignmentNumber"] = this.assignmentNumber;
        data["employeeId"] = this.employeeId;
        data["supervisorId"] = this.supervisorId;
        data["departmentId"] = this.departmentId;
        data["payRollTypeId"] = this.payRollTypeId;
        data["jobId"] = this.jobId;
        data["gradeId"] = this.gradeId;
        data["gradeStepId"] = this.gradeStepId;
        data["locationId"] = this.locationId;
        data["positionId"] = this.positionId;
        data["ministryId"] = this.ministryId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["contractEndDate"] = this.contractEndDate ? this.contractEndDate.toISOString() : <any>undefined;
        data["salaryScaleId"] = this.salaryScaleId;
        data["dateofPresentAppointment"] = this.dateofPresentAppointment ? this.dateofPresentAppointment.toISOString() : <any>undefined;
        data["dateOfAppointment"] = this.dateOfAppointment ? this.dateOfAppointment.toISOString() : <any>undefined;
        data["dateOfLastDeployment"] = this.dateOfLastDeployment ? this.dateOfLastDeployment.toISOString() : <any>undefined;
        data["dateOfConversion"] = this.dateOfConversion ? this.dateOfConversion.toISOString() : <any>undefined;
        data["dateOfConfirmation"] = this.dateOfConfirmation ? this.dateOfConfirmation.toISOString() : <any>undefined;
        data["dateDeployed"] = this.dateDeployed ? this.dateDeployed.toISOString() : <any>undefined;
        data["datePromotion"] = this.datePromotion ? this.datePromotion.toISOString() : <any>undefined;
        data["dateOfRetirement"] = this.dateOfRetirement ? this.dateOfRetirement.toISOString() : <any>undefined;
        data["retirementTypeId"] = this.retirementTypeId;
        data["isContractActive"] = this.isContractActive;
        data["isDefaultContract"] = this.isDefaultContract;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["peopleGroupId"] = this.peopleGroupId;
        data["lastPromotionDate"] = this.lastPromotionDate ? this.lastPromotionDate.toISOString() : <any>undefined;
        data["schoolId"] = this.schoolId;
        data["unitId"] = this.unitId;
        data["cadreID"] = this.cadreID;
        data["directorateID"] = this.directorateID;
        data["lcdaID"] = this.lcdaID;
        data["isOffPayrolled"] = this.isOffPayrolled;
        data["payrollType"] = this.payrollType ? this.payrollType.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeContractAssignment {
        const json = this.toJSON();
        let result = new EmployeeContractAssignment();
        result.init(json);
        return result;
    }
}

export interface IEmployeeContractAssignment {
    assignmentNumber: string;
    employeeId: number;
    supervisorId: number | undefined;
    departmentId: number | undefined;
    payRollTypeId: number | undefined;
    jobId: number | undefined;
    gradeId: number | undefined;
    gradeStepId: number | undefined;
    locationId: number | undefined;
    positionId: number | undefined;
    ministryId: number | undefined;
    employmentTypeId: number;
    contractEndDate: Date | undefined;
    salaryScaleId: number;
    dateofPresentAppointment: Date;
    dateOfAppointment: Date;
    dateOfLastDeployment: Date | undefined;
    dateOfConversion: Date | undefined;
    dateOfConfirmation: Date | undefined;
    dateDeployed: Date | undefined;
    datePromotion: Date | undefined;
    dateOfRetirement: Date | undefined;
    retirementTypeId: number | undefined;
    isContractActive: boolean;
    isDefaultContract: boolean;
    noOfLeaveDays: number | undefined;
    peopleGroupId: number | undefined;
    lastPromotionDate: Date | undefined;
    schoolId: number | undefined;
    unitId: number | undefined;
    cadreID: number | undefined;
    directorateID: number | undefined;
    lcdaID: number | undefined;
    isOffPayrolled: number | undefined;
    payrollType: PayrollType;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class FrequencyRuleMapping implements IFrequencyRuleMapping {
    frequencyRuleId!: number;
    payPeriodId!: number;
    frequencyRule!: FrequencyRule;
    id!: number;
    company_id!: number;
    sub_id!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    row_version!: string | undefined;

    constructor(data?: IFrequencyRuleMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.frequencyRuleId = _data["frequencyRuleId"];
            this.payPeriodId = _data["payPeriodId"];
            this.frequencyRule = _data["frequencyRule"] ? FrequencyRule.fromJS(_data["frequencyRule"]) : <any>undefined;
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            this.row_version = _data["row_version"];
        }
    }

    static fromJS(data: any): FrequencyRuleMapping {
        data = typeof data === 'object' ? data : {};
        let result = new FrequencyRuleMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["frequencyRuleId"] = this.frequencyRuleId;
        data["payPeriodId"] = this.payPeriodId;
        data["frequencyRule"] = this.frequencyRule ? this.frequencyRule.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        data["row_version"] = this.row_version;
        return data; 
    }

    clone(): FrequencyRuleMapping {
        const json = this.toJSON();
        let result = new FrequencyRuleMapping();
        result.init(json);
        return result;
    }
}

export interface IFrequencyRuleMapping {
    frequencyRuleId: number;
    payPeriodId: number;
    frequencyRule: FrequencyRule;
    id: number;
    company_id: number;
    sub_id: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    row_version: string | undefined;
}

export class FrequencyRule implements IFrequencyRule {
    name!: string | undefined;
    type!: number;
    payrollTypes!: PayrollType[] | undefined;
    frequencyRuleMappings!: FrequencyRuleMapping[] | undefined;
    id!: number;
    company_id!: number;
    sub_id!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    row_version!: string | undefined;

    constructor(data?: IFrequencyRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            if (Array.isArray(_data["payrollTypes"])) {
                this.payrollTypes = [] as any;
                for (let item of _data["payrollTypes"])
                    this.payrollTypes!.push(PayrollType.fromJS(item));
            }
            if (Array.isArray(_data["frequencyRuleMappings"])) {
                this.frequencyRuleMappings = [] as any;
                for (let item of _data["frequencyRuleMappings"])
                    this.frequencyRuleMappings!.push(FrequencyRuleMapping.fromJS(item));
            }
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            this.row_version = _data["row_version"];
        }
    }

    static fromJS(data: any): FrequencyRule {
        data = typeof data === 'object' ? data : {};
        let result = new FrequencyRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        if (Array.isArray(this.payrollTypes)) {
            data["payrollTypes"] = [];
            for (let item of this.payrollTypes)
                data["payrollTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.frequencyRuleMappings)) {
            data["frequencyRuleMappings"] = [];
            for (let item of this.frequencyRuleMappings)
                data["frequencyRuleMappings"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        data["row_version"] = this.row_version;
        return data; 
    }

    clone(): FrequencyRule {
        const json = this.toJSON();
        let result = new FrequencyRule();
        result.init(json);
        return result;
    }
}

export interface IFrequencyRule {
    name: string | undefined;
    type: number;
    payrollTypes: PayrollType[] | undefined;
    frequencyRuleMappings: FrequencyRuleMapping[] | undefined;
    id: number;
    company_id: number;
    sub_id: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    row_version: string | undefined;
}

export class PayrollType implements IPayrollType {
    name!: string | undefined;
    frequencyRuleId!: number;
    firstPeriodEndDate!: Date;
    strFirstPeriodEndDate!: string | undefined;
    noOfYears!: number;
    effectiveDate!: Date;
    strEffectiveDate!: string | undefined;
    payslipDate_Offset!: number;
    scheduleRunDate_Offset!: number;
    negativePaymentAllowed!: boolean;
    code!: string | undefined;
    employees!: EmployeeContractAssignment[] | undefined;
    frequencyRule!: FrequencyRule;
    id!: number;
    company_id!: number;
    sub_id!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    row_version!: string | undefined;

    constructor(data?: IPayrollType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.frequencyRuleId = _data["frequencyRuleId"];
            this.firstPeriodEndDate = _data["firstPeriodEndDate"] ? new Date(_data["firstPeriodEndDate"].toString()) : <any>undefined;
            this.strFirstPeriodEndDate = _data["strFirstPeriodEndDate"];
            this.noOfYears = _data["noOfYears"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.strEffectiveDate = _data["strEffectiveDate"];
            this.payslipDate_Offset = _data["payslipDate_Offset"];
            this.scheduleRunDate_Offset = _data["scheduleRunDate_Offset"];
            this.negativePaymentAllowed = _data["negativePaymentAllowed"];
            this.code = _data["code"];
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(EmployeeContractAssignment.fromJS(item));
            }
            this.frequencyRule = _data["frequencyRule"] ? FrequencyRule.fromJS(_data["frequencyRule"]) : <any>undefined;
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            this.row_version = _data["row_version"];
        }
    }

    static fromJS(data: any): PayrollType {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["frequencyRuleId"] = this.frequencyRuleId;
        data["firstPeriodEndDate"] = this.firstPeriodEndDate ? this.firstPeriodEndDate.toISOString() : <any>undefined;
        data["strFirstPeriodEndDate"] = this.strFirstPeriodEndDate;
        data["noOfYears"] = this.noOfYears;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["strEffectiveDate"] = this.strEffectiveDate;
        data["payslipDate_Offset"] = this.payslipDate_Offset;
        data["scheduleRunDate_Offset"] = this.scheduleRunDate_Offset;
        data["negativePaymentAllowed"] = this.negativePaymentAllowed;
        data["code"] = this.code;
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        data["frequencyRule"] = this.frequencyRule ? this.frequencyRule.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        data["row_version"] = this.row_version;
        return data; 
    }

    clone(): PayrollType {
        const json = this.toJSON();
        let result = new PayrollType();
        result.init(json);
        return result;
    }
}

export interface IPayrollType {
    name: string | undefined;
    frequencyRuleId: number;
    firstPeriodEndDate: Date;
    strFirstPeriodEndDate: string | undefined;
    noOfYears: number;
    effectiveDate: Date;
    strEffectiveDate: string | undefined;
    payslipDate_Offset: number;
    scheduleRunDate_Offset: number;
    negativePaymentAllowed: boolean;
    code: string | undefined;
    employees: EmployeeContractAssignment[] | undefined;
    frequencyRule: FrequencyRule;
    id: number;
    company_id: number;
    sub_id: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    row_version: string | undefined;
}

export class PayrollTypeIListApiResult implements IPayrollTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayrollType[] | undefined;
    totalCount!: number;

    constructor(data?: IPayrollTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PayrollType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PayrollTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PayrollTypeIListApiResult {
        const json = this.toJSON();
        let result = new PayrollTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayrollTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayrollType[] | undefined;
    totalCount: number;
}

export class FrequencyRuleIListApiResult implements IFrequencyRuleIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: FrequencyRule[] | undefined;
    totalCount!: number;

    constructor(data?: IFrequencyRuleIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(FrequencyRule.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FrequencyRuleIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new FrequencyRuleIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): FrequencyRuleIListApiResult {
        const json = this.toJSON();
        let result = new FrequencyRuleIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IFrequencyRuleIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: FrequencyRule[] | undefined;
    totalCount: number;
}

export class TenantBeneficiary implements ITenantBeneficiary {
    accountNo!: string | undefined;
    accountName!: string | undefined;
    bankId!: number;
    bankName!: string | undefined;
    bankCode!: string | undefined;
    initiatedById!: number;
    initiatedBy!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ITenantBeneficiary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountNo = _data["accountNo"];
            this.accountName = _data["accountName"];
            this.bankId = _data["bankId"];
            this.bankName = _data["bankName"];
            this.bankCode = _data["bankCode"];
            this.initiatedById = _data["initiatedById"];
            this.initiatedBy = _data["initiatedBy"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): TenantBeneficiary {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBeneficiary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountNo"] = this.accountNo;
        data["accountName"] = this.accountName;
        data["bankId"] = this.bankId;
        data["bankName"] = this.bankName;
        data["bankCode"] = this.bankCode;
        data["initiatedById"] = this.initiatedById;
        data["initiatedBy"] = this.initiatedBy;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): TenantBeneficiary {
        const json = this.toJSON();
        let result = new TenantBeneficiary();
        result.init(json);
        return result;
    }
}

export interface ITenantBeneficiary {
    accountNo: string | undefined;
    accountName: string | undefined;
    bankId: number;
    bankName: string | undefined;
    bankCode: string | undefined;
    initiatedById: number;
    initiatedBy: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class TenantBeneficiaryIListApiResult implements ITenantBeneficiaryIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TenantBeneficiary[] | undefined;
    totalCount!: number;

    constructor(data?: ITenantBeneficiaryIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TenantBeneficiary.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TenantBeneficiaryIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBeneficiaryIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TenantBeneficiaryIListApiResult {
        const json = this.toJSON();
        let result = new TenantBeneficiaryIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITenantBeneficiaryIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TenantBeneficiary[] | undefined;
    totalCount: number;
}

export class DeploymentLog implements IDeploymentLog {
    employeeContractid!: number;
    refNo!: string | undefined;
    comment!: string;
    request_by!: string | undefined;
    is_new!: boolean;
    last_deployment_date!: Date | undefined;
    current_location_id!: number;
    current_school_id!: number | undefined;
    current_ministry_id!: number | undefined;
    requested_location_id!: number;
    requested_school_id!: number | undefined;
    requested_ministry_id!: number | undefined;
    log_status!: number;
    bulkaction_id!: number | undefined;
    request_date!: Date;
    effective_date!: Date | undefined;
    is_treated!: boolean | undefined;
    fileName!: string | undefined;
    filePath!: string | undefined;
    location!: Location;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDeploymentLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeContractid = _data["employeeContractid"];
            this.refNo = _data["refNo"];
            this.comment = _data["comment"];
            this.request_by = _data["request_by"];
            this.is_new = _data["is_new"];
            this.last_deployment_date = _data["last_deployment_date"] ? new Date(_data["last_deployment_date"].toString()) : <any>undefined;
            this.current_location_id = _data["current_location_id"];
            this.current_school_id = _data["current_school_id"];
            this.current_ministry_id = _data["current_ministry_id"];
            this.requested_location_id = _data["requested_location_id"];
            this.requested_school_id = _data["requested_school_id"];
            this.requested_ministry_id = _data["requested_ministry_id"];
            this.log_status = _data["log_status"];
            this.bulkaction_id = _data["bulkaction_id"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.effective_date = _data["effective_date"] ? new Date(_data["effective_date"].toString()) : <any>undefined;
            this.is_treated = _data["is_treated"];
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DeploymentLog {
        data = typeof data === 'object' ? data : {};
        let result = new DeploymentLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeContractid"] = this.employeeContractid;
        data["refNo"] = this.refNo;
        data["comment"] = this.comment;
        data["request_by"] = this.request_by;
        data["is_new"] = this.is_new;
        data["last_deployment_date"] = this.last_deployment_date ? this.last_deployment_date.toISOString() : <any>undefined;
        data["current_location_id"] = this.current_location_id;
        data["current_school_id"] = this.current_school_id;
        data["current_ministry_id"] = this.current_ministry_id;
        data["requested_location_id"] = this.requested_location_id;
        data["requested_school_id"] = this.requested_school_id;
        data["requested_ministry_id"] = this.requested_ministry_id;
        data["log_status"] = this.log_status;
        data["bulkaction_id"] = this.bulkaction_id;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["effective_date"] = this.effective_date ? this.effective_date.toISOString() : <any>undefined;
        data["is_treated"] = this.is_treated;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DeploymentLog {
        const json = this.toJSON();
        let result = new DeploymentLog();
        result.init(json);
        return result;
    }
}

export interface IDeploymentLog {
    employeeContractid: number;
    refNo: string | undefined;
    comment: string;
    request_by: string | undefined;
    is_new: boolean;
    last_deployment_date: Date | undefined;
    current_location_id: number;
    current_school_id: number | undefined;
    current_ministry_id: number | undefined;
    requested_location_id: number;
    requested_school_id: number | undefined;
    requested_ministry_id: number | undefined;
    log_status: number;
    bulkaction_id: number | undefined;
    request_date: Date;
    effective_date: Date | undefined;
    is_treated: boolean | undefined;
    fileName: string | undefined;
    filePath: string | undefined;
    location: Location;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Location implements ILocation {
    location_name!: string;
    lga_id!: number | undefined;
    state_id!: number | undefined;
    is_enabled!: boolean;
    deploymentLogs!: DeploymentLog[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location_name = _data["location_name"];
            this.lga_id = _data["lga_id"];
            this.state_id = _data["state_id"];
            this.is_enabled = _data["is_enabled"];
            if (Array.isArray(_data["deploymentLogs"])) {
                this.deploymentLogs = [] as any;
                for (let item of _data["deploymentLogs"])
                    this.deploymentLogs!.push(DeploymentLog.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location_name"] = this.location_name;
        data["lga_id"] = this.lga_id;
        data["state_id"] = this.state_id;
        data["is_enabled"] = this.is_enabled;
        if (Array.isArray(this.deploymentLogs)) {
            data["deploymentLogs"] = [];
            for (let item of this.deploymentLogs)
                data["deploymentLogs"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Location {
        const json = this.toJSON();
        let result = new Location();
        result.init(json);
        return result;
    }
}

export interface ILocation {
    location_name: string;
    lga_id: number | undefined;
    state_id: number | undefined;
    is_enabled: boolean;
    deploymentLogs: DeploymentLog[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LocationIListApiResult implements ILocationIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Location[] | undefined;
    totalCount!: number;

    constructor(data?: ILocationIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Location.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LocationIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LocationIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LocationIListApiResult {
        const json = this.toJSON();
        let result = new LocationIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILocationIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Location[] | undefined;
    totalCount: number;
}

export class DepartmentIListApiResult implements IDepartmentIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Department[] | undefined;
    totalCount!: number;

    constructor(data?: IDepartmentIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Department.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DepartmentIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DepartmentIListApiResult {
        const json = this.toJSON();
        let result = new DepartmentIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDepartmentIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Department[] | undefined;
    totalCount: number;
}

export class JobRole implements IJobRole {
    name!: string;
    code!: string | undefined;
    amount!: number | undefined;
    promotion_min_years!: number | undefined;
    next_job_role_id!: number | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    parent_id!: number | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IJobRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.amount = _data["amount"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.next_job_role_id = _data["next_job_role_id"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.parent_id = _data["parent_id"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): JobRole {
        data = typeof data === 'object' ? data : {};
        let result = new JobRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["amount"] = this.amount;
        data["promotion_min_years"] = this.promotion_min_years;
        data["next_job_role_id"] = this.next_job_role_id;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["parent_id"] = this.parent_id;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): JobRole {
        const json = this.toJSON();
        let result = new JobRole();
        result.init(json);
        return result;
    }
}

export interface IJobRole {
    name: string;
    code: string | undefined;
    amount: number | undefined;
    promotion_min_years: number | undefined;
    next_job_role_id: number | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    parent_id: number | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class JobRoleIListApiResult implements IJobRoleIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: JobRole[] | undefined;
    totalCount!: number;

    constructor(data?: IJobRoleIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(JobRole.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): JobRoleIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobRoleIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): JobRoleIListApiResult {
        const json = this.toJSON();
        let result = new JobRoleIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IJobRoleIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: JobRole[] | undefined;
    totalCount: number;
}

export class Event implements IEvent {
    eventTypeID!: number;
    title!: string | undefined;
    isSystem!: boolean;
    notify_Employee!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventTypeID = _data["eventTypeID"];
            this.title = _data["title"];
            this.isSystem = _data["isSystem"];
            this.notify_Employee = _data["notify_Employee"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Event {
        data = typeof data === 'object' ? data : {};
        let result = new Event();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventTypeID"] = this.eventTypeID;
        data["title"] = this.title;
        data["isSystem"] = this.isSystem;
        data["notify_Employee"] = this.notify_Employee;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Event {
        const json = this.toJSON();
        let result = new Event();
        result.init(json);
        return result;
    }
}

export interface IEvent {
    eventTypeID: number;
    title: string | undefined;
    isSystem: boolean;
    notify_Employee: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EventIListApiResult implements IEventIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Event[] | undefined;
    totalCount!: number;

    constructor(data?: IEventIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Event.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EventIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EventIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EventIListApiResult {
        const json = this.toJSON();
        let result = new EventIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEventIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Event[] | undefined;
    totalCount: number;
}

export class PositionRequirement implements IPositionRequirement {
    positionId!: number;
    requirementId!: number;
    requirementValue!: string | undefined;
    requirementTypeId!: number;
    requirementTypeName!: string | undefined;
    position!: Position;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IPositionRequirement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.positionId = _data["positionId"];
            this.requirementId = _data["requirementId"];
            this.requirementValue = _data["requirementValue"];
            this.requirementTypeId = _data["requirementTypeId"];
            this.requirementTypeName = _data["requirementTypeName"];
            this.position = _data["position"] ? Position.fromJS(_data["position"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): PositionRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new PositionRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["positionId"] = this.positionId;
        data["requirementId"] = this.requirementId;
        data["requirementValue"] = this.requirementValue;
        data["requirementTypeId"] = this.requirementTypeId;
        data["requirementTypeName"] = this.requirementTypeName;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): PositionRequirement {
        const json = this.toJSON();
        let result = new PositionRequirement();
        result.init(json);
        return result;
    }
}

export interface IPositionRequirement {
    positionId: number;
    requirementId: number;
    requirementValue: string | undefined;
    requirementTypeId: number;
    requirementTypeName: string | undefined;
    position: Position;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Position implements IPosition {
    title!: string | undefined;
    amount!: number | undefined;
    promotion_min_years!: number | undefined;
    min_years_experience!: number | undefined;
    min_years_experience_in_days!: number | undefined;
    promotion_min_in_days!: number;
    next_position_id!: number | undefined;
    description!: string | undefined;
    parent_id!: number | undefined;
    has_requirement!: boolean;
    positionRequirements!: PositionRequirement[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.amount = _data["amount"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.min_years_experience = _data["min_years_experience"];
            this.min_years_experience_in_days = _data["min_years_experience_in_days"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.next_position_id = _data["next_position_id"];
            this.description = _data["description"];
            this.parent_id = _data["parent_id"];
            this.has_requirement = _data["has_requirement"];
            if (Array.isArray(_data["positionRequirements"])) {
                this.positionRequirements = [] as any;
                for (let item of _data["positionRequirements"])
                    this.positionRequirements!.push(PositionRequirement.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Position {
        data = typeof data === 'object' ? data : {};
        let result = new Position();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["amount"] = this.amount;
        data["promotion_min_years"] = this.promotion_min_years;
        data["min_years_experience"] = this.min_years_experience;
        data["min_years_experience_in_days"] = this.min_years_experience_in_days;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["next_position_id"] = this.next_position_id;
        data["description"] = this.description;
        data["parent_id"] = this.parent_id;
        data["has_requirement"] = this.has_requirement;
        if (Array.isArray(this.positionRequirements)) {
            data["positionRequirements"] = [];
            for (let item of this.positionRequirements)
                data["positionRequirements"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Position {
        const json = this.toJSON();
        let result = new Position();
        result.init(json);
        return result;
    }
}

export interface IPosition {
    title: string | undefined;
    amount: number | undefined;
    promotion_min_years: number | undefined;
    min_years_experience: number | undefined;
    min_years_experience_in_days: number | undefined;
    promotion_min_in_days: number;
    next_position_id: number | undefined;
    description: string | undefined;
    parent_id: number | undefined;
    has_requirement: boolean;
    positionRequirements: PositionRequirement[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class PositionIListApiResult implements IPositionIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Position[] | undefined;
    totalCount!: number;

    constructor(data?: IPositionIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Position.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PositionIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PositionIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PositionIListApiResult {
        const json = this.toJSON();
        let result = new PositionIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPositionIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Position[] | undefined;
    totalCount: number;
}

export class SalaryScale implements ISalaryScale {
    code!: string | undefined;
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISalaryScale) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): SalaryScale {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryScale();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): SalaryScale {
        const json = this.toJSON();
        let result = new SalaryScale();
        result.init(json);
        return result;
    }
}

export interface ISalaryScale {
    code: string | undefined;
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class SalaryScaleIListApiResult implements ISalaryScaleIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SalaryScale[] | undefined;
    totalCount!: number;

    constructor(data?: ISalaryScaleIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SalaryScale.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SalaryScaleIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryScaleIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SalaryScaleIListApiResult {
        const json = this.toJSON();
        let result = new SalaryScaleIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISalaryScaleIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SalaryScale[] | undefined;
    totalCount: number;
}

export class Grade implements IGrade {
    name!: string;
    code!: string | undefined;
    created_by!: string | undefined;
    promotion_min_years!: number;
    promotion_min_in_days!: number | undefined;
    noOfLeaveDays!: number;
    salaryScaleId!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IGrade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Grade {
        data = typeof data === 'object' ? data : {};
        let result = new Grade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["promotion_min_years"] = this.promotion_min_years;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["salaryScaleId"] = this.salaryScaleId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Grade {
        const json = this.toJSON();
        let result = new Grade();
        result.init(json);
        return result;
    }
}

export interface IGrade {
    name: string;
    code: string | undefined;
    created_by: string | undefined;
    promotion_min_years: number;
    promotion_min_in_days: number | undefined;
    noOfLeaveDays: number;
    salaryScaleId: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class GradeIListApiResult implements IGradeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Grade[] | undefined;
    totalCount!: number;

    constructor(data?: IGradeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Grade.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GradeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): GradeIListApiResult {
        const json = this.toJSON();
        let result = new GradeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Grade[] | undefined;
    totalCount: number;
}

export class GradeStep implements IGradeStep {
    grade_id!: number;
    step_no!: number;
    name!: string;
    created_by!: string | undefined;
    promotion_min_years!: number | undefined;
    promotion_min_in_days!: number | undefined;
    ministry_id!: number | undefined;
    next_grade_step_id!: number | undefined;
    grade!: Grade;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IGradeStep) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grade_id = _data["grade_id"];
            this.step_no = _data["step_no"];
            this.name = _data["name"];
            this.created_by = _data["created_by"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.ministry_id = _data["ministry_id"];
            this.next_grade_step_id = _data["next_grade_step_id"];
            this.grade = _data["grade"] ? Grade.fromJS(_data["grade"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): GradeStep {
        data = typeof data === 'object' ? data : {};
        let result = new GradeStep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grade_id"] = this.grade_id;
        data["step_no"] = this.step_no;
        data["name"] = this.name;
        data["created_by"] = this.created_by;
        data["promotion_min_years"] = this.promotion_min_years;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["ministry_id"] = this.ministry_id;
        data["next_grade_step_id"] = this.next_grade_step_id;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): GradeStep {
        const json = this.toJSON();
        let result = new GradeStep();
        result.init(json);
        return result;
    }
}

export interface IGradeStep {
    grade_id: number;
    step_no: number;
    name: string;
    created_by: string | undefined;
    promotion_min_years: number | undefined;
    promotion_min_in_days: number | undefined;
    ministry_id: number | undefined;
    next_grade_step_id: number | undefined;
    grade: Grade;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class GradeStepIListApiResult implements IGradeStepIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: GradeStep[] | undefined;
    totalCount!: number;

    constructor(data?: IGradeStepIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GradeStep.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GradeStepIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeStepIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): GradeStepIListApiResult {
        const json = this.toJSON();
        let result = new GradeStepIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeStepIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: GradeStep[] | undefined;
    totalCount: number;
}

export class GradeLevelBenefit implements IGradeLevelBenefit {
    salaryScaleId!: number;
    gradeId!: number;
    gradeStepId!: number;
    benefitId!: number;
    amount!: number;
    salaryScaleName!: string | undefined;
    gradeName!: string | undefined;
    stepName!: string | undefined;
    benefitName!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IGradeLevelBenefit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salaryScaleId = _data["salaryScaleId"];
            this.gradeId = _data["gradeId"];
            this.gradeStepId = _data["gradeStepId"];
            this.benefitId = _data["benefitId"];
            this.amount = _data["amount"];
            this.salaryScaleName = _data["salaryScaleName"];
            this.gradeName = _data["gradeName"];
            this.stepName = _data["stepName"];
            this.benefitName = _data["benefitName"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): GradeLevelBenefit {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelBenefit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salaryScaleId"] = this.salaryScaleId;
        data["gradeId"] = this.gradeId;
        data["gradeStepId"] = this.gradeStepId;
        data["benefitId"] = this.benefitId;
        data["amount"] = this.amount;
        data["salaryScaleName"] = this.salaryScaleName;
        data["gradeName"] = this.gradeName;
        data["stepName"] = this.stepName;
        data["benefitName"] = this.benefitName;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): GradeLevelBenefit {
        const json = this.toJSON();
        let result = new GradeLevelBenefit();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelBenefit {
    salaryScaleId: number;
    gradeId: number;
    gradeStepId: number;
    benefitId: number;
    amount: number;
    salaryScaleName: string | undefined;
    gradeName: string | undefined;
    stepName: string | undefined;
    benefitName: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class GradeLevelBenefitIListApiResult implements IGradeLevelBenefitIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: GradeLevelBenefit[] | undefined;
    totalCount!: number;

    constructor(data?: IGradeLevelBenefitIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GradeLevelBenefit.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GradeLevelBenefitIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelBenefitIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): GradeLevelBenefitIListApiResult {
        const json = this.toJSON();
        let result = new GradeLevelBenefitIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelBenefitIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: GradeLevelBenefit[] | undefined;
    totalCount: number;
}

export class RequestType implements IRequestType {
    name!: string;
    typeId!: string | undefined;
    approval!: string | undefined;
    processid!: number;
    code!: string | undefined;
    enable_step_notify!: boolean;
    is_system_requirement!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRequestType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.approval = _data["approval"];
            this.processid = _data["processid"];
            this.code = _data["code"];
            this.enable_step_notify = _data["enable_step_notify"];
            this.is_system_requirement = _data["is_system_requirement"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RequestType {
        data = typeof data === 'object' ? data : {};
        let result = new RequestType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["approval"] = this.approval;
        data["processid"] = this.processid;
        data["code"] = this.code;
        data["enable_step_notify"] = this.enable_step_notify;
        data["is_system_requirement"] = this.is_system_requirement;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RequestType {
        const json = this.toJSON();
        let result = new RequestType();
        result.init(json);
        return result;
    }
}

export interface IRequestType {
    name: string;
    typeId: string | undefined;
    approval: string | undefined;
    processid: number;
    code: string | undefined;
    enable_step_notify: boolean;
    is_system_requirement: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RequestTypeIListApiResult implements IRequestTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestType[] | undefined;
    totalCount!: number;

    constructor(data?: IRequestTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RequestType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RequestTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RequestTypeIListApiResult {
        const json = this.toJSON();
        let result = new RequestTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestType[] | undefined;
    totalCount: number;
}

export class Skill implements ISkill {
    sectorId!: number;
    name!: string | undefined;
    point!: number | undefined;
    employeeSkills!: EmployeeSkill[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISkill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sectorId = _data["sectorId"];
            this.name = _data["name"];
            this.point = _data["point"];
            if (Array.isArray(_data["employeeSkills"])) {
                this.employeeSkills = [] as any;
                for (let item of _data["employeeSkills"])
                    this.employeeSkills!.push(EmployeeSkill.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Skill {
        data = typeof data === 'object' ? data : {};
        let result = new Skill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectorId"] = this.sectorId;
        data["name"] = this.name;
        data["point"] = this.point;
        if (Array.isArray(this.employeeSkills)) {
            data["employeeSkills"] = [];
            for (let item of this.employeeSkills)
                data["employeeSkills"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Skill {
        const json = this.toJSON();
        let result = new Skill();
        result.init(json);
        return result;
    }
}

export interface ISkill {
    sectorId: number;
    name: string | undefined;
    point: number | undefined;
    employeeSkills: EmployeeSkill[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeSkill implements IEmployeeSkill {
    employeeId!: number;
    skillId!: number;
    skillName!: string | undefined;
    startDate!: Date | undefined;
    numberOfExperienceInMonth!: number | undefined;
    point!: number | undefined;
    employee!: Employee;
    skill!: Skill;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeSkill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.skillId = _data["skillId"];
            this.skillName = _data["skillName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.numberOfExperienceInMonth = _data["numberOfExperienceInMonth"];
            this.point = _data["point"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.skill = _data["skill"] ? Skill.fromJS(_data["skill"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeSkill {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeSkill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["skillId"] = this.skillId;
        data["skillName"] = this.skillName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["numberOfExperienceInMonth"] = this.numberOfExperienceInMonth;
        data["point"] = this.point;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["skill"] = this.skill ? this.skill.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeSkill {
        const json = this.toJSON();
        let result = new EmployeeSkill();
        result.init(json);
        return result;
    }
}

export interface IEmployeeSkill {
    employeeId: number;
    skillId: number;
    skillName: string | undefined;
    startDate: Date | undefined;
    numberOfExperienceInMonth: number | undefined;
    point: number | undefined;
    employee: Employee;
    skill: Skill;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Course implements ICourse {
    name!: string | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Course {
        const json = this.toJSON();
        let result = new Course();
        result.init(json);
        return result;
    }
}

export interface ICourse {
    name: string | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class QualificationGrade implements IQualificationGrade {
    name!: string | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IQualificationGrade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): QualificationGrade {
        data = typeof data === 'object' ? data : {};
        let result = new QualificationGrade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): QualificationGrade {
        const json = this.toJSON();
        let result = new QualificationGrade();
        result.init(json);
        return result;
    }
}

export interface IQualificationGrade {
    name: string | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Qualification implements IQualification {
    categoryId!: number;
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IQualification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Qualification {
        data = typeof data === 'object' ? data : {};
        let result = new Qualification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Qualification {
        const json = this.toJSON();
        let result = new Qualification();
        result.init(json);
        return result;
    }
}

export interface IQualification {
    categoryId: number;
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeQualification implements IEmployeeQualification {
    employeeId!: number;
    name!: string;
    type!: string;
    qualificationId!: number;
    qualificationGradeId!: number;
    courseId!: number;
    courseName!: string | undefined;
    institution!: string | undefined;
    grade!: string | undefined;
    startdate!: Date | undefined;
    stopdate!: Date | undefined;
    comment!: string | undefined;
    is_professional!: number | undefined;
    employee!: Employee;
    course!: Course;
    qualificationGrade!: QualificationGrade;
    qualification!: Qualification;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeQualification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.qualificationId = _data["qualificationId"];
            this.qualificationGradeId = _data["qualificationGradeId"];
            this.courseId = _data["courseId"];
            this.courseName = _data["courseName"];
            this.institution = _data["institution"];
            this.grade = _data["grade"];
            this.startdate = _data["startdate"] ? new Date(_data["startdate"].toString()) : <any>undefined;
            this.stopdate = _data["stopdate"] ? new Date(_data["stopdate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.is_professional = _data["is_professional"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.qualificationGrade = _data["qualificationGrade"] ? QualificationGrade.fromJS(_data["qualificationGrade"]) : <any>undefined;
            this.qualification = _data["qualification"] ? Qualification.fromJS(_data["qualification"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeQualification {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeQualification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["qualificationId"] = this.qualificationId;
        data["qualificationGradeId"] = this.qualificationGradeId;
        data["courseId"] = this.courseId;
        data["courseName"] = this.courseName;
        data["institution"] = this.institution;
        data["grade"] = this.grade;
        data["startdate"] = this.startdate ? this.startdate.toISOString() : <any>undefined;
        data["stopdate"] = this.stopdate ? this.stopdate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["is_professional"] = this.is_professional;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["qualificationGrade"] = this.qualificationGrade ? this.qualificationGrade.toJSON() : <any>undefined;
        data["qualification"] = this.qualification ? this.qualification.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeQualification {
        const json = this.toJSON();
        let result = new EmployeeQualification();
        result.init(json);
        return result;
    }
}

export interface IEmployeeQualification {
    employeeId: number;
    name: string;
    type: string;
    qualificationId: number;
    qualificationGradeId: number;
    courseId: number;
    courseName: string | undefined;
    institution: string | undefined;
    grade: string | undefined;
    startdate: Date | undefined;
    stopdate: Date | undefined;
    comment: string | undefined;
    is_professional: number | undefined;
    employee: Employee;
    course: Course;
    qualificationGrade: QualificationGrade;
    qualification: Qualification;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Certification implements ICertification {
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    completionDate!: Date | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            this.completionDate = _data["completionDate"] ? new Date(_data["completionDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Certification {
        data = typeof data === 'object' ? data : {};
        let result = new Certification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        data["completionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Certification {
        const json = this.toJSON();
        let result = new Certification();
        result.init(json);
        return result;
    }
}

export interface ICertification {
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    completionDate: Date | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeCertification implements IEmployeeCertification {
    employeeId!: number;
    certificationId!: number;
    institution!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    comment!: string | undefined;
    numberOfExperienceInMonth!: number | undefined;
    certification!: Certification;
    employee!: Employee;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeCertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.certificationId = _data["certificationId"];
            this.institution = _data["institution"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.numberOfExperienceInMonth = _data["numberOfExperienceInMonth"];
            this.certification = _data["certification"] ? Certification.fromJS(_data["certification"]) : <any>undefined;
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeCertification {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeCertification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["certificationId"] = this.certificationId;
        data["institution"] = this.institution;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["numberOfExperienceInMonth"] = this.numberOfExperienceInMonth;
        data["certification"] = this.certification ? this.certification.toJSON() : <any>undefined;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeCertification {
        const json = this.toJSON();
        let result = new EmployeeCertification();
        result.init(json);
        return result;
    }
}

export interface IEmployeeCertification {
    employeeId: number;
    certificationId: number;
    institution: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    comment: string | undefined;
    numberOfExperienceInMonth: number | undefined;
    certification: Certification;
    employee: Employee;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class State implements IState {
    country_id!: number;
    state_name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.country_id = _data["country_id"];
            this.state_name = _data["state_name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): State {
        data = typeof data === 'object' ? data : {};
        let result = new State();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country_id"] = this.country_id;
        data["state_name"] = this.state_name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): State {
        const json = this.toJSON();
        let result = new State();
        result.init(json);
        return result;
    }
}

export interface IState {
    country_id: number;
    state_name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LGA implements ILGA {
    state_id!: number | undefined;
    lga_name!: string | undefined;
    directorate_id!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILGA) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state_id = _data["state_id"];
            this.lga_name = _data["lga_name"];
            this.directorate_id = _data["directorate_id"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LGA {
        data = typeof data === 'object' ? data : {};
        let result = new LGA();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state_id"] = this.state_id;
        data["lga_name"] = this.lga_name;
        data["directorate_id"] = this.directorate_id;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LGA {
        const json = this.toJSON();
        let result = new LGA();
        result.init(json);
        return result;
    }
}

export interface ILGA {
    state_id: number | undefined;
    lga_name: string | undefined;
    directorate_id: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Address implements IAddress {
    employee_id!: number;
    country_id!: number;
    state_id!: number;
    lga_id!: number;
    address1!: string | undefined;
    address2!: string | undefined;
    address_type!: number;
    is_primary_address!: boolean;
    employee!: Employee;
    state!: State;
    lga!: LGA;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employee_id = _data["employee_id"];
            this.country_id = _data["country_id"];
            this.state_id = _data["state_id"];
            this.lga_id = _data["lga_id"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.address_type = _data["address_type"];
            this.is_primary_address = _data["is_primary_address"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.state = _data["state"] ? State.fromJS(_data["state"]) : <any>undefined;
            this.lga = _data["lga"] ? LGA.fromJS(_data["lga"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employee_id"] = this.employee_id;
        data["country_id"] = this.country_id;
        data["state_id"] = this.state_id;
        data["lga_id"] = this.lga_id;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["address_type"] = this.address_type;
        data["is_primary_address"] = this.is_primary_address;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["lga"] = this.lga ? this.lga.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Address {
        const json = this.toJSON();
        let result = new Address();
        result.init(json);
        return result;
    }
}

export interface IAddress {
    employee_id: number;
    country_id: number;
    state_id: number;
    lga_id: number;
    address1: string | undefined;
    address2: string | undefined;
    address_type: number;
    is_primary_address: boolean;
    employee: Employee;
    state: State;
    lga: LGA;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Employee implements IEmployee {
    userId!: number;
    titleId!: number;
    religionId!: number | undefined;
    serialNo!: string | undefined;
    firstName!: string;
    lastName!: string;
    otherNames!: string | undefined;
    employeeNumber!: string;
    dateOfBirth!: Date | undefined;
    maritalStatusId!: number;
    genderId!: number;
    lasraaNumber!: string | undefined;
    regNo!: string | undefined;
    estabFileNo!: string | undefined;
    personalEmail!: string | undefined;
    workEmail!: string | undefined;
    fullName!: string | undefined;
    peopleGroupId!: number | undefined;
    niNumber!: string | undefined;
    profilePic!: string | undefined;
    workMobile!: string | undefined;
    defaultMobile!: string | undefined;
    subjectSpecialization!: string | undefined;
    selfServiceStatus!: string | undefined;
    employmentStatusId!: number | undefined;
    pensionerFileNo!: string | undefined;
    pfaId!: number | undefined;
    rsaNumber!: string | undefined;
    stateOfOrigion!: string | undefined;
    lgaOfOrigion!: string | undefined;
    internalAddressLine!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    originCountry!: number | undefined;
    originState!: number | undefined;
    residentialCountry!: number | undefined;
    residentialState!: number | undefined;
    residentialLga!: number | undefined;
    residentialAddress!: string | undefined;
    created_by!: string | undefined;
    bvn!: string | undefined;
    bvnStatus!: number;
    bvnValidationResponse!: string | undefined;
    lastBVNValidation!: Date | undefined;
    deviceId!: number | undefined;
    employeeSkills!: EmployeeSkill[] | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    employeeCertifications!: EmployeeCertification[] | undefined;
    addresses!: Address[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.titleId = _data["titleId"];
            this.religionId = _data["religionId"];
            this.serialNo = _data["serialNo"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherNames = _data["otherNames"];
            this.employeeNumber = _data["employeeNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.maritalStatusId = _data["maritalStatusId"];
            this.genderId = _data["genderId"];
            this.lasraaNumber = _data["lasraaNumber"];
            this.regNo = _data["regNo"];
            this.estabFileNo = _data["estabFileNo"];
            this.personalEmail = _data["personalEmail"];
            this.workEmail = _data["workEmail"];
            this.fullName = _data["fullName"];
            this.peopleGroupId = _data["peopleGroupId"];
            this.niNumber = _data["niNumber"];
            this.profilePic = _data["profilePic"];
            this.workMobile = _data["workMobile"];
            this.defaultMobile = _data["defaultMobile"];
            this.subjectSpecialization = _data["subjectSpecialization"];
            this.selfServiceStatus = _data["selfServiceStatus"];
            this.employmentStatusId = _data["employmentStatusId"];
            this.pensionerFileNo = _data["pensionerFileNo"];
            this.pfaId = _data["pfaId"];
            this.rsaNumber = _data["rsaNumber"];
            this.stateOfOrigion = _data["stateOfOrigion"];
            this.lgaOfOrigion = _data["lgaOfOrigion"];
            this.internalAddressLine = _data["internalAddressLine"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.originCountry = _data["originCountry"];
            this.originState = _data["originState"];
            this.residentialCountry = _data["residentialCountry"];
            this.residentialState = _data["residentialState"];
            this.residentialLga = _data["residentialLga"];
            this.residentialAddress = _data["residentialAddress"];
            this.created_by = _data["created_by"];
            this.bvn = _data["bvn"];
            this.bvnStatus = _data["bvnStatus"];
            this.bvnValidationResponse = _data["bvnValidationResponse"];
            this.lastBVNValidation = _data["lastBVNValidation"] ? new Date(_data["lastBVNValidation"].toString()) : <any>undefined;
            this.deviceId = _data["deviceId"];
            if (Array.isArray(_data["employeeSkills"])) {
                this.employeeSkills = [] as any;
                for (let item of _data["employeeSkills"])
                    this.employeeSkills!.push(EmployeeSkill.fromJS(item));
            }
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            if (Array.isArray(_data["employeeCertifications"])) {
                this.employeeCertifications = [] as any;
                for (let item of _data["employeeCertifications"])
                    this.employeeCertifications!.push(EmployeeCertification.fromJS(item));
            }
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(Address.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Employee {
        data = typeof data === 'object' ? data : {};
        let result = new Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["titleId"] = this.titleId;
        data["religionId"] = this.religionId;
        data["serialNo"] = this.serialNo;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherNames"] = this.otherNames;
        data["employeeNumber"] = this.employeeNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["maritalStatusId"] = this.maritalStatusId;
        data["genderId"] = this.genderId;
        data["lasraaNumber"] = this.lasraaNumber;
        data["regNo"] = this.regNo;
        data["estabFileNo"] = this.estabFileNo;
        data["personalEmail"] = this.personalEmail;
        data["workEmail"] = this.workEmail;
        data["fullName"] = this.fullName;
        data["peopleGroupId"] = this.peopleGroupId;
        data["niNumber"] = this.niNumber;
        data["profilePic"] = this.profilePic;
        data["workMobile"] = this.workMobile;
        data["defaultMobile"] = this.defaultMobile;
        data["subjectSpecialization"] = this.subjectSpecialization;
        data["selfServiceStatus"] = this.selfServiceStatus;
        data["employmentStatusId"] = this.employmentStatusId;
        data["pensionerFileNo"] = this.pensionerFileNo;
        data["pfaId"] = this.pfaId;
        data["rsaNumber"] = this.rsaNumber;
        data["stateOfOrigion"] = this.stateOfOrigion;
        data["lgaOfOrigion"] = this.lgaOfOrigion;
        data["internalAddressLine"] = this.internalAddressLine;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["originCountry"] = this.originCountry;
        data["originState"] = this.originState;
        data["residentialCountry"] = this.residentialCountry;
        data["residentialState"] = this.residentialState;
        data["residentialLga"] = this.residentialLga;
        data["residentialAddress"] = this.residentialAddress;
        data["created_by"] = this.created_by;
        data["bvn"] = this.bvn;
        data["bvnStatus"] = this.bvnStatus;
        data["bvnValidationResponse"] = this.bvnValidationResponse;
        data["lastBVNValidation"] = this.lastBVNValidation ? this.lastBVNValidation.toISOString() : <any>undefined;
        data["deviceId"] = this.deviceId;
        if (Array.isArray(this.employeeSkills)) {
            data["employeeSkills"] = [];
            for (let item of this.employeeSkills)
                data["employeeSkills"].push(item.toJSON());
        }
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        if (Array.isArray(this.employeeCertifications)) {
            data["employeeCertifications"] = [];
            for (let item of this.employeeCertifications)
                data["employeeCertifications"].push(item.toJSON());
        }
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Employee {
        const json = this.toJSON();
        let result = new Employee();
        result.init(json);
        return result;
    }
}

export interface IEmployee {
    userId: number;
    titleId: number;
    religionId: number | undefined;
    serialNo: string | undefined;
    firstName: string;
    lastName: string;
    otherNames: string | undefined;
    employeeNumber: string;
    dateOfBirth: Date | undefined;
    maritalStatusId: number;
    genderId: number;
    lasraaNumber: string | undefined;
    regNo: string | undefined;
    estabFileNo: string | undefined;
    personalEmail: string | undefined;
    workEmail: string | undefined;
    fullName: string | undefined;
    peopleGroupId: number | undefined;
    niNumber: string | undefined;
    profilePic: string | undefined;
    workMobile: string | undefined;
    defaultMobile: string | undefined;
    subjectSpecialization: string | undefined;
    selfServiceStatus: string | undefined;
    employmentStatusId: number | undefined;
    pensionerFileNo: string | undefined;
    pfaId: number | undefined;
    rsaNumber: string | undefined;
    stateOfOrigion: string | undefined;
    lgaOfOrigion: string | undefined;
    internalAddressLine: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    originCountry: number | undefined;
    originState: number | undefined;
    residentialCountry: number | undefined;
    residentialState: number | undefined;
    residentialLga: number | undefined;
    residentialAddress: string | undefined;
    created_by: string | undefined;
    bvn: string | undefined;
    bvnStatus: number;
    bvnValidationResponse: string | undefined;
    lastBVNValidation: Date | undefined;
    deviceId: number | undefined;
    employeeSkills: EmployeeSkill[] | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    employeeCertifications: EmployeeCertification[] | undefined;
    addresses: Address[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RequestFile implements IRequestFile {
    request_id!: number;
    filename!: string | undefined;
    filepath!: string | undefined;
    requests!: Request;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRequestFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.request_id = _data["request_id"];
            this.filename = _data["filename"];
            this.filepath = _data["filepath"];
            this.requests = _data["requests"] ? Request.fromJS(_data["requests"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RequestFile {
        data = typeof data === 'object' ? data : {};
        let result = new RequestFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["request_id"] = this.request_id;
        data["filename"] = this.filename;
        data["filepath"] = this.filepath;
        data["requests"] = this.requests ? this.requests.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RequestFile {
        const json = this.toJSON();
        let result = new RequestFile();
        result.init(json);
        return result;
    }
}

export interface IRequestFile {
    request_id: number;
    filename: string | undefined;
    filepath: string | undefined;
    requests: Request;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Request implements IRequest {
    requestTypeId!: number;
    employeeId!: number;
    employeeContractId!: number;
    request_date!: Date;
    title!: string;
    description!: string;
    log_status!: number;
    resolution!: string | undefined;
    temp_resolution!: string | undefined;
    submitted_by!: string | undefined;
    date_resolved!: Date;
    refNo!: string | undefined;
    requestType!: RequestType;
    employees!: Employee;
    employeeContractAssignment!: EmployeeContractAssignment;
    requestFiles!: RequestFile[] | undefined;
    employeeName!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestTypeId = _data["requestTypeId"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.log_status = _data["log_status"];
            this.resolution = _data["resolution"];
            this.temp_resolution = _data["temp_resolution"];
            this.submitted_by = _data["submitted_by"];
            this.date_resolved = _data["date_resolved"] ? new Date(_data["date_resolved"].toString()) : <any>undefined;
            this.refNo = _data["refNo"];
            this.requestType = _data["requestType"] ? RequestType.fromJS(_data["requestType"]) : <any>undefined;
            this.employees = _data["employees"] ? Employee.fromJS(_data["employees"]) : <any>undefined;
            this.employeeContractAssignment = _data["employeeContractAssignment"] ? EmployeeContractAssignment.fromJS(_data["employeeContractAssignment"]) : <any>undefined;
            if (Array.isArray(_data["requestFiles"])) {
                this.requestFiles = [] as any;
                for (let item of _data["requestFiles"])
                    this.requestFiles!.push(RequestFile.fromJS(item));
            }
            this.employeeName = _data["employeeName"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestTypeId"] = this.requestTypeId;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["log_status"] = this.log_status;
        data["resolution"] = this.resolution;
        data["temp_resolution"] = this.temp_resolution;
        data["submitted_by"] = this.submitted_by;
        data["date_resolved"] = this.date_resolved ? this.date_resolved.toISOString() : <any>undefined;
        data["refNo"] = this.refNo;
        data["requestType"] = this.requestType ? this.requestType.toJSON() : <any>undefined;
        data["employees"] = this.employees ? this.employees.toJSON() : <any>undefined;
        data["employeeContractAssignment"] = this.employeeContractAssignment ? this.employeeContractAssignment.toJSON() : <any>undefined;
        if (Array.isArray(this.requestFiles)) {
            data["requestFiles"] = [];
            for (let item of this.requestFiles)
                data["requestFiles"].push(item.toJSON());
        }
        data["employeeName"] = this.employeeName;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Request {
        const json = this.toJSON();
        let result = new Request();
        result.init(json);
        return result;
    }
}

export interface IRequest {
    requestTypeId: number;
    employeeId: number;
    employeeContractId: number;
    request_date: Date;
    title: string;
    description: string;
    log_status: number;
    resolution: string | undefined;
    temp_resolution: string | undefined;
    submitted_by: string | undefined;
    date_resolved: Date;
    refNo: string | undefined;
    requestType: RequestType;
    employees: Employee;
    employeeContractAssignment: EmployeeContractAssignment;
    requestFiles: RequestFile[] | undefined;
    employeeName: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RequestIListApiResult implements IRequestIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Request[] | undefined;
    totalCount!: number;

    constructor(data?: IRequestIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Request.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RequestIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RequestIListApiResult {
        const json = this.toJSON();
        let result = new RequestIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Request[] | undefined;
    totalCount: number;
}

export class RetirementDocAttachment implements IRetirementDocAttachment {
    id!: number;
    retirementId!: number;
    documentName!: string | undefined;
    docUrl!: string | undefined;
    retirement!: Retirement;

    constructor(data?: IRetirementDocAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.retirementId = _data["retirementId"];
            this.documentName = _data["documentName"];
            this.docUrl = _data["docUrl"];
            this.retirement = _data["retirement"] ? Retirement.fromJS(_data["retirement"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RetirementDocAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementDocAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["retirementId"] = this.retirementId;
        data["documentName"] = this.documentName;
        data["docUrl"] = this.docUrl;
        data["retirement"] = this.retirement ? this.retirement.toJSON() : <any>undefined;
        return data; 
    }

    clone(): RetirementDocAttachment {
        const json = this.toJSON();
        let result = new RetirementDocAttachment();
        result.init(json);
        return result;
    }
}

export interface IRetirementDocAttachment {
    id: number;
    retirementId: number;
    documentName: string | undefined;
    docUrl: string | undefined;
    retirement: Retirement;
}

export class Retirement implements IRetirement {
    id!: number;
    retirementTypeId!: number;
    retirementUserId!: number;
    comment!: string | undefined;
    dateRetired!: Date;
    loggedDate!: Date;
    createdBy!: string | undefined;
    requriesBenefits!: boolean;
    retirmentDocAttachments!: RetirementDocAttachment[] | undefined;

    constructor(data?: IRetirement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.retirementTypeId = _data["retirementTypeId"];
            this.retirementUserId = _data["retirementUserId"];
            this.comment = _data["comment"];
            this.dateRetired = _data["dateRetired"] ? new Date(_data["dateRetired"].toString()) : <any>undefined;
            this.loggedDate = _data["loggedDate"] ? new Date(_data["loggedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.requriesBenefits = _data["requriesBenefits"];
            if (Array.isArray(_data["retirmentDocAttachments"])) {
                this.retirmentDocAttachments = [] as any;
                for (let item of _data["retirmentDocAttachments"])
                    this.retirmentDocAttachments!.push(RetirementDocAttachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Retirement {
        data = typeof data === 'object' ? data : {};
        let result = new Retirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["retirementTypeId"] = this.retirementTypeId;
        data["retirementUserId"] = this.retirementUserId;
        data["comment"] = this.comment;
        data["dateRetired"] = this.dateRetired ? this.dateRetired.toISOString() : <any>undefined;
        data["loggedDate"] = this.loggedDate ? this.loggedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["requriesBenefits"] = this.requriesBenefits;
        if (Array.isArray(this.retirmentDocAttachments)) {
            data["retirmentDocAttachments"] = [];
            for (let item of this.retirmentDocAttachments)
                data["retirmentDocAttachments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Retirement {
        const json = this.toJSON();
        let result = new Retirement();
        result.init(json);
        return result;
    }
}

export interface IRetirement {
    id: number;
    retirementTypeId: number;
    retirementUserId: number;
    comment: string | undefined;
    dateRetired: Date;
    loggedDate: Date;
    createdBy: string | undefined;
    requriesBenefits: boolean;
    retirmentDocAttachments: RetirementDocAttachment[] | undefined;
}

export class RetirementIListApiResult implements IRetirementIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Retirement[] | undefined;
    totalCount!: number;

    constructor(data?: IRetirementIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Retirement.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RetirementIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RetirementIListApiResult {
        const json = this.toJSON();
        let result = new RetirementIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRetirementIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Retirement[] | undefined;
    totalCount: number;
}

export class RetirementType implements IRetirementType {
    id!: number;
    name!: string | undefined;
    requirements!: string | undefined;
    isEntitledToBenefits!: boolean;

    constructor(data?: IRetirementType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.requirements = _data["requirements"];
            this.isEntitledToBenefits = _data["isEntitledToBenefits"];
        }
    }

    static fromJS(data: any): RetirementType {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["requirements"] = this.requirements;
        data["isEntitledToBenefits"] = this.isEntitledToBenefits;
        return data; 
    }

    clone(): RetirementType {
        const json = this.toJSON();
        let result = new RetirementType();
        result.init(json);
        return result;
    }
}

export interface IRetirementType {
    id: number;
    name: string | undefined;
    requirements: string | undefined;
    isEntitledToBenefits: boolean;
}

export class RetirementTypeIListApiResult implements IRetirementTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RetirementType[] | undefined;
    totalCount!: number;

    constructor(data?: IRetirementTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RetirementType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RetirementTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RetirementTypeIListApiResult {
        const json = this.toJSON();
        let result = new RetirementTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRetirementTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RetirementType[] | undefined;
    totalCount: number;
}

export class VwConfirmationDTO implements IVwConfirmationDTO {
    id!: number;
    company_id!: number;
    subsidiary_id!: number;
    employee_id!: number;
    mgr_feedback!: string | undefined;
    mgr_advice!: string | undefined;
    appointment_date!: Date | undefined;
    probation_period!: string | undefined;
    log_status!: number;
    request_by!: string | undefined;
    request_date!: Date | undefined;
    employee_contractId!: number;
    employee_name!: string | undefined;
    status!: string | undefined;
    staff_no!: string | undefined;
    effective_date!: Date | undefined;
    str_effective_date!: string | undefined;
    confirmationDate!: Date | undefined;

    constructor(data?: IVwConfirmationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.subsidiary_id = _data["subsidiary_id"];
            this.employee_id = _data["employee_id"];
            this.mgr_feedback = _data["mgr_feedback"];
            this.mgr_advice = _data["mgr_advice"];
            this.appointment_date = _data["appointment_date"] ? new Date(_data["appointment_date"].toString()) : <any>undefined;
            this.probation_period = _data["probation_period"];
            this.log_status = _data["log_status"];
            this.request_by = _data["request_by"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.employee_contractId = _data["employee_contractId"];
            this.employee_name = _data["employee_name"];
            this.status = _data["status"];
            this.staff_no = _data["staff_no"];
            this.effective_date = _data["effective_date"] ? new Date(_data["effective_date"].toString()) : <any>undefined;
            this.str_effective_date = _data["str_effective_date"];
            this.confirmationDate = _data["confirmationDate"] ? new Date(_data["confirmationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VwConfirmationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new VwConfirmationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["subsidiary_id"] = this.subsidiary_id;
        data["employee_id"] = this.employee_id;
        data["mgr_feedback"] = this.mgr_feedback;
        data["mgr_advice"] = this.mgr_advice;
        data["appointment_date"] = this.appointment_date ? this.appointment_date.toISOString() : <any>undefined;
        data["probation_period"] = this.probation_period;
        data["log_status"] = this.log_status;
        data["request_by"] = this.request_by;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["employee_contractId"] = this.employee_contractId;
        data["employee_name"] = this.employee_name;
        data["status"] = this.status;
        data["staff_no"] = this.staff_no;
        data["effective_date"] = this.effective_date ? this.effective_date.toISOString() : <any>undefined;
        data["str_effective_date"] = this.str_effective_date;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): VwConfirmationDTO {
        const json = this.toJSON();
        let result = new VwConfirmationDTO();
        result.init(json);
        return result;
    }
}

export interface IVwConfirmationDTO {
    id: number;
    company_id: number;
    subsidiary_id: number;
    employee_id: number;
    mgr_feedback: string | undefined;
    mgr_advice: string | undefined;
    appointment_date: Date | undefined;
    probation_period: string | undefined;
    log_status: number;
    request_by: string | undefined;
    request_date: Date | undefined;
    employee_contractId: number;
    employee_name: string | undefined;
    status: string | undefined;
    staff_no: string | undefined;
    effective_date: Date | undefined;
    str_effective_date: string | undefined;
    confirmationDate: Date | undefined;
}

export class 
VwConfirmationDTOIListApiResult implements IVwConfirmationDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwConfirmationDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IVwConfirmationDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(VwConfirmationDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VwConfirmationDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwConfirmationDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VwConfirmationDTOIListApiResult {
        const json = this.toJSON();
        let result = new VwConfirmationDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwConfirmationDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwConfirmationDTO[] | undefined;
    totalCount: number;
}

export class IDTextViewModel implements IIDTextViewModel {
    id!: number;
    text!: string | undefined;

    constructor(data?: IIDTextViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): IDTextViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new IDTextViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        return data; 
    }

    clone(): IDTextViewModel {
        const json = this.toJSON();
        let result = new IDTextViewModel();
        result.init(json);
        return result;
    }
}

export interface IIDTextViewModel {
    id: number;
    text: string | undefined;
}

export class IDTextViewModelIListApiResult implements IIDTextViewModelIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: IDTextViewModel[] | undefined;
    totalCount!: number;

    constructor(data?: IIDTextViewModelIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(IDTextViewModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): IDTextViewModelIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new IDTextViewModelIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): IDTextViewModelIListApiResult {
        const json = this.toJSON();
        let result = new IDTextViewModelIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IIDTextViewModelIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: IDTextViewModel[] | undefined;
    totalCount: number;
}

export class DropdownValue implements IDropdownValue {
    dropdown_id!: number;
    option_text!: string;
    option_value!: number;
    is_deleted!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDropdownValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dropdown_id = _data["dropdown_id"];
            this.option_text = _data["option_text"];
            this.option_value = _data["option_value"];
            this.is_deleted = _data["is_deleted"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DropdownValue {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dropdown_id"] = this.dropdown_id;
        data["option_text"] = this.option_text;
        data["option_value"] = this.option_value;
        data["is_deleted"] = this.is_deleted;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DropdownValue {
        const json = this.toJSON();
        let result = new DropdownValue();
        result.init(json);
        return result;
    }
}

export interface IDropdownValue {
    dropdown_id: number;
    option_text: string;
    option_value: number;
    is_deleted: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DropdownValueIListApiResult implements IDropdownValueIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DropdownValue[] | undefined;
    totalCount!: number;

    constructor(data?: IDropdownValueIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DropdownValue.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DropdownValueIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValueIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DropdownValueIListApiResult {
        const json = this.toJSON();
        let result = new DropdownValueIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDropdownValueIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DropdownValue[] | undefined;
    totalCount: number;
}

export class Country implements ICountry {
    name!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export interface ICountry {
    name: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CountryIListApiResult implements ICountryIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Country[] | undefined;
    totalCount!: number;

    constructor(data?: ICountryIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Country.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CountryIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CountryIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CountryIListApiResult {
        const json = this.toJSON();
        let result = new CountryIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICountryIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Country[] | undefined;
    totalCount: number;
}

export class StateIListApiResult implements IStateIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: State[] | undefined;
    totalCount!: number;

    constructor(data?: IStateIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(State.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StateIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new StateIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): StateIListApiResult {
        const json = this.toJSON();
        let result = new StateIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IStateIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: State[] | undefined;
    totalCount: number;
}

export class LGAIListApiResult implements ILGAIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LGA[] | undefined;
    totalCount!: number;

    constructor(data?: ILGAIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LGA.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LGAIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LGAIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LGAIListApiResult {
        const json = this.toJSON();
        let result = new LGAIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILGAIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LGA[] | undefined;
    totalCount: number;
}

export class ManageDepartmentDTO implements IManageDepartmentDTO {
    id!: number;
    name!: string;
    code!: string;

    constructor(data?: IManageDepartmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ManageDepartmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageDepartmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }

    clone(): ManageDepartmentDTO {
        const json = this.toJSON();
        let result = new ManageDepartmentDTO();
        result.init(json);
        return result;
    }
}

export interface IManageDepartmentDTO {
    id: number;
    name: string;
    code: string;
}

export class DepartmentDTO implements IDepartmentDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    headOfDepartment!: number;

    constructor(data?: IDepartmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.headOfDepartment = _data["headOfDepartment"];
        }
    }

    static fromJS(data: any): DepartmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["headOfDepartment"] = this.headOfDepartment;
        return data; 
    }

    clone(): DepartmentDTO {
        const json = this.toJSON();
        let result = new DepartmentDTO();
        result.init(json);
        return result;
    }
}

export interface IDepartmentDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    headOfDepartment: number;
}

export class DepartmentDTOListApiResult implements IDepartmentDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DepartmentDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IDepartmentDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DepartmentDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DepartmentDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DepartmentDTOListApiResult {
        const json = this.toJSON();
        let result = new DepartmentDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDepartmentDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DepartmentDTO[] | undefined;
    totalCount: number;
}

export class DepartmentDTOApiResult implements IDepartmentDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DepartmentDTO;
    totalCount!: number;

    constructor(data?: IDepartmentDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? DepartmentDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DepartmentDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DepartmentDTOApiResult {
        const json = this.toJSON();
        let result = new DepartmentDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IDepartmentDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DepartmentDTO;
    totalCount: number;
}

export class DeploymentLogIListApiResult implements IDeploymentLogIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DeploymentLog[] | undefined;
    totalCount!: number;

    constructor(data?: IDeploymentLogIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DeploymentLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DeploymentLogIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DeploymentLogIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DeploymentLogIListApiResult {
        const json = this.toJSON();
        let result = new DeploymentLogIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDeploymentLogIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DeploymentLog[] | undefined;
    totalCount: number;
}

export class SearchDeploymentDto implements ISearchDeploymentDto {
    companyID!: number;
    subID!: number;
    employeeContractid!: number;
    name!: string | undefined;
    id!: number;
    strStartDate!: string | undefined;
    strEndDate!: string | undefined;
    referenceId!: string | undefined;
    code!: string | undefined;
    pageNumber!: number;
    pageSize!: number;

    constructor(data?: ISearchDeploymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.employeeContractid = _data["employeeContractid"];
            this.name = _data["name"];
            this.id = _data["id"];
            this.strStartDate = _data["strStartDate"];
            this.strEndDate = _data["strEndDate"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): SearchDeploymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchDeploymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["employeeContractid"] = this.employeeContractid;
        data["name"] = this.name;
        data["id"] = this.id;
        data["strStartDate"] = this.strStartDate;
        data["strEndDate"] = this.strEndDate;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data; 
    }

    clone(): SearchDeploymentDto {
        const json = this.toJSON();
        let result = new SearchDeploymentDto();
        result.init(json);
        return result;
    }
}

export interface ISearchDeploymentDto {
    companyID: number;
    subID: number;
    employeeContractid: number;
    name: string | undefined;
    id: number;
    strStartDate: string | undefined;
    strEndDate: string | undefined;
    referenceId: string | undefined;
    code: string | undefined;
    pageNumber: number;
    pageSize: number;
}

export class IdNameObj implements IIdNameObj {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: IIdNameObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameObj {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }

    clone(): IdNameObj {
        const json = this.toJSON();
        let result = new IdNameObj();
        result.init(json);
        return result;
    }
}

export interface IIdNameObj {
    id: number;
    code: string | undefined;
    name: string | undefined;
}

export class CreateDeploymentViewModel implements ICreateDeploymentViewModel {
    lstLocations!: Location[] | undefined;
    ministries!: IdNameObj[] | undefined;

    constructor(data?: ICreateDeploymentViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lstLocations"])) {
                this.lstLocations = [] as any;
                for (let item of _data["lstLocations"])
                    this.lstLocations!.push(Location.fromJS(item));
            }
            if (Array.isArray(_data["ministries"])) {
                this.ministries = [] as any;
                for (let item of _data["ministries"])
                    this.ministries!.push(IdNameObj.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateDeploymentViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeploymentViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lstLocations)) {
            data["lstLocations"] = [];
            for (let item of this.lstLocations)
                data["lstLocations"].push(item.toJSON());
        }
        if (Array.isArray(this.ministries)) {
            data["ministries"] = [];
            for (let item of this.ministries)
                data["ministries"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateDeploymentViewModel {
        const json = this.toJSON();
        let result = new CreateDeploymentViewModel();
        result.init(json);
        return result;
    }
}

export interface ICreateDeploymentViewModel {
    lstLocations: Location[] | undefined;
    ministries: IdNameObj[] | undefined;
}

export class 

CreateDeploymentViewModelIListApiResult implements ICreateDeploymentViewModelIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CreateDeploymentViewModel[] | undefined;
    totalCount!: number;

    constructor(data?: ICreateDeploymentViewModelIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CreateDeploymentViewModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CreateDeploymentViewModelIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeploymentViewModelIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CreateDeploymentViewModelIListApiResult {
        const json = this.toJSON();
        let result = new CreateDeploymentViewModelIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICreateDeploymentViewModelIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CreateDeploymentViewModel[] | undefined;
    totalCount: number;
}

export class SingleDisbursementPostDTO implements ISingleDisbursementPostDTO {
    id!: number;
    categoryId!: number;
    disbursementBudgetItemId!: number | undefined;
    projectId!: number | undefined;
    channelId!: number;
    isRecurring!: boolean;
    frequencyId!: number;
    runCount!: number | undefined;
    saveAsBeneficiary!: boolean;
    amount!: number;
    accountNumber!: string;
    accountName!: string;
    bankId!: number;
    scheduledDate!: Date;
    description!: string;
    startDate!: Date | undefined;
    endDate!: Date | undefined;

    constructor(data?: ISingleDisbursementPostDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.disbursementBudgetItemId = _data["disbursementBudgetItemId"];
            this.projectId = _data["projectId"];
            this.channelId = _data["channelId"];
            this.isRecurring = _data["isRecurring"];
            this.frequencyId = _data["frequencyId"];
            this.runCount = _data["runCount"];
            this.saveAsBeneficiary = _data["saveAsBeneficiary"];
            this.amount = _data["amount"];
            this.accountNumber = _data["accountNumber"];
            this.accountName = _data["accountName"];
            this.bankId = _data["bankId"];
            this.scheduledDate = _data["scheduledDate"] ? new Date(_data["scheduledDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SingleDisbursementPostDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SingleDisbursementPostDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["disbursementBudgetItemId"] = this.disbursementBudgetItemId;
        data["projectId"] = this.projectId;
        data["channelId"] = this.channelId;
        data["isRecurring"] = this.isRecurring;
        data["frequencyId"] = this.frequencyId;
        data["runCount"] = this.runCount;
        data["saveAsBeneficiary"] = this.saveAsBeneficiary;
        data["amount"] = this.amount;
        data["accountNumber"] = this.accountNumber;
        data["accountName"] = this.accountName;
        data["bankId"] = this.bankId;
        data["scheduledDate"] = this.scheduledDate ? this.scheduledDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): SingleDisbursementPostDTO {
        const json = this.toJSON();
        let result = new SingleDisbursementPostDTO();
        result.init(json);
        return result;
    }
}

export interface ISingleDisbursementPostDTO {
    id: number;
    categoryId: number;
    disbursementBudgetItemId: number | undefined;
    projectId: number | undefined;
    channelId: number;
    isRecurring: boolean;
    frequencyId: number;
    runCount: number | undefined;
    saveAsBeneficiary: boolean;
    amount: number;
    accountNumber: string;
    accountName: string;
    bankId: number;
    scheduledDate: Date;
    description: string;
    startDate: Date | undefined;
    endDate: Date | undefined;
}

export class EmailLog implements IEmailLog {
    sender!: string | undefined;
    receiver!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    messageBody!: string | undefined;
    hasAttachment!: boolean;
    isSent!: boolean;
    retires!: number;
    dateSent!: Date | undefined;
    dateToSend!: Date | undefined;
    emailAttachments!: EmailLogAttachment[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmailLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sender = _data["sender"];
            this.receiver = _data["receiver"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.messageBody = _data["messageBody"];
            this.hasAttachment = _data["hasAttachment"];
            this.isSent = _data["isSent"];
            this.retires = _data["retires"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.dateToSend = _data["dateToSend"] ? new Date(_data["dateToSend"].toString()) : <any>undefined;
            if (Array.isArray(_data["emailAttachments"])) {
                this.emailAttachments = [] as any;
                for (let item of _data["emailAttachments"])
                    this.emailAttachments!.push(EmailLogAttachment.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmailLog {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sender"] = this.sender;
        data["receiver"] = this.receiver;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["messageBody"] = this.messageBody;
        data["hasAttachment"] = this.hasAttachment;
        data["isSent"] = this.isSent;
        data["retires"] = this.retires;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["dateToSend"] = this.dateToSend ? this.dateToSend.toISOString() : <any>undefined;
        if (Array.isArray(this.emailAttachments)) {
            data["emailAttachments"] = [];
            for (let item of this.emailAttachments)
                data["emailAttachments"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmailLog {
        const json = this.toJSON();
        let result = new EmailLog();
        result.init(json);
        return result;
    }
}

export interface IEmailLog {
    sender: string | undefined;
    receiver: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    messageBody: string | undefined;
    hasAttachment: boolean;
    isSent: boolean;
    retires: number;
    dateSent: Date | undefined;
    dateToSend: Date | undefined;
    emailAttachments: EmailLogAttachment[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmailLogAttachment implements IEmailLogAttachment {
    id!: number;
    emailLogID!: number;
    emailLog!: EmailLog;
    folderOnServer!: string | undefined;
    fileNameOnServer!: string | undefined;
    emailFileName!: string | undefined;
    dateCreated!: Date;

    constructor(data?: IEmailLogAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailLogID = _data["emailLogID"];
            this.emailLog = _data["emailLog"] ? EmailLog.fromJS(_data["emailLog"]) : <any>undefined;
            this.folderOnServer = _data["folderOnServer"];
            this.fileNameOnServer = _data["fileNameOnServer"];
            this.emailFileName = _data["emailFileName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmailLogAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailLogID"] = this.emailLogID;
        data["emailLog"] = this.emailLog ? this.emailLog.toJSON() : <any>undefined;
        data["folderOnServer"] = this.folderOnServer;
        data["fileNameOnServer"] = this.fileNameOnServer;
        data["emailFileName"] = this.emailFileName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        return data; 
    }

    clone(): EmailLogAttachment {
        const json = this.toJSON();
        let result = new EmailLogAttachment();
        result.init(json);
        return result;
    }
}

export interface IEmailLogAttachment {
    id: number;
    emailLogID: number;
    emailLog: EmailLog;
    folderOnServer: string | undefined;
    fileNameOnServer: string | undefined;
    emailFileName: string | undefined;
    dateCreated: Date;
}

export class EmailLogDTO implements IEmailLogDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    sender!: string | undefined;
    receiver!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    messageBody!: string | undefined;
    hasAttachment!: boolean;
    isSent!: boolean;
    retires!: number;
    dateSent!: Date | undefined;
    dateToSend!: Date | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    emailAttachments!: EmailLogAttachment[] | undefined;

    constructor(data?: IEmailLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.sender = _data["sender"];
            this.receiver = _data["receiver"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.messageBody = _data["messageBody"];
            this.hasAttachment = _data["hasAttachment"];
            this.isSent = _data["isSent"];
            this.retires = _data["retires"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.dateToSend = _data["dateToSend"] ? new Date(_data["dateToSend"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            if (Array.isArray(_data["emailAttachments"])) {
                this.emailAttachments = [] as any;
                for (let item of _data["emailAttachments"])
                    this.emailAttachments!.push(EmailLogAttachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["sender"] = this.sender;
        data["receiver"] = this.receiver;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["messageBody"] = this.messageBody;
        data["hasAttachment"] = this.hasAttachment;
        data["isSent"] = this.isSent;
        data["retires"] = this.retires;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["dateToSend"] = this.dateToSend ? this.dateToSend.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        if (Array.isArray(this.emailAttachments)) {
            data["emailAttachments"] = [];
            for (let item of this.emailAttachments)
                data["emailAttachments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EmailLogDTO {
        const json = this.toJSON();
        let result = new EmailLogDTO();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTO {
    id: number;
    companyID: number;
    subID: number;
    sender: string | undefined;
    receiver: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    messageBody: string | undefined;
    hasAttachment: boolean;
    isSent: boolean;
    retires: number;
    dateSent: Date | undefined;
    dateToSend: Date | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    emailAttachments: EmailLogAttachment[] | undefined;
}

export class EmailLogDTOIListApiResult implements IEmailLogDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailLogDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IEmailLogDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmailLogDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmailLogDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmailLogDTOIListApiResult {
        const json = this.toJSON();
        let result = new EmailLogDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailLogDTO[] | undefined;
    totalCount: number;
}

export class EmailLogDTOApiResult implements IEmailLogDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailLogDTO;
    totalCount!: number;

    constructor(data?: IEmailLogDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmailLogDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmailLogDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmailLogDTOApiResult {
        const json = this.toJSON();
        let result = new EmailLogDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailLogDTO;
    totalCount: number;
}

export class EmailTemplateDTO implements IEmailTemplateDTO {
    id!: number;
    name!: string | undefined;
    subject!: string;
    text!: string;
    emailTemplateCol!: IDTextViewModel[] | undefined;

    constructor(data?: IEmailTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.subject = _data["subject"];
            this.text = _data["text"];
            if (Array.isArray(_data["emailTemplateCol"])) {
                this.emailTemplateCol = [] as any;
                for (let item of _data["emailTemplateCol"])
                    this.emailTemplateCol!.push(IDTextViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["subject"] = this.subject;
        data["text"] = this.text;
        if (Array.isArray(this.emailTemplateCol)) {
            data["emailTemplateCol"] = [];
            for (let item of this.emailTemplateCol)
                data["emailTemplateCol"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EmailTemplateDTO {
        const json = this.toJSON();
        let result = new EmailTemplateDTO();
        result.init(json);
        return result;
    }
}

export interface IEmailTemplateDTO {
    id: number;
    name: string | undefined;
    subject: string;
    text: string;
    emailTemplateCol: IDTextViewModel[] | undefined;
}

export class EmailTemplateDTOApiResult implements IEmailTemplateDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailTemplateDTO;
    totalCount!: number;

    constructor(data?: IEmailTemplateDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmailTemplateDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmailTemplateDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTemplateDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmailTemplateDTOApiResult {
        const json = this.toJSON();
        let result = new EmailTemplateDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailTemplateDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailTemplateDTO;
    totalCount: number;
}

export class EmployeeDTO implements IEmployeeDTO {
    id!: number;
    employeeContractId!: number;
    companyId!: number;
    subID!: number;
    userId!: number;
    userEmail!: string | undefined;
    titleId!: number;
    religionId!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    serialNo!: string | undefined;
    firstName!: string;
    lastName!: string;
    otherNames!: string | undefined;
    employeeNumber!: string;
    assignmentNumber!: string | undefined;
    dateOfBirth!: Date | undefined;
    maritalStatusId!: number;
    genderId!: number;
    lasraaNumber!: string | undefined;
    regNo!: string | undefined;
    estabFileNo!: string | undefined;
    personalEmail!: string | undefined;
    workEmail!: string;
    fullName!: string | undefined;
    peopleGroupId!: number | undefined;
    niNumber!: string | undefined;
    profilePic!: string | undefined;
    workMobile!: string | undefined;
    defaultMobile!: string;
    dialingCode!: string | undefined;
    subjectSpecialization!: string | undefined;
    selfServiceStatus!: string | undefined;
    employmentStatusId!: number;
    employmentStatus!: string | undefined;
    yearsOfService!: number;
    age!: number;
    department!: string | undefined;
    jobRole!: string | undefined;
    location!: string | undefined;
    pensionerFileNo!: string | undefined;
    pfaId!: number | undefined;
    rsaNumber!: string | undefined;
    stateOfOrigion!: string | undefined;
    lgaOfOrigion!: string | undefined;
    internalAddressLine!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    originCountry!: number | undefined;
    originState!: number | undefined;
    residentialCountry!: number | undefined;
    residentialState!: number | undefined;
    residentialLga!: number | undefined;
    residentialAddress!: string | undefined;
    created_by!: string | undefined;
    bvn!: string | undefined;
    bvnStatus!: number;
    bvnValidationResponse!: string | undefined;
    lastBVNValidation!: Date | undefined;
    deviceId!: number | undefined;
    isOnboarding!: boolean;

    constructor(data?: IEmployeeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeContractId = _data["employeeContractId"];
            this.companyId = _data["companyId"];
            this.subID = _data["subID"];
            this.userId = _data["userId"];
            this.userEmail = _data["userEmail"];
            this.titleId = _data["titleId"];
            this.religionId = _data["religionId"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.serialNo = _data["serialNo"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherNames = _data["otherNames"];
            this.employeeNumber = _data["employeeNumber"];
            this.assignmentNumber = _data["assignmentNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.maritalStatusId = _data["maritalStatusId"];
            this.genderId = _data["genderId"];
            this.lasraaNumber = _data["lasraaNumber"];
            this.regNo = _data["regNo"];
            this.estabFileNo = _data["estabFileNo"];
            this.personalEmail = _data["personalEmail"];
            this.workEmail = _data["workEmail"];
            this.fullName = _data["fullName"];
            this.peopleGroupId = _data["peopleGroupId"];
            this.niNumber = _data["niNumber"];
            this.profilePic = _data["profilePic"];
            this.workMobile = _data["workMobile"];
            this.defaultMobile = _data["defaultMobile"];
            this.dialingCode = _data["dialingCode"];
            this.subjectSpecialization = _data["subjectSpecialization"];
            this.selfServiceStatus = _data["selfServiceStatus"];
            this.employmentStatusId = _data["employmentStatusId"];
            this.employmentStatus = _data["employmentStatus"];
            this.yearsOfService = _data["yearsOfService"];
            this.age = _data["age"];
            this.department = _data["department"];
            this.jobRole = _data["jobRole"];
            this.location = _data["location"];
            this.pensionerFileNo = _data["pensionerFileNo"];
            this.pfaId = _data["pfaId"];
            this.rsaNumber = _data["rsaNumber"];
            this.stateOfOrigion = _data["stateOfOrigion"];
            this.lgaOfOrigion = _data["lgaOfOrigion"];
            this.internalAddressLine = _data["internalAddressLine"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.originCountry = _data["originCountry"];
            this.originState = _data["originState"];
            this.residentialCountry = _data["residentialCountry"];
            this.residentialState = _data["residentialState"];
            this.residentialLga = _data["residentialLga"];
            this.residentialAddress = _data["residentialAddress"];
            this.created_by = _data["created_by"];
            this.bvn = _data["bvn"];
            this.bvnStatus = _data["bvnStatus"];
            this.bvnValidationResponse = _data["bvnValidationResponse"];
            this.lastBVNValidation = _data["lastBVNValidation"] ? new Date(_data["lastBVNValidation"].toString()) : <any>undefined;
            this.deviceId = _data["deviceId"];
            this.isOnboarding = _data["isOnboarding"];
        }
    }

    static fromJS(data: any): EmployeeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeContractId"] = this.employeeContractId;
        data["companyId"] = this.companyId;
        data["subID"] = this.subID;
        data["userId"] = this.userId;
        data["userEmail"] = this.userEmail;
        data["titleId"] = this.titleId;
        data["religionId"] = this.religionId;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["serialNo"] = this.serialNo;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherNames"] = this.otherNames;
        data["employeeNumber"] = this.employeeNumber;
        data["assignmentNumber"] = this.assignmentNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["maritalStatusId"] = this.maritalStatusId;
        data["genderId"] = this.genderId;
        data["lasraaNumber"] = this.lasraaNumber;
        data["regNo"] = this.regNo;
        data["estabFileNo"] = this.estabFileNo;
        data["personalEmail"] = this.personalEmail;
        data["workEmail"] = this.workEmail;
        data["fullName"] = this.fullName;
        data["peopleGroupId"] = this.peopleGroupId;
        data["niNumber"] = this.niNumber;
        data["profilePic"] = this.profilePic;
        data["workMobile"] = this.workMobile;
        data["defaultMobile"] = this.defaultMobile;
        data["dialingCode"] = this.dialingCode;
        data["subjectSpecialization"] = this.subjectSpecialization;
        data["selfServiceStatus"] = this.selfServiceStatus;
        data["employmentStatusId"] = this.employmentStatusId;
        data["employmentStatus"] = this.employmentStatus;
        data["yearsOfService"] = this.yearsOfService;
        data["age"] = this.age;
        data["department"] = this.department;
        data["jobRole"] = this.jobRole;
        data["location"] = this.location;
        data["pensionerFileNo"] = this.pensionerFileNo;
        data["pfaId"] = this.pfaId;
        data["rsaNumber"] = this.rsaNumber;
        data["stateOfOrigion"] = this.stateOfOrigion;
        data["lgaOfOrigion"] = this.lgaOfOrigion;
        data["internalAddressLine"] = this.internalAddressLine;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["originCountry"] = this.originCountry;
        data["originState"] = this.originState;
        data["residentialCountry"] = this.residentialCountry;
        data["residentialState"] = this.residentialState;
        data["residentialLga"] = this.residentialLga;
        data["residentialAddress"] = this.residentialAddress;
        data["created_by"] = this.created_by;
        data["bvn"] = this.bvn;
        data["bvnStatus"] = this.bvnStatus;
        data["bvnValidationResponse"] = this.bvnValidationResponse;
        data["lastBVNValidation"] = this.lastBVNValidation ? this.lastBVNValidation.toISOString() : <any>undefined;
        data["deviceId"] = this.deviceId;
        data["isOnboarding"] = this.isOnboarding;
        return data; 
    }

    clone(): EmployeeDTO {
        const json = this.toJSON();
        let result = new EmployeeDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDTO {
    id: number;
    employeeContractId: number;
    companyId: number;
    subID: number;
    userId: number;
    userEmail: string | undefined;
    titleId: number;
    religionId: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    serialNo: string | undefined;
    firstName: string;
    lastName: string;
    otherNames: string | undefined;
    employeeNumber: string;
    assignmentNumber: string | undefined;
    dateOfBirth: Date | undefined;
    maritalStatusId: number;
    genderId: number;
    lasraaNumber: string | undefined;
    regNo: string | undefined;
    estabFileNo: string | undefined;
    personalEmail: string | undefined;
    workEmail: string;
    fullName: string | undefined;
    peopleGroupId: number | undefined;
    niNumber: string | undefined;
    profilePic: string | undefined;
    workMobile: string | undefined;
    defaultMobile: string;
    dialingCode: string | undefined;
    subjectSpecialization: string | undefined;
    selfServiceStatus: string | undefined;
    employmentStatusId: number;
    employmentStatus: string | undefined;
    yearsOfService: number;
    age: number;
    department: string | undefined;
    jobRole: string | undefined;
    location: string | undefined;
    pensionerFileNo: string | undefined;
    pfaId: number | undefined;
    rsaNumber: string | undefined;
    stateOfOrigion: string | undefined;
    lgaOfOrigion: string | undefined;
    internalAddressLine: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    originCountry: number | undefined;
    originState: number | undefined;
    residentialCountry: number | undefined;
    residentialState: number | undefined;
    residentialLga: number | undefined;
    residentialAddress: string | undefined;
    created_by: string | undefined;
    bvn: string | undefined;
    bvnStatus: number;
    bvnValidationResponse: string | undefined;
    lastBVNValidation: Date | undefined;
    deviceId: number | undefined;
    isOnboarding: boolean;
}

export class File implements IFile {

    constructor(data?: IFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): File {
        data = typeof data === 'object' ? data : {};
        let result = new File();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): File {
        const json = this.toJSON();
        let result = new File();
        result.init(json);
        return result;
    }
}

export interface IFile {
}

export class DropdownValueDTO implements IDropdownValueDTO {
    option_text!: string | undefined;
    option_value!: number;
    employee_number!: string | undefined;
    company_id!: number;
    subsidary_id!: number;

    constructor(data?: IDropdownValueDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.option_text = _data["option_text"];
            this.option_value = _data["option_value"];
            this.employee_number = _data["employee_number"];
            this.company_id = _data["company_id"];
            this.subsidary_id = _data["subsidary_id"];
        }
    }

    static fromJS(data: any): DropdownValueDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValueDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["option_text"] = this.option_text;
        data["option_value"] = this.option_value;
        data["employee_number"] = this.employee_number;
        data["company_id"] = this.company_id;
        data["subsidary_id"] = this.subsidary_id;
        return data; 
    }

    clone(): DropdownValueDTO {
        const json = this.toJSON();
        let result = new DropdownValueDTO();
        result.init(json);
        return result;
    }
}

export interface IDropdownValueDTO {
    option_text: string | undefined;
    option_value: number;
    employee_number: string | undefined;
    company_id: number;
    subsidary_id: number;
}

export class DropdownValueDTOIListApiResult implements IDropdownValueDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DropdownValueDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IDropdownValueDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DropdownValueDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DropdownValueDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValueDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DropdownValueDTOIListApiResult {
        const json = this.toJSON();
        let result = new DropdownValueDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDropdownValueDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DropdownValueDTO[] | undefined;
    totalCount: number;
}

export class EmployeeDTOApiResult implements IEmployeeDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeDTO;
    totalCount!: number;

    constructor(data?: IEmployeeDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmployeeDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmployeeDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmployeeDTOApiResult {
        const json = this.toJSON();
        let result = new EmployeeDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeDTO;
    totalCount: number;
}

export class EmployeeDTOIListApiResult implements IEmployeeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IEmployeeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmployeeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmployeeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmployeeDTOIListApiResult {
        const json = this.toJSON();
        let result = new EmployeeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeDTO[] | undefined;
    totalCount: number;
}

export class EmployeeContractAssignmentDTO implements IEmployeeContractAssignmentDTO {
    sn!: number;
    id!: number;
    _id!: string | undefined;
    companyID!: number;
    subID!: number;
    supNumber!: string | undefined;
    assignmentNumber!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    otherName!: string | undefined;
    employeeId!: number;
    employmentTypeId!: number;
    contractEndDate!: Date | undefined;
    supervisorId!: number | undefined;
    supervisorName!: string | undefined;
    fullName!: string | undefined;
    departmentId!: number | undefined;
    departmentName!: string | undefined;
    jobId!: number;
    jobName!: string | undefined;
    gradeId!: number | undefined;
    gradeName!: string | undefined;
    gradeStepId!: number | undefined;
    stepNo!: string | undefined;
    locationId!: number;
    locationName!: string | undefined;
    locationCode!: string | undefined;
    positionId!: number | undefined;
    positionName!: string | undefined;
    ministryId!: number | undefined;
    ministryName!: string | undefined;
    salaryScaleId!: number | undefined;
    salaryScaleName!: string | undefined;
    dateofPresentAppointment!: Date;
    dateofPresentAppointmentStr!: string | undefined;
    dateOfAppointment!: Date;
    dateOfAppointmentStr!: string | undefined;
    dateOfLastDeployment!: Date | undefined;
    dateOfLastDeploymentStr!: string | undefined;
    dateOfConversion!: Date | undefined;
    dateOfConversionStr!: string | undefined;
    dateOfConfirmation!: Date | undefined;
    dateOfConfirmationStr!: string | undefined;
    dateDeployed!: Date | undefined;
    dateDeployedStr!: string | undefined;
    contractEndDateStr!: string | undefined;
    datePromotion!: Date | undefined;
    datePromotionStr!: string | undefined;
    dateOfRetirement!: Date | undefined;
    dateOfRetirementStr!: string | undefined;
    totalEarnings!: number | undefined;
    totalDeductions!: number | undefined;
    netPayment!: number | undefined;
    isContractActive!: boolean;
    isDefaultContract!: boolean;
    noOfLeaveDays!: number | undefined;
    peopleGroupId!: number | undefined;
    lastPromotionDate!: Date | undefined;
    url!: string | undefined;
    payRollTypeId!: number;
    cadreId!: number;
    directorate_id!: number;
    lcda_id!: number;
    lga_id!: number;

    constructor(data?: IEmployeeContractAssignmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sn = _data["sn"];
            this.id = _data["id"];
            this._id = _data["_id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.supNumber = _data["supNumber"];
            this.assignmentNumber = _data["assignmentNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherName = _data["otherName"];
            this.employeeId = _data["employeeId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.contractEndDate = _data["contractEndDate"] ? new Date(_data["contractEndDate"].toString()) : <any>undefined;
            this.supervisorId = _data["supervisorId"];
            this.supervisorName = _data["supervisorName"];
            this.fullName = _data["fullName"];
            this.departmentId = _data["departmentId"];
            this.departmentName = _data["departmentName"];
            this.jobId = _data["jobId"];
            this.jobName = _data["jobName"];
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.gradeStepId = _data["gradeStepId"];
            this.stepNo = _data["stepNo"];
            this.locationId = _data["locationId"];
            this.locationName = _data["locationName"];
            this.locationCode = _data["locationCode"];
            this.positionId = _data["positionId"];
            this.positionName = _data["positionName"];
            this.ministryId = _data["ministryId"];
            this.ministryName = _data["ministryName"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.salaryScaleName = _data["salaryScaleName"];
            this.dateofPresentAppointment = _data["dateofPresentAppointment"] ? new Date(_data["dateofPresentAppointment"].toString()) : <any>undefined;
            this.dateofPresentAppointmentStr = _data["dateofPresentAppointmentStr"];
            this.dateOfAppointment = _data["dateOfAppointment"] ? new Date(_data["dateOfAppointment"].toString()) : <any>undefined;
            this.dateOfAppointmentStr = _data["dateOfAppointmentStr"];
            this.dateOfLastDeployment = _data["dateOfLastDeployment"] ? new Date(_data["dateOfLastDeployment"].toString()) : <any>undefined;
            this.dateOfLastDeploymentStr = _data["dateOfLastDeploymentStr"];
            this.dateOfConversion = _data["dateOfConversion"] ? new Date(_data["dateOfConversion"].toString()) : <any>undefined;
            this.dateOfConversionStr = _data["dateOfConversionStr"];
            this.dateOfConfirmation = _data["dateOfConfirmation"] ? new Date(_data["dateOfConfirmation"].toString()) : <any>undefined;
            this.dateOfConfirmationStr = _data["dateOfConfirmationStr"];
            this.dateDeployed = _data["dateDeployed"] ? new Date(_data["dateDeployed"].toString()) : <any>undefined;
            this.dateDeployedStr = _data["dateDeployedStr"];
            this.contractEndDateStr = _data["contractEndDateStr"];
            this.datePromotion = _data["datePromotion"] ? new Date(_data["datePromotion"].toString()) : <any>undefined;
            this.datePromotionStr = _data["datePromotionStr"];
            this.dateOfRetirement = _data["dateOfRetirement"] ? new Date(_data["dateOfRetirement"].toString()) : <any>undefined;
            this.dateOfRetirementStr = _data["dateOfRetirementStr"];
            this.totalEarnings = _data["totalEarnings"];
            this.totalDeductions = _data["totalDeductions"];
            this.netPayment = _data["netPayment"];
            this.isContractActive = _data["isContractActive"];
            this.isDefaultContract = _data["isDefaultContract"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.peopleGroupId = _data["peopleGroupId"];
            this.lastPromotionDate = _data["lastPromotionDate"] ? new Date(_data["lastPromotionDate"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.payRollTypeId = _data["payRollTypeId"];
            this.cadreId = _data["cadreId"];
            this.directorate_id = _data["directorate_id"];
            this.lcda_id = _data["lcda_id"];
            this.lga_id = _data["lga_id"];
        }
    }

    static fromJS(data: any): EmployeeContractAssignmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeContractAssignmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sn"] = this.sn;
        data["id"] = this.id;
        data["_id"] = this._id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["supNumber"] = this.supNumber;
        data["assignmentNumber"] = this.assignmentNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherName"] = this.otherName;
        data["employeeId"] = this.employeeId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["contractEndDate"] = this.contractEndDate ? this.contractEndDate.toISOString() : <any>undefined;
        data["supervisorId"] = this.supervisorId;
        data["supervisorName"] = this.supervisorName;
        data["fullName"] = this.fullName;
        data["departmentId"] = this.departmentId;
        data["departmentName"] = this.departmentName;
        data["jobId"] = this.jobId;
        data["jobName"] = this.jobName;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["gradeStepId"] = this.gradeStepId;
        data["stepNo"] = this.stepNo;
        data["locationId"] = this.locationId;
        data["locationName"] = this.locationName;
        data["locationCode"] = this.locationCode;
        data["positionId"] = this.positionId;
        data["positionName"] = this.positionName;
        data["ministryId"] = this.ministryId;
        data["ministryName"] = this.ministryName;
        data["salaryScaleId"] = this.salaryScaleId;
        data["salaryScaleName"] = this.salaryScaleName;
        data["dateofPresentAppointment"] = this.dateofPresentAppointment ? this.dateofPresentAppointment.toISOString() : <any>undefined;
        data["dateofPresentAppointmentStr"] = this.dateofPresentAppointmentStr;
        data["dateOfAppointment"] = this.dateOfAppointment ? this.dateOfAppointment.toISOString() : <any>undefined;
        data["dateOfAppointmentStr"] = this.dateOfAppointmentStr;
        data["dateOfLastDeployment"] = this.dateOfLastDeployment ? this.dateOfLastDeployment.toISOString() : <any>undefined;
        data["dateOfLastDeploymentStr"] = this.dateOfLastDeploymentStr;
        data["dateOfConversion"] = this.dateOfConversion ? this.dateOfConversion.toISOString() : <any>undefined;
        data["dateOfConversionStr"] = this.dateOfConversionStr;
        data["dateOfConfirmation"] = this.dateOfConfirmation ? this.dateOfConfirmation.toISOString() : <any>undefined;
        data["dateOfConfirmationStr"] = this.dateOfConfirmationStr;
        data["dateDeployed"] = this.dateDeployed ? this.dateDeployed.toISOString() : <any>undefined;
        data["dateDeployedStr"] = this.dateDeployedStr;
        data["contractEndDateStr"] = this.contractEndDateStr;
        data["datePromotion"] = this.datePromotion ? this.datePromotion.toISOString() : <any>undefined;
        data["datePromotionStr"] = this.datePromotionStr;
        data["dateOfRetirement"] = this.dateOfRetirement ? this.dateOfRetirement.toISOString() : <any>undefined;
        data["dateOfRetirementStr"] = this.dateOfRetirementStr;
        data["totalEarnings"] = this.totalEarnings;
        data["totalDeductions"] = this.totalDeductions;
        data["netPayment"] = this.netPayment;
        data["isContractActive"] = this.isContractActive;
        data["isDefaultContract"] = this.isDefaultContract;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["peopleGroupId"] = this.peopleGroupId;
        data["lastPromotionDate"] = this.lastPromotionDate ? this.lastPromotionDate.toISOString() : <any>undefined;
        data["url"] = this.url;
        data["payRollTypeId"] = this.payRollTypeId;
        data["cadreId"] = this.cadreId;
        data["directorate_id"] = this.directorate_id;
        data["lcda_id"] = this.lcda_id;
        data["lga_id"] = this.lga_id;
        return data; 
    }

    clone(): EmployeeContractAssignmentDTO {
        const json = this.toJSON();
        let result = new EmployeeContractAssignmentDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeContractAssignmentDTO {
    sn: number;
    id: number;
    _id: string | undefined;
    companyID: number;
    subID: number;
    supNumber: string | undefined;
    assignmentNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    otherName: string | undefined;
    employeeId: number;
    employmentTypeId: number;
    contractEndDate: Date | undefined;
    supervisorId: number | undefined;
    supervisorName: string | undefined;
    fullName: string | undefined;
    departmentId: number | undefined;
    departmentName: string | undefined;
    jobId: number;
    jobName: string | undefined;
    gradeId: number | undefined;
    gradeName: string | undefined;
    gradeStepId: number | undefined;
    stepNo: string | undefined;
    locationId: number;
    locationName: string | undefined;
    locationCode: string | undefined;
    positionId: number | undefined;
    positionName: string | undefined;
    ministryId: number | undefined;
    ministryName: string | undefined;
    salaryScaleId: number | undefined;
    salaryScaleName: string | undefined;
    dateofPresentAppointment: Date;
    dateofPresentAppointmentStr: string | undefined;
    dateOfAppointment: Date;
    dateOfAppointmentStr: string | undefined;
    dateOfLastDeployment: Date | undefined;
    dateOfLastDeploymentStr: string | undefined;
    dateOfConversion: Date | undefined;
    dateOfConversionStr: string | undefined;
    dateOfConfirmation: Date | undefined;
    dateOfConfirmationStr: string | undefined;
    dateDeployed: Date | undefined;
    dateDeployedStr: string | undefined;
    contractEndDateStr: string | undefined;
    datePromotion: Date | undefined;
    datePromotionStr: string | undefined;
    dateOfRetirement: Date | undefined;
    dateOfRetirementStr: string | undefined;
    totalEarnings: number | undefined;
    totalDeductions: number | undefined;
    netPayment: number | undefined;
    isContractActive: boolean;
    isDefaultContract: boolean;
    noOfLeaveDays: number | undefined;
    peopleGroupId: number | undefined;
    lastPromotionDate: Date | undefined;
    url: string | undefined;
    payRollTypeId: number;
    cadreId: number;
    directorate_id: number;
    lcda_id: number;
    lga_id: number;
}

export class EmployeeContractAssignmentDTOApiResult implements IEmployeeContractAssignmentDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeContractAssignmentDTO;
    totalCount!: number;

    constructor(data?: IEmployeeContractAssignmentDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmployeeContractAssignmentDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmployeeContractAssignmentDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeContractAssignmentDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmployeeContractAssignmentDTOApiResult {
        const json = this.toJSON();
        let result = new EmployeeContractAssignmentDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeContractAssignmentDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeContractAssignmentDTO;
    totalCount: number;
}

export class ManageEventDTO implements IManageEventDTO {
    title!: string;
    id!: number;
    notify_Employee!: boolean;
    file!: string | undefined;

    constructor(data?: IManageEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.id = _data["id"];
            this.notify_Employee = _data["notify_Employee"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): ManageEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["id"] = this.id;
        data["notify_Employee"] = this.notify_Employee;
        data["file"] = this.file;
        return data; 
    }

    clone(): ManageEventDTO {
        const json = this.toJSON();
        let result = new ManageEventDTO();
        result.init(json);
        return result;
    }
}

export interface IManageEventDTO {
    title: string;
    id: number;
    notify_Employee: boolean;
    file: string | undefined;
}

export class EventDTO implements IEventDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    eventName!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    eventTypeID!: number;
    title!: string | undefined;
    isSystem!: boolean;
    notify_Employee!: boolean;
    file!: string | undefined;

    constructor(data?: IEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.eventName = _data["eventName"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.eventTypeID = _data["eventTypeID"];
            this.title = _data["title"];
            this.isSystem = _data["isSystem"];
            this.notify_Employee = _data["notify_Employee"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): EventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["eventName"] = this.eventName;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["eventTypeID"] = this.eventTypeID;
        data["title"] = this.title;
        data["isSystem"] = this.isSystem;
        data["notify_Employee"] = this.notify_Employee;
        data["file"] = this.file;
        return data; 
    }

    clone(): EventDTO {
        const json = this.toJSON();
        let result = new EventDTO();
        result.init(json);
        return result;
    }
}

export interface IEventDTO {
    id: number;
    companyID: number;
    subID: number;
    eventName: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    eventTypeID: number;
    title: string | undefined;
    isSystem: boolean;
    notify_Employee: boolean;
    file: string | undefined;
}

export class EventDTOListApiResult implements IEventDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EventDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IEventDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EventDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EventDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EventDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EventDTOListApiResult {
        const json = this.toJSON();
        let result = new EventDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEventDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EventDTO[] | undefined;
    totalCount: number;
}

export class EventDTOApiResult implements IEventDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EventDTO;
    totalCount!: number;

    constructor(data?: IEventDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EventDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EventDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EventDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EventDTOApiResult {
        const json = this.toJSON();
        let result = new EventDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEventDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EventDTO;
    totalCount: number;
}

export class ExpenseGroupDto implements IExpenseGroupDto {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    referenceId!: string | undefined;

    constructor(data?: IExpenseGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.referenceId = _data["referenceId"];
        }
    }

    static fromJS(data: any): ExpenseGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["referenceId"] = this.referenceId;
        return data; 
    }

    clone(): ExpenseGroupDto {
        const json = this.toJSON();
        let result = new ExpenseGroupDto();
        result.init(json);
        return result;
    }
}

export interface IExpenseGroupDto {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    referenceId: string | undefined;
}

export class ExpenseGroup implements IExpenseGroup {
    name!: string | undefined;
    referenceId!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.referenceId = _data["referenceId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseGroup {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["referenceId"] = this.referenceId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseGroup {
        const json = this.toJSON();
        let result = new ExpenseGroup();
        result.init(json);
        return result;
    }
}

export interface IExpenseGroup {
    name: string | undefined;
    referenceId: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseGroupIListApiResult implements IExpenseGroupIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ExpenseGroup[] | undefined;
    totalCount!: number;

    constructor(data?: IExpenseGroupIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ExpenseGroup.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ExpenseGroupIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseGroupIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ExpenseGroupIListApiResult {
        const json = this.toJSON();
        let result = new ExpenseGroupIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IExpenseGroupIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ExpenseGroup[] | undefined;
    totalCount: number;
}

export class ExpenseProjectDto implements IExpenseProjectDto {
    id!: number;
    name!: string | undefined;
    companyID!: number;
    subID!: number;
    description!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    ban!: boolean;
    referenceId!: string | undefined;
    code!: string | undefined;
    isClosedEnded!: boolean;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    actionTitle!: string | undefined;
    readonly startDateString!: string | undefined;
    readonly endDateString!: string | undefined;
    status!: string | undefined;

    constructor(data?: IExpenseProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.ban = _data["ban"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isClosedEnded = _data["isClosedEnded"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.actionTitle = _data["actionTitle"];
            (<any>this).startDateString = _data["startDateString"];
            (<any>this).endDateString = _data["endDateString"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ExpenseProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ban"] = this.ban;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isClosedEnded"] = this.isClosedEnded;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["actionTitle"] = this.actionTitle;
        data["startDateString"] = this.startDateString;
        data["endDateString"] = this.endDateString;
        data["status"] = this.status;
        return data; 
    }

    clone(): ExpenseProjectDto {
        const json = this.toJSON();
        let result = new ExpenseProjectDto();
        result.init(json);
        return result;
    }
}

export interface IExpenseProjectDto {
    id: number;
    name: string | undefined;
    companyID: number;
    subID: number;
    description: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    ban: boolean;
    referenceId: string | undefined;
    code: string | undefined;
    isClosedEnded: boolean;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    actionTitle: string | undefined;
    startDateString: string | undefined;
    endDateString: string | undefined;
    status: string | undefined;
}

export class ExpenseDoc implements IExpenseDoc {
    expenseId!: number;
    path!: string | undefined;
    docType!: number;
    expense!: Expense;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseDoc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expenseId = _data["expenseId"];
            this.path = _data["path"];
            this.docType = _data["docType"];
            this.expense = _data["expense"] ? Expense.fromJS(_data["expense"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseDoc {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseDoc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expenseId"] = this.expenseId;
        data["path"] = this.path;
        data["docType"] = this.docType;
        data["expense"] = this.expense ? this.expense.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseDoc {
        const json = this.toJSON();
        let result = new ExpenseDoc();
        result.init(json);
        return result;
    }
}

export interface IExpenseDoc {
    expenseId: number;
    path: string | undefined;
    docType: number;
    expense: Expense;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseSubType implements IExpenseSubType {
    expenseTypeId!: number;
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    referenceId!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    approvalProcessId!: number | undefined;
    budgetedAmount!: number | undefined;
    currentAmount!: number | undefined;
    strBudgetedAmount!: string | undefined;
    strCurrentAmount!: string | undefined;
    expenses!: Expense[] | undefined;
    expenseType!: ExpenseType;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseSubType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expenseTypeId = _data["expenseTypeId"];
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.budgetedAmount = _data["budgetedAmount"];
            this.currentAmount = _data["currentAmount"];
            this.strBudgetedAmount = _data["strBudgetedAmount"];
            this.strCurrentAmount = _data["strCurrentAmount"];
            if (Array.isArray(_data["expenses"])) {
                this.expenses = [] as any;
                for (let item of _data["expenses"])
                    this.expenses!.push(Expense.fromJS(item));
            }
            this.expenseType = _data["expenseType"] ? ExpenseType.fromJS(_data["expenseType"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseSubType {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseSubType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expenseTypeId"] = this.expenseTypeId;
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["approvalProcessId"] = this.approvalProcessId;
        data["budgetedAmount"] = this.budgetedAmount;
        data["currentAmount"] = this.currentAmount;
        data["strBudgetedAmount"] = this.strBudgetedAmount;
        data["strCurrentAmount"] = this.strCurrentAmount;
        if (Array.isArray(this.expenses)) {
            data["expenses"] = [];
            for (let item of this.expenses)
                data["expenses"].push(item.toJSON());
        }
        data["expenseType"] = this.expenseType ? this.expenseType.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseSubType {
        const json = this.toJSON();
        let result = new ExpenseSubType();
        result.init(json);
        return result;
    }
}

export interface IExpenseSubType {
    expenseTypeId: number;
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    referenceId: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    approvalProcessId: number | undefined;
    budgetedAmount: number | undefined;
    currentAmount: number | undefined;
    strBudgetedAmount: string | undefined;
    strCurrentAmount: string | undefined;
    expenses: Expense[] | undefined;
    expenseType: ExpenseType;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseType implements IExpenseType {
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    referenceId!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    expenses!: Expense[] | undefined;
    expenseSubTypes!: ExpenseSubType[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["expenses"])) {
                this.expenses = [] as any;
                for (let item of _data["expenses"])
                    this.expenses!.push(Expense.fromJS(item));
            }
            if (Array.isArray(_data["expenseSubTypes"])) {
                this.expenseSubTypes = [] as any;
                for (let item of _data["expenseSubTypes"])
                    this.expenseSubTypes!.push(ExpenseSubType.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseType {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.expenses)) {
            data["expenses"] = [];
            for (let item of this.expenses)
                data["expenses"].push(item.toJSON());
        }
        if (Array.isArray(this.expenseSubTypes)) {
            data["expenseSubTypes"] = [];
            for (let item of this.expenseSubTypes)
                data["expenseSubTypes"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseType {
        const json = this.toJSON();
        let result = new ExpenseType();
        result.init(json);
        return result;
    }
}

export interface IExpenseType {
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    referenceId: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    expenses: Expense[] | undefined;
    expenseSubTypes: ExpenseSubType[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseProjectActivity implements IExpenseProjectActivity {
    expenseProjectId!: number;
    name!: string | undefined;
    description!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    closedEnded!: boolean | undefined;
    ban!: boolean;
    referenceId!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    expenses!: Expense[] | undefined;
    expenseProject!: ExpenseProject;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseProjectActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expenseProjectId = _data["expenseProjectId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.closedEnded = _data["closedEnded"];
            this.ban = _data["ban"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["expenses"])) {
                this.expenses = [] as any;
                for (let item of _data["expenses"])
                    this.expenses!.push(Expense.fromJS(item));
            }
            this.expenseProject = _data["expenseProject"] ? ExpenseProject.fromJS(_data["expenseProject"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseProjectActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseProjectActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expenseProjectId"] = this.expenseProjectId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["closedEnded"] = this.closedEnded;
        data["ban"] = this.ban;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.expenses)) {
            data["expenses"] = [];
            for (let item of this.expenses)
                data["expenses"].push(item.toJSON());
        }
        data["expenseProject"] = this.expenseProject ? this.expenseProject.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseProjectActivity {
        const json = this.toJSON();
        let result = new ExpenseProjectActivity();
        result.init(json);
        return result;
    }
}

export interface IExpenseProjectActivity {
    expenseProjectId: number;
    name: string | undefined;
    description: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    closedEnded: boolean | undefined;
    ban: boolean;
    referenceId: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    expenses: Expense[] | undefined;
    expenseProject: ExpenseProject;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Expense implements IExpense {
    refNo!: string | undefined;
    title!: string | undefined;
    description!: string | undefined;
    expenseSubTypeId!: number | undefined;
    expenseTypeId!: number;
    loggedByUserId!: number;
    loggedForEmployeeId!: number | undefined;
    expenseProjectActivityId!: number | undefined;
    expenseProjectId!: number;
    requestedAmount!: number;
    approvedAmount!: number;
    dateIncurred!: Date;
    dateReconciled!: Date | undefined;
    dateDisbursed!: Date | undefined;
    disburseComment!: string | undefined;
    dateApproved!: Date | undefined;
    reconciledStatus!: boolean;
    reconciledBy!: number | undefined;
    disbursedBy!: string | undefined;
    approvedBy!: number | undefined;
    departmentId!: number;
    declineReason!: string | undefined;
    disbursementType!: number | undefined;
    is_disbursed!: boolean;
    log_status!: number;
    approvalProcessId!: number;
    expenseGroupId!: number;
    expenseDocs!: ExpenseDoc[] | undefined;
    expenseType!: ExpenseType;
    expenseSubType!: ExpenseSubType;
    expenseProjectActivity!: ExpenseProjectActivity;
    expenseProject!: ExpenseProject;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpense) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refNo = _data["refNo"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.expenseSubTypeId = _data["expenseSubTypeId"];
            this.expenseTypeId = _data["expenseTypeId"];
            this.loggedByUserId = _data["loggedByUserId"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.expenseProjectActivityId = _data["expenseProjectActivityId"];
            this.expenseProjectId = _data["expenseProjectId"];
            this.requestedAmount = _data["requestedAmount"];
            this.approvedAmount = _data["approvedAmount"];
            this.dateIncurred = _data["dateIncurred"] ? new Date(_data["dateIncurred"].toString()) : <any>undefined;
            this.dateReconciled = _data["dateReconciled"] ? new Date(_data["dateReconciled"].toString()) : <any>undefined;
            this.dateDisbursed = _data["dateDisbursed"] ? new Date(_data["dateDisbursed"].toString()) : <any>undefined;
            this.disburseComment = _data["disburseComment"];
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.reconciledStatus = _data["reconciledStatus"];
            this.reconciledBy = _data["reconciledBy"];
            this.disbursedBy = _data["disbursedBy"];
            this.approvedBy = _data["approvedBy"];
            this.departmentId = _data["departmentId"];
            this.declineReason = _data["declineReason"];
            this.disbursementType = _data["disbursementType"];
            this.is_disbursed = _data["is_disbursed"];
            this.log_status = _data["log_status"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.expenseGroupId = _data["expenseGroupId"];
            if (Array.isArray(_data["expenseDocs"])) {
                this.expenseDocs = [] as any;
                for (let item of _data["expenseDocs"])
                    this.expenseDocs!.push(ExpenseDoc.fromJS(item));
            }
            this.expenseType = _data["expenseType"] ? ExpenseType.fromJS(_data["expenseType"]) : <any>undefined;
            this.expenseSubType = _data["expenseSubType"] ? ExpenseSubType.fromJS(_data["expenseSubType"]) : <any>undefined;
            this.expenseProjectActivity = _data["expenseProjectActivity"] ? ExpenseProjectActivity.fromJS(_data["expenseProjectActivity"]) : <any>undefined;
            this.expenseProject = _data["expenseProject"] ? ExpenseProject.fromJS(_data["expenseProject"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Expense {
        data = typeof data === 'object' ? data : {};
        let result = new Expense();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refNo"] = this.refNo;
        data["title"] = this.title;
        data["description"] = this.description;
        data["expenseSubTypeId"] = this.expenseSubTypeId;
        data["expenseTypeId"] = this.expenseTypeId;
        data["loggedByUserId"] = this.loggedByUserId;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["expenseProjectActivityId"] = this.expenseProjectActivityId;
        data["expenseProjectId"] = this.expenseProjectId;
        data["requestedAmount"] = this.requestedAmount;
        data["approvedAmount"] = this.approvedAmount;
        data["dateIncurred"] = this.dateIncurred ? this.dateIncurred.toISOString() : <any>undefined;
        data["dateReconciled"] = this.dateReconciled ? this.dateReconciled.toISOString() : <any>undefined;
        data["dateDisbursed"] = this.dateDisbursed ? this.dateDisbursed.toISOString() : <any>undefined;
        data["disburseComment"] = this.disburseComment;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["reconciledStatus"] = this.reconciledStatus;
        data["reconciledBy"] = this.reconciledBy;
        data["disbursedBy"] = this.disbursedBy;
        data["approvedBy"] = this.approvedBy;
        data["departmentId"] = this.departmentId;
        data["declineReason"] = this.declineReason;
        data["disbursementType"] = this.disbursementType;
        data["is_disbursed"] = this.is_disbursed;
        data["log_status"] = this.log_status;
        data["approvalProcessId"] = this.approvalProcessId;
        data["expenseGroupId"] = this.expenseGroupId;
        if (Array.isArray(this.expenseDocs)) {
            data["expenseDocs"] = [];
            for (let item of this.expenseDocs)
                data["expenseDocs"].push(item.toJSON());
        }
        data["expenseType"] = this.expenseType ? this.expenseType.toJSON() : <any>undefined;
        data["expenseSubType"] = this.expenseSubType ? this.expenseSubType.toJSON() : <any>undefined;
        data["expenseProjectActivity"] = this.expenseProjectActivity ? this.expenseProjectActivity.toJSON() : <any>undefined;
        data["expenseProject"] = this.expenseProject ? this.expenseProject.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Expense {
        const json = this.toJSON();
        let result = new Expense();
        result.init(json);
        return result;
    }
}

export interface IExpense {
    refNo: string | undefined;
    title: string | undefined;
    description: string | undefined;
    expenseSubTypeId: number | undefined;
    expenseTypeId: number;
    loggedByUserId: number;
    loggedForEmployeeId: number | undefined;
    expenseProjectActivityId: number | undefined;
    expenseProjectId: number;
    requestedAmount: number;
    approvedAmount: number;
    dateIncurred: Date;
    dateReconciled: Date | undefined;
    dateDisbursed: Date | undefined;
    disburseComment: string | undefined;
    dateApproved: Date | undefined;
    reconciledStatus: boolean;
    reconciledBy: number | undefined;
    disbursedBy: string | undefined;
    approvedBy: number | undefined;
    departmentId: number;
    declineReason: string | undefined;
    disbursementType: number | undefined;
    is_disbursed: boolean;
    log_status: number;
    approvalProcessId: number;
    expenseGroupId: number;
    expenseDocs: ExpenseDoc[] | undefined;
    expenseType: ExpenseType;
    expenseSubType: ExpenseSubType;
    expenseProjectActivity: ExpenseProjectActivity;
    expenseProject: ExpenseProject;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseProject implements IExpenseProject {
    name!: string | undefined;
    description!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    ban!: boolean;
    referenceId!: string | undefined;
    code!: string | undefined;
    isClosedEnded!: boolean;
    expenses!: Expense[] | undefined;
    expenseProjectActivities!: ExpenseProjectActivity[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.ban = _data["ban"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isClosedEnded = _data["isClosedEnded"];
            if (Array.isArray(_data["expenses"])) {
                this.expenses = [] as any;
                for (let item of _data["expenses"])
                    this.expenses!.push(Expense.fromJS(item));
            }
            if (Array.isArray(_data["expenseProjectActivities"])) {
                this.expenseProjectActivities = [] as any;
                for (let item of _data["expenseProjectActivities"])
                    this.expenseProjectActivities!.push(ExpenseProjectActivity.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseProject {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ban"] = this.ban;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isClosedEnded"] = this.isClosedEnded;
        if (Array.isArray(this.expenses)) {
            data["expenses"] = [];
            for (let item of this.expenses)
                data["expenses"].push(item.toJSON());
        }
        if (Array.isArray(this.expenseProjectActivities)) {
            data["expenseProjectActivities"] = [];
            for (let item of this.expenseProjectActivities)
                data["expenseProjectActivities"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseProject {
        const json = this.toJSON();
        let result = new ExpenseProject();
        result.init(json);
        return result;
    }
}

export interface IExpenseProject {
    name: string | undefined;
    description: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    ban: boolean;
    referenceId: string | undefined;
    code: string | undefined;
    isClosedEnded: boolean;
    expenses: Expense[] | undefined;
    expenseProjectActivities: ExpenseProjectActivity[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseDTO implements IExpenseDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    approvalProcessId!: number;
    title!: string | undefined;
    description!: string | undefined;
    expenseSubTypeId!: number | undefined;
    expenseSubTypeName!: string | undefined;
    expenseTypeId!: number;
    expenseTypeName!: string | undefined;
    loggedByUserId!: number;
    loggedByUsername!: string | undefined;
    loggedForEmployeeId!: number | undefined;
    loggedForEmployeeName!: string | undefined;
    loggedForEmployeeNo!: string | undefined;
    expenseProjectActivityId!: number | undefined;
    expenseProjectActivityName!: string | undefined;
    expenseProjectId!: number;
    expenseProjectName!: string | undefined;
    requestedAmount!: number;
    approvedAmount!: number;
    dateIncurred!: Date | undefined;
    dateReconciled!: Date | undefined;
    dateDisbursed!: Date | undefined;
    disburseComment!: string | undefined;
    dateApproved!: Date | undefined;
    reconciledStatus!: boolean;
    reconciledBy!: number | undefined;
    reconciledByName!: string | undefined;
    disbursedBy!: string | undefined;
    disbursedByName!: string | undefined;
    approvedBy!: number | undefined;
    approvedByName!: string | undefined;
    refNo!: string | undefined;
    departmentId!: number;
    declineReason!: string | undefined;
    disbursementType!: number | undefined;
    is_disbursed!: boolean;
    log_status!: number;
    expenseGroupId!: number;
    expenseGroupName!: string | undefined;
    strRequestedAmount!: string | undefined;
    strApprovedAmount!: string | undefined;
    strDateIncurred!: string | undefined;
    _ServerDocURL!: string | undefined;
    tempRef!: string | undefined;
    departmentName!: string | undefined;
    locatioName!: string | undefined;

    constructor(data?: IExpenseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.expenseSubTypeId = _data["expenseSubTypeId"];
            this.expenseSubTypeName = _data["expenseSubTypeName"];
            this.expenseTypeId = _data["expenseTypeId"];
            this.expenseTypeName = _data["expenseTypeName"];
            this.loggedByUserId = _data["loggedByUserId"];
            this.loggedByUsername = _data["loggedByUsername"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.loggedForEmployeeName = _data["loggedForEmployeeName"];
            this.loggedForEmployeeNo = _data["loggedForEmployeeNo"];
            this.expenseProjectActivityId = _data["expenseProjectActivityId"];
            this.expenseProjectActivityName = _data["expenseProjectActivityName"];
            this.expenseProjectId = _data["expenseProjectId"];
            this.expenseProjectName = _data["expenseProjectName"];
            this.requestedAmount = _data["requestedAmount"];
            this.approvedAmount = _data["approvedAmount"];
            this.dateIncurred = _data["dateIncurred"] ? new Date(_data["dateIncurred"].toString()) : <any>undefined;
            this.dateReconciled = _data["dateReconciled"] ? new Date(_data["dateReconciled"].toString()) : <any>undefined;
            this.dateDisbursed = _data["dateDisbursed"] ? new Date(_data["dateDisbursed"].toString()) : <any>undefined;
            this.disburseComment = _data["disburseComment"];
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.reconciledStatus = _data["reconciledStatus"];
            this.reconciledBy = _data["reconciledBy"];
            this.reconciledByName = _data["reconciledByName"];
            this.disbursedBy = _data["disbursedBy"];
            this.disbursedByName = _data["disbursedByName"];
            this.approvedBy = _data["approvedBy"];
            this.approvedByName = _data["approvedByName"];
            this.refNo = _data["refNo"];
            this.departmentId = _data["departmentId"];
            this.declineReason = _data["declineReason"];
            this.disbursementType = _data["disbursementType"];
            this.is_disbursed = _data["is_disbursed"];
            this.log_status = _data["log_status"];
            this.expenseGroupId = _data["expenseGroupId"];
            this.expenseGroupName = _data["expenseGroupName"];
            this.strRequestedAmount = _data["strRequestedAmount"];
            this.strApprovedAmount = _data["strApprovedAmount"];
            this.strDateIncurred = _data["strDateIncurred"];
            this._ServerDocURL = _data["_ServerDocURL"];
            this.tempRef = _data["tempRef"];
            this.departmentName = _data["departmentName"];
            this.locatioName = _data["locatioName"];
        }
    }

    static fromJS(data: any): ExpenseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["approvalProcessId"] = this.approvalProcessId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["expenseSubTypeId"] = this.expenseSubTypeId;
        data["expenseSubTypeName"] = this.expenseSubTypeName;
        data["expenseTypeId"] = this.expenseTypeId;
        data["expenseTypeName"] = this.expenseTypeName;
        data["loggedByUserId"] = this.loggedByUserId;
        data["loggedByUsername"] = this.loggedByUsername;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["loggedForEmployeeName"] = this.loggedForEmployeeName;
        data["loggedForEmployeeNo"] = this.loggedForEmployeeNo;
        data["expenseProjectActivityId"] = this.expenseProjectActivityId;
        data["expenseProjectActivityName"] = this.expenseProjectActivityName;
        data["expenseProjectId"] = this.expenseProjectId;
        data["expenseProjectName"] = this.expenseProjectName;
        data["requestedAmount"] = this.requestedAmount;
        data["approvedAmount"] = this.approvedAmount;
        data["dateIncurred"] = this.dateIncurred ? this.dateIncurred.toISOString() : <any>undefined;
        data["dateReconciled"] = this.dateReconciled ? this.dateReconciled.toISOString() : <any>undefined;
        data["dateDisbursed"] = this.dateDisbursed ? this.dateDisbursed.toISOString() : <any>undefined;
        data["disburseComment"] = this.disburseComment;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["reconciledStatus"] = this.reconciledStatus;
        data["reconciledBy"] = this.reconciledBy;
        data["reconciledByName"] = this.reconciledByName;
        data["disbursedBy"] = this.disbursedBy;
        data["disbursedByName"] = this.disbursedByName;
        data["approvedBy"] = this.approvedBy;
        data["approvedByName"] = this.approvedByName;
        data["refNo"] = this.refNo;
        data["departmentId"] = this.departmentId;
        data["declineReason"] = this.declineReason;
        data["disbursementType"] = this.disbursementType;
        data["is_disbursed"] = this.is_disbursed;
        data["log_status"] = this.log_status;
        data["expenseGroupId"] = this.expenseGroupId;
        data["expenseGroupName"] = this.expenseGroupName;
        data["strRequestedAmount"] = this.strRequestedAmount;
        data["strApprovedAmount"] = this.strApprovedAmount;
        data["strDateIncurred"] = this.strDateIncurred;
        data["_ServerDocURL"] = this._ServerDocURL;
        data["tempRef"] = this.tempRef;
        data["departmentName"] = this.departmentName;
        data["locatioName"] = this.locatioName;
        return data; 
    }

    clone(): ExpenseDTO {
        const json = this.toJSON();
        let result = new ExpenseDTO();
        result.init(json);
        return result;
    }
}

export interface IExpenseDTO {
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    approvalProcessId: number;
    title: string | undefined;
    description: string | undefined;
    expenseSubTypeId: number | undefined;
    expenseSubTypeName: string | undefined;
    expenseTypeId: number;
    expenseTypeName: string | undefined;
    loggedByUserId: number;
    loggedByUsername: string | undefined;
    loggedForEmployeeId: number | undefined;
    loggedForEmployeeName: string | undefined;
    loggedForEmployeeNo: string | undefined;
    expenseProjectActivityId: number | undefined;
    expenseProjectActivityName: string | undefined;
    expenseProjectId: number;
    expenseProjectName: string | undefined;
    requestedAmount: number;
    approvedAmount: number;
    dateIncurred: Date | undefined;
    dateReconciled: Date | undefined;
    dateDisbursed: Date | undefined;
    disburseComment: string | undefined;
    dateApproved: Date | undefined;
    reconciledStatus: boolean;
    reconciledBy: number | undefined;
    reconciledByName: string | undefined;
    disbursedBy: string | undefined;
    disbursedByName: string | undefined;
    approvedBy: number | undefined;
    approvedByName: string | undefined;
    refNo: string | undefined;
    departmentId: number;
    declineReason: string | undefined;
    disbursementType: number | undefined;
    is_disbursed: boolean;
    log_status: number;
    expenseGroupId: number;
    expenseGroupName: string | undefined;
    strRequestedAmount: string | undefined;
    strApprovedAmount: string | undefined;
    strDateIncurred: string | undefined;
    _ServerDocURL: string | undefined;
    tempRef: string | undefined;
    departmentName: string | undefined;
    locatioName: string | undefined;
}

export class ExpenseDTOIListApiResult implements IExpenseDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ExpenseDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IExpenseDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ExpenseDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ExpenseDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ExpenseDTOIListApiResult {
        const json = this.toJSON();
        let result = new ExpenseDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IExpenseDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ExpenseDTO[] | undefined;
    totalCount: number;
}

export class ExpenseTypeDto implements IExpenseTypeDto {
    id!: number;
    companyID!: number;
    subID!: number;
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    referenceId!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IExpenseTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ExpenseTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ExpenseTypeDto {
        const json = this.toJSON();
        let result = new ExpenseTypeDto();
        result.init(json);
        return result;
    }
}

export interface IExpenseTypeDto {
    id: number;
    companyID: number;
    subID: number;
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    referenceId: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class ExpenseTypeIListApiResult implements IExpenseTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ExpenseType[] | undefined;
    totalCount!: number;

    constructor(data?: IExpenseTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ExpenseType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ExpenseTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ExpenseTypeIListApiResult {
        const json = this.toJSON();
        let result = new ExpenseTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IExpenseTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ExpenseType[] | undefined;
    totalCount: number;
}

export class GradeLevelCreatePayload implements IGradeLevelCreatePayload {
    id!: number;
    name!: string;
    code!: string | undefined;
    created_by!: string | undefined;
    promotion_min_years!: number;
    promotion_min_in_days!: number | undefined;
    noOfLeaveDays!: number;

    constructor(data?: IGradeLevelCreatePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
        }
    }

    static fromJS(data: any): GradeLevelCreatePayload {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelCreatePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["promotion_min_years"] = this.promotion_min_years;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        return data; 
    }

    clone(): GradeLevelCreatePayload {
        const json = this.toJSON();
        let result = new GradeLevelCreatePayload();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelCreatePayload {
    id: number;
    name: string;
    code: string | undefined;
    created_by: string | undefined;
    promotion_min_years: number;
    promotion_min_in_days: number | undefined;
    noOfLeaveDays: number;
}

export class GradeLevelDTO implements IGradeLevelDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    promotion_min_years!: number | undefined;
    promotion_min_in_days!: number | undefined;
    noOfLeaveDays!: number | undefined;
    salaryScaleId!: number;

    constructor(data?: IGradeLevelDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.salaryScaleId = _data["salaryScaleId"];
        }
    }

    static fromJS(data: any): GradeLevelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["promotion_min_years"] = this.promotion_min_years;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["salaryScaleId"] = this.salaryScaleId;
        return data; 
    }

    clone(): GradeLevelDTO {
        const json = this.toJSON();
        let result = new GradeLevelDTO();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    promotion_min_years: number | undefined;
    promotion_min_in_days: number | undefined;
    noOfLeaveDays: number | undefined;
    salaryScaleId: number;
}

export class GradeLevelDTOListApiResult implements IGradeLevelDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: GradeLevelDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IGradeLevelDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GradeLevelDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GradeLevelDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): GradeLevelDTOListApiResult {
        const json = this.toJSON();
        let result = new GradeLevelDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: GradeLevelDTO[] | undefined;
    totalCount: number;
}

export class ManageGradeLevelBenefitDTO implements IManageGradeLevelBenefitDTO {
    id!: number;
    benefitName!: string | undefined;
    gradeId!: number;
    gradeStepId!: number;
    amount!: number;
    salaryScaleId!: number;
    name!: string | undefined;
    promotion_min_years!: number | undefined;
    noOfLeaveDays!: number | undefined;
    benefitId!: number;
    gradeName!: string | undefined;

    constructor(data?: IManageGradeLevelBenefitDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.benefitName = _data["benefitName"];
            this.gradeId = _data["gradeId"];
            this.gradeStepId = _data["gradeStepId"];
            this.amount = _data["amount"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.name = _data["name"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.benefitId = _data["benefitId"];
            this.gradeName = _data["gradeName"];
        }
    }

    static fromJS(data: any): ManageGradeLevelBenefitDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageGradeLevelBenefitDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["benefitName"] = this.benefitName;
        data["gradeId"] = this.gradeId;
        data["gradeStepId"] = this.gradeStepId;
        data["amount"] = this.amount;
        data["salaryScaleId"] = this.salaryScaleId;
        data["name"] = this.name;
        data["promotion_min_years"] = this.promotion_min_years;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["benefitId"] = this.benefitId;
        data["gradeName"] = this.gradeName;
        return data; 
    }

    clone(): ManageGradeLevelBenefitDTO {
        const json = this.toJSON();
        let result = new ManageGradeLevelBenefitDTO();
        result.init(json);
        return result;
    }
}

export interface IManageGradeLevelBenefitDTO {
    id: number;
    benefitName: string | undefined;
    gradeId: number;
    gradeStepId: number;
    amount: number;
    salaryScaleId: number;
    name: string | undefined;
    promotion_min_years: number | undefined;
    noOfLeaveDays: number | undefined;
    benefitId: number;
    gradeName: string | undefined;
}

export class GradeLevelBenefitDTO implements IGradeLevelBenefitDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    salaryScaleId!: number;
    promotion_min_years!: number;
    promotion_min_in_days!: number | undefined;
    noOfLeaveDays!: number;
    gradeId!: number;
    gradeStepId!: number;
    salaryScaleName!: string | undefined;
    amount!: number;
    gradeName!: string | undefined;

    constructor(data?: IGradeLevelBenefitDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.gradeId = _data["gradeId"];
            this.gradeStepId = _data["gradeStepId"];
            this.salaryScaleName = _data["salaryScaleName"];
            this.amount = _data["amount"];
            this.gradeName = _data["gradeName"];
        }
    }

    static fromJS(data: any): GradeLevelBenefitDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelBenefitDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["salaryScaleId"] = this.salaryScaleId;
        data["promotion_min_years"] = this.promotion_min_years;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["gradeId"] = this.gradeId;
        data["gradeStepId"] = this.gradeStepId;
        data["salaryScaleName"] = this.salaryScaleName;
        data["amount"] = this.amount;
        data["gradeName"] = this.gradeName;
        return data; 
    }

    clone(): GradeLevelBenefitDTO {
        const json = this.toJSON();
        let result = new GradeLevelBenefitDTO();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelBenefitDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    salaryScaleId: number;
    promotion_min_years: number;
    promotion_min_in_days: number | undefined;
    noOfLeaveDays: number;
    gradeId: number;
    gradeStepId: number;
    salaryScaleName: string | undefined;
    amount: number;
    gradeName: string | undefined;
}

export class GradeLevelBenefitDTOApiResult implements IGradeLevelBenefitDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: GradeLevelBenefitDTO;
    totalCount!: number;

    constructor(data?: IGradeLevelBenefitDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? GradeLevelBenefitDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GradeLevelBenefitDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelBenefitDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): GradeLevelBenefitDTOApiResult {
        const json = this.toJSON();
        let result = new GradeLevelBenefitDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelBenefitDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: GradeLevelBenefitDTO;
    totalCount: number;
}

export class GradeLevelBenefitDTOListApiResult implements IGradeLevelBenefitDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: GradeLevelBenefitDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IGradeLevelBenefitDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GradeLevelBenefitDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GradeLevelBenefitDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelBenefitDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): GradeLevelBenefitDTOListApiResult {
        const json = this.toJSON();
        let result = new GradeLevelBenefitDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelBenefitDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: GradeLevelBenefitDTO[] | undefined;
    totalCount: number;
}

export class ManageJobRoleDTO implements IManageJobRoleDTO {
    id!: number;
    name!: string;
    code!: string | undefined;
    amount!: number;
    parentPositionId!: number;

    constructor(data?: IManageJobRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.amount = _data["amount"];
            this.parentPositionId = _data["parentPositionId"];
        }
    }

    static fromJS(data: any): ManageJobRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageJobRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["amount"] = this.amount;
        data["parentPositionId"] = this.parentPositionId;
        return data; 
    }

    clone(): ManageJobRoleDTO {
        const json = this.toJSON();
        let result = new ManageJobRoleDTO();
        result.init(json);
        return result;
    }
}

export interface IManageJobRoleDTO {
    id: number;
    name: string;
    code: string | undefined;
    amount: number;
    parentPositionId: number;
}

export class JobRolesDTO implements IJobRolesDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    promotion_min_years!: number | undefined;
    next_job_role_id!: number | undefined;
    parent_id!: number | undefined;

    constructor(data?: IJobRolesDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.next_job_role_id = _data["next_job_role_id"];
            this.parent_id = _data["parent_id"];
        }
    }

    static fromJS(data: any): JobRolesDTO {
        data = typeof data === 'object' ? data : {};
        let result = new JobRolesDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["promotion_min_years"] = this.promotion_min_years;
        data["next_job_role_id"] = this.next_job_role_id;
        data["parent_id"] = this.parent_id;
        return data; 
    }

    clone(): JobRolesDTO {
        const json = this.toJSON();
        let result = new JobRolesDTO();
        result.init(json);
        return result;
    }
}

export interface IJobRolesDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    promotion_min_years: number | undefined;
    next_job_role_id: number | undefined;
    parent_id: number | undefined;
}

export class JobRolesDTOListApiResult implements IJobRolesDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: JobRolesDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IJobRolesDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(JobRolesDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): JobRolesDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobRolesDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): JobRolesDTOListApiResult {
        const json = this.toJSON();
        let result = new JobRolesDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IJobRolesDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: JobRolesDTO[] | undefined;
    totalCount: number;
}

export class JobRolesDTOApiResult implements IJobRolesDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: JobRolesDTO;
    totalCount!: number;

    constructor(data?: IJobRolesDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? JobRolesDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): JobRolesDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobRolesDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): JobRolesDTOApiResult {
        const json = this.toJSON();
        let result = new JobRolesDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IJobRolesDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: JobRolesDTO;
    totalCount: number;
}

export class SectionDTO implements ISectionDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    section_name!: string | undefined;
    isMarkObtainable!: boolean;
    maximum_score_obtainable!: number;
    weight!: number;
    description!: string | undefined;
    instructions!: string | undefined;
    is_notified_employees!: boolean;
    order!: number;
    no_of_kpis!: number;
    kpi_rating_type_id!: number;
    strategyCategoryId!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    readonly strategyCategory!: string | undefined;
    readonly ratingType!: string | undefined;

    constructor(data?: ISectionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.section_name = _data["section_name"];
            this.isMarkObtainable = _data["isMarkObtainable"];
            this.maximum_score_obtainable = _data["maximum_score_obtainable"];
            this.weight = _data["weight"];
            this.description = _data["description"];
            this.instructions = _data["instructions"];
            this.is_notified_employees = _data["is_notified_employees"];
            this.order = _data["order"];
            this.no_of_kpis = _data["no_of_kpis"];
            this.kpi_rating_type_id = _data["kpi_rating_type_id"];
            this.strategyCategoryId = _data["strategyCategoryId"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            (<any>this).strategyCategory = _data["strategyCategory"];
            (<any>this).ratingType = _data["ratingType"];
        }
    }

    static fromJS(data: any): SectionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SectionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["section_name"] = this.section_name;
        data["isMarkObtainable"] = this.isMarkObtainable;
        data["maximum_score_obtainable"] = this.maximum_score_obtainable;
        data["weight"] = this.weight;
        data["description"] = this.description;
        data["instructions"] = this.instructions;
        data["is_notified_employees"] = this.is_notified_employees;
        data["order"] = this.order;
        data["no_of_kpis"] = this.no_of_kpis;
        data["kpi_rating_type_id"] = this.kpi_rating_type_id;
        data["strategyCategoryId"] = this.strategyCategoryId;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["strategyCategory"] = this.strategyCategory;
        data["ratingType"] = this.ratingType;
        return data; 
    }

    clone(): SectionDTO {
        const json = this.toJSON();
        let result = new SectionDTO();
        result.init(json);
        return result;
    }
}

export interface ISectionDTO {
    id: number;
    companyID: number;
    subID: number;
    section_name: string | undefined;
    isMarkObtainable: boolean;
    maximum_score_obtainable: number;
    weight: number;
    description: string | undefined;
    instructions: string | undefined;
    is_notified_employees: boolean;
    order: number;
    no_of_kpis: number;
    kpi_rating_type_id: number;
    strategyCategoryId: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    strategyCategory: string | undefined;
    ratingType: string | undefined;
}

export class SectionDTOIListApiResult implements ISectionDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SectionDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ISectionDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SectionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SectionDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SectionDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SectionDTOIListApiResult {
        const json = this.toJSON();
        let result = new SectionDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISectionDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SectionDTO[] | undefined;
    totalCount: number;
}

export class KPI implements IKPI {
    kpi_section_id!: number;
    title!: string | undefined;
    unit_of_measurement_id!: number;
    canComment!: boolean;
    instruction!: string | undefined;
    description!: string | undefined;
    is_compulsory!: boolean;
    order!: number;
    is_closed_ended!: boolean;
    score!: number | undefined;
    sendToEmployee!: boolean;
    is_employee_entry!: boolean | undefined;
    contract_id!: number | undefined;
    kpiSection!: KPISection;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IKPI) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kpi_section_id = _data["kpi_section_id"];
            this.title = _data["title"];
            this.unit_of_measurement_id = _data["unit_of_measurement_id"];
            this.canComment = _data["canComment"];
            this.instruction = _data["instruction"];
            this.description = _data["description"];
            this.is_compulsory = _data["is_compulsory"];
            this.order = _data["order"];
            this.is_closed_ended = _data["is_closed_ended"];
            this.score = _data["score"];
            this.sendToEmployee = _data["sendToEmployee"];
            this.is_employee_entry = _data["is_employee_entry"];
            this.contract_id = _data["contract_id"];
            this.kpiSection = _data["kpiSection"] ? KPISection.fromJS(_data["kpiSection"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): KPI {
        data = typeof data === 'object' ? data : {};
        let result = new KPI();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kpi_section_id"] = this.kpi_section_id;
        data["title"] = this.title;
        data["unit_of_measurement_id"] = this.unit_of_measurement_id;
        data["canComment"] = this.canComment;
        data["instruction"] = this.instruction;
        data["description"] = this.description;
        data["is_compulsory"] = this.is_compulsory;
        data["order"] = this.order;
        data["is_closed_ended"] = this.is_closed_ended;
        data["score"] = this.score;
        data["sendToEmployee"] = this.sendToEmployee;
        data["is_employee_entry"] = this.is_employee_entry;
        data["contract_id"] = this.contract_id;
        data["kpiSection"] = this.kpiSection ? this.kpiSection.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): KPI {
        const json = this.toJSON();
        let result = new KPI();
        result.init(json);
        return result;
    }
}

export interface IKPI {
    kpi_section_id: number;
    title: string | undefined;
    unit_of_measurement_id: number;
    canComment: boolean;
    instruction: string | undefined;
    description: string | undefined;
    is_compulsory: boolean;
    order: number;
    is_closed_ended: boolean;
    score: number | undefined;
    sendToEmployee: boolean;
    is_employee_entry: boolean | undefined;
    contract_id: number | undefined;
    kpiSection: KPISection;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class KPISection implements IKPISection {
    section_name!: string;
    isMarkObtainable!: boolean;
    maximum_score_obtainable!: number;
    description!: string | undefined;
    instructions!: string | undefined;
    is_notified_employees!: boolean;
    order!: number;
    kpi_rating_type_id!: number;
    category_id!: number;
    weight!: number;
    kpis!: KPI[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IKPISection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.section_name = _data["section_name"];
            this.isMarkObtainable = _data["isMarkObtainable"];
            this.maximum_score_obtainable = _data["maximum_score_obtainable"];
            this.description = _data["description"];
            this.instructions = _data["instructions"];
            this.is_notified_employees = _data["is_notified_employees"];
            this.order = _data["order"];
            this.kpi_rating_type_id = _data["kpi_rating_type_id"];
            this.category_id = _data["category_id"];
            this.weight = _data["weight"];
            if (Array.isArray(_data["kpis"])) {
                this.kpis = [] as any;
                for (let item of _data["kpis"])
                    this.kpis!.push(KPI.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): KPISection {
        data = typeof data === 'object' ? data : {};
        let result = new KPISection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["section_name"] = this.section_name;
        data["isMarkObtainable"] = this.isMarkObtainable;
        data["maximum_score_obtainable"] = this.maximum_score_obtainable;
        data["description"] = this.description;
        data["instructions"] = this.instructions;
        data["is_notified_employees"] = this.is_notified_employees;
        data["order"] = this.order;
        data["kpi_rating_type_id"] = this.kpi_rating_type_id;
        data["category_id"] = this.category_id;
        data["weight"] = this.weight;
        if (Array.isArray(this.kpis)) {
            data["kpis"] = [];
            for (let item of this.kpis)
                data["kpis"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): KPISection {
        const json = this.toJSON();
        let result = new KPISection();
        result.init(json);
        return result;
    }
}

export interface IKPISection {
    section_name: string;
    isMarkObtainable: boolean;
    maximum_score_obtainable: number;
    description: string | undefined;
    instructions: string | undefined;
    is_notified_employees: boolean;
    order: number;
    kpi_rating_type_id: number;
    category_id: number;
    weight: number;
    kpis: KPI[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class KPISectionIListApiResult implements IKPISectionIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: KPISection[] | undefined;
    totalCount!: number;

    constructor(data?: IKPISectionIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(KPISection.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): KPISectionIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new KPISectionIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): KPISectionIListApiResult {
        const json = this.toJSON();
        let result = new KPISectionIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IKPISectionIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: KPISection[] | undefined;
    totalCount: number;
}

export class SectionDTOApiResult implements ISectionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SectionDTO;
    totalCount!: number;

    constructor(data?: ISectionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? SectionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SectionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SectionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SectionDTOApiResult {
        const json = this.toJSON();
        let result = new SectionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ISectionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SectionDTO;
    totalCount: number;
}

export class ManageSectionDTO implements IManageSectionDTO {
    id!: number;
    name!: string;
    score!: number;
    weight!: number;
    strategyCategoryId!: number;
    order!: number;
    description!: string | undefined;
    instructions!: string | undefined;
    ratingTypeId!: number;

    constructor(data?: IManageSectionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.score = _data["score"];
            this.weight = _data["weight"];
            this.strategyCategoryId = _data["strategyCategoryId"];
            this.order = _data["order"];
            this.description = _data["description"];
            this.instructions = _data["instructions"];
            this.ratingTypeId = _data["ratingTypeId"];
        }
    }

    static fromJS(data: any): ManageSectionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageSectionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["score"] = this.score;
        data["weight"] = this.weight;
        data["strategyCategoryId"] = this.strategyCategoryId;
        data["order"] = this.order;
        data["description"] = this.description;
        data["instructions"] = this.instructions;
        data["ratingTypeId"] = this.ratingTypeId;
        return data; 
    }

    clone(): ManageSectionDTO {
        const json = this.toJSON();
        let result = new ManageSectionDTO();
        result.init(json);
        return result;
    }
}

export interface IManageSectionDTO {
    id: number;
    name: string;
    score: number;
    weight: number;
    strategyCategoryId: number;
    order: number;
    description: string | undefined;
    instructions: string | undefined;
    ratingTypeId: number;
}

export class AssignKraDto implements IAssignKraDto {
    cycleId!: number;
    krAs!: string;
    reviewerId!: number;
    employeeContractIds!: string;

    constructor(data?: IAssignKraDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cycleId = _data["cycleId"];
            this.krAs = _data["krAs"];
            this.reviewerId = _data["reviewerId"];
            this.employeeContractIds = _data["employeeContractIds"];
        }
    }

    static fromJS(data: any): AssignKraDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssignKraDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cycleId"] = this.cycleId;
        data["krAs"] = this.krAs;
        data["reviewerId"] = this.reviewerId;
        data["employeeContractIds"] = this.employeeContractIds;
        return data; 
    }

    clone(): AssignKraDto {
        const json = this.toJSON();
        let result = new AssignKraDto();
        result.init(json);
        return result;
    }
}

export interface IAssignKraDto {
    cycleId: number;
    krAs: string;
    reviewerId: number;
    employeeContractIds: string;
}

export class ManageKpiDTO implements IManageKpiDTO {
    id!: number;
    title!: string;
    description!: string | undefined;
    kra_id!: number;
    score!: number;
    unit_of_measurement_id!: number;
    canComment!: boolean;

    constructor(data?: IManageKpiDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.kra_id = _data["kra_id"];
            this.score = _data["score"];
            this.unit_of_measurement_id = _data["unit_of_measurement_id"];
            this.canComment = _data["canComment"];
        }
    }

    static fromJS(data: any): ManageKpiDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageKpiDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["kra_id"] = this.kra_id;
        data["score"] = this.score;
        data["unit_of_measurement_id"] = this.unit_of_measurement_id;
        data["canComment"] = this.canComment;
        return data; 
    }

    clone(): ManageKpiDTO {
        const json = this.toJSON();
        let result = new ManageKpiDTO();
        result.init(json);
        return result;
    }
}

export interface IManageKpiDTO {
    id: number;
    title: string;
    description: string | undefined;
    kra_id: number;
    score: number;
    unit_of_measurement_id: number;
    canComment: boolean;
}

export class KpiDTO implements IKpiDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    title!: string;
    kpi_section_id!: number;
    unit_of_measurement_id!: number;
    canComment!: boolean;
    is_closed_ended!: boolean;
    section_name!: string | undefined;
    sectionTotalScore!: number;
    instruction!: string | undefined;
    description!: string | undefined;
    is_compulsory!: boolean;
    order!: number;
    order_count!: number;
    kpi_score!: number | undefined;
    employee_score!: number | undefined;
    supervisor_score!: number | undefined;
    score!: number | undefined;
    is_employee_entry!: boolean | undefined;
    sendToEmployee!: boolean;
    contract_id!: number | undefined;
    response!: string | undefined;
    supervisorResponse!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    readonly unitOfMeasurement!: string | undefined;

    constructor(data?: IKpiDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.title = _data["title"];
            this.kpi_section_id = _data["kpi_section_id"];
            this.unit_of_measurement_id = _data["unit_of_measurement_id"];
            this.canComment = _data["canComment"];
            this.is_closed_ended = _data["is_closed_ended"];
            this.section_name = _data["section_name"];
            this.sectionTotalScore = _data["sectionTotalScore"];
            this.instruction = _data["instruction"];
            this.description = _data["description"];
            this.is_compulsory = _data["is_compulsory"];
            this.order = _data["order"];
            this.order_count = _data["order_count"];
            this.kpi_score = _data["kpi_score"];
            this.employee_score = _data["employee_score"];
            this.supervisor_score = _data["supervisor_score"];
            this.score = _data["score"];
            this.is_employee_entry = _data["is_employee_entry"];
            this.sendToEmployee = _data["sendToEmployee"];
            this.contract_id = _data["contract_id"];
            this.response = _data["response"];
            this.supervisorResponse = _data["supervisorResponse"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            (<any>this).unitOfMeasurement = _data["unitOfMeasurement"];
        }
    }

    static fromJS(data: any): KpiDTO {
        data = typeof data === 'object' ? data : {};
        let result = new KpiDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["title"] = this.title;
        data["kpi_section_id"] = this.kpi_section_id;
        data["unit_of_measurement_id"] = this.unit_of_measurement_id;
        data["canComment"] = this.canComment;
        data["is_closed_ended"] = this.is_closed_ended;
        data["section_name"] = this.section_name;
        data["sectionTotalScore"] = this.sectionTotalScore;
        data["instruction"] = this.instruction;
        data["description"] = this.description;
        data["is_compulsory"] = this.is_compulsory;
        data["order"] = this.order;
        data["order_count"] = this.order_count;
        data["kpi_score"] = this.kpi_score;
        data["employee_score"] = this.employee_score;
        data["supervisor_score"] = this.supervisor_score;
        data["score"] = this.score;
        data["is_employee_entry"] = this.is_employee_entry;
        data["sendToEmployee"] = this.sendToEmployee;
        data["contract_id"] = this.contract_id;
        data["response"] = this.response;
        data["supervisorResponse"] = this.supervisorResponse;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        return data; 
    }

    clone(): KpiDTO {
        const json = this.toJSON();
        let result = new KpiDTO();
        result.init(json);
        return result;
    }
}

export interface IKpiDTO {
    id: number;
    companyID: number;
    subID: number;
    title: string;
    kpi_section_id: number;
    unit_of_measurement_id: number;
    canComment: boolean;
    is_closed_ended: boolean;
    section_name: string | undefined;
    sectionTotalScore: number;
    instruction: string | undefined;
    description: string | undefined;
    is_compulsory: boolean;
    order: number;
    order_count: number;
    kpi_score: number | undefined;
    employee_score: number | undefined;
    supervisor_score: number | undefined;
    score: number | undefined;
    is_employee_entry: boolean | undefined;
    sendToEmployee: boolean;
    contract_id: number | undefined;
    response: string | undefined;
    supervisorResponse: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    unitOfMeasurement: string | undefined;
}

export class KpiDTOIListApiResult implements IKpiDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: KpiDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IKpiDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(KpiDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): KpiDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new KpiDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): KpiDTOIListApiResult {
        const json = this.toJSON();
        let result = new KpiDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IKpiDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: KpiDTO[] | undefined;
    totalCount: number;
}

export class KpiDTOApiResult implements IKpiDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: KpiDTO;
    totalCount!: number;

    constructor(data?: IKpiDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? KpiDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): KpiDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new KpiDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): KpiDTOApiResult {
        const json = this.toJSON();
        let result = new KpiDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IKpiDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: KpiDTO;
    totalCount: number;
}

export class LeaveEntitlementResource implements ILeaveEntitlementResource {
    id!: number;
    companyID!: number;
    subID!: number;
    gradeID!: number;
    leaveTypeID!: number;
    entitlement!: number;
    daysUsed!: number;
    daysRemaining!: number;
    leaveType!: string | undefined;
    grade!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveEntitlementResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.gradeID = _data["gradeID"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.entitlement = _data["entitlement"];
            this.daysUsed = _data["daysUsed"];
            this.daysRemaining = _data["daysRemaining"];
            this.leaveType = _data["leaveType"];
            this.grade = _data["grade"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveEntitlementResource {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["gradeID"] = this.gradeID;
        data["leaveTypeID"] = this.leaveTypeID;
        data["entitlement"] = this.entitlement;
        data["daysUsed"] = this.daysUsed;
        data["daysRemaining"] = this.daysRemaining;
        data["leaveType"] = this.leaveType;
        data["grade"] = this.grade;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveEntitlementResource {
        const json = this.toJSON();
        let result = new LeaveEntitlementResource();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementResource {
    id: number;
    companyID: number;
    subID: number;
    gradeID: number;
    leaveTypeID: number;
    entitlement: number;
    daysUsed: number;
    daysRemaining: number;
    leaveType: string | undefined;
    grade: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveEntitlementResourceListApiResult implements ILeaveEntitlementResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveEntitlementResource[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveEntitlementResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveEntitlementResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveEntitlementResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveEntitlementResourceListApiResult {
        const json = this.toJSON();
        let result = new LeaveEntitlementResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveEntitlementResource[] | undefined;
    totalCount: number;
}

export class LeaveEntitlementResourceApiResult implements ILeaveEntitlementResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveEntitlementResource;
    totalCount!: number;

    constructor(data?: ILeaveEntitlementResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveEntitlementResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveEntitlementResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveEntitlementResourceApiResult {
        const json = this.toJSON();
        let result = new LeaveEntitlementResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveEntitlementResource;
    totalCount: number;
}

export class LeaveEntitlementPayload implements ILeaveEntitlementPayload {
    gradeID!: number;
    leaveTypeID!: number;
    entitlement!: number;
    id!: number;

    constructor(data?: ILeaveEntitlementPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeID = _data["gradeID"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.entitlement = _data["entitlement"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LeaveEntitlementPayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeID"] = this.gradeID;
        data["leaveTypeID"] = this.leaveTypeID;
        data["entitlement"] = this.entitlement;
        data["id"] = this.id;
        return data; 
    }

    clone(): LeaveEntitlementPayload {
        const json = this.toJSON();
        let result = new LeaveEntitlementPayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementPayload {
    gradeID: number;
    leaveTypeID: number;
    entitlement: number;
    id: number;
}

export class GradeListApiResult implements IGradeListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Grade[] | undefined;
    totalCount!: number;

    constructor(data?: IGradeListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Grade.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GradeListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): GradeListApiResult {
        const json = this.toJSON();
        let result = new GradeListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Grade[] | undefined;
    totalCount: number;
}

export class ManageLeaveHolidayDTO implements IManageLeaveHolidayDTO {
    id!: number;
    holidayDate!: Date;
    description!: string | undefined;
    leaveYearId!: number;

    constructor(data?: IManageLeaveHolidayDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.holidayDate = _data["holidayDate"] ? new Date(_data["holidayDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.leaveYearId = _data["leaveYearId"];
        }
    }

    static fromJS(data: any): ManageLeaveHolidayDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageLeaveHolidayDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["holidayDate"] = this.holidayDate ? this.holidayDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["leaveYearId"] = this.leaveYearId;
        return data; 
    }

    clone(): ManageLeaveHolidayDTO {
        const json = this.toJSON();
        let result = new ManageLeaveHolidayDTO();
        result.init(json);
        return result;
    }
}

export interface IManageLeaveHolidayDTO {
    id: number;
    holidayDate: Date;
    description: string | undefined;
    leaveYearId: number;
}

export class LeaveHolidayDTO implements ILeaveHolidayDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    holidayDate!: Date;
    description!: string | undefined;
    leaveYearId!: number;
    leaveYear!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveHolidayDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.holidayDate = _data["holidayDate"] ? new Date(_data["holidayDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.leaveYearId = _data["leaveYearId"];
            this.leaveYear = _data["leaveYear"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveHolidayDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveHolidayDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["holidayDate"] = this.holidayDate ? this.holidayDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["leaveYearId"] = this.leaveYearId;
        data["leaveYear"] = this.leaveYear;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveHolidayDTO {
        const json = this.toJSON();
        let result = new LeaveHolidayDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveHolidayDTO {
    id: number;
    companyID: number;
    subID: number;
    holidayDate: Date;
    description: string | undefined;
    leaveYearId: number;
    leaveYear: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveHolidayDTOListApiResult implements ILeaveHolidayDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveHolidayDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveHolidayDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveHolidayDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveHolidayDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveHolidayDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveHolidayDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveHolidayDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveHolidayDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveHolidayDTO[] | undefined;
    totalCount: number;
}

export class LeaveHolidayDTOApiResult implements ILeaveHolidayDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveHolidayDTO;
    totalCount!: number;

    constructor(data?: ILeaveHolidayDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveHolidayDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveHolidayDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveHolidayDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveHolidayDTOApiResult {
        const json = this.toJSON();
        let result = new LeaveHolidayDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveHolidayDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveHolidayDTO;
    totalCount: number;
}

export class LeavePlanDTO implements ILeavePlanDTO {
    employeeContractId!: number;
    leaveTypeId!: number;
    leaveYearId!: number;
    comment!: string;
    startDate!: Date;
    endDate!: Date;
    noOfDays!: number;
    locationId!: number;

    constructor(data?: ILeavePlanDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeContractId = _data["employeeContractId"];
            this.leaveTypeId = _data["leaveTypeId"];
            this.leaveYearId = _data["leaveYearId"];
            this.comment = _data["comment"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.locationId = _data["locationId"];
        }
    }

    static fromJS(data: any): LeavePlanDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePlanDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeContractId"] = this.employeeContractId;
        data["leaveTypeId"] = this.leaveTypeId;
        data["leaveYearId"] = this.leaveYearId;
        data["comment"] = this.comment;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["locationId"] = this.locationId;
        return data; 
    }

    clone(): LeavePlanDTO {
        const json = this.toJSON();
        let result = new LeavePlanDTO();
        result.init(json);
        return result;
    }
}

export interface ILeavePlanDTO {
    employeeContractId: number;
    leaveTypeId: number;
    leaveYearId: number;
    comment: string;
    startDate: Date;
    endDate: Date;
    noOfDays: number;
    locationId: number;
}

export class LeavePlanResource implements ILeavePlanResource {
    strApprovalStatus!: string | undefined;
    isApproved!: number;
    dateCreated!: Date;
    id!: number;
    employeeContractId!: number;
    leaveTypeId!: number;
    leaveYearId!: number;
    comment!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    noOfDays!: number;
    locationName!: string | undefined;
    locationId!: number;
    employeeNo!: string | undefined;
    fullName!: string | undefined;
    leaveType!: string | undefined;
    leaveYear!: string | undefined;
    companyId!: number;
    subId!: number;

    constructor(data?: ILeavePlanResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.strApprovalStatus = _data["strApprovalStatus"];
            this.isApproved = _data["isApproved"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.employeeContractId = _data["employeeContractId"];
            this.leaveTypeId = _data["leaveTypeId"];
            this.leaveYearId = _data["leaveYearId"];
            this.comment = _data["comment"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.locationName = _data["locationName"];
            this.locationId = _data["locationId"];
            this.employeeNo = _data["employeeNo"];
            this.fullName = _data["fullName"];
            this.leaveType = _data["leaveType"];
            this.leaveYear = _data["leaveYear"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
        }
    }

    static fromJS(data: any): LeavePlanResource {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePlanResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["strApprovalStatus"] = this.strApprovalStatus;
        data["isApproved"] = this.isApproved;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["employeeContractId"] = this.employeeContractId;
        data["leaveTypeId"] = this.leaveTypeId;
        data["leaveYearId"] = this.leaveYearId;
        data["comment"] = this.comment;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["locationName"] = this.locationName;
        data["locationId"] = this.locationId;
        data["employeeNo"] = this.employeeNo;
        data["fullName"] = this.fullName;
        data["leaveType"] = this.leaveType;
        data["leaveYear"] = this.leaveYear;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        return data; 
    }

    clone(): LeavePlanResource {
        const json = this.toJSON();
        let result = new LeavePlanResource();
        result.init(json);
        return result;
    }
}

export interface ILeavePlanResource {
    strApprovalStatus: string | undefined;
    isApproved: number;
    dateCreated: Date;
    id: number;
    employeeContractId: number;
    leaveTypeId: number;
    leaveYearId: number;
    comment: string | undefined;
    startDate: Date;
    endDate: Date;
    noOfDays: number;
    locationName: string | undefined;
    locationId: number;
    employeeNo: string | undefined;
    fullName: string | undefined;
    leaveType: string | undefined;
    leaveYear: string | undefined;
    companyId: number;
    subId: number;
}

export class LeavePlanResourceListApiResult implements ILeavePlanResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeavePlanResource[] | undefined;
    totalCount!: number;

    constructor(data?: ILeavePlanResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeavePlanResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeavePlanResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePlanResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeavePlanResourceListApiResult {
        const json = this.toJSON();
        let result = new LeavePlanResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeavePlanResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeavePlanResource[] | undefined;
    totalCount: number;
}

export enum LeavePlaneStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ApproveOrRejectPayload implements IApproveOrRejectPayload {
    id!: number;
    companyId!: number | undefined;
    leavePlaneStatus!: LeavePlaneStatus;

    constructor(data?: IApproveOrRejectPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.leavePlaneStatus = _data["leavePlaneStatus"];
        }
    }

    static fromJS(data: any): ApproveOrRejectPayload {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveOrRejectPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["leavePlaneStatus"] = this.leavePlaneStatus;
        return data; 
    }

    clone(): ApproveOrRejectPayload {
        const json = this.toJSON();
        let result = new ApproveOrRejectPayload();
        result.init(json);
        return result;
    }
}

export interface IApproveOrRejectPayload {
    id: number;
    companyId: number | undefined;
    leavePlaneStatus: LeavePlaneStatus;
}

export class ManageLeaveRequestDTO implements IManageLeaveRequestDTO {
    id!: number;
    employeeNumber!: string | undefined;
    leaveTypeID!: number;
    leaveYearID!: number;
    startDate!: Date;
    noOfDays!: number;
    contactInfoOnLeave!: string;
    reliefOfficerStaffNo!: string;
    file!: string | undefined;

    constructor(data?: IManageLeaveRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeNumber = _data["employeeNumber"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.leaveYearID = _data["leaveYearID"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.contactInfoOnLeave = _data["contactInfoOnLeave"];
            this.reliefOfficerStaffNo = _data["reliefOfficerStaffNo"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): ManageLeaveRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageLeaveRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeNumber"] = this.employeeNumber;
        data["leaveTypeID"] = this.leaveTypeID;
        data["leaveYearID"] = this.leaveYearID;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["contactInfoOnLeave"] = this.contactInfoOnLeave;
        data["reliefOfficerStaffNo"] = this.reliefOfficerStaffNo;
        data["file"] = this.file;
        return data; 
    }

    clone(): ManageLeaveRequestDTO {
        const json = this.toJSON();
        let result = new ManageLeaveRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IManageLeaveRequestDTO {
    id: number;
    employeeNumber: string | undefined;
    leaveTypeID: number;
    leaveYearID: number;
    startDate: Date;
    noOfDays: number;
    contactInfoOnLeave: string;
    reliefOfficerStaffNo: string;
    file: string | undefined;
}

export class LeaveReportListDTO implements ILeaveReportListDTO {
    sn!: number;
    id!: number;
    fullName!: string | undefined;
    position!: string | undefined;
    yearName!: string | undefined;
    leaveType!: string | undefined;
    approvalStatus!: string | undefined;
    employeeID!: number | undefined;
    employeeContractID!: number | undefined;
    startDate!: string | undefined;
    enddate!: string | undefined;
    resumptionDate!: string | undefined;
    entitlement!: number;
    assignmentNumber!: string | undefined;
    daysRem!: number;
    noOfDays!: number;

    constructor(data?: ILeaveReportListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sn = _data["sn"];
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.position = _data["position"];
            this.yearName = _data["yearName"];
            this.leaveType = _data["leaveType"];
            this.approvalStatus = _data["approvalStatus"];
            this.employeeID = _data["employeeID"];
            this.employeeContractID = _data["employeeContractID"];
            this.startDate = _data["startDate"];
            this.enddate = _data["enddate"];
            this.resumptionDate = _data["resumptionDate"];
            this.entitlement = _data["entitlement"];
            this.assignmentNumber = _data["assignmentNumber"];
            this.daysRem = _data["daysRem"];
            this.noOfDays = _data["noOfDays"];
        }
    }

    static fromJS(data: any): LeaveReportListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveReportListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sn"] = this.sn;
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["position"] = this.position;
        data["yearName"] = this.yearName;
        data["leaveType"] = this.leaveType;
        data["approvalStatus"] = this.approvalStatus;
        data["employeeID"] = this.employeeID;
        data["employeeContractID"] = this.employeeContractID;
        data["startDate"] = this.startDate;
        data["enddate"] = this.enddate;
        data["resumptionDate"] = this.resumptionDate;
        data["entitlement"] = this.entitlement;
        data["assignmentNumber"] = this.assignmentNumber;
        data["daysRem"] = this.daysRem;
        data["noOfDays"] = this.noOfDays;
        return data; 
    }

    clone(): LeaveReportListDTO {
        const json = this.toJSON();
        let result = new LeaveReportListDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveReportListDTO {
    sn: number;
    id: number;
    fullName: string | undefined;
    position: string | undefined;
    yearName: string | undefined;
    leaveType: string | undefined;
    approvalStatus: string | undefined;
    employeeID: number | undefined;
    employeeContractID: number | undefined;
    startDate: string | undefined;
    enddate: string | undefined;
    resumptionDate: string | undefined;
    entitlement: number;
    assignmentNumber: string | undefined;
    daysRem: number;
    noOfDays: number;
}

export class LeaveReportListDTOListApiResult implements ILeaveReportListDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveReportListDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveReportListDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveReportListDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveReportListDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveReportListDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveReportListDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveReportListDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveReportListDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveReportListDTO[] | undefined;
    totalCount: number;
}

export class LeaveYear implements ILeaveYear {
    yearName!: string;
    isActiveYear!: boolean;
    yearStartDate!: Date;
    yearEndDate!: Date;
    yearEndDateString!: string | undefined;
    yearStartDateString!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveYear) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.yearName = _data["yearName"];
            this.isActiveYear = _data["isActiveYear"];
            this.yearStartDate = _data["yearStartDate"] ? new Date(_data["yearStartDate"].toString()) : <any>undefined;
            this.yearEndDate = _data["yearEndDate"] ? new Date(_data["yearEndDate"].toString()) : <any>undefined;
            this.yearEndDateString = _data["yearEndDateString"];
            this.yearStartDateString = _data["yearStartDateString"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveYear {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYear();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yearName"] = this.yearName;
        data["isActiveYear"] = this.isActiveYear;
        data["yearStartDate"] = this.yearStartDate ? this.yearStartDate.toISOString() : <any>undefined;
        data["yearEndDate"] = this.yearEndDate ? this.yearEndDate.toISOString() : <any>undefined;
        data["yearEndDateString"] = this.yearEndDateString;
        data["yearStartDateString"] = this.yearStartDateString;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveYear {
        const json = this.toJSON();
        let result = new LeaveYear();
        result.init(json);
        return result;
    }
}

export interface ILeaveYear {
    yearName: string;
    isActiveYear: boolean;
    yearStartDate: Date;
    yearEndDate: Date;
    yearEndDateString: string | undefined;
    yearStartDateString: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveType implements ILeaveType {
    description!: string;
    isDeductableFromAnualLeave!: boolean;
    excludeWeekendInCalculation!: boolean;
    isOnlyAvailableToAdmin!: boolean;
    isAnnualLeave!: boolean;
    allowedGender!: number;
    maxDays!: number;
    minDays!: number;
    isSystemDefault!: boolean;
    maxNoofPossibleApplication!: number;
    maxNoofYearlyApplication!: number;
    isGradeDependent!: boolean;
    pro_rateLeaveDays!: boolean;
    onlyForConfirmStaff!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.maxDays = 0;
            this.minDays = 0;
            this.maxNoofPossibleApplication = 0;
            this.maxNoofYearlyApplication = 0;
            this.isGradeDependent = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.isDeductableFromAnualLeave = _data["isDeductableFromAnualLeave"];
            this.excludeWeekendInCalculation = _data["excludeWeekendInCalculation"];
            this.isOnlyAvailableToAdmin = _data["isOnlyAvailableToAdmin"];
            this.isAnnualLeave = _data["isAnnualLeave"];
            this.allowedGender = _data["allowedGender"];
            this.maxDays = _data["maxDays"] !== undefined ? _data["maxDays"] : 0;
            this.minDays = _data["minDays"] !== undefined ? _data["minDays"] : 0;
            this.isSystemDefault = _data["isSystemDefault"];
            this.maxNoofPossibleApplication = _data["maxNoofPossibleApplication"] !== undefined ? _data["maxNoofPossibleApplication"] : 0;
            this.maxNoofYearlyApplication = _data["maxNoofYearlyApplication"] !== undefined ? _data["maxNoofYearlyApplication"] : 0;
            this.isGradeDependent = _data["isGradeDependent"] !== undefined ? _data["isGradeDependent"] : false;
            this.pro_rateLeaveDays = _data["pro_rateLeaveDays"];
            this.onlyForConfirmStaff = _data["onlyForConfirmStaff"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveType {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["isDeductableFromAnualLeave"] = this.isDeductableFromAnualLeave;
        data["excludeWeekendInCalculation"] = this.excludeWeekendInCalculation;
        data["isOnlyAvailableToAdmin"] = this.isOnlyAvailableToAdmin;
        data["isAnnualLeave"] = this.isAnnualLeave;
        data["allowedGender"] = this.allowedGender;
        data["maxDays"] = this.maxDays;
        data["minDays"] = this.minDays;
        data["isSystemDefault"] = this.isSystemDefault;
        data["maxNoofPossibleApplication"] = this.maxNoofPossibleApplication;
        data["maxNoofYearlyApplication"] = this.maxNoofYearlyApplication;
        data["isGradeDependent"] = this.isGradeDependent;
        data["pro_rateLeaveDays"] = this.pro_rateLeaveDays;
        data["onlyForConfirmStaff"] = this.onlyForConfirmStaff;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveType {
        const json = this.toJSON();
        let result = new LeaveType();
        result.init(json);
        return result;
    }
}

export interface ILeaveType {
    description: string;
    isDeductableFromAnualLeave: boolean;
    excludeWeekendInCalculation: boolean;
    isOnlyAvailableToAdmin: boolean;
    isAnnualLeave: boolean;
    allowedGender: number;
    maxDays: number;
    minDays: number;
    isSystemDefault: boolean;
    maxNoofPossibleApplication: number;
    maxNoofYearlyApplication: number;
    isGradeDependent: boolean;
    pro_rateLeaveDays: boolean;
    onlyForConfirmStaff: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveEntitlement implements ILeaveEntitlement {
    gradeID!: number;
    leaveTypeID!: number;
    entitlement!: number;
    daysUsed!: number;
    daysRemaining!: number;
    leaveType!: LeaveType;
    grades!: Grade;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveEntitlement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeID = _data["gradeID"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.entitlement = _data["entitlement"];
            this.daysUsed = _data["daysUsed"];
            this.daysRemaining = _data["daysRemaining"];
            this.leaveType = _data["leaveType"] ? LeaveType.fromJS(_data["leaveType"]) : <any>undefined;
            this.grades = _data["grades"] ? Grade.fromJS(_data["grades"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveEntitlement {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeID"] = this.gradeID;
        data["leaveTypeID"] = this.leaveTypeID;
        data["entitlement"] = this.entitlement;
        data["daysUsed"] = this.daysUsed;
        data["daysRemaining"] = this.daysRemaining;
        data["leaveType"] = this.leaveType ? this.leaveType.toJSON() : <any>undefined;
        data["grades"] = this.grades ? this.grades.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveEntitlement {
        const json = this.toJSON();
        let result = new LeaveEntitlement();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlement {
    gradeID: number;
    leaveTypeID: number;
    entitlement: number;
    daysUsed: number;
    daysRemaining: number;
    leaveType: LeaveType;
    grades: Grade;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveRequest implements ILeaveRequest {
    leaveTypeID!: number;
    employeeID!: number;
    employeeContractID!: number | undefined;
    employeeNumber!: string | undefined;
    leaveYearID!: number;
    leaveCalendarID!: number;
    initiatorComment!: string;
    contactInfoOnLeave!: string;
    reliefOfficer!: string;
    reliefOfficerId!: number;
    startDate!: Date;
    startDateString!: string | undefined;
    enddate!: Date;
    noOfDays!: number;
    resumptionDate!: Date;
    dateApplied!: Date;
    gradeID!: number;
    dateApproved!: Date | undefined;
    rejectedBy!: string | undefined;
    employee!: Employee;
    leaveYear!: LeaveYear;
    leaveType!: LeaveType;
    grade!: Grade;
    file!: string | undefined;
    leaveHistory!: LeaveRequest[] | undefined;
    leaveEntitlement!: LeaveEntitlement[] | undefined;
    approvalDecision!: string | undefined;
    approvalStatus!: string | undefined;
    log_status!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leaveTypeID = _data["leaveTypeID"];
            this.employeeID = _data["employeeID"];
            this.employeeContractID = _data["employeeContractID"];
            this.employeeNumber = _data["employeeNumber"];
            this.leaveYearID = _data["leaveYearID"];
            this.leaveCalendarID = _data["leaveCalendarID"];
            this.initiatorComment = _data["initiatorComment"];
            this.contactInfoOnLeave = _data["contactInfoOnLeave"];
            this.reliefOfficer = _data["reliefOfficer"];
            this.reliefOfficerId = _data["reliefOfficerId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.startDateString = _data["startDateString"];
            this.enddate = _data["enddate"] ? new Date(_data["enddate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.resumptionDate = _data["resumptionDate"] ? new Date(_data["resumptionDate"].toString()) : <any>undefined;
            this.dateApplied = _data["dateApplied"] ? new Date(_data["dateApplied"].toString()) : <any>undefined;
            this.gradeID = _data["gradeID"];
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.rejectedBy = _data["rejectedBy"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.leaveYear = _data["leaveYear"] ? LeaveYear.fromJS(_data["leaveYear"]) : <any>undefined;
            this.leaveType = _data["leaveType"] ? LeaveType.fromJS(_data["leaveType"]) : <any>undefined;
            this.grade = _data["grade"] ? Grade.fromJS(_data["grade"]) : <any>undefined;
            this.file = _data["file"];
            if (Array.isArray(_data["leaveHistory"])) {
                this.leaveHistory = [] as any;
                for (let item of _data["leaveHistory"])
                    this.leaveHistory!.push(LeaveRequest.fromJS(item));
            }
            if (Array.isArray(_data["leaveEntitlement"])) {
                this.leaveEntitlement = [] as any;
                for (let item of _data["leaveEntitlement"])
                    this.leaveEntitlement!.push(LeaveEntitlement.fromJS(item));
            }
            this.approvalDecision = _data["approvalDecision"];
            this.approvalStatus = _data["approvalStatus"];
            this.log_status = _data["log_status"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaveTypeID"] = this.leaveTypeID;
        data["employeeID"] = this.employeeID;
        data["employeeContractID"] = this.employeeContractID;
        data["employeeNumber"] = this.employeeNumber;
        data["leaveYearID"] = this.leaveYearID;
        data["leaveCalendarID"] = this.leaveCalendarID;
        data["initiatorComment"] = this.initiatorComment;
        data["contactInfoOnLeave"] = this.contactInfoOnLeave;
        data["reliefOfficer"] = this.reliefOfficer;
        data["reliefOfficerId"] = this.reliefOfficerId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["startDateString"] = this.startDateString;
        data["enddate"] = this.enddate ? this.enddate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["resumptionDate"] = this.resumptionDate ? this.resumptionDate.toISOString() : <any>undefined;
        data["dateApplied"] = this.dateApplied ? this.dateApplied.toISOString() : <any>undefined;
        data["gradeID"] = this.gradeID;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["rejectedBy"] = this.rejectedBy;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["leaveYear"] = this.leaveYear ? this.leaveYear.toJSON() : <any>undefined;
        data["leaveType"] = this.leaveType ? this.leaveType.toJSON() : <any>undefined;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        data["file"] = this.file;
        if (Array.isArray(this.leaveHistory)) {
            data["leaveHistory"] = [];
            for (let item of this.leaveHistory)
                data["leaveHistory"].push(item.toJSON());
        }
        if (Array.isArray(this.leaveEntitlement)) {
            data["leaveEntitlement"] = [];
            for (let item of this.leaveEntitlement)
                data["leaveEntitlement"].push(item.toJSON());
        }
        data["approvalDecision"] = this.approvalDecision;
        data["approvalStatus"] = this.approvalStatus;
        data["log_status"] = this.log_status;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveRequest {
        const json = this.toJSON();
        let result = new LeaveRequest();
        result.init(json);
        return result;
    }
}

export interface ILeaveRequest {
    leaveTypeID: number;
    employeeID: number;
    employeeContractID: number | undefined;
    employeeNumber: string | undefined;
    leaveYearID: number;
    leaveCalendarID: number;
    initiatorComment: string;
    contactInfoOnLeave: string;
    reliefOfficer: string;
    reliefOfficerId: number;
    startDate: Date;
    startDateString: string | undefined;
    enddate: Date;
    noOfDays: number;
    resumptionDate: Date;
    dateApplied: Date;
    gradeID: number;
    dateApproved: Date | undefined;
    rejectedBy: string | undefined;
    employee: Employee;
    leaveYear: LeaveYear;
    leaveType: LeaveType;
    grade: Grade;
    file: string | undefined;
    leaveHistory: LeaveRequest[] | undefined;
    leaveEntitlement: LeaveEntitlement[] | undefined;
    approvalDecision: string | undefined;
    approvalStatus: string | undefined;
    log_status: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveRequestApiResult implements ILeaveRequestApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveRequest;
    totalCount!: number;

    constructor(data?: ILeaveRequestApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveRequest.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveRequestApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveRequestApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveRequestApiResult {
        const json = this.toJSON();
        let result = new LeaveRequestApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveRequestApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveRequest;
    totalCount: number;
}

export class LeaveTypeDTO implements ILeaveTypeDTO {
    id!: number;
    name!: string | undefined;
    companyID!: number;
    subID!: number;
    isDeductableFromAnualLeave!: boolean;
    excludeWeekendInCalculation!: boolean;
    isOnlyAvailableToAdmin!: boolean;
    isAnnualLeave!: boolean;
    allowedGender!: number;
    maxDays!: number;
    minDays!: number;
    isSystemDefault!: boolean;
    maxNoofPossibleApplication!: number;
    maxNoofYearlyApplication!: number;
    isGradeDependent!: boolean;
    pro_rateLeaveDays!: boolean;
    onlyForConfirmStaff!: boolean;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isDeductableFromAnualLeave = _data["isDeductableFromAnualLeave"];
            this.excludeWeekendInCalculation = _data["excludeWeekendInCalculation"];
            this.isOnlyAvailableToAdmin = _data["isOnlyAvailableToAdmin"];
            this.isAnnualLeave = _data["isAnnualLeave"];
            this.allowedGender = _data["allowedGender"];
            this.maxDays = _data["maxDays"];
            this.minDays = _data["minDays"];
            this.isSystemDefault = _data["isSystemDefault"];
            this.maxNoofPossibleApplication = _data["maxNoofPossibleApplication"];
            this.maxNoofYearlyApplication = _data["maxNoofYearlyApplication"];
            this.isGradeDependent = _data["isGradeDependent"];
            this.pro_rateLeaveDays = _data["pro_rateLeaveDays"];
            this.onlyForConfirmStaff = _data["onlyForConfirmStaff"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isDeductableFromAnualLeave"] = this.isDeductableFromAnualLeave;
        data["excludeWeekendInCalculation"] = this.excludeWeekendInCalculation;
        data["isOnlyAvailableToAdmin"] = this.isOnlyAvailableToAdmin;
        data["isAnnualLeave"] = this.isAnnualLeave;
        data["allowedGender"] = this.allowedGender;
        data["maxDays"] = this.maxDays;
        data["minDays"] = this.minDays;
        data["isSystemDefault"] = this.isSystemDefault;
        data["maxNoofPossibleApplication"] = this.maxNoofPossibleApplication;
        data["maxNoofYearlyApplication"] = this.maxNoofYearlyApplication;
        data["isGradeDependent"] = this.isGradeDependent;
        data["pro_rateLeaveDays"] = this.pro_rateLeaveDays;
        data["onlyForConfirmStaff"] = this.onlyForConfirmStaff;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveTypeDTO {
        const json = this.toJSON();
        let result = new LeaveTypeDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeDTO {
    id: number;
    name: string | undefined;
    companyID: number;
    subID: number;
    isDeductableFromAnualLeave: boolean;
    excludeWeekendInCalculation: boolean;
    isOnlyAvailableToAdmin: boolean;
    isAnnualLeave: boolean;
    allowedGender: number;
    maxDays: number;
    minDays: number;
    isSystemDefault: boolean;
    maxNoofPossibleApplication: number;
    maxNoofYearlyApplication: number;
    isGradeDependent: boolean;
    pro_rateLeaveDays: boolean;
    onlyForConfirmStaff: boolean;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveTypeDTOListApiResult implements ILeaveTypeDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveTypeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveTypeDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveTypeDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveTypeDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveTypeDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveTypeDTO[] | undefined;
    totalCount: number;
}

export class LeaveTypeCreatePayload implements ILeaveTypeCreatePayload {
    id!: number;
    name!: string;
    allowedGender!: number;
    maxDays!: number;
    minDays!: number;
    maxNoofPossibleApplication!: number;
    maxNoofYearlyApplication!: number;

    constructor(data?: ILeaveTypeCreatePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.allowedGender = _data["allowedGender"];
            this.maxDays = _data["maxDays"];
            this.minDays = _data["minDays"];
            this.maxNoofPossibleApplication = _data["maxNoofPossibleApplication"];
            this.maxNoofYearlyApplication = _data["maxNoofYearlyApplication"];
        }
    }

    static fromJS(data: any): LeaveTypeCreatePayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeCreatePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["allowedGender"] = this.allowedGender;
        data["maxDays"] = this.maxDays;
        data["minDays"] = this.minDays;
        data["maxNoofPossibleApplication"] = this.maxNoofPossibleApplication;
        data["maxNoofYearlyApplication"] = this.maxNoofYearlyApplication;
        return data; 
    }

    clone(): LeaveTypeCreatePayload {
        const json = this.toJSON();
        let result = new LeaveTypeCreatePayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeCreatePayload {
    id: number;
    name: string;
    allowedGender: number;
    maxDays: number;
    minDays: number;
    maxNoofPossibleApplication: number;
    maxNoofYearlyApplication: number;
}

export class LeaveTypeDTOApiResult implements ILeaveTypeDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveTypeDTO;
    totalCount!: number;

    constructor(data?: ILeaveTypeDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveTypeDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveTypeDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveTypeDTOApiResult {
        const json = this.toJSON();
        let result = new LeaveTypeDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveTypeDTO;
    totalCount: number;
}

export class LeaveWorkFlow implements ILeaveWorkFlow {
    departmentID!: number;
    workFlowName!: string | undefined;
    workFlowItems!: LeaveWorkFlowItem[] | undefined;
    department!: Department;
    workFlowString!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveWorkFlow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentID = _data["departmentID"];
            this.workFlowName = _data["workFlowName"];
            if (Array.isArray(_data["workFlowItems"])) {
                this.workFlowItems = [] as any;
                for (let item of _data["workFlowItems"])
                    this.workFlowItems!.push(LeaveWorkFlowItem.fromJS(item));
            }
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.workFlowString = _data["workFlowString"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveWorkFlow {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentID"] = this.departmentID;
        data["workFlowName"] = this.workFlowName;
        if (Array.isArray(this.workFlowItems)) {
            data["workFlowItems"] = [];
            for (let item of this.workFlowItems)
                data["workFlowItems"].push(item.toJSON());
        }
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["workFlowString"] = this.workFlowString;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveWorkFlow {
        const json = this.toJSON();
        let result = new LeaveWorkFlow();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlow {
    departmentID: number;
    workFlowName: string | undefined;
    workFlowItems: LeaveWorkFlowItem[] | undefined;
    department: Department;
    workFlowString: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveWorkFlowItem implements ILeaveWorkFlowItem {
    stepName!: string | undefined;
    jobRoleID!: number;
    leaveWorkFlowID!: number;
    rank!: number;
    isFinalApproval!: boolean;
    recipientName!: string | undefined;
    jobRole!: JobRole;
    leaveWorkFlow!: LeaveWorkFlow;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveWorkFlowItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stepName = _data["stepName"];
            this.jobRoleID = _data["jobRoleID"];
            this.leaveWorkFlowID = _data["leaveWorkFlowID"];
            this.rank = _data["rank"];
            this.isFinalApproval = _data["isFinalApproval"];
            this.recipientName = _data["recipientName"];
            this.jobRole = _data["jobRole"] ? JobRole.fromJS(_data["jobRole"]) : <any>undefined;
            this.leaveWorkFlow = _data["leaveWorkFlow"] ? LeaveWorkFlow.fromJS(_data["leaveWorkFlow"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowItem {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stepName"] = this.stepName;
        data["jobRoleID"] = this.jobRoleID;
        data["leaveWorkFlowID"] = this.leaveWorkFlowID;
        data["rank"] = this.rank;
        data["isFinalApproval"] = this.isFinalApproval;
        data["recipientName"] = this.recipientName;
        data["jobRole"] = this.jobRole ? this.jobRole.toJSON() : <any>undefined;
        data["leaveWorkFlow"] = this.leaveWorkFlow ? this.leaveWorkFlow.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveWorkFlowItem {
        const json = this.toJSON();
        let result = new LeaveWorkFlowItem();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowItem {
    stepName: string | undefined;
    jobRoleID: number;
    leaveWorkFlowID: number;
    rank: number;
    isFinalApproval: boolean;
    recipientName: string | undefined;
    jobRole: JobRole;
    leaveWorkFlow: LeaveWorkFlow;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveWorkFlowResource implements ILeaveWorkFlowResource {
    departmentID!: number;
    workFlowName!: string | undefined;
    workFlowItems!: LeaveWorkFlowItem[] | undefined;
    department!: Department;
    workFlowString!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;

    constructor(data?: ILeaveWorkFlowResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentID = _data["departmentID"];
            this.workFlowName = _data["workFlowName"];
            if (Array.isArray(_data["workFlowItems"])) {
                this.workFlowItems = [] as any;
                for (let item of _data["workFlowItems"])
                    this.workFlowItems!.push(LeaveWorkFlowItem.fromJS(item));
            }
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.workFlowString = _data["workFlowString"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowResource {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentID"] = this.departmentID;
        data["workFlowName"] = this.workFlowName;
        if (Array.isArray(this.workFlowItems)) {
            data["workFlowItems"] = [];
            for (let item of this.workFlowItems)
                data["workFlowItems"].push(item.toJSON());
        }
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["workFlowString"] = this.workFlowString;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        return data; 
    }

    clone(): LeaveWorkFlowResource {
        const json = this.toJSON();
        let result = new LeaveWorkFlowResource();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowResource {
    departmentID: number;
    workFlowName: string | undefined;
    workFlowItems: LeaveWorkFlowItem[] | undefined;
    department: Department;
    workFlowString: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
}

export class LeaveWorkFlowResourceListApiResult implements ILeaveWorkFlowResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveWorkFlowResource[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveWorkFlowResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveWorkFlowResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveWorkFlowResourceListApiResult {
        const json = this.toJSON();
        let result = new LeaveWorkFlowResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveWorkFlowResource[] | undefined;
    totalCount: number;
}

export class LeaveWorkFlowResourceApiResult implements ILeaveWorkFlowResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveWorkFlowResource;
    totalCount!: number;

    constructor(data?: ILeaveWorkFlowResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveWorkFlowResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveWorkFlowResourceApiResult {
        const json = this.toJSON();
        let result = new LeaveWorkFlowResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveWorkFlowResource;
    totalCount: number;
}

export class LeaveworkFlowPayload implements ILeaveworkFlowPayload {
    leaveWorkFlowID!: number;
    departmentID!: number;
    workFlowName!: string;
    workFlowString!: string;

    constructor(data?: ILeaveworkFlowPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leaveWorkFlowID = _data["leaveWorkFlowID"];
            this.departmentID = _data["departmentID"];
            this.workFlowName = _data["workFlowName"];
            this.workFlowString = _data["workFlowString"];
        }
    }

    static fromJS(data: any): LeaveworkFlowPayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveworkFlowPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaveWorkFlowID"] = this.leaveWorkFlowID;
        data["departmentID"] = this.departmentID;
        data["workFlowName"] = this.workFlowName;
        data["workFlowString"] = this.workFlowString;
        return data; 
    }

    clone(): LeaveworkFlowPayload {
        const json = this.toJSON();
        let result = new LeaveworkFlowPayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveworkFlowPayload {
    leaveWorkFlowID: number;
    departmentID: number;
    workFlowName: string;
    workFlowString: string;
}

export class LeaveYearDTO implements ILeaveYearDTO {
    yearName!: string | undefined;
    isActiveYear!: boolean;
    yearStartDate!: Date;
    yearEndDate!: Date;
    log_status!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    create_contextyId!: number;
    dateModified!: Date | undefined;
    modifie_contextyId!: number | undefined;

    constructor(data?: ILeaveYearDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.yearName = _data["yearName"];
            this.isActiveYear = _data["isActiveYear"];
            this.yearStartDate = _data["yearStartDate"] ? new Date(_data["yearStartDate"].toString()) : <any>undefined;
            this.yearEndDate = _data["yearEndDate"] ? new Date(_data["yearEndDate"].toString()) : <any>undefined;
            this.log_status = _data["log_status"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.create_contextyId = _data["create_contextyId"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifie_contextyId = _data["modifie_contextyId"];
        }
    }

    static fromJS(data: any): LeaveYearDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yearName"] = this.yearName;
        data["isActiveYear"] = this.isActiveYear;
        data["yearStartDate"] = this.yearStartDate ? this.yearStartDate.toISOString() : <any>undefined;
        data["yearEndDate"] = this.yearEndDate ? this.yearEndDate.toISOString() : <any>undefined;
        data["log_status"] = this.log_status;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["create_contextyId"] = this.create_contextyId;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifie_contextyId"] = this.modifie_contextyId;
        return data; 
    }

    clone(): LeaveYearDTO {
        const json = this.toJSON();
        let result = new LeaveYearDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearDTO {
    yearName: string | undefined;
    isActiveYear: boolean;
    yearStartDate: Date;
    yearEndDate: Date;
    log_status: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    create_contextyId: number;
    dateModified: Date | undefined;
    modifie_contextyId: number | undefined;
}

export class LeaveYearDTOListApiResult implements ILeaveYearDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveYearDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveYearDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveYearDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveYearDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveYearDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveYearDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveYearDTO[] | undefined;
    totalCount: number;
}

export class LeaveYearCreatePayload implements ILeaveYearCreatePayload {
    yearName!: string;
    isActiveYear!: boolean;
    yearStartDate!: Date;
    yearEndDate!: Date;

    constructor(data?: ILeaveYearCreatePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.yearName = _data["yearName"];
            this.isActiveYear = _data["isActiveYear"];
            this.yearStartDate = _data["yearStartDate"] ? new Date(_data["yearStartDate"].toString()) : <any>undefined;
            this.yearEndDate = _data["yearEndDate"] ? new Date(_data["yearEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LeaveYearCreatePayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearCreatePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yearName"] = this.yearName;
        data["isActiveYear"] = this.isActiveYear;
        data["yearStartDate"] = this.yearStartDate ? this.yearStartDate.toISOString() : <any>undefined;
        data["yearEndDate"] = this.yearEndDate ? this.yearEndDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): LeaveYearCreatePayload {
        const json = this.toJSON();
        let result = new LeaveYearCreatePayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearCreatePayload {
    yearName: string;
    isActiveYear: boolean;
    yearStartDate: Date;
    yearEndDate: Date;
}

export class LeaveYearDTOApiResult implements ILeaveYearDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveYearDTO;
    totalCount!: number;

    constructor(data?: ILeaveYearDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveYearDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveYearDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveYearDTOApiResult {
        const json = this.toJSON();
        let result = new LeaveYearDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveYearDTO;
    totalCount: number;
}

export class LoanRequestDTO implements ILoanRequestDTO {
    id!: number;
    loanTypeId!: number;
    refNo!: string | undefined;
    employeeNo!: string | undefined;
    employeeName!: string | undefined;
    loanTypeName!: string | undefined;
    employeeId!: number;
    log_status!: number;
    is_disbursed!: boolean;
    is_active!: boolean;
    amount!: number;
    tenor!: number;
    totalPrincipalRepaid!: number;
    approvalProcessId!: number;
    requestedTenor!: number;
    approvedTenor!: number;
    strRequestedAmount!: string | undefined;
    strEffectiveDate!: string | undefined;
    tempRef!: string | undefined;
    strApprovedAmount!: string | undefined;
    strMaturityDate!: string | undefined;
    _ServerDocURL!: string | undefined;
    strGuarantorIds!: string | undefined;
    effectiveDate!: Date | undefined;
    outstandingPrincipal!: number;
    outstandingInterest!: number;
    requestedAmount!: number;
    approvedAmount!: number;
    autoDeduction!: boolean;
    customAnswer!: string | undefined;
    loggedForEmployeeId!: string | undefined;
    justification!: string | undefined;
    submittedByUserId!: number;

    constructor(data?: ILoanRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.loanTypeId = _data["loanTypeId"];
            this.refNo = _data["refNo"];
            this.employeeNo = _data["employeeNo"];
            this.employeeName = _data["employeeName"];
            this.loanTypeName = _data["loanTypeName"];
            this.employeeId = _data["employeeId"];
            this.log_status = _data["log_status"];
            this.is_disbursed = _data["is_disbursed"];
            this.is_active = _data["is_active"];
            this.amount = _data["amount"];
            this.tenor = _data["tenor"];
            this.totalPrincipalRepaid = _data["totalPrincipalRepaid"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.requestedTenor = _data["requestedTenor"];
            this.approvedTenor = _data["approvedTenor"];
            this.strRequestedAmount = _data["strRequestedAmount"];
            this.strEffectiveDate = _data["strEffectiveDate"];
            this.tempRef = _data["tempRef"];
            this.strApprovedAmount = _data["strApprovedAmount"];
            this.strMaturityDate = _data["strMaturityDate"];
            this._ServerDocURL = _data["_ServerDocURL"];
            this.strGuarantorIds = _data["strGuarantorIds"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.outstandingPrincipal = _data["outstandingPrincipal"];
            this.outstandingInterest = _data["outstandingInterest"];
            this.requestedAmount = _data["requestedAmount"];
            this.approvedAmount = _data["approvedAmount"];
            this.autoDeduction = _data["autoDeduction"];
            this.customAnswer = _data["customAnswer"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.justification = _data["justification"];
            this.submittedByUserId = _data["submittedByUserId"];
        }
    }

    static fromJS(data: any): LoanRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["loanTypeId"] = this.loanTypeId;
        data["refNo"] = this.refNo;
        data["employeeNo"] = this.employeeNo;
        data["employeeName"] = this.employeeName;
        data["loanTypeName"] = this.loanTypeName;
        data["employeeId"] = this.employeeId;
        data["log_status"] = this.log_status;
        data["is_disbursed"] = this.is_disbursed;
        data["is_active"] = this.is_active;
        data["amount"] = this.amount;
        data["tenor"] = this.tenor;
        data["totalPrincipalRepaid"] = this.totalPrincipalRepaid;
        data["approvalProcessId"] = this.approvalProcessId;
        data["requestedTenor"] = this.requestedTenor;
        data["approvedTenor"] = this.approvedTenor;
        data["strRequestedAmount"] = this.strRequestedAmount;
        data["strEffectiveDate"] = this.strEffectiveDate;
        data["tempRef"] = this.tempRef;
        data["strApprovedAmount"] = this.strApprovedAmount;
        data["strMaturityDate"] = this.strMaturityDate;
        data["_ServerDocURL"] = this._ServerDocURL;
        data["strGuarantorIds"] = this.strGuarantorIds;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["outstandingPrincipal"] = this.outstandingPrincipal;
        data["outstandingInterest"] = this.outstandingInterest;
        data["requestedAmount"] = this.requestedAmount;
        data["approvedAmount"] = this.approvedAmount;
        data["autoDeduction"] = this.autoDeduction;
        data["customAnswer"] = this.customAnswer;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["justification"] = this.justification;
        data["submittedByUserId"] = this.submittedByUserId;
        return data; 
    }

    clone(): LoanRequestDTO {
        const json = this.toJSON();
        let result = new LoanRequestDTO();
        result.init(json);
        return result;
    }
}

export interface ILoanRequestDTO {
    id: number;
    loanTypeId: number;
    refNo: string | undefined;
    employeeNo: string | undefined;
    employeeName: string | undefined;
    loanTypeName: string | undefined;
    employeeId: number;
    log_status: number;
    is_disbursed: boolean;
    is_active: boolean;
    amount: number;
    tenor: number;
    totalPrincipalRepaid: number;
    approvalProcessId: number;
    requestedTenor: number;
    approvedTenor: number;
    strRequestedAmount: string | undefined;
    strEffectiveDate: string | undefined;
    tempRef: string | undefined;
    strApprovedAmount: string | undefined;
    strMaturityDate: string | undefined;
    _ServerDocURL: string | undefined;
    strGuarantorIds: string | undefined;
    effectiveDate: Date | undefined;
    outstandingPrincipal: number;
    outstandingInterest: number;
    requestedAmount: number;
    approvedAmount: number;
    autoDeduction: boolean;
    customAnswer: string | undefined;
    loggedForEmployeeId: string | undefined;
    justification: string | undefined;
    submittedByUserId: number;
}

export class PostLoanDto implements IPostLoanDto {
    loan_id!: number;
    repaymentcomment!: string | undefined;
    repaymenttotalamt!: string | undefined;
    repaymenttype!: string | undefined;
    partamt!: string | undefined;
    repytdate!: string | undefined;

    constructor(data?: IPostLoanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loan_id = _data["loan_id"];
            this.repaymentcomment = _data["repaymentcomment"];
            this.repaymenttotalamt = _data["repaymenttotalamt"];
            this.repaymenttype = _data["repaymenttype"];
            this.partamt = _data["partamt"];
            this.repytdate = _data["repytdate"];
        }
    }

    static fromJS(data: any): PostLoanDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostLoanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loan_id"] = this.loan_id;
        data["repaymentcomment"] = this.repaymentcomment;
        data["repaymenttotalamt"] = this.repaymenttotalamt;
        data["repaymenttype"] = this.repaymenttype;
        data["partamt"] = this.partamt;
        data["repytdate"] = this.repytdate;
        return data; 
    }

    clone(): PostLoanDto {
        const json = this.toJSON();
        let result = new PostLoanDto();
        result.init(json);
        return result;
    }
}

export interface IPostLoanDto {
    loan_id: number;
    repaymentcomment: string | undefined;
    repaymenttotalamt: string | undefined;
    repaymenttype: string | undefined;
    partamt: string | undefined;
    repytdate: string | undefined;
}

export class LoanRepaymentLog implements ILoanRepaymentLog {
    id!: number;
    loanRequestId!: number;
    amountRepaid!: number;
    principalRepayment!: number;
    interestRepayment!: number;
    repaymentDate!: Date;
    repaymentType!: string | undefined;
    comment!: string | undefined;
    isSchedule!: boolean;
    strRepaymentDate!: string | undefined;

    constructor(data?: ILoanRepaymentLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.loanRequestId = _data["loanRequestId"];
            this.amountRepaid = _data["amountRepaid"];
            this.principalRepayment = _data["principalRepayment"];
            this.interestRepayment = _data["interestRepayment"];
            this.repaymentDate = _data["repaymentDate"] ? new Date(_data["repaymentDate"].toString()) : <any>undefined;
            this.repaymentType = _data["repaymentType"];
            this.comment = _data["comment"];
            this.isSchedule = _data["isSchedule"];
            this.strRepaymentDate = _data["strRepaymentDate"];
        }
    }

    static fromJS(data: any): LoanRepaymentLog {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRepaymentLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["loanRequestId"] = this.loanRequestId;
        data["amountRepaid"] = this.amountRepaid;
        data["principalRepayment"] = this.principalRepayment;
        data["interestRepayment"] = this.interestRepayment;
        data["repaymentDate"] = this.repaymentDate ? this.repaymentDate.toISOString() : <any>undefined;
        data["repaymentType"] = this.repaymentType;
        data["comment"] = this.comment;
        data["isSchedule"] = this.isSchedule;
        data["strRepaymentDate"] = this.strRepaymentDate;
        return data; 
    }

    clone(): LoanRepaymentLog {
        const json = this.toJSON();
        let result = new LoanRepaymentLog();
        result.init(json);
        return result;
    }
}

export interface ILoanRepaymentLog {
    id: number;
    loanRequestId: number;
    amountRepaid: number;
    principalRepayment: number;
    interestRepayment: number;
    repaymentDate: Date;
    repaymentType: string | undefined;
    comment: string | undefined;
    isSchedule: boolean;
    strRepaymentDate: string | undefined;
}

export class LoanRepaymentLogIListApiResult implements ILoanRepaymentLogIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanRepaymentLog[] | undefined;
    totalCount!: number;

    constructor(data?: ILoanRepaymentLogIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LoanRepaymentLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LoanRepaymentLogIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRepaymentLogIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LoanRepaymentLogIListApiResult {
        const json = this.toJSON();
        let result = new LoanRepaymentLogIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanRepaymentLogIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanRepaymentLog[] | undefined;
    totalCount: number;
}

export class LoanRequestDTOIListApiResult implements ILoanRequestDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanRequestDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILoanRequestDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LoanRequestDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LoanRequestDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequestDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LoanRequestDTOIListApiResult {
        const json = this.toJSON();
        let result = new LoanRequestDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanRequestDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanRequestDTO[] | undefined;
    totalCount: number;
}

export class IdNameObjIListApiResult implements IIdNameObjIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: IdNameObj[] | undefined;
    totalCount!: number;

    constructor(data?: IIdNameObjIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(IdNameObj.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): IdNameObjIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameObjIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): IdNameObjIListApiResult {
        const json = this.toJSON();
        let result = new IdNameObjIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IIdNameObjIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: IdNameObj[] | undefined;
    totalCount: number;
}

export class UpdateLoadRequestDTO implements IUpdateLoadRequestDTO {
    effective_date!: string | undefined;
    loan_id!: number;
    approved_tenor!: string | undefined;
    approved_amt!: string | undefined;

    constructor(data?: IUpdateLoadRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.effective_date = _data["effective_date"];
            this.loan_id = _data["loan_id"];
            this.approved_tenor = _data["approved_tenor"];
            this.approved_amt = _data["approved_amt"];
        }
    }

    static fromJS(data: any): UpdateLoadRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLoadRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["effective_date"] = this.effective_date;
        data["loan_id"] = this.loan_id;
        data["approved_tenor"] = this.approved_tenor;
        data["approved_amt"] = this.approved_amt;
        return data; 
    }

    clone(): UpdateLoadRequestDTO {
        const json = this.toJSON();
        let result = new UpdateLoadRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IUpdateLoadRequestDTO {
    effective_date: string | undefined;
    loan_id: number;
    approved_tenor: string | undefined;
    approved_amt: string | undefined;
}

export class LoanRequest implements ILoanRequest {
    loanTypeId!: number;
    submittedByUserId!: number;
    loggedForEmployeeId!: number;
    refNo!: string | undefined;
    interestRate!: number;
    requestedAmount!: number;
    approvalProcessId!: number;
    interestType!: number;
    requestedTenor!: number;
    approvedTenor!: number;
    approvedAmount!: number;
    totalPrincipalRepaid!: number;
    totalInterestRepaid!: number;
    totalAmountRepaid!: number;
    lastRepaymentDate!: Date | undefined;
    effectiveDate!: Date | undefined;
    dateApproved!: Date | undefined;
    customAnswer!: string | undefined;
    justification!: string | undefined;
    log_status!: number;
    is_disbursed!: boolean;
    date_disbursed!: Date | undefined;
    autoDeduction!: boolean;
    maxLoanRepaytPercent!: number;
    maxLoanRepaytAmount!: number;
    is_repaid!: boolean;
    disbursementdetails!: string | undefined;
    disburseby!: string | undefined;
    disbursementType!: number | undefined;
    employeeNo!: string | undefined;
    employeeName!: string | undefined;
    loanTypeName!: string | undefined;
    strRequestedAmount!: string | undefined;
    strEffectiveDate!: string | undefined;
    tempRef!: string | undefined;
    strApprovedAmount!: string | undefined;
    strMaturityDate!: string | undefined;
    _ServerDocURL!: string | undefined;
    strGuarantorIds!: string | undefined;
    outstandingPrincipal!: number;
    outstandingInterest!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILoanRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loanTypeId = _data["loanTypeId"];
            this.submittedByUserId = _data["submittedByUserId"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.refNo = _data["refNo"];
            this.interestRate = _data["interestRate"];
            this.requestedAmount = _data["requestedAmount"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.interestType = _data["interestType"];
            this.requestedTenor = _data["requestedTenor"];
            this.approvedTenor = _data["approvedTenor"];
            this.approvedAmount = _data["approvedAmount"];
            this.totalPrincipalRepaid = _data["totalPrincipalRepaid"];
            this.totalInterestRepaid = _data["totalInterestRepaid"];
            this.totalAmountRepaid = _data["totalAmountRepaid"];
            this.lastRepaymentDate = _data["lastRepaymentDate"] ? new Date(_data["lastRepaymentDate"].toString()) : <any>undefined;
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.customAnswer = _data["customAnswer"];
            this.justification = _data["justification"];
            this.log_status = _data["log_status"];
            this.is_disbursed = _data["is_disbursed"];
            this.date_disbursed = _data["date_disbursed"] ? new Date(_data["date_disbursed"].toString()) : <any>undefined;
            this.autoDeduction = _data["autoDeduction"];
            this.maxLoanRepaytPercent = _data["maxLoanRepaytPercent"];
            this.maxLoanRepaytAmount = _data["maxLoanRepaytAmount"];
            this.is_repaid = _data["is_repaid"];
            this.disbursementdetails = _data["disbursementdetails"];
            this.disburseby = _data["disburseby"];
            this.disbursementType = _data["disbursementType"];
            this.employeeNo = _data["employeeNo"];
            this.employeeName = _data["employeeName"];
            this.loanTypeName = _data["loanTypeName"];
            this.strRequestedAmount = _data["strRequestedAmount"];
            this.strEffectiveDate = _data["strEffectiveDate"];
            this.tempRef = _data["tempRef"];
            this.strApprovedAmount = _data["strApprovedAmount"];
            this.strMaturityDate = _data["strMaturityDate"];
            this._ServerDocURL = _data["_ServerDocURL"];
            this.strGuarantorIds = _data["strGuarantorIds"];
            this.outstandingPrincipal = _data["outstandingPrincipal"];
            this.outstandingInterest = _data["outstandingInterest"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LoanRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loanTypeId"] = this.loanTypeId;
        data["submittedByUserId"] = this.submittedByUserId;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["refNo"] = this.refNo;
        data["interestRate"] = this.interestRate;
        data["requestedAmount"] = this.requestedAmount;
        data["approvalProcessId"] = this.approvalProcessId;
        data["interestType"] = this.interestType;
        data["requestedTenor"] = this.requestedTenor;
        data["approvedTenor"] = this.approvedTenor;
        data["approvedAmount"] = this.approvedAmount;
        data["totalPrincipalRepaid"] = this.totalPrincipalRepaid;
        data["totalInterestRepaid"] = this.totalInterestRepaid;
        data["totalAmountRepaid"] = this.totalAmountRepaid;
        data["lastRepaymentDate"] = this.lastRepaymentDate ? this.lastRepaymentDate.toISOString() : <any>undefined;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["customAnswer"] = this.customAnswer;
        data["justification"] = this.justification;
        data["log_status"] = this.log_status;
        data["is_disbursed"] = this.is_disbursed;
        data["date_disbursed"] = this.date_disbursed ? this.date_disbursed.toISOString() : <any>undefined;
        data["autoDeduction"] = this.autoDeduction;
        data["maxLoanRepaytPercent"] = this.maxLoanRepaytPercent;
        data["maxLoanRepaytAmount"] = this.maxLoanRepaytAmount;
        data["is_repaid"] = this.is_repaid;
        data["disbursementdetails"] = this.disbursementdetails;
        data["disburseby"] = this.disburseby;
        data["disbursementType"] = this.disbursementType;
        data["employeeNo"] = this.employeeNo;
        data["employeeName"] = this.employeeName;
        data["loanTypeName"] = this.loanTypeName;
        data["strRequestedAmount"] = this.strRequestedAmount;
        data["strEffectiveDate"] = this.strEffectiveDate;
        data["tempRef"] = this.tempRef;
        data["strApprovedAmount"] = this.strApprovedAmount;
        data["strMaturityDate"] = this.strMaturityDate;
        data["_ServerDocURL"] = this._ServerDocURL;
        data["strGuarantorIds"] = this.strGuarantorIds;
        data["outstandingPrincipal"] = this.outstandingPrincipal;
        data["outstandingInterest"] = this.outstandingInterest;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LoanRequest {
        const json = this.toJSON();
        let result = new LoanRequest();
        result.init(json);
        return result;
    }
}

export interface ILoanRequest {
    loanTypeId: number;
    submittedByUserId: number;
    loggedForEmployeeId: number;
    refNo: string | undefined;
    interestRate: number;
    requestedAmount: number;
    approvalProcessId: number;
    interestType: number;
    requestedTenor: number;
    approvedTenor: number;
    approvedAmount: number;
    totalPrincipalRepaid: number;
    totalInterestRepaid: number;
    totalAmountRepaid: number;
    lastRepaymentDate: Date | undefined;
    effectiveDate: Date | undefined;
    dateApproved: Date | undefined;
    customAnswer: string | undefined;
    justification: string | undefined;
    log_status: number;
    is_disbursed: boolean;
    date_disbursed: Date | undefined;
    autoDeduction: boolean;
    maxLoanRepaytPercent: number;
    maxLoanRepaytAmount: number;
    is_repaid: boolean;
    disbursementdetails: string | undefined;
    disburseby: string | undefined;
    disbursementType: number | undefined;
    employeeNo: string | undefined;
    employeeName: string | undefined;
    loanTypeName: string | undefined;
    strRequestedAmount: string | undefined;
    strEffectiveDate: string | undefined;
    tempRef: string | undefined;
    strApprovedAmount: string | undefined;
    strMaturityDate: string | undefined;
    _ServerDocURL: string | undefined;
    strGuarantorIds: string | undefined;
    outstandingPrincipal: number;
    outstandingInterest: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LoanRequestApiResult implements ILoanRequestApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanRequest;
    totalCount!: number;

    constructor(data?: ILoanRequestApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LoanRequest.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LoanRequestApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequestApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LoanRequestApiResult {
        const json = this.toJSON();
        let result = new LoanRequestApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanRequestApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanRequest;
    totalCount: number;
}

export class LoanTypeDTO implements ILoanTypeDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    code!: string | undefined;
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    approvalProcessId!: number;
    interestRate!: number;
    minTenor!: number;
    maxTenor!: number;
    minAmount!: number;
    maxAmount!: number;
    interestType!: number;
    requiresGuarantor!: boolean;
    requiredNoOfGuarantors!: number;
    eligibleGrades!: string | undefined;
    eligibleEmploymentStatus!: number;
    customQuestion!: string | undefined;
    maxLoanRepaytPercent!: number;
    strMinAmount!: string | undefined;
    strMaxAmount!: string | undefined;
    strRequiresGuarantor!: string | undefined;

    constructor(data?: ILoanTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.code = _data["code"];
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.interestRate = _data["interestRate"];
            this.minTenor = _data["minTenor"];
            this.maxTenor = _data["maxTenor"];
            this.minAmount = _data["minAmount"];
            this.maxAmount = _data["maxAmount"];
            this.interestType = _data["interestType"];
            this.requiresGuarantor = _data["requiresGuarantor"];
            this.requiredNoOfGuarantors = _data["requiredNoOfGuarantors"];
            this.eligibleGrades = _data["eligibleGrades"];
            this.eligibleEmploymentStatus = _data["eligibleEmploymentStatus"];
            this.customQuestion = _data["customQuestion"];
            this.maxLoanRepaytPercent = _data["maxLoanRepaytPercent"];
            this.strMinAmount = _data["strMinAmount"];
            this.strMaxAmount = _data["strMaxAmount"];
            this.strRequiresGuarantor = _data["strRequiresGuarantor"];
        }
    }

    static fromJS(data: any): LoanTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoanTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["code"] = this.code;
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["approvalProcessId"] = this.approvalProcessId;
        data["interestRate"] = this.interestRate;
        data["minTenor"] = this.minTenor;
        data["maxTenor"] = this.maxTenor;
        data["minAmount"] = this.minAmount;
        data["maxAmount"] = this.maxAmount;
        data["interestType"] = this.interestType;
        data["requiresGuarantor"] = this.requiresGuarantor;
        data["requiredNoOfGuarantors"] = this.requiredNoOfGuarantors;
        data["eligibleGrades"] = this.eligibleGrades;
        data["eligibleEmploymentStatus"] = this.eligibleEmploymentStatus;
        data["customQuestion"] = this.customQuestion;
        data["maxLoanRepaytPercent"] = this.maxLoanRepaytPercent;
        data["strMinAmount"] = this.strMinAmount;
        data["strMaxAmount"] = this.strMaxAmount;
        data["strRequiresGuarantor"] = this.strRequiresGuarantor;
        return data; 
    }

    clone(): LoanTypeDTO {
        const json = this.toJSON();
        let result = new LoanTypeDTO();
        result.init(json);
        return result;
    }
}

export interface ILoanTypeDTO {
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    code: string | undefined;
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    approvalProcessId: number;
    interestRate: number;
    minTenor: number;
    maxTenor: number;
    minAmount: number;
    maxAmount: number;
    interestType: number;
    requiresGuarantor: boolean;
    requiredNoOfGuarantors: number;
    eligibleGrades: string | undefined;
    eligibleEmploymentStatus: number;
    customQuestion: string | undefined;
    maxLoanRepaytPercent: number;
    strMinAmount: string | undefined;
    strMaxAmount: string | undefined;
    strRequiresGuarantor: string | undefined;
}

export class LoadTypeById implements ILoadTypeById {
    id!: number;
    companyID!: number;

    constructor(data?: ILoadTypeById) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
        }
    }

    static fromJS(data: any): LoadTypeById {
        data = typeof data === 'object' ? data : {};
        let result = new LoadTypeById();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        return data; 
    }

    clone(): LoadTypeById {
        const json = this.toJSON();
        let result = new LoadTypeById();
        result.init(json);
        return result;
    }
}

export interface ILoadTypeById {
    id: number;
    companyID: number;
}

export class LoanType implements ILoanType {
    code!: string | undefined;
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    approvalProcessId!: number;
    interestRate!: number;
    minTenor!: number;
    maxTenor!: number;
    minAmount!: number;
    maxAmount!: number;
    interestType!: number;
    requiresGuarantor!: boolean;
    requiredNoOfGuarantors!: number;
    eligibleGrades!: string | undefined;
    eligibleEmploymentStatus!: number;
    customQuestion!: string | undefined;
    maxLoanRepaytPercent!: number;
    strMinAmount!: string | undefined;
    strMaxAmount!: string | undefined;
    strRequiresGuarantor!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILoanType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.interestRate = _data["interestRate"];
            this.minTenor = _data["minTenor"];
            this.maxTenor = _data["maxTenor"];
            this.minAmount = _data["minAmount"];
            this.maxAmount = _data["maxAmount"];
            this.interestType = _data["interestType"];
            this.requiresGuarantor = _data["requiresGuarantor"];
            this.requiredNoOfGuarantors = _data["requiredNoOfGuarantors"];
            this.eligibleGrades = _data["eligibleGrades"];
            this.eligibleEmploymentStatus = _data["eligibleEmploymentStatus"];
            this.customQuestion = _data["customQuestion"];
            this.maxLoanRepaytPercent = _data["maxLoanRepaytPercent"];
            this.strMinAmount = _data["strMinAmount"];
            this.strMaxAmount = _data["strMaxAmount"];
            this.strRequiresGuarantor = _data["strRequiresGuarantor"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LoanType {
        data = typeof data === 'object' ? data : {};
        let result = new LoanType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["approvalProcessId"] = this.approvalProcessId;
        data["interestRate"] = this.interestRate;
        data["minTenor"] = this.minTenor;
        data["maxTenor"] = this.maxTenor;
        data["minAmount"] = this.minAmount;
        data["maxAmount"] = this.maxAmount;
        data["interestType"] = this.interestType;
        data["requiresGuarantor"] = this.requiresGuarantor;
        data["requiredNoOfGuarantors"] = this.requiredNoOfGuarantors;
        data["eligibleGrades"] = this.eligibleGrades;
        data["eligibleEmploymentStatus"] = this.eligibleEmploymentStatus;
        data["customQuestion"] = this.customQuestion;
        data["maxLoanRepaytPercent"] = this.maxLoanRepaytPercent;
        data["strMinAmount"] = this.strMinAmount;
        data["strMaxAmount"] = this.strMaxAmount;
        data["strRequiresGuarantor"] = this.strRequiresGuarantor;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LoanType {
        const json = this.toJSON();
        let result = new LoanType();
        result.init(json);
        return result;
    }
}

export interface ILoanType {
    code: string | undefined;
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    approvalProcessId: number;
    interestRate: number;
    minTenor: number;
    maxTenor: number;
    minAmount: number;
    maxAmount: number;
    interestType: number;
    requiresGuarantor: boolean;
    requiredNoOfGuarantors: number;
    eligibleGrades: string | undefined;
    eligibleEmploymentStatus: number;
    customQuestion: string | undefined;
    maxLoanRepaytPercent: number;
    strMinAmount: string | undefined;
    strMaxAmount: string | undefined;
    strRequiresGuarantor: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LoanTypeIListApiResult implements ILoanTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanType[] | undefined;
    totalCount!: number;

    constructor(data?: ILoanTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LoanType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LoanTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LoanTypeIListApiResult {
        const json = this.toJSON();
        let result = new LoanTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanType[] | undefined;
    totalCount: number;
}

export class ManageLocationDTO implements IManageLocationDTO {
    id!: number;
    location_name!: string;
    state_id!: number;
    lga_id!: number;
    is_enabled!: boolean;

    constructor(data?: IManageLocationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.location_name = _data["location_name"];
            this.state_id = _data["state_id"];
            this.lga_id = _data["lga_id"];
            this.is_enabled = _data["is_enabled"];
        }
    }

    static fromJS(data: any): ManageLocationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageLocationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["location_name"] = this.location_name;
        data["state_id"] = this.state_id;
        data["lga_id"] = this.lga_id;
        data["is_enabled"] = this.is_enabled;
        return data; 
    }

    clone(): ManageLocationDTO {
        const json = this.toJSON();
        let result = new ManageLocationDTO();
        result.init(json);
        return result;
    }
}

export interface IManageLocationDTO {
    id: number;
    location_name: string;
    state_id: number;
    lga_id: number;
    is_enabled: boolean;
}

export class LocationDTO implements ILocationDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    location_name!: string | undefined;
    lga_id!: number | undefined;
    state_id!: number | undefined;
    lga!: string | undefined;
    state!: string | undefined;
    is_enabled!: boolean;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILocationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.location_name = _data["location_name"];
            this.lga_id = _data["lga_id"];
            this.state_id = _data["state_id"];
            this.lga = _data["lga"];
            this.state = _data["state"];
            this.is_enabled = _data["is_enabled"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LocationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["location_name"] = this.location_name;
        data["lga_id"] = this.lga_id;
        data["state_id"] = this.state_id;
        data["lga"] = this.lga;
        data["state"] = this.state;
        data["is_enabled"] = this.is_enabled;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LocationDTO {
        const json = this.toJSON();
        let result = new LocationDTO();
        result.init(json);
        return result;
    }
}

export interface ILocationDTO {
    id: number;
    companyID: number;
    subID: number;
    location_name: string | undefined;
    lga_id: number | undefined;
    state_id: number | undefined;
    lga: string | undefined;
    state: string | undefined;
    is_enabled: boolean;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LocationDTOListApiResult implements ILocationDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LocationDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILocationDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LocationDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LocationDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LocationDTOListApiResult {
        const json = this.toJSON();
        let result = new LocationDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILocationDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LocationDTO[] | undefined;
    totalCount: number;
}

export class LocationDTOApiResult implements ILocationDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LocationDTO;
    totalCount!: number;

    constructor(data?: ILocationDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LocationDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LocationDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LocationDTOApiResult {
        const json = this.toJSON();
        let result = new LocationDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ILocationDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LocationDTO;
    totalCount: number;
}

export class OnboardingPersonalDTO implements IOnboardingPersonalDTO {
    id!: number;
    companyId!: number;
    subID!: number;
    titleId!: number;
    firstName!: string;
    lastName!: string;
    otherNames!: string | undefined;
    phoneNumber!: string | undefined;
    dateOfBirth!: Date;
    maritalStatusId!: number;
    genderId!: number;
    residentialAddress!: string | undefined;
    personalEmail!: string;
    defaultMobile!: string;
    religionId!: number;
    martialStatusId!: number | undefined;
    fieldOfStudy!: string;
    degree!: string;
    dateofCompletion!: Date;
    cgpa!: string | undefined;
    institutionId!: number | undefined;
    nextOfKinFullName!: string | undefined;
    netofKinRelationship!: string | undefined;
    nextofKinPhoneNumber!: string | undefined;
    nextofKinAddress!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    userId!: number;
    created_by!: string | undefined;

    constructor(data?: IOnboardingPersonalDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.subID = _data["subID"];
            this.titleId = _data["titleId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherNames = _data["otherNames"];
            this.phoneNumber = _data["phoneNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.maritalStatusId = _data["maritalStatusId"];
            this.genderId = _data["genderId"];
            this.residentialAddress = _data["residentialAddress"];
            this.personalEmail = _data["personalEmail"];
            this.defaultMobile = _data["defaultMobile"];
            this.religionId = _data["religionId"];
            this.martialStatusId = _data["martialStatusId"];
            this.fieldOfStudy = _data["fieldOfStudy"];
            this.degree = _data["degree"];
            this.dateofCompletion = _data["dateofCompletion"] ? new Date(_data["dateofCompletion"].toString()) : <any>undefined;
            this.cgpa = _data["cgpa"];
            this.institutionId = _data["institutionId"];
            this.nextOfKinFullName = _data["nextOfKinFullName"];
            this.netofKinRelationship = _data["netofKinRelationship"];
            this.nextofKinPhoneNumber = _data["nextofKinPhoneNumber"];
            this.nextofKinAddress = _data["nextofKinAddress"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.userId = _data["userId"];
            this.created_by = _data["created_by"];
        }
    }

    static fromJS(data: any): OnboardingPersonalDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingPersonalDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["subID"] = this.subID;
        data["titleId"] = this.titleId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherNames"] = this.otherNames;
        data["phoneNumber"] = this.phoneNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["maritalStatusId"] = this.maritalStatusId;
        data["genderId"] = this.genderId;
        data["residentialAddress"] = this.residentialAddress;
        data["personalEmail"] = this.personalEmail;
        data["defaultMobile"] = this.defaultMobile;
        data["religionId"] = this.religionId;
        data["martialStatusId"] = this.martialStatusId;
        data["fieldOfStudy"] = this.fieldOfStudy;
        data["degree"] = this.degree;
        data["dateofCompletion"] = this.dateofCompletion ? this.dateofCompletion.toISOString() : <any>undefined;
        data["cgpa"] = this.cgpa;
        data["institutionId"] = this.institutionId;
        data["nextOfKinFullName"] = this.nextOfKinFullName;
        data["netofKinRelationship"] = this.netofKinRelationship;
        data["nextofKinPhoneNumber"] = this.nextofKinPhoneNumber;
        data["nextofKinAddress"] = this.nextofKinAddress;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["userId"] = this.userId;
        data["created_by"] = this.created_by;
        return data; 
    }

    clone(): OnboardingPersonalDTO {
        const json = this.toJSON();
        let result = new OnboardingPersonalDTO();
        result.init(json);
        return result;
    }
}

export interface IOnboardingPersonalDTO {
    id: number;
    companyId: number;
    subID: number;
    titleId: number;
    firstName: string;
    lastName: string;
    otherNames: string | undefined;
    phoneNumber: string | undefined;
    dateOfBirth: Date;
    maritalStatusId: number;
    genderId: number;
    residentialAddress: string | undefined;
    personalEmail: string;
    defaultMobile: string;
    religionId: number;
    martialStatusId: number | undefined;
    fieldOfStudy: string;
    degree: string;
    dateofCompletion: Date;
    cgpa: string | undefined;
    institutionId: number | undefined;
    nextOfKinFullName: string | undefined;
    netofKinRelationship: string | undefined;
    nextofKinPhoneNumber: string | undefined;
    nextofKinAddress: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    userId: number;
    created_by: string | undefined;
}

export class OnboardingBankDTO implements IOnboardingBankDTO {
    id!: number;
    companyId!: number;
    subID!: number;
    onboardingId!: number;
    bankNameId!: number;
    accountName!: string;
    accountNumber!: string;
    accountTypeId!: number;
    paymentMethodId!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    userId!: number;
    bvn!: string | undefined;
    fullName!: string | undefined;
    dialingCode!: string | undefined;
    created_by!: string | undefined;

    constructor(data?: IOnboardingBankDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.subID = _data["subID"];
            this.onboardingId = _data["onboardingId"];
            this.bankNameId = _data["bankNameId"];
            this.accountName = _data["accountName"];
            this.accountNumber = _data["accountNumber"];
            this.accountTypeId = _data["accountTypeId"];
            this.paymentMethodId = _data["paymentMethodId"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.userId = _data["userId"];
            this.bvn = _data["bvn"];
            this.fullName = _data["fullName"];
            this.dialingCode = _data["dialingCode"];
            this.created_by = _data["created_by"];
        }
    }

    static fromJS(data: any): OnboardingBankDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingBankDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["subID"] = this.subID;
        data["onboardingId"] = this.onboardingId;
        data["bankNameId"] = this.bankNameId;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["accountTypeId"] = this.accountTypeId;
        data["paymentMethodId"] = this.paymentMethodId;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["userId"] = this.userId;
        data["bvn"] = this.bvn;
        data["fullName"] = this.fullName;
        data["dialingCode"] = this.dialingCode;
        data["created_by"] = this.created_by;
        return data; 
    }

    clone(): OnboardingBankDTO {
        const json = this.toJSON();
        let result = new OnboardingBankDTO();
        result.init(json);
        return result;
    }
}

export interface IOnboardingBankDTO {
    id: number;
    companyId: number;
    subID: number;
    onboardingId: number;
    bankNameId: number;
    accountName: string;
    accountNumber: string;
    accountTypeId: number;
    paymentMethodId: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    userId: number;
    bvn: string | undefined;
    fullName: string | undefined;
    dialingCode: string | undefined;
    created_by: string | undefined;
}

export class OnboardingWorkDTO implements IOnboardingWorkDTO {
    id!: number;
    companyId!: number;
    subID!: number;
    onboardingId!: number;
    hireDate!: Date;
    dateofJoining!: Date;
    salaryPerAnnum!: number;
    desginationId!: number;
    employeeTypeId!: number;
    departmentId!: number;
    reportingManagerId!: number;
    location!: string | undefined;
    workEmail!: string;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    userId!: number;
    created_by!: string | undefined;

    constructor(data?: IOnboardingWorkDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.subID = _data["subID"];
            this.onboardingId = _data["onboardingId"];
            this.hireDate = _data["hireDate"] ? new Date(_data["hireDate"].toString()) : <any>undefined;
            this.dateofJoining = _data["dateofJoining"] ? new Date(_data["dateofJoining"].toString()) : <any>undefined;
            this.salaryPerAnnum = _data["salaryPerAnnum"];
            this.desginationId = _data["desginationId"];
            this.employeeTypeId = _data["employeeTypeId"];
            this.departmentId = _data["departmentId"];
            this.reportingManagerId = _data["reportingManagerId"];
            this.location = _data["location"];
            this.workEmail = _data["workEmail"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.userId = _data["userId"];
            this.created_by = _data["created_by"];
        }
    }

    static fromJS(data: any): OnboardingWorkDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingWorkDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["subID"] = this.subID;
        data["onboardingId"] = this.onboardingId;
        data["hireDate"] = this.hireDate ? this.hireDate.toISOString() : <any>undefined;
        data["dateofJoining"] = this.dateofJoining ? this.dateofJoining.toISOString() : <any>undefined;
        data["salaryPerAnnum"] = this.salaryPerAnnum;
        data["desginationId"] = this.desginationId;
        data["employeeTypeId"] = this.employeeTypeId;
        data["departmentId"] = this.departmentId;
        data["reportingManagerId"] = this.reportingManagerId;
        data["location"] = this.location;
        data["workEmail"] = this.workEmail;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["userId"] = this.userId;
        data["created_by"] = this.created_by;
        return data; 
    }

    clone(): OnboardingWorkDTO {
        const json = this.toJSON();
        let result = new OnboardingWorkDTO();
        result.init(json);
        return result;
    }
}

export interface IOnboardingWorkDTO {
    id: number;
    companyId: number;
    subID: number;
    onboardingId: number;
    hireDate: Date;
    dateofJoining: Date;
    salaryPerAnnum: number;
    desginationId: number;
    employeeTypeId: number;
    departmentId: number;
    reportingManagerId: number;
    location: string | undefined;
    workEmail: string;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    userId: number;
    created_by: string | undefined;
}

export class OnboardingTaxDTO implements IOnboardingTaxDTO {
    id!: number;
    companyId!: number;
    subID!: number;
    onboardingId!: number;
    taxId!: string;
    nationality_Nigeria!: boolean;
    passportNumber!: string | undefined;
    passportExpiryDate!: Date;
    countryId!: number;
    visaTypeId!: number;
    visaExpiryDate!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dialingCode!: string | undefined;
    created_by!: string | undefined;

    constructor(data?: IOnboardingTaxDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.subID = _data["subID"];
            this.onboardingId = _data["onboardingId"];
            this.taxId = _data["taxId"];
            this.nationality_Nigeria = _data["nationality_Nigeria"];
            this.passportNumber = _data["passportNumber"];
            this.passportExpiryDate = _data["passportExpiryDate"] ? new Date(_data["passportExpiryDate"].toString()) : <any>undefined;
            this.countryId = _data["countryId"];
            this.visaTypeId = _data["visaTypeId"];
            this.visaExpiryDate = _data["visaExpiryDate"] ? new Date(_data["visaExpiryDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dialingCode = _data["dialingCode"];
            this.created_by = _data["created_by"];
        }
    }

    static fromJS(data: any): OnboardingTaxDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingTaxDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["subID"] = this.subID;
        data["onboardingId"] = this.onboardingId;
        data["taxId"] = this.taxId;
        data["nationality_Nigeria"] = this.nationality_Nigeria;
        data["passportNumber"] = this.passportNumber;
        data["passportExpiryDate"] = this.passportExpiryDate ? this.passportExpiryDate.toISOString() : <any>undefined;
        data["countryId"] = this.countryId;
        data["visaTypeId"] = this.visaTypeId;
        data["visaExpiryDate"] = this.visaExpiryDate ? this.visaExpiryDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dialingCode"] = this.dialingCode;
        data["created_by"] = this.created_by;
        return data; 
    }

    clone(): OnboardingTaxDTO {
        const json = this.toJSON();
        let result = new OnboardingTaxDTO();
        result.init(json);
        return result;
    }
}

export interface IOnboardingTaxDTO {
    id: number;
    companyId: number;
    subID: number;
    onboardingId: number;
    taxId: string;
    nationality_Nigeria: boolean;
    passportNumber: string | undefined;
    passportExpiryDate: Date;
    countryId: number;
    visaTypeId: number;
    visaExpiryDate: Date;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dialingCode: string | undefined;
    created_by: string | undefined;
}

export class OnboardingMedicalDisclosureDTO implements IOnboardingMedicalDisclosureDTO {
    id!: number;
    companyId!: number;
    subID!: number;
    onboardingId!: number;
    genotype!: string;
    bloodGroup!: string;
    anyPreInjury!: boolean;
    statePreInjury!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    userId!: number;
    created_by!: string | undefined;

    constructor(data?: IOnboardingMedicalDisclosureDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.subID = _data["subID"];
            this.onboardingId = _data["onboardingId"];
            this.genotype = _data["genotype"];
            this.bloodGroup = _data["bloodGroup"];
            this.anyPreInjury = _data["anyPreInjury"];
            this.statePreInjury = _data["statePreInjury"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.userId = _data["userId"];
            this.created_by = _data["created_by"];
        }
    }

    static fromJS(data: any): OnboardingMedicalDisclosureDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingMedicalDisclosureDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["subID"] = this.subID;
        data["onboardingId"] = this.onboardingId;
        data["genotype"] = this.genotype;
        data["bloodGroup"] = this.bloodGroup;
        data["anyPreInjury"] = this.anyPreInjury;
        data["statePreInjury"] = this.statePreInjury;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["userId"] = this.userId;
        data["created_by"] = this.created_by;
        return data; 
    }

    clone(): OnboardingMedicalDisclosureDTO {
        const json = this.toJSON();
        let result = new OnboardingMedicalDisclosureDTO();
        result.init(json);
        return result;
    }
}

export interface IOnboardingMedicalDisclosureDTO {
    id: number;
    companyId: number;
    subID: number;
    onboardingId: number;
    genotype: string;
    bloodGroup: string;
    anyPreInjury: boolean;
    statePreInjury: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    userId: number;
    created_by: string | undefined;
}

export class OnboardingPersonalInfo implements IOnboardingPersonalInfo {
    userId!: number;
    titleId!: number;
    firstName!: string | undefined;
    lastName!: string | undefined;
    phoneNumber!: string | undefined;
    dateofBirth!: Date;
    martialStatus!: number;
    genderId!: number;
    residentialAddress!: string | undefined;
    fieldofStudy!: string | undefined;
    degree!: string | undefined;
    defaultMobile!: string | undefined;
    personalEmail!: string | undefined;
    dateofCompletion!: Date;
    cgpa!: string | undefined;
    institutionId!: number;
    nextOfKinFullName!: string | undefined;
    netofKinRelationship!: string | undefined;
    nextofKinPhoneNumber!: string | undefined;
    nextofKinAddress!: string | undefined;
    martialStatusId!: number;
    completedOnboarding!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IOnboardingPersonalInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.titleId = _data["titleId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.dateofBirth = _data["dateofBirth"] ? new Date(_data["dateofBirth"].toString()) : <any>undefined;
            this.martialStatus = _data["martialStatus"];
            this.genderId = _data["genderId"];
            this.residentialAddress = _data["residentialAddress"];
            this.fieldofStudy = _data["fieldofStudy"];
            this.degree = _data["degree"];
            this.defaultMobile = _data["defaultMobile"];
            this.personalEmail = _data["personalEmail"];
            this.dateofCompletion = _data["dateofCompletion"] ? new Date(_data["dateofCompletion"].toString()) : <any>undefined;
            this.cgpa = _data["cgpa"];
            this.institutionId = _data["institutionId"];
            this.nextOfKinFullName = _data["nextOfKinFullName"];
            this.netofKinRelationship = _data["netofKinRelationship"];
            this.nextofKinPhoneNumber = _data["nextofKinPhoneNumber"];
            this.nextofKinAddress = _data["nextofKinAddress"];
            this.martialStatusId = _data["martialStatusId"];
            this.completedOnboarding = _data["completedOnboarding"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): OnboardingPersonalInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingPersonalInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["titleId"] = this.titleId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["martialStatus"] = this.martialStatus;
        data["genderId"] = this.genderId;
        data["residentialAddress"] = this.residentialAddress;
        data["fieldofStudy"] = this.fieldofStudy;
        data["degree"] = this.degree;
        data["defaultMobile"] = this.defaultMobile;
        data["personalEmail"] = this.personalEmail;
        data["dateofCompletion"] = this.dateofCompletion ? this.dateofCompletion.toISOString() : <any>undefined;
        data["cgpa"] = this.cgpa;
        data["institutionId"] = this.institutionId;
        data["nextOfKinFullName"] = this.nextOfKinFullName;
        data["netofKinRelationship"] = this.netofKinRelationship;
        data["nextofKinPhoneNumber"] = this.nextofKinPhoneNumber;
        data["nextofKinAddress"] = this.nextofKinAddress;
        data["martialStatusId"] = this.martialStatusId;
        data["completedOnboarding"] = this.completedOnboarding;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): OnboardingPersonalInfo {
        const json = this.toJSON();
        let result = new OnboardingPersonalInfo();
        result.init(json);
        return result;
    }
}

export interface IOnboardingPersonalInfo {
    userId: number;
    titleId: number;
    firstName: string | undefined;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    dateofBirth: Date;
    martialStatus: number;
    genderId: number;
    residentialAddress: string | undefined;
    fieldofStudy: string | undefined;
    degree: string | undefined;
    defaultMobile: string | undefined;
    personalEmail: string | undefined;
    dateofCompletion: Date;
    cgpa: string | undefined;
    institutionId: number;
    nextOfKinFullName: string | undefined;
    netofKinRelationship: string | undefined;
    nextofKinPhoneNumber: string | undefined;
    nextofKinAddress: string | undefined;
    martialStatusId: number;
    completedOnboarding: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class OnboardingPersonalInfoApiResult implements IOnboardingPersonalInfoApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: OnboardingPersonalInfo;
    totalCount!: number;

    constructor(data?: IOnboardingPersonalInfoApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? OnboardingPersonalInfo.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): OnboardingPersonalInfoApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingPersonalInfoApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): OnboardingPersonalInfoApiResult {
        const json = this.toJSON();
        let result = new OnboardingPersonalInfoApiResult();
        result.init(json);
        return result;
    }
}

export interface IOnboardingPersonalInfoApiResult {
    hasError: boolean;
    message: string | undefined;
    result: OnboardingPersonalInfo;
    totalCount: number;
}

export class OnboardingDocumentInfo implements IOnboardingDocumentInfo {
    onboardingId!: number;
    nyscCertificate!: string | undefined;
    birthCertificate!: string | undefined;
    driverLicense!: string | undefined;
    addtionalDocument!: string | undefined;
    passport!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IOnboardingDocumentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onboardingId = _data["onboardingId"];
            this.nyscCertificate = _data["nyscCertificate"];
            this.birthCertificate = _data["birthCertificate"];
            this.driverLicense = _data["driverLicense"];
            this.addtionalDocument = _data["addtionalDocument"];
            this.passport = _data["passport"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): OnboardingDocumentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingDocumentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onboardingId"] = this.onboardingId;
        data["nyscCertificate"] = this.nyscCertificate;
        data["birthCertificate"] = this.birthCertificate;
        data["driverLicense"] = this.driverLicense;
        data["addtionalDocument"] = this.addtionalDocument;
        data["passport"] = this.passport;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): OnboardingDocumentInfo {
        const json = this.toJSON();
        let result = new OnboardingDocumentInfo();
        result.init(json);
        return result;
    }
}

export interface IOnboardingDocumentInfo {
    onboardingId: number;
    nyscCertificate: string | undefined;
    birthCertificate: string | undefined;
    driverLicense: string | undefined;
    addtionalDocument: string | undefined;
    passport: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class OnboardingDocumentInfoApiResult implements IOnboardingDocumentInfoApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: OnboardingDocumentInfo;
    totalCount!: number;

    constructor(data?: IOnboardingDocumentInfoApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? OnboardingDocumentInfo.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): OnboardingDocumentInfoApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingDocumentInfoApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): OnboardingDocumentInfoApiResult {
        const json = this.toJSON();
        let result = new OnboardingDocumentInfoApiResult();
        result.init(json);
        return result;
    }
}

export interface IOnboardingDocumentInfoApiResult {
    hasError: boolean;
    message: string | undefined;
    result: OnboardingDocumentInfo;
    totalCount: number;
}

export class OnboardingMedicalDisclosureInfo implements IOnboardingMedicalDisclosureInfo {
    onboardingId!: number;
    genotype!: string | undefined;
    bloodGroup!: string | undefined;
    anyPreInjury!: boolean;
    statePreInjury!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IOnboardingMedicalDisclosureInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onboardingId = _data["onboardingId"];
            this.genotype = _data["genotype"];
            this.bloodGroup = _data["bloodGroup"];
            this.anyPreInjury = _data["anyPreInjury"];
            this.statePreInjury = _data["statePreInjury"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): OnboardingMedicalDisclosureInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingMedicalDisclosureInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onboardingId"] = this.onboardingId;
        data["genotype"] = this.genotype;
        data["bloodGroup"] = this.bloodGroup;
        data["anyPreInjury"] = this.anyPreInjury;
        data["statePreInjury"] = this.statePreInjury;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): OnboardingMedicalDisclosureInfo {
        const json = this.toJSON();
        let result = new OnboardingMedicalDisclosureInfo();
        result.init(json);
        return result;
    }
}

export interface IOnboardingMedicalDisclosureInfo {
    onboardingId: number;
    genotype: string | undefined;
    bloodGroup: string | undefined;
    anyPreInjury: boolean;
    statePreInjury: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class OnboardingMedicalDisclosureInfoApiResult implements IOnboardingMedicalDisclosureInfoApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: OnboardingMedicalDisclosureInfo;
    totalCount!: number;

    constructor(data?: IOnboardingMedicalDisclosureInfoApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? OnboardingMedicalDisclosureInfo.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): OnboardingMedicalDisclosureInfoApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingMedicalDisclosureInfoApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): OnboardingMedicalDisclosureInfoApiResult {
        const json = this.toJSON();
        let result = new OnboardingMedicalDisclosureInfoApiResult();
        result.init(json);
        return result;
    }
}

export interface IOnboardingMedicalDisclosureInfoApiResult {
    hasError: boolean;
    message: string | undefined;
    result: OnboardingMedicalDisclosureInfo;
    totalCount: number;
}

export class OnboardingTaxInfo implements IOnboardingTaxInfo {
    onboardingId!: number;
    taxId!: string | undefined;
    nationality_Nigeria!: boolean;
    passportNumber!: string | undefined;
    passportExpiryDate!: Date;
    countryId!: number;
    visaTypeId!: number;
    visaExpiryDate!: Date;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IOnboardingTaxInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onboardingId = _data["onboardingId"];
            this.taxId = _data["taxId"];
            this.nationality_Nigeria = _data["nationality_Nigeria"];
            this.passportNumber = _data["passportNumber"];
            this.passportExpiryDate = _data["passportExpiryDate"] ? new Date(_data["passportExpiryDate"].toString()) : <any>undefined;
            this.countryId = _data["countryId"];
            this.visaTypeId = _data["visaTypeId"];
            this.visaExpiryDate = _data["visaExpiryDate"] ? new Date(_data["visaExpiryDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): OnboardingTaxInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingTaxInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onboardingId"] = this.onboardingId;
        data["taxId"] = this.taxId;
        data["nationality_Nigeria"] = this.nationality_Nigeria;
        data["passportNumber"] = this.passportNumber;
        data["passportExpiryDate"] = this.passportExpiryDate ? this.passportExpiryDate.toISOString() : <any>undefined;
        data["countryId"] = this.countryId;
        data["visaTypeId"] = this.visaTypeId;
        data["visaExpiryDate"] = this.visaExpiryDate ? this.visaExpiryDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): OnboardingTaxInfo {
        const json = this.toJSON();
        let result = new OnboardingTaxInfo();
        result.init(json);
        return result;
    }
}

export interface IOnboardingTaxInfo {
    onboardingId: number;
    taxId: string | undefined;
    nationality_Nigeria: boolean;
    passportNumber: string | undefined;
    passportExpiryDate: Date;
    countryId: number;
    visaTypeId: number;
    visaExpiryDate: Date;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class OnboardingTaxInfoApiResult implements IOnboardingTaxInfoApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: OnboardingTaxInfo;
    totalCount!: number;

    constructor(data?: IOnboardingTaxInfoApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? OnboardingTaxInfo.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): OnboardingTaxInfoApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingTaxInfoApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): OnboardingTaxInfoApiResult {
        const json = this.toJSON();
        let result = new OnboardingTaxInfoApiResult();
        result.init(json);
        return result;
    }
}

export interface IOnboardingTaxInfoApiResult {
    hasError: boolean;
    message: string | undefined;
    result: OnboardingTaxInfo;
    totalCount: number;
}

export class OnboardingPaymentInfo implements IOnboardingPaymentInfo {
    onboardingId!: number;
    bankNameId!: number;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    accountTypeId!: number;
    paymentMethodId!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IOnboardingPaymentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onboardingId = _data["onboardingId"];
            this.bankNameId = _data["bankNameId"];
            this.accountName = _data["accountName"];
            this.accountNumber = _data["accountNumber"];
            this.accountTypeId = _data["accountTypeId"];
            this.paymentMethodId = _data["paymentMethodId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): OnboardingPaymentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingPaymentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onboardingId"] = this.onboardingId;
        data["bankNameId"] = this.bankNameId;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["accountTypeId"] = this.accountTypeId;
        data["paymentMethodId"] = this.paymentMethodId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): OnboardingPaymentInfo {
        const json = this.toJSON();
        let result = new OnboardingPaymentInfo();
        result.init(json);
        return result;
    }
}

export interface IOnboardingPaymentInfo {
    onboardingId: number;
    bankNameId: number;
    accountName: string | undefined;
    accountNumber: string | undefined;
    accountTypeId: number;
    paymentMethodId: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class OnboardingWorkInformation implements IOnboardingWorkInformation {
    onboardingId!: number;
    hireDate!: Date;
    dateofJoining!: Date;
    salaryPerAnnum!: number;
    desginationId!: number;
    employeeTypeId!: number;
    departmentId!: number;
    reportingManagerId!: number;
    location!: string | undefined;
    workEmail!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IOnboardingWorkInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onboardingId = _data["onboardingId"];
            this.hireDate = _data["hireDate"] ? new Date(_data["hireDate"].toString()) : <any>undefined;
            this.dateofJoining = _data["dateofJoining"] ? new Date(_data["dateofJoining"].toString()) : <any>undefined;
            this.salaryPerAnnum = _data["salaryPerAnnum"];
            this.desginationId = _data["desginationId"];
            this.employeeTypeId = _data["employeeTypeId"];
            this.departmentId = _data["departmentId"];
            this.reportingManagerId = _data["reportingManagerId"];
            this.location = _data["location"];
            this.workEmail = _data["workEmail"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): OnboardingWorkInformation {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingWorkInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onboardingId"] = this.onboardingId;
        data["hireDate"] = this.hireDate ? this.hireDate.toISOString() : <any>undefined;
        data["dateofJoining"] = this.dateofJoining ? this.dateofJoining.toISOString() : <any>undefined;
        data["salaryPerAnnum"] = this.salaryPerAnnum;
        data["desginationId"] = this.desginationId;
        data["employeeTypeId"] = this.employeeTypeId;
        data["departmentId"] = this.departmentId;
        data["reportingManagerId"] = this.reportingManagerId;
        data["location"] = this.location;
        data["workEmail"] = this.workEmail;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): OnboardingWorkInformation {
        const json = this.toJSON();
        let result = new OnboardingWorkInformation();
        result.init(json);
        return result;
    }
}

export interface IOnboardingWorkInformation {
    onboardingId: number;
    hireDate: Date;
    dateofJoining: Date;
    salaryPerAnnum: number;
    desginationId: number;
    employeeTypeId: number;
    departmentId: number;
    reportingManagerId: number;
    location: string | undefined;
    workEmail: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeOnboardingPersonalData implements IEmployeeOnboardingPersonalData {
    onboardingId!: number;
    onboardingDocumentInfo!: OnboardingDocumentInfo;
    onboardingMedicalDisclosureInfo!: OnboardingMedicalDisclosureInfo;
    onboardingPaymentInfo!: OnboardingPaymentInfo;
    onboardingPersonalInfo!: OnboardingPersonalInfo;
    onboardingTaxInfo!: OnboardingTaxInfo;
    onboardingWorkInformation!: OnboardingWorkInformation;

    constructor(data?: IEmployeeOnboardingPersonalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onboardingId = _data["onboardingId"];
            this.onboardingDocumentInfo = _data["onboardingDocumentInfo"] ? OnboardingDocumentInfo.fromJS(_data["onboardingDocumentInfo"]) : <any>undefined;
            this.onboardingMedicalDisclosureInfo = _data["onboardingMedicalDisclosureInfo"] ? OnboardingMedicalDisclosureInfo.fromJS(_data["onboardingMedicalDisclosureInfo"]) : <any>undefined;
            this.onboardingPaymentInfo = _data["onboardingPaymentInfo"] ? OnboardingPaymentInfo.fromJS(_data["onboardingPaymentInfo"]) : <any>undefined;
            this.onboardingPersonalInfo = _data["onboardingPersonalInfo"] ? OnboardingPersonalInfo.fromJS(_data["onboardingPersonalInfo"]) : <any>undefined;
            this.onboardingTaxInfo = _data["onboardingTaxInfo"] ? OnboardingTaxInfo.fromJS(_data["onboardingTaxInfo"]) : <any>undefined;
            this.onboardingWorkInformation = _data["onboardingWorkInformation"] ? OnboardingWorkInformation.fromJS(_data["onboardingWorkInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmployeeOnboardingPersonalData {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeOnboardingPersonalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onboardingId"] = this.onboardingId;
        data["onboardingDocumentInfo"] = this.onboardingDocumentInfo ? this.onboardingDocumentInfo.toJSON() : <any>undefined;
        data["onboardingMedicalDisclosureInfo"] = this.onboardingMedicalDisclosureInfo ? this.onboardingMedicalDisclosureInfo.toJSON() : <any>undefined;
        data["onboardingPaymentInfo"] = this.onboardingPaymentInfo ? this.onboardingPaymentInfo.toJSON() : <any>undefined;
        data["onboardingPersonalInfo"] = this.onboardingPersonalInfo ? this.onboardingPersonalInfo.toJSON() : <any>undefined;
        data["onboardingTaxInfo"] = this.onboardingTaxInfo ? this.onboardingTaxInfo.toJSON() : <any>undefined;
        data["onboardingWorkInformation"] = this.onboardingWorkInformation ? this.onboardingWorkInformation.toJSON() : <any>undefined;
        return data; 
    }

    clone(): EmployeeOnboardingPersonalData {
        const json = this.toJSON();
        let result = new EmployeeOnboardingPersonalData();
        result.init(json);
        return result;
    }
}

export interface IEmployeeOnboardingPersonalData {
    onboardingId: number;
    onboardingDocumentInfo: OnboardingDocumentInfo;
    onboardingMedicalDisclosureInfo: OnboardingMedicalDisclosureInfo;
    onboardingPaymentInfo: OnboardingPaymentInfo;
    onboardingPersonalInfo: OnboardingPersonalInfo;
    onboardingTaxInfo: OnboardingTaxInfo;
    onboardingWorkInformation: OnboardingWorkInformation;
}

export class EmployeeOnboardingPersonalDataListApiResult implements IEmployeeOnboardingPersonalDataListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeOnboardingPersonalData[] | undefined;
    totalCount!: number;

    constructor(data?: IEmployeeOnboardingPersonalDataListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmployeeOnboardingPersonalData.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmployeeOnboardingPersonalDataListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeOnboardingPersonalDataListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmployeeOnboardingPersonalDataListApiResult {
        const json = this.toJSON();
        let result = new EmployeeOnboardingPersonalDataListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeOnboardingPersonalDataListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeOnboardingPersonalData[] | undefined;
    totalCount: number;
}

export class ManagePayElementDTO implements IManagePayElementDTO {
    id!: number;
    payrollItemId!: number;
    payTypeId!: number;
    paymentInstitutionId!: number;
    name!: string | undefined;
    elementTypeId!: number;
    elementCategoryId!: number;
    is_reoccurring!: boolean;
    isTaxDeduct!: boolean;
    amount!: number | undefined;
    is_variable!: boolean;
    ratio!: number | undefined;
    taxPercentage!: number | undefined;
    hourlyPay!: number | undefined;
    noOfWorkHours!: number | undefined;
    start_date!: Date | undefined;
    end_date!: Date | undefined;

    constructor(data?: IManagePayElementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.payrollItemId = _data["payrollItemId"];
            this.payTypeId = _data["payTypeId"];
            this.paymentInstitutionId = _data["paymentInstitutionId"];
            this.name = _data["name"];
            this.elementTypeId = _data["elementTypeId"];
            this.elementCategoryId = _data["elementCategoryId"];
            this.is_reoccurring = _data["is_reoccurring"];
            this.isTaxDeduct = _data["isTaxDeduct"];
            this.amount = _data["amount"];
            this.is_variable = _data["is_variable"];
            this.ratio = _data["ratio"];
            this.taxPercentage = _data["taxPercentage"];
            this.hourlyPay = _data["hourlyPay"];
            this.noOfWorkHours = _data["noOfWorkHours"];
            this.start_date = _data["start_date"] ? new Date(_data["start_date"].toString()) : <any>undefined;
            this.end_date = _data["end_date"] ? new Date(_data["end_date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ManagePayElementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManagePayElementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["payrollItemId"] = this.payrollItemId;
        data["payTypeId"] = this.payTypeId;
        data["paymentInstitutionId"] = this.paymentInstitutionId;
        data["name"] = this.name;
        data["elementTypeId"] = this.elementTypeId;
        data["elementCategoryId"] = this.elementCategoryId;
        data["is_reoccurring"] = this.is_reoccurring;
        data["isTaxDeduct"] = this.isTaxDeduct;
        data["amount"] = this.amount;
        data["is_variable"] = this.is_variable;
        data["ratio"] = this.ratio;
        data["taxPercentage"] = this.taxPercentage;
        data["hourlyPay"] = this.hourlyPay;
        data["noOfWorkHours"] = this.noOfWorkHours;
        data["start_date"] = this.start_date ? this.start_date.toISOString() : <any>undefined;
        data["end_date"] = this.end_date ? this.end_date.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ManagePayElementDTO {
        const json = this.toJSON();
        let result = new ManagePayElementDTO();
        result.init(json);
        return result;
    }
}

export interface IManagePayElementDTO {
    id: number;
    payrollItemId: number;
    payTypeId: number;
    paymentInstitutionId: number;
    name: string | undefined;
    elementTypeId: number;
    elementCategoryId: number;
    is_reoccurring: boolean;
    isTaxDeduct: boolean;
    amount: number | undefined;
    is_variable: boolean;
    ratio: number | undefined;
    taxPercentage: number | undefined;
    hourlyPay: number | undefined;
    noOfWorkHours: number | undefined;
    start_date: Date | undefined;
    end_date: Date | undefined;
}

export class PayElementDTO implements IPayElementDTO {
    id!: number;
    company_id!: number;
    sub_id!: number;
    payrollItemId!: number;
    payTypeId!: number;
    paymentInstitutionId!: number;
    paymentInstitution!: string | undefined;
    name!: string | undefined;
    elementTypeId!: number;
    elementType!: string | undefined;
    elementCategoryId!: number;
    elementCategory!: string | undefined;
    is_reoccurring!: boolean;
    isTaxDeduct!: boolean;
    amount!: number | undefined;
    is_variable!: boolean;
    ratio!: number | undefined;
    taxPercentage!: number | undefined;
    hourlyPay!: number | undefined;
    noOfWorkHours!: number | undefined;
    start_date!: Date | undefined;
    end_date!: Date | undefined;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    readonly payType!: string | undefined;

    constructor(data?: IPayElementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.payrollItemId = _data["payrollItemId"];
            this.payTypeId = _data["payTypeId"];
            this.paymentInstitutionId = _data["paymentInstitutionId"];
            this.paymentInstitution = _data["paymentInstitution"];
            this.name = _data["name"];
            this.elementTypeId = _data["elementTypeId"];
            this.elementType = _data["elementType"];
            this.elementCategoryId = _data["elementCategoryId"];
            this.elementCategory = _data["elementCategory"];
            this.is_reoccurring = _data["is_reoccurring"];
            this.isTaxDeduct = _data["isTaxDeduct"];
            this.amount = _data["amount"];
            this.is_variable = _data["is_variable"];
            this.ratio = _data["ratio"];
            this.taxPercentage = _data["taxPercentage"];
            this.hourlyPay = _data["hourlyPay"];
            this.noOfWorkHours = _data["noOfWorkHours"];
            this.start_date = _data["start_date"] ? new Date(_data["start_date"].toString()) : <any>undefined;
            this.end_date = _data["end_date"] ? new Date(_data["end_date"].toString()) : <any>undefined;
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            (<any>this).payType = _data["payType"];
        }
    }

    static fromJS(data: any): PayElementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PayElementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["payrollItemId"] = this.payrollItemId;
        data["payTypeId"] = this.payTypeId;
        data["paymentInstitutionId"] = this.paymentInstitutionId;
        data["paymentInstitution"] = this.paymentInstitution;
        data["name"] = this.name;
        data["elementTypeId"] = this.elementTypeId;
        data["elementType"] = this.elementType;
        data["elementCategoryId"] = this.elementCategoryId;
        data["elementCategory"] = this.elementCategory;
        data["is_reoccurring"] = this.is_reoccurring;
        data["isTaxDeduct"] = this.isTaxDeduct;
        data["amount"] = this.amount;
        data["is_variable"] = this.is_variable;
        data["ratio"] = this.ratio;
        data["taxPercentage"] = this.taxPercentage;
        data["hourlyPay"] = this.hourlyPay;
        data["noOfWorkHours"] = this.noOfWorkHours;
        data["start_date"] = this.start_date ? this.start_date.toISOString() : <any>undefined;
        data["end_date"] = this.end_date ? this.end_date.toISOString() : <any>undefined;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        data["payType"] = this.payType;
        return data; 
    }

    clone(): PayElementDTO {
        const json = this.toJSON();
        let result = new PayElementDTO();
        result.init(json);
        return result;
    }
}

export interface IPayElementDTO {
    id: number;
    company_id: number;
    sub_id: number;
    payrollItemId: number;
    payTypeId: number;
    paymentInstitutionId: number;
    paymentInstitution: string | undefined;
    name: string | undefined;
    elementTypeId: number;
    elementType: string | undefined;
    elementCategoryId: number;
    elementCategory: string | undefined;
    is_reoccurring: boolean;
    isTaxDeduct: boolean;
    amount: number | undefined;
    is_variable: boolean;
    ratio: number | undefined;
    taxPercentage: number | undefined;
    hourlyPay: number | undefined;
    noOfWorkHours: number | undefined;
    start_date: Date | undefined;
    end_date: Date | undefined;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    payType: string | undefined;
}

export class PayElementDTOListApiResult implements IPayElementDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayElementDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IPayElementDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PayElementDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PayElementDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayElementDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PayElementDTOListApiResult {
        const json = this.toJSON();
        let result = new PayElementDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayElementDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayElementDTO[] | undefined;
    totalCount: number;
}

export class PayElementDTOApiResult implements IPayElementDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayElementDTO;
    totalCount!: number;

    constructor(data?: IPayElementDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? PayElementDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PayElementDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayElementDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PayElementDTOApiResult {
        const json = this.toJSON();
        let result = new PayElementDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayElementDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayElementDTO;
    totalCount: number;
}

export class ManagePayInstitutionDTO implements IManagePayInstitutionDTO {
    id!: number;
    categoryId!: number;
    name!: string | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    bankId!: number;

    constructor(data?: IManagePayInstitutionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.accountName = _data["accountName"];
            this.accountNumber = _data["accountNumber"];
            this.bankId = _data["bankId"];
        }
    }

    static fromJS(data: any): ManagePayInstitutionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManagePayInstitutionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["bankId"] = this.bankId;
        return data; 
    }

    clone(): ManagePayInstitutionDTO {
        const json = this.toJSON();
        let result = new ManagePayInstitutionDTO();
        result.init(json);
        return result;
    }
}

export interface IManagePayInstitutionDTO {
    id: number;
    categoryId: number;
    name: string | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    bankId: number;
}

export class PayInstitutionDTO implements IPayInstitutionDTO {
    id!: number;
    company_id!: number;
    sub_id!: number;
    categoryId!: number;
    name!: string | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    bankId!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;

    constructor(data?: IPayInstitutionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.accountName = _data["accountName"];
            this.accountNumber = _data["accountNumber"];
            this.bankId = _data["bankId"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PayInstitutionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PayInstitutionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["bankId"] = this.bankId;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        return data; 
    }

    clone(): PayInstitutionDTO {
        const json = this.toJSON();
        let result = new PayInstitutionDTO();
        result.init(json);
        return result;
    }
}

export interface IPayInstitutionDTO {
    id: number;
    company_id: number;
    sub_id: number;
    categoryId: number;
    name: string | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    bankId: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
}

export class PayInstitutionDTOListApiResult implements IPayInstitutionDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayInstitutionDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IPayInstitutionDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PayInstitutionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PayInstitutionDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayInstitutionDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PayInstitutionDTOListApiResult {
        const json = this.toJSON();
        let result = new PayInstitutionDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayInstitutionDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayInstitutionDTO[] | undefined;
    totalCount: number;
}

export class PayInstitutionDTOApiResult implements IPayInstitutionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayInstitutionDTO;
    totalCount!: number;

    constructor(data?: IPayInstitutionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? PayInstitutionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PayInstitutionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayInstitutionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PayInstitutionDTOApiResult {
        const json = this.toJSON();
        let result = new PayInstitutionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayInstitutionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayInstitutionDTO;
    totalCount: number;
}

export class ManagePayrollTypeDTO implements IManagePayrollTypeDTO {
    id!: number;
    name!: string | undefined;
    frequencyRuleId!: number;
    firstPeriodEndDate!: Date;
    noOfYears!: number;
    effectiveDate!: Date;
    negativePaymentAllowed!: boolean;
    code!: string | undefined;

    constructor(data?: IManagePayrollTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.frequencyRuleId = _data["frequencyRuleId"];
            this.firstPeriodEndDate = _data["firstPeriodEndDate"] ? new Date(_data["firstPeriodEndDate"].toString()) : <any>undefined;
            this.noOfYears = _data["noOfYears"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.negativePaymentAllowed = _data["negativePaymentAllowed"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ManagePayrollTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManagePayrollTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["frequencyRuleId"] = this.frequencyRuleId;
        data["firstPeriodEndDate"] = this.firstPeriodEndDate ? this.firstPeriodEndDate.toISOString() : <any>undefined;
        data["noOfYears"] = this.noOfYears;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["negativePaymentAllowed"] = this.negativePaymentAllowed;
        data["code"] = this.code;
        return data; 
    }

    clone(): ManagePayrollTypeDTO {
        const json = this.toJSON();
        let result = new ManagePayrollTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IManagePayrollTypeDTO {
    id: number;
    name: string | undefined;
    frequencyRuleId: number;
    firstPeriodEndDate: Date;
    noOfYears: number;
    effectiveDate: Date;
    negativePaymentAllowed: boolean;
    code: string | undefined;
}

export class EmployeeProfileDTO implements IEmployeeProfileDTO {
    employeeNumber!: string | undefined;
    fullName!: string | undefined;
    employeeId!: number;
    contractId!: number;
    salaryScaleId!: number;
    salaryScale!: string | undefined;
    departmentId!: number;
    department!: string | undefined;
    gradeId!: number;
    grade!: string | undefined;
    employmentTypeId!: number;
    employmentType!: string | undefined;

    constructor(data?: IEmployeeProfileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeNumber = _data["employeeNumber"];
            this.fullName = _data["fullName"];
            this.employeeId = _data["employeeId"];
            this.contractId = _data["contractId"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.salaryScale = _data["salaryScale"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"];
            this.gradeId = _data["gradeId"];
            this.grade = _data["grade"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.employmentType = _data["employmentType"];
        }
    }

    static fromJS(data: any): EmployeeProfileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeProfileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeNumber"] = this.employeeNumber;
        data["fullName"] = this.fullName;
        data["employeeId"] = this.employeeId;
        data["contractId"] = this.contractId;
        data["salaryScaleId"] = this.salaryScaleId;
        data["salaryScale"] = this.salaryScale;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department;
        data["gradeId"] = this.gradeId;
        data["grade"] = this.grade;
        data["employmentTypeId"] = this.employmentTypeId;
        data["employmentType"] = this.employmentType;
        return data; 
    }

    clone(): EmployeeProfileDTO {
        const json = this.toJSON();
        let result = new EmployeeProfileDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeProfileDTO {
    employeeNumber: string | undefined;
    fullName: string | undefined;
    employeeId: number;
    contractId: number;
    salaryScaleId: number;
    salaryScale: string | undefined;
    departmentId: number;
    department: string | undefined;
    gradeId: number;
    grade: string | undefined;
    employmentTypeId: number;
    employmentType: string | undefined;
}

export class PayrollTypeDTO implements IPayrollTypeDTO {
    id!: number;
    company_id!: number;
    sub_id!: number;
    name!: string | undefined;
    frequencyRuleId!: number;
    frequencyRule!: string | undefined;
    firstPeriodEndDate!: Date;
    noOfEmployees!: number;
    noOfYears!: number;
    effectiveDate!: Date;
    negativePaymentAllowed!: boolean;
    code!: string | undefined;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    employees!: EmployeeProfileDTO[] | undefined;

    constructor(data?: IPayrollTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.name = _data["name"];
            this.frequencyRuleId = _data["frequencyRuleId"];
            this.frequencyRule = _data["frequencyRule"];
            this.firstPeriodEndDate = _data["firstPeriodEndDate"] ? new Date(_data["firstPeriodEndDate"].toString()) : <any>undefined;
            this.noOfEmployees = _data["noOfEmployees"];
            this.noOfYears = _data["noOfYears"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.negativePaymentAllowed = _data["negativePaymentAllowed"];
            this.code = _data["code"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(EmployeeProfileDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PayrollTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["name"] = this.name;
        data["frequencyRuleId"] = this.frequencyRuleId;
        data["frequencyRule"] = this.frequencyRule;
        data["firstPeriodEndDate"] = this.firstPeriodEndDate ? this.firstPeriodEndDate.toISOString() : <any>undefined;
        data["noOfEmployees"] = this.noOfEmployees;
        data["noOfYears"] = this.noOfYears;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["negativePaymentAllowed"] = this.negativePaymentAllowed;
        data["code"] = this.code;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PayrollTypeDTO {
        const json = this.toJSON();
        let result = new PayrollTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IPayrollTypeDTO {
    id: number;
    company_id: number;
    sub_id: number;
    name: string | undefined;
    frequencyRuleId: number;
    frequencyRule: string | undefined;
    firstPeriodEndDate: Date;
    noOfEmployees: number;
    noOfYears: number;
    effectiveDate: Date;
    negativePaymentAllowed: boolean;
    code: string | undefined;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    employees: EmployeeProfileDTO[] | undefined;
}

export class PayrollTypeDTOListApiResult implements IPayrollTypeDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayrollTypeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IPayrollTypeDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PayrollTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PayrollTypeDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollTypeDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PayrollTypeDTOListApiResult {
        const json = this.toJSON();
        let result = new PayrollTypeDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayrollTypeDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayrollTypeDTO[] | undefined;
    totalCount: number;
}

export class PayrollTypeDTOApiResult implements IPayrollTypeDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayrollTypeDTO;
    totalCount!: number;

    constructor(data?: IPayrollTypeDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? PayrollTypeDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PayrollTypeDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollTypeDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PayrollTypeDTOApiResult {
        const json = this.toJSON();
        let result = new PayrollTypeDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayrollTypeDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayrollTypeDTO;
    totalCount: number;
}

export class CycleDTO implements ICycleDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string;
    description!: string;
    instruction!: string | undefined;
    reviewPurposeId!: number;
    appraisalTypeId!: number;
    ratingTypeId!: number;
    minRating!: number | undefined;
    maxRating!: number | undefined;
    departmentId!: number | undefined;
    locationId!: number | undefined;
    unitId!: number | undefined;
    cycleInfo!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    periodUnderReview!: string | undefined;
    lastPeriodUnderReview!: string | undefined;
    dueDate!: Date;
    dateStopped!: Date | undefined;
    frequencyId!: number;
    repeatKPI!: boolean;
    isNotify!: boolean;
    employeeCanSignOffOnManager!: boolean;
    recommendators!: string | undefined;
    commendators!: string | undefined;
    isStopped!: boolean;
    isManualSupervisorSetup!: boolean;
    status!: number;
    log_status!: number;
    approvalProcessId!: number;
    dateApproved!: Date | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    readonly statusType!: string | undefined;
    readonly reviewPurpose!: string | undefined;
    readonly appraisalType!: string | undefined;
    readonly ratingType!: string | undefined;

    constructor(data?: ICycleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.instruction = _data["instruction"];
            this.reviewPurposeId = _data["reviewPurposeId"];
            this.appraisalTypeId = _data["appraisalTypeId"];
            this.ratingTypeId = _data["ratingTypeId"];
            this.minRating = _data["minRating"];
            this.maxRating = _data["maxRating"];
            this.departmentId = _data["departmentId"];
            this.locationId = _data["locationId"];
            this.unitId = _data["unitId"];
            this.cycleInfo = _data["cycleInfo"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.periodUnderReview = _data["periodUnderReview"];
            this.lastPeriodUnderReview = _data["lastPeriodUnderReview"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.dateStopped = _data["dateStopped"] ? new Date(_data["dateStopped"].toString()) : <any>undefined;
            this.frequencyId = _data["frequencyId"];
            this.repeatKPI = _data["repeatKPI"];
            this.isNotify = _data["isNotify"];
            this.employeeCanSignOffOnManager = _data["employeeCanSignOffOnManager"];
            this.recommendators = _data["recommendators"];
            this.commendators = _data["commendators"];
            this.isStopped = _data["isStopped"];
            this.isManualSupervisorSetup = _data["isManualSupervisorSetup"];
            this.status = _data["status"];
            this.log_status = _data["log_status"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            (<any>this).statusType = _data["statusType"];
            (<any>this).reviewPurpose = _data["reviewPurpose"];
            (<any>this).appraisalType = _data["appraisalType"];
            (<any>this).ratingType = _data["ratingType"];
        }
    }

    static fromJS(data: any): CycleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CycleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["instruction"] = this.instruction;
        data["reviewPurposeId"] = this.reviewPurposeId;
        data["appraisalTypeId"] = this.appraisalTypeId;
        data["ratingTypeId"] = this.ratingTypeId;
        data["minRating"] = this.minRating;
        data["maxRating"] = this.maxRating;
        data["departmentId"] = this.departmentId;
        data["locationId"] = this.locationId;
        data["unitId"] = this.unitId;
        data["cycleInfo"] = this.cycleInfo;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["periodUnderReview"] = this.periodUnderReview;
        data["lastPeriodUnderReview"] = this.lastPeriodUnderReview;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["dateStopped"] = this.dateStopped ? this.dateStopped.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["repeatKPI"] = this.repeatKPI;
        data["isNotify"] = this.isNotify;
        data["employeeCanSignOffOnManager"] = this.employeeCanSignOffOnManager;
        data["recommendators"] = this.recommendators;
        data["commendators"] = this.commendators;
        data["isStopped"] = this.isStopped;
        data["isManualSupervisorSetup"] = this.isManualSupervisorSetup;
        data["status"] = this.status;
        data["log_status"] = this.log_status;
        data["approvalProcessId"] = this.approvalProcessId;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["statusType"] = this.statusType;
        data["reviewPurpose"] = this.reviewPurpose;
        data["appraisalType"] = this.appraisalType;
        data["ratingType"] = this.ratingType;
        return data; 
    }

    clone(): CycleDTO {
        const json = this.toJSON();
        let result = new CycleDTO();
        result.init(json);
        return result;
    }
}

export interface ICycleDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string;
    description: string;
    instruction: string | undefined;
    reviewPurposeId: number;
    appraisalTypeId: number;
    ratingTypeId: number;
    minRating: number | undefined;
    maxRating: number | undefined;
    departmentId: number | undefined;
    locationId: number | undefined;
    unitId: number | undefined;
    cycleInfo: string | undefined;
    startDate: Date;
    endDate: Date;
    periodUnderReview: string | undefined;
    lastPeriodUnderReview: string | undefined;
    dueDate: Date;
    dateStopped: Date | undefined;
    frequencyId: number;
    repeatKPI: boolean;
    isNotify: boolean;
    employeeCanSignOffOnManager: boolean;
    recommendators: string | undefined;
    commendators: string | undefined;
    isStopped: boolean;
    isManualSupervisorSetup: boolean;
    status: number;
    log_status: number;
    approvalProcessId: number;
    dateApproved: Date | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    statusType: string | undefined;
    reviewPurpose: string | undefined;
    appraisalType: string | undefined;
    ratingType: string | undefined;
}

export class CycleDTOIListApiResult implements ICycleDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CycleDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ICycleDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CycleDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CycleDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CycleDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CycleDTOIListApiResult {
        const json = this.toJSON();
        let result = new CycleDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICycleDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CycleDTO[] | undefined;
    totalCount: number;
}

export class CycleDTOApiResult implements ICycleDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CycleDTO;
    totalCount!: number;

    constructor(data?: ICycleDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? CycleDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CycleDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CycleDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CycleDTOApiResult {
        const json = this.toJSON();
        let result = new CycleDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ICycleDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CycleDTO;
    totalCount: number;
}

export class ManageCycleDTO implements IManageCycleDTO {
    id!: number;
    name!: string;
    description!: string;
    instructions!: string | undefined;
    reviewPurposeId!: number;
    appraisalTypeId!: number;
    ratingTypeId!: number;
    minRating!: number | undefined;
    maxRating!: number | undefined;
    departmentId!: number | undefined;
    locationId!: number | undefined;
    unitId!: number | undefined;
    cycleInfo!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    periodUnderReview!: string | undefined;
    lastPeriodUnderReview!: string | undefined;
    dueDate!: Date;
    isActive!: boolean;

    constructor(data?: IManageCycleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.instructions = _data["instructions"];
            this.reviewPurposeId = _data["reviewPurposeId"];
            this.appraisalTypeId = _data["appraisalTypeId"];
            this.ratingTypeId = _data["ratingTypeId"];
            this.minRating = _data["minRating"];
            this.maxRating = _data["maxRating"];
            this.departmentId = _data["departmentId"];
            this.locationId = _data["locationId"];
            this.unitId = _data["unitId"];
            this.cycleInfo = _data["cycleInfo"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.periodUnderReview = _data["periodUnderReview"];
            this.lastPeriodUnderReview = _data["lastPeriodUnderReview"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ManageCycleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageCycleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["instructions"] = this.instructions;
        data["reviewPurposeId"] = this.reviewPurposeId;
        data["appraisalTypeId"] = this.appraisalTypeId;
        data["ratingTypeId"] = this.ratingTypeId;
        data["minRating"] = this.minRating;
        data["maxRating"] = this.maxRating;
        data["departmentId"] = this.departmentId;
        data["locationId"] = this.locationId;
        data["unitId"] = this.unitId;
        data["cycleInfo"] = this.cycleInfo;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["periodUnderReview"] = this.periodUnderReview;
        data["lastPeriodUnderReview"] = this.lastPeriodUnderReview;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ManageCycleDTO {
        const json = this.toJSON();
        let result = new ManageCycleDTO();
        result.init(json);
        return result;
    }
}

export interface IManageCycleDTO {
    id: number;
    name: string;
    description: string;
    instructions: string | undefined;
    reviewPurposeId: number;
    appraisalTypeId: number;
    ratingTypeId: number;
    minRating: number | undefined;
    maxRating: number | undefined;
    departmentId: number | undefined;
    locationId: number | undefined;
    unitId: number | undefined;
    cycleInfo: string | undefined;
    startDate: Date;
    endDate: Date;
    periodUnderReview: string | undefined;
    lastPeriodUnderReview: string | undefined;
    dueDate: Date;
    isActive: boolean;
}

export class ManagePositionDTO implements IManagePositionDTO {
    id!: number;
    title!: string;
    description!: string;
    basic_salary!: number | undefined;
    promotion_min_years!: number | undefined;
    min_years_experience!: number | undefined;
    parent_id!: number | undefined;
    next_position_id!: number | undefined;
    selectedQualifications!: string | undefined;
    selectedCertifications!: string | undefined;

    constructor(data?: IManagePositionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.basic_salary = _data["basic_salary"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.min_years_experience = _data["min_years_experience"];
            this.parent_id = _data["parent_id"];
            this.next_position_id = _data["next_position_id"];
            this.selectedQualifications = _data["selectedQualifications"];
            this.selectedCertifications = _data["selectedCertifications"];
        }
    }

    static fromJS(data: any): ManagePositionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManagePositionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["basic_salary"] = this.basic_salary;
        data["promotion_min_years"] = this.promotion_min_years;
        data["min_years_experience"] = this.min_years_experience;
        data["parent_id"] = this.parent_id;
        data["next_position_id"] = this.next_position_id;
        data["selectedQualifications"] = this.selectedQualifications;
        data["selectedCertifications"] = this.selectedCertifications;
        return data; 
    }

    clone(): ManagePositionDTO {
        const json = this.toJSON();
        let result = new ManagePositionDTO();
        result.init(json);
        return result;
    }
}

export interface IManagePositionDTO {
    id: number;
    title: string;
    description: string;
    basic_salary: number | undefined;
    promotion_min_years: number | undefined;
    min_years_experience: number | undefined;
    parent_id: number | undefined;
    next_position_id: number | undefined;
    selectedQualifications: string | undefined;
    selectedCertifications: string | undefined;
}

export class PositionDTO implements IPositionDTO {
    id!: number;
    title!: string | undefined;
    description!: string | undefined;
    companyID!: number;
    subID!: number;
    basic_salary!: number | undefined;
    promotion_min_years!: number | undefined;
    min_years_experience!: number | undefined;
    parent_id!: number | undefined;
    next_position_id!: number | undefined;
    next_position!: string | undefined;
    parent_position!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    positionRequirements!: PositionRequirement[] | undefined;

    constructor(data?: IPositionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.basic_salary = _data["basic_salary"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.min_years_experience = _data["min_years_experience"];
            this.parent_id = _data["parent_id"];
            this.next_position_id = _data["next_position_id"];
            this.next_position = _data["next_position"];
            this.parent_position = _data["parent_position"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            if (Array.isArray(_data["positionRequirements"])) {
                this.positionRequirements = [] as any;
                for (let item of _data["positionRequirements"])
                    this.positionRequirements!.push(PositionRequirement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PositionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PositionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["basic_salary"] = this.basic_salary;
        data["promotion_min_years"] = this.promotion_min_years;
        data["min_years_experience"] = this.min_years_experience;
        data["parent_id"] = this.parent_id;
        data["next_position_id"] = this.next_position_id;
        data["next_position"] = this.next_position;
        data["parent_position"] = this.parent_position;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        if (Array.isArray(this.positionRequirements)) {
            data["positionRequirements"] = [];
            for (let item of this.positionRequirements)
                data["positionRequirements"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PositionDTO {
        const json = this.toJSON();
        let result = new PositionDTO();
        result.init(json);
        return result;
    }
}

export interface IPositionDTO {
    id: number;
    title: string | undefined;
    description: string | undefined;
    companyID: number;
    subID: number;
    basic_salary: number | undefined;
    promotion_min_years: number | undefined;
    min_years_experience: number | undefined;
    parent_id: number | undefined;
    next_position_id: number | undefined;
    next_position: string | undefined;
    parent_position: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    positionRequirements: PositionRequirement[] | undefined;
}

export class PositionDTOListApiResult implements IPositionDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PositionDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IPositionDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PositionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PositionDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PositionDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PositionDTOListApiResult {
        const json = this.toJSON();
        let result = new PositionDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPositionDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PositionDTO[] | undefined;
    totalCount: number;
}

export class PositionDTOApiResult implements IPositionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PositionDTO;
    totalCount!: number;

    constructor(data?: IPositionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? PositionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PositionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PositionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PositionDTOApiResult {
        const json = this.toJSON();
        let result = new PositionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IPositionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PositionDTO;
    totalCount: number;
}

export class SelectListGroup implements ISelectListGroup {
    disabled!: boolean;
    name!: string | undefined;

    constructor(data?: ISelectListGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SelectListGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["name"] = this.name;
        return data; 
    }

    clone(): SelectListGroup {
        const json = this.toJSON();
        let result = new SelectListGroup();
        result.init(json);
        return result;
    }
}

export interface ISelectListGroup {
    disabled: boolean;
    name: string | undefined;
}

export class SelectListItem implements ISelectListItem {
    disabled!: boolean;
    group!: SelectListGroup;
    selected!: boolean;
    text!: string | undefined;
    value!: string | undefined;

    constructor(data?: ISelectListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.group = _data["group"] ? SelectListGroup.fromJS(_data["group"]) : <any>undefined;
            this.selected = _data["selected"];
            this.text = _data["text"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SelectListItem {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["selected"] = this.selected;
        data["text"] = this.text;
        data["value"] = this.value;
        return data; 
    }

    clone(): SelectListItem {
        const json = this.toJSON();
        let result = new SelectListItem();
        result.init(json);
        return result;
    }
}

export interface ISelectListItem {
    disabled: boolean;
    group: SelectListGroup;
    selected: boolean;
    text: string | undefined;
    value: string | undefined;
}

export class Sp_FetchEligibleEmployees implements ISp_FetchEligibleEmployees {
    current_position_id!: number | undefined;
    current_position!: string | undefined;
    period_in_current_postion!: string | undefined;
    years_in_current_position!: number | undefined;
    next_position!: string | undefined;
    next_position_id!: number | undefined;
    current_position_parent_id!: number | undefined;
    current_parent_position!: string | undefined;
    current_grade_id!: number | undefined;
    current_grade!: string | undefined;
    salaryScale!: string | undefined;
    id!: number | undefined;
    employee_contract_id!: number;
    eligiblility_id!: number | undefined;
    date_of_appointment!: Date | undefined;
    date_of_birth!: Date | undefined;
    date_of_confirmation!: Date | undefined;
    first_name!: string | undefined;
    last_name!: string | undefined;
    other_names!: string | undefined;
    profile_pic!: string | undefined;
    last_promotion_date!: Date | undefined;
    period_in_current_grade!: string | undefined;
    years_in_current_grade!: number | undefined;
    oracle_no!: string | undefined;
    professional_qualifications!: number | undefined;
    department!: string | undefined;
    location!: string | undefined;
    job_role!: string | undefined;
    is_submitted!: boolean;
    is_selected!: boolean;
    date_submitted!: Date | undefined;
    current_step!: string | undefined;
    current_step_id!: number | undefined;
    current_step_no!: number;
    next_grade!: string | undefined;
    next_step!: string | undefined;
    next_step_id!: number | undefined;
    salaryScaleId!: number | undefined;
    log_status!: string | undefined;
    log_status_id!: number;
    effective_date!: Date | undefined;
    str_effective_date!: string | undefined;

    constructor(data?: ISp_FetchEligibleEmployees) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.current_position_id = _data["current_position_id"];
            this.current_position = _data["current_position"];
            this.period_in_current_postion = _data["period_in_current_postion"];
            this.years_in_current_position = _data["years_in_current_position"];
            this.next_position = _data["next_position"];
            this.next_position_id = _data["next_position_id"];
            this.current_position_parent_id = _data["current_position_parent_id"];
            this.current_parent_position = _data["current_parent_position"];
            this.current_grade_id = _data["current_grade_id"];
            this.current_grade = _data["current_grade"];
            this.salaryScale = _data["salaryScale"];
            this.id = _data["id"];
            this.employee_contract_id = _data["employee_contract_id"];
            this.eligiblility_id = _data["eligiblility_id"];
            this.date_of_appointment = _data["date_of_appointment"] ? new Date(_data["date_of_appointment"].toString()) : <any>undefined;
            this.date_of_birth = _data["date_of_birth"] ? new Date(_data["date_of_birth"].toString()) : <any>undefined;
            this.date_of_confirmation = _data["date_of_confirmation"] ? new Date(_data["date_of_confirmation"].toString()) : <any>undefined;
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            this.other_names = _data["other_names"];
            this.profile_pic = _data["profile_pic"];
            this.last_promotion_date = _data["last_promotion_date"] ? new Date(_data["last_promotion_date"].toString()) : <any>undefined;
            this.period_in_current_grade = _data["period_in_current_grade"];
            this.years_in_current_grade = _data["years_in_current_grade"];
            this.oracle_no = _data["oracle_no"];
            this.professional_qualifications = _data["professional_qualifications"];
            this.department = _data["department"];
            this.location = _data["location"];
            this.job_role = _data["job_role"];
            this.is_submitted = _data["is_submitted"];
            this.is_selected = _data["is_selected"];
            this.date_submitted = _data["date_submitted"] ? new Date(_data["date_submitted"].toString()) : <any>undefined;
            this.current_step = _data["current_step"];
            this.current_step_id = _data["current_step_id"];
            this.current_step_no = _data["current_step_no"];
            this.next_grade = _data["next_grade"];
            this.next_step = _data["next_step"];
            this.next_step_id = _data["next_step_id"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.log_status = _data["log_status"];
            this.log_status_id = _data["log_status_id"];
            this.effective_date = _data["effective_date"] ? new Date(_data["effective_date"].toString()) : <any>undefined;
            this.str_effective_date = _data["str_effective_date"];
        }
    }

    static fromJS(data: any): Sp_FetchEligibleEmployees {
        data = typeof data === 'object' ? data : {};
        let result = new Sp_FetchEligibleEmployees();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["current_position_id"] = this.current_position_id;
        data["current_position"] = this.current_position;
        data["period_in_current_postion"] = this.period_in_current_postion;
        data["years_in_current_position"] = this.years_in_current_position;
        data["next_position"] = this.next_position;
        data["next_position_id"] = this.next_position_id;
        data["current_position_parent_id"] = this.current_position_parent_id;
        data["current_parent_position"] = this.current_parent_position;
        data["current_grade_id"] = this.current_grade_id;
        data["current_grade"] = this.current_grade;
        data["salaryScale"] = this.salaryScale;
        data["id"] = this.id;
        data["employee_contract_id"] = this.employee_contract_id;
        data["eligiblility_id"] = this.eligiblility_id;
        data["date_of_appointment"] = this.date_of_appointment ? this.date_of_appointment.toISOString() : <any>undefined;
        data["date_of_birth"] = this.date_of_birth ? this.date_of_birth.toISOString() : <any>undefined;
        data["date_of_confirmation"] = this.date_of_confirmation ? this.date_of_confirmation.toISOString() : <any>undefined;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["other_names"] = this.other_names;
        data["profile_pic"] = this.profile_pic;
        data["last_promotion_date"] = this.last_promotion_date ? this.last_promotion_date.toISOString() : <any>undefined;
        data["period_in_current_grade"] = this.period_in_current_grade;
        data["years_in_current_grade"] = this.years_in_current_grade;
        data["oracle_no"] = this.oracle_no;
        data["professional_qualifications"] = this.professional_qualifications;
        data["department"] = this.department;
        data["location"] = this.location;
        data["job_role"] = this.job_role;
        data["is_submitted"] = this.is_submitted;
        data["is_selected"] = this.is_selected;
        data["date_submitted"] = this.date_submitted ? this.date_submitted.toISOString() : <any>undefined;
        data["current_step"] = this.current_step;
        data["current_step_id"] = this.current_step_id;
        data["current_step_no"] = this.current_step_no;
        data["next_grade"] = this.next_grade;
        data["next_step"] = this.next_step;
        data["next_step_id"] = this.next_step_id;
        data["salaryScaleId"] = this.salaryScaleId;
        data["log_status"] = this.log_status;
        data["log_status_id"] = this.log_status_id;
        data["effective_date"] = this.effective_date ? this.effective_date.toISOString() : <any>undefined;
        data["str_effective_date"] = this.str_effective_date;
        return data; 
    }

    clone(): Sp_FetchEligibleEmployees {
        const json = this.toJSON();
        let result = new Sp_FetchEligibleEmployees();
        result.init(json);
        return result;
    }
}

export interface ISp_FetchEligibleEmployees {
    current_position_id: number | undefined;
    current_position: string | undefined;
    period_in_current_postion: string | undefined;
    years_in_current_position: number | undefined;
    next_position: string | undefined;
    next_position_id: number | undefined;
    current_position_parent_id: number | undefined;
    current_parent_position: string | undefined;
    current_grade_id: number | undefined;
    current_grade: string | undefined;
    salaryScale: string | undefined;
    id: number | undefined;
    employee_contract_id: number;
    eligiblility_id: number | undefined;
    date_of_appointment: Date | undefined;
    date_of_birth: Date | undefined;
    date_of_confirmation: Date | undefined;
    first_name: string | undefined;
    last_name: string | undefined;
    other_names: string | undefined;
    profile_pic: string | undefined;
    last_promotion_date: Date | undefined;
    period_in_current_grade: string | undefined;
    years_in_current_grade: number | undefined;
    oracle_no: string | undefined;
    professional_qualifications: number | undefined;
    department: string | undefined;
    location: string | undefined;
    job_role: string | undefined;
    is_submitted: boolean;
    is_selected: boolean;
    date_submitted: Date | undefined;
    current_step: string | undefined;
    current_step_id: number | undefined;
    current_step_no: number;
    next_grade: string | undefined;
    next_step: string | undefined;
    next_step_id: number | undefined;
    salaryScaleId: number | undefined;
    log_status: string | undefined;
    log_status_id: number;
    effective_date: Date | undefined;
    str_effective_date: string | undefined;
}

export class PromotionEligibilityViewModel implements IPromotionEligibilityViewModel {
    id!: number;
    company_id!: number;
    subsidiary_id!: number;
    name!: string;
    date_generated!: Date;
    generated_by!: string | undefined;
    submitted_by!: string | undefined;
    is_closed!: boolean;
    date_closed!: Date | undefined;
    closed_by!: string | undefined;
    comments!: string;
    noOfMembers!: number;
    is_active!: boolean;
    approvalProcessId!: number | undefined;
    actionTitle!: string | undefined;
    approvalWorkFlows!: SelectListItem[] | undefined;
    eligibles!: Sp_FetchEligibleEmployees[] | undefined;
    readonly strDateGenerated!: string | undefined;
    readonly isClosed!: string | undefined;
    readonly strDateClosed!: string | undefined;

    constructor(data?: IPromotionEligibilityViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.subsidiary_id = _data["subsidiary_id"];
            this.name = _data["name"];
            this.date_generated = _data["date_generated"] ? new Date(_data["date_generated"].toString()) : <any>undefined;
            this.generated_by = _data["generated_by"];
            this.submitted_by = _data["submitted_by"];
            this.is_closed = _data["is_closed"];
            this.date_closed = _data["date_closed"] ? new Date(_data["date_closed"].toString()) : <any>undefined;
            this.closed_by = _data["closed_by"];
            this.comments = _data["comments"];
            this.noOfMembers = _data["noOfMembers"];
            this.is_active = _data["is_active"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.actionTitle = _data["actionTitle"];
            if (Array.isArray(_data["approvalWorkFlows"])) {
                this.approvalWorkFlows = [] as any;
                for (let item of _data["approvalWorkFlows"])
                    this.approvalWorkFlows!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["eligibles"])) {
                this.eligibles = [] as any;
                for (let item of _data["eligibles"])
                    this.eligibles!.push(Sp_FetchEligibleEmployees.fromJS(item));
            }
            (<any>this).strDateGenerated = _data["strDateGenerated"];
            (<any>this).isClosed = _data["isClosed"];
            (<any>this).strDateClosed = _data["strDateClosed"];
        }
    }

    static fromJS(data: any): PromotionEligibilityViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionEligibilityViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["subsidiary_id"] = this.subsidiary_id;
        data["name"] = this.name;
        data["date_generated"] = this.date_generated ? this.date_generated.toISOString() : <any>undefined;
        data["generated_by"] = this.generated_by;
        data["submitted_by"] = this.submitted_by;
        data["is_closed"] = this.is_closed;
        data["date_closed"] = this.date_closed ? this.date_closed.toISOString() : <any>undefined;
        data["closed_by"] = this.closed_by;
        data["comments"] = this.comments;
        data["noOfMembers"] = this.noOfMembers;
        data["is_active"] = this.is_active;
        data["approvalProcessId"] = this.approvalProcessId;
        data["actionTitle"] = this.actionTitle;
        if (Array.isArray(this.approvalWorkFlows)) {
            data["approvalWorkFlows"] = [];
            for (let item of this.approvalWorkFlows)
                data["approvalWorkFlows"].push(item.toJSON());
        }
        if (Array.isArray(this.eligibles)) {
            data["eligibles"] = [];
            for (let item of this.eligibles)
                data["eligibles"].push(item.toJSON());
        }
        data["strDateGenerated"] = this.strDateGenerated;
        data["isClosed"] = this.isClosed;
        data["strDateClosed"] = this.strDateClosed;
        return data; 
    }

    clone(): PromotionEligibilityViewModel {
        const json = this.toJSON();
        let result = new PromotionEligibilityViewModel();
        result.init(json);
        return result;
    }
}

export interface IPromotionEligibilityViewModel {
    id: number;
    company_id: number;
    subsidiary_id: number;
    name: string;
    date_generated: Date;
    generated_by: string | undefined;
    submitted_by: string | undefined;
    is_closed: boolean;
    date_closed: Date | undefined;
    closed_by: string | undefined;
    comments: string;
    noOfMembers: number;
    is_active: boolean;
    approvalProcessId: number | undefined;
    actionTitle: string | undefined;
    approvalWorkFlows: SelectListItem[] | undefined;
    eligibles: Sp_FetchEligibleEmployees[] | undefined;
    strDateGenerated: string | undefined;
    isClosed: string | undefined;
    strDateClosed: string | undefined;
}

export class Sp_FetchEligibleEmployeesIListApiResult implements ISp_FetchEligibleEmployeesIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Sp_FetchEligibleEmployees[] | undefined;
    totalCount!: number;

    constructor(data?: ISp_FetchEligibleEmployeesIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Sp_FetchEligibleEmployees.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): Sp_FetchEligibleEmployeesIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new Sp_FetchEligibleEmployeesIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): Sp_FetchEligibleEmployeesIListApiResult {
        const json = this.toJSON();
        let result = new Sp_FetchEligibleEmployeesIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISp_FetchEligibleEmployeesIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Sp_FetchEligibleEmployees[] | undefined;
    totalCount: number;
}

export class VwGradeSteps implements IVwGradeSteps {
    id!: number;
    companyID!: number;
    subID!: number;
    grade_id!: number;
    name!: string;
    grade_name!: string | undefined;
    promotion_min_years!: number;
    dateCreated!: Date;
    salary_scale_id!: number;
    salary_scale!: string | undefined;
    next_grade_step_id!: number | undefined;
    next_grade_step!: string | undefined;
    step_no!: number;
    created_by!: string | undefined;
    ministry_id!: number;
    isDeleted!: boolean;
    isActive!: boolean;
    actionTitle!: string | undefined;
    allGradeSteps!: SelectListItem[] | undefined;
    nextGradeSteps!: SelectListItem[] | undefined;

    constructor(data?: IVwGradeSteps) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.grade_id = _data["grade_id"];
            this.name = _data["name"];
            this.grade_name = _data["grade_name"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.salary_scale_id = _data["salary_scale_id"];
            this.salary_scale = _data["salary_scale"];
            this.next_grade_step_id = _data["next_grade_step_id"];
            this.next_grade_step = _data["next_grade_step"];
            this.step_no = _data["step_no"];
            this.created_by = _data["created_by"];
            this.ministry_id = _data["ministry_id"];
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.actionTitle = _data["actionTitle"];
            if (Array.isArray(_data["allGradeSteps"])) {
                this.allGradeSteps = [] as any;
                for (let item of _data["allGradeSteps"])
                    this.allGradeSteps!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["nextGradeSteps"])) {
                this.nextGradeSteps = [] as any;
                for (let item of _data["nextGradeSteps"])
                    this.nextGradeSteps!.push(SelectListItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VwGradeSteps {
        data = typeof data === 'object' ? data : {};
        let result = new VwGradeSteps();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["grade_id"] = this.grade_id;
        data["name"] = this.name;
        data["grade_name"] = this.grade_name;
        data["promotion_min_years"] = this.promotion_min_years;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["salary_scale_id"] = this.salary_scale_id;
        data["salary_scale"] = this.salary_scale;
        data["next_grade_step_id"] = this.next_grade_step_id;
        data["next_grade_step"] = this.next_grade_step;
        data["step_no"] = this.step_no;
        data["created_by"] = this.created_by;
        data["ministry_id"] = this.ministry_id;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["actionTitle"] = this.actionTitle;
        if (Array.isArray(this.allGradeSteps)) {
            data["allGradeSteps"] = [];
            for (let item of this.allGradeSteps)
                data["allGradeSteps"].push(item.toJSON());
        }
        if (Array.isArray(this.nextGradeSteps)) {
            data["nextGradeSteps"] = [];
            for (let item of this.nextGradeSteps)
                data["nextGradeSteps"].push(item.toJSON());
        }
        return data; 
    }

    clone(): VwGradeSteps {
        const json = this.toJSON();
        let result = new VwGradeSteps();
        result.init(json);
        return result;
    }
}

export interface IVwGradeSteps {
    id: number;
    companyID: number;
    subID: number;
    grade_id: number;
    name: string;
    grade_name: string | undefined;
    promotion_min_years: number;
    dateCreated: Date;
    salary_scale_id: number;
    salary_scale: string | undefined;
    next_grade_step_id: number | undefined;
    next_grade_step: string | undefined;
    step_no: number;
    created_by: string | undefined;
    ministry_id: number;
    isDeleted: boolean;
    isActive: boolean;
    actionTitle: string | undefined;
    allGradeSteps: SelectListItem[] | undefined;
    nextGradeSteps: SelectListItem[] | undefined;
}

export class VwPromotionSchedule implements IVwPromotionSchedule {
    companyId!: number;
    subsidiaryId!: number;
    eligibilityId!: number;
    parentPositionId!: number;
    promotionCategoryId!: number;
    eligibilityName!: string | undefined;
    isClosed!: boolean;
    eligibeEmployees!: Sp_FetchEligibleEmployees[] | undefined;
    gradeSteps!: VwGradeSteps[] | undefined;
    parentPositions!: SelectListItem[] | undefined;
    positions!: PositionDTO[] | undefined;
    promotionCategorys!: SelectListItem[] | undefined;

    constructor(data?: IVwPromotionSchedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.subsidiaryId = _data["subsidiaryId"];
            this.eligibilityId = _data["eligibilityId"];
            this.parentPositionId = _data["parentPositionId"];
            this.promotionCategoryId = _data["promotionCategoryId"];
            this.eligibilityName = _data["eligibilityName"];
            this.isClosed = _data["isClosed"];
            if (Array.isArray(_data["eligibeEmployees"])) {
                this.eligibeEmployees = [] as any;
                for (let item of _data["eligibeEmployees"])
                    this.eligibeEmployees!.push(Sp_FetchEligibleEmployees.fromJS(item));
            }
            if (Array.isArray(_data["gradeSteps"])) {
                this.gradeSteps = [] as any;
                for (let item of _data["gradeSteps"])
                    this.gradeSteps!.push(VwGradeSteps.fromJS(item));
            }
            if (Array.isArray(_data["parentPositions"])) {
                this.parentPositions = [] as any;
                for (let item of _data["parentPositions"])
                    this.parentPositions!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["positions"])) {
                this.positions = [] as any;
                for (let item of _data["positions"])
                    this.positions!.push(PositionDTO.fromJS(item));
            }
            if (Array.isArray(_data["promotionCategorys"])) {
                this.promotionCategorys = [] as any;
                for (let item of _data["promotionCategorys"])
                    this.promotionCategorys!.push(SelectListItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VwPromotionSchedule {
        data = typeof data === 'object' ? data : {};
        let result = new VwPromotionSchedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["subsidiaryId"] = this.subsidiaryId;
        data["eligibilityId"] = this.eligibilityId;
        data["parentPositionId"] = this.parentPositionId;
        data["promotionCategoryId"] = this.promotionCategoryId;
        data["eligibilityName"] = this.eligibilityName;
        data["isClosed"] = this.isClosed;
        if (Array.isArray(this.eligibeEmployees)) {
            data["eligibeEmployees"] = [];
            for (let item of this.eligibeEmployees)
                data["eligibeEmployees"].push(item.toJSON());
        }
        if (Array.isArray(this.gradeSteps)) {
            data["gradeSteps"] = [];
            for (let item of this.gradeSteps)
                data["gradeSteps"].push(item.toJSON());
        }
        if (Array.isArray(this.parentPositions)) {
            data["parentPositions"] = [];
            for (let item of this.parentPositions)
                data["parentPositions"].push(item.toJSON());
        }
        if (Array.isArray(this.positions)) {
            data["positions"] = [];
            for (let item of this.positions)
                data["positions"].push(item.toJSON());
        }
        if (Array.isArray(this.promotionCategorys)) {
            data["promotionCategorys"] = [];
            for (let item of this.promotionCategorys)
                data["promotionCategorys"].push(item.toJSON());
        }
        return data; 
    }

    clone(): VwPromotionSchedule {
        const json = this.toJSON();
        let result = new VwPromotionSchedule();
        result.init(json);
        return result;
    }
}

export interface IVwPromotionSchedule {
    companyId: number;
    subsidiaryId: number;
    eligibilityId: number;
    parentPositionId: number;
    promotionCategoryId: number;
    eligibilityName: string | undefined;
    isClosed: boolean;
    eligibeEmployees: Sp_FetchEligibleEmployees[] | undefined;
    gradeSteps: VwGradeSteps[] | undefined;
    parentPositions: SelectListItem[] | undefined;
    positions: PositionDTO[] | undefined;
    promotionCategorys: SelectListItem[] | undefined;
}

export class VwPromotionScheduleApiResult implements IVwPromotionScheduleApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwPromotionSchedule;
    totalCount!: number;

    constructor(data?: IVwPromotionScheduleApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? VwPromotionSchedule.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VwPromotionScheduleApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwPromotionScheduleApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VwPromotionScheduleApiResult {
        const json = this.toJSON();
        let result = new VwPromotionScheduleApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwPromotionScheduleApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwPromotionSchedule;
    totalCount: number;
}

export class RatingDTO implements IRatingDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    scoreFrom!: number;
    scoreTo!: number;
    grade!: string | undefined;
    description!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRatingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.scoreFrom = _data["scoreFrom"];
            this.scoreTo = _data["scoreTo"];
            this.grade = _data["grade"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RatingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RatingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["scoreFrom"] = this.scoreFrom;
        data["scoreTo"] = this.scoreTo;
        data["grade"] = this.grade;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RatingDTO {
        const json = this.toJSON();
        let result = new RatingDTO();
        result.init(json);
        return result;
    }
}

export interface IRatingDTO {
    id: number;
    companyID: number;
    subID: number;
    scoreFrom: number;
    scoreTo: number;
    grade: string | undefined;
    description: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RatingDTOIListApiResult implements IRatingDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RatingDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IRatingDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RatingDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RatingDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RatingDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RatingDTOIListApiResult {
        const json = this.toJSON();
        let result = new RatingDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRatingDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RatingDTO[] | undefined;
    totalCount: number;
}

export class ManageRequestDTO implements IManageRequestDTO {
    id!: number;
    requestTypeId!: number;
    employeeId!: number;
    employeeContractId!: number;
    request_date!: Date;
    title!: string;
    description!: string;
    log_status!: number;
    resolution!: string | undefined;
    temp_resolution!: string | undefined;
    submitted_by!: string | undefined;
    date_resolved!: Date;
    refNo!: string | undefined;

    constructor(data?: IManageRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requestTypeId = _data["requestTypeId"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.log_status = _data["log_status"];
            this.resolution = _data["resolution"];
            this.temp_resolution = _data["temp_resolution"];
            this.submitted_by = _data["submitted_by"];
            this.date_resolved = _data["date_resolved"] ? new Date(_data["date_resolved"].toString()) : <any>undefined;
            this.refNo = _data["refNo"];
        }
    }

    static fromJS(data: any): ManageRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requestTypeId"] = this.requestTypeId;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["log_status"] = this.log_status;
        data["resolution"] = this.resolution;
        data["temp_resolution"] = this.temp_resolution;
        data["submitted_by"] = this.submitted_by;
        data["date_resolved"] = this.date_resolved ? this.date_resolved.toISOString() : <any>undefined;
        data["refNo"] = this.refNo;
        return data; 
    }

    clone(): ManageRequestDTO {
        const json = this.toJSON();
        let result = new ManageRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IManageRequestDTO {
    id: number;
    requestTypeId: number;
    employeeId: number;
    employeeContractId: number;
    request_date: Date;
    title: string;
    description: string;
    log_status: number;
    resolution: string | undefined;
    temp_resolution: string | undefined;
    submitted_by: string | undefined;
    date_resolved: Date;
    refNo: string | undefined;
}

export class RequestDTO implements IRequestDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    requestTypeId!: number;
    employeeId!: number;
    employeeContractId!: number;
    request_date!: Date;
    title!: string;
    description!: string;
    resolution!: string | undefined;
    temp_resolution!: string | undefined;
    submitted_by!: string | undefined;
    date_resolved!: Date;
    refNo!: string | undefined;
    employeeName!: string | undefined;
    status!: string | undefined;

    constructor(data?: IRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.requestTypeId = _data["requestTypeId"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.resolution = _data["resolution"];
            this.temp_resolution = _data["temp_resolution"];
            this.submitted_by = _data["submitted_by"];
            this.date_resolved = _data["date_resolved"] ? new Date(_data["date_resolved"].toString()) : <any>undefined;
            this.refNo = _data["refNo"];
            this.employeeName = _data["employeeName"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): RequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["requestTypeId"] = this.requestTypeId;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["resolution"] = this.resolution;
        data["temp_resolution"] = this.temp_resolution;
        data["submitted_by"] = this.submitted_by;
        data["date_resolved"] = this.date_resolved ? this.date_resolved.toISOString() : <any>undefined;
        data["refNo"] = this.refNo;
        data["employeeName"] = this.employeeName;
        data["status"] = this.status;
        return data; 
    }

    clone(): RequestDTO {
        const json = this.toJSON();
        let result = new RequestDTO();
        result.init(json);
        return result;
    }
}

export interface IRequestDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    requestTypeId: number;
    employeeId: number;
    employeeContractId: number;
    request_date: Date;
    title: string;
    description: string;
    resolution: string | undefined;
    temp_resolution: string | undefined;
    submitted_by: string | undefined;
    date_resolved: Date;
    refNo: string | undefined;
    employeeName: string | undefined;
    status: string | undefined;
}

export class RequestDTOListApiResult implements IRequestDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IRequestDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RequestDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RequestDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RequestDTOListApiResult {
        const json = this.toJSON();
        let result = new RequestDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestDTO[] | undefined;
    totalCount: number;
}

export class RequestDTOApiResult implements IRequestDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestDTO;
    totalCount!: number;

    constructor(data?: IRequestDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? RequestDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RequestDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RequestDTOApiResult {
        const json = this.toJSON();
        let result = new RequestDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestDTO;
    totalCount: number;
}

export class ManageRequestTypeDTO implements IManageRequestTypeDTO {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    is_SystemRequirment!: boolean;
    isActive!: boolean;
    is_StepNotify!: boolean;

    constructor(data?: IManageRequestTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.is_SystemRequirment = _data["is_SystemRequirment"];
            this.isActive = _data["isActive"];
            this.is_StepNotify = _data["is_StepNotify"];
        }
    }

    static fromJS(data: any): ManageRequestTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageRequestTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["is_SystemRequirment"] = this.is_SystemRequirment;
        data["isActive"] = this.isActive;
        data["is_StepNotify"] = this.is_StepNotify;
        return data; 
    }

    clone(): ManageRequestTypeDTO {
        const json = this.toJSON();
        let result = new ManageRequestTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IManageRequestTypeDTO {
    id: number;
    name: string | undefined;
    code: string | undefined;
    is_SystemRequirment: boolean;
    isActive: boolean;
    is_StepNotify: boolean;
}

export class RequestTypeDTO implements IRequestTypeDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    typeId!: string | undefined;
    approval!: string | undefined;
    processid!: number;
    enable_step_notify!: boolean;
    is_system_requirement!: boolean;

    constructor(data?: IRequestTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.typeId = _data["typeId"];
            this.approval = _data["approval"];
            this.processid = _data["processid"];
            this.enable_step_notify = _data["enable_step_notify"];
            this.is_system_requirement = _data["is_system_requirement"];
        }
    }

    static fromJS(data: any): RequestTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RequestTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["typeId"] = this.typeId;
        data["approval"] = this.approval;
        data["processid"] = this.processid;
        data["enable_step_notify"] = this.enable_step_notify;
        data["is_system_requirement"] = this.is_system_requirement;
        return data; 
    }

    clone(): RequestTypeDTO {
        const json = this.toJSON();
        let result = new RequestTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IRequestTypeDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    typeId: string | undefined;
    approval: string | undefined;
    processid: number;
    enable_step_notify: boolean;
    is_system_requirement: boolean;
}

export class RequestTypeDTOListApiResult implements IRequestTypeDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestTypeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IRequestTypeDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RequestTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RequestTypeDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestTypeDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RequestTypeDTOListApiResult {
        const json = this.toJSON();
        let result = new RequestTypeDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestTypeDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestTypeDTO[] | undefined;
    totalCount: number;
}

export class RequestTypeDTOApiResult implements IRequestTypeDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestTypeDTO;
    totalCount!: number;

    constructor(data?: IRequestTypeDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? RequestTypeDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RequestTypeDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestTypeDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RequestTypeDTOApiResult {
        const json = this.toJSON();
        let result = new RequestTypeDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestTypeDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestTypeDTO;
    totalCount: number;
}

export class RetirmentDTO implements IRetirmentDTO {
    id!: number;
    retirementLogId!: number;
    retirementTypeId!: number;
    retirementType!: string | undefined;
    age!: number;
    strAge!: string | undefined;
    yearsOfService!: number;
    strYearsOfService!: string | undefined;
    employeeId!: number;
    employeeContractId!: number;
    staffNo!: string | undefined;
    fullName!: string | undefined;
    dob!: Date | undefined;
    appointmentDate!: Date | undefined;
    effectiveDate!: Date | undefined;
    strEffectiveDate!: string | undefined;
    refNo!: string | undefined;
    causeOfLeaving!: string | undefined;
    otherComments!: string | undefined;
    submittedBy!: string | undefined;
    dateSubmitted!: Date | undefined;
    reviewedBy!: string | undefined;
    reviewerComment!: string | undefined;
    dateReviewed!: Date | undefined;
    isAccepted!: boolean | undefined;
    log_status!: number;

    constructor(data?: IRetirmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.retirementLogId = _data["retirementLogId"];
            this.retirementTypeId = _data["retirementTypeId"];
            this.retirementType = _data["retirementType"];
            this.age = _data["age"];
            this.strAge = _data["strAge"];
            this.yearsOfService = _data["yearsOfService"];
            this.strYearsOfService = _data["strYearsOfService"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
            this.staffNo = _data["staffNo"];
            this.fullName = _data["fullName"];
            this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
            this.appointmentDate = _data["appointmentDate"] ? new Date(_data["appointmentDate"].toString()) : <any>undefined;
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.strEffectiveDate = _data["strEffectiveDate"];
            this.refNo = _data["refNo"];
            this.causeOfLeaving = _data["causeOfLeaving"];
            this.otherComments = _data["otherComments"];
            this.submittedBy = _data["submittedBy"];
            this.dateSubmitted = _data["dateSubmitted"] ? new Date(_data["dateSubmitted"].toString()) : <any>undefined;
            this.reviewedBy = _data["reviewedBy"];
            this.reviewerComment = _data["reviewerComment"];
            this.dateReviewed = _data["dateReviewed"] ? new Date(_data["dateReviewed"].toString()) : <any>undefined;
            this.isAccepted = _data["isAccepted"];
            this.log_status = _data["log_status"];
        }
    }

    static fromJS(data: any): RetirmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RetirmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["retirementLogId"] = this.retirementLogId;
        data["retirementTypeId"] = this.retirementTypeId;
        data["retirementType"] = this.retirementType;
        data["age"] = this.age;
        data["strAge"] = this.strAge;
        data["yearsOfService"] = this.yearsOfService;
        data["strYearsOfService"] = this.strYearsOfService;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        data["staffNo"] = this.staffNo;
        data["fullName"] = this.fullName;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>undefined;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["strEffectiveDate"] = this.strEffectiveDate;
        data["refNo"] = this.refNo;
        data["causeOfLeaving"] = this.causeOfLeaving;
        data["otherComments"] = this.otherComments;
        data["submittedBy"] = this.submittedBy;
        data["dateSubmitted"] = this.dateSubmitted ? this.dateSubmitted.toISOString() : <any>undefined;
        data["reviewedBy"] = this.reviewedBy;
        data["reviewerComment"] = this.reviewerComment;
        data["dateReviewed"] = this.dateReviewed ? this.dateReviewed.toISOString() : <any>undefined;
        data["isAccepted"] = this.isAccepted;
        data["log_status"] = this.log_status;
        return data; 
    }

    clone(): RetirmentDTO {
        const json = this.toJSON();
        let result = new RetirmentDTO();
        result.init(json);
        return result;
    }
}

export interface IRetirmentDTO {
    id: number;
    retirementLogId: number;
    retirementTypeId: number;
    retirementType: string | undefined;
    age: number;
    strAge: string | undefined;
    yearsOfService: number;
    strYearsOfService: string | undefined;
    employeeId: number;
    employeeContractId: number;
    staffNo: string | undefined;
    fullName: string | undefined;
    dob: Date | undefined;
    appointmentDate: Date | undefined;
    effectiveDate: Date | undefined;
    strEffectiveDate: string | undefined;
    refNo: string | undefined;
    causeOfLeaving: string | undefined;
    otherComments: string | undefined;
    submittedBy: string | undefined;
    dateSubmitted: Date | undefined;
    reviewedBy: string | undefined;
    reviewerComment: string | undefined;
    dateReviewed: Date | undefined;
    isAccepted: boolean | undefined;
    log_status: number;
}

export class RetirmentDTOListApiResult implements IRetirmentDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RetirmentDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IRetirmentDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RetirmentDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RetirmentDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RetirmentDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RetirmentDTOListApiResult {
        const json = this.toJSON();
        let result = new RetirmentDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRetirmentDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RetirmentDTO[] | undefined;
    totalCount: number;
}

export class RetirmentDTOApiResult implements IRetirmentDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RetirmentDTO;
    totalCount!: number;

    constructor(data?: IRetirmentDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? RetirmentDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RetirmentDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RetirmentDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RetirmentDTOApiResult {
        const json = this.toJSON();
        let result = new RetirmentDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IRetirmentDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RetirmentDTO;
    totalCount: number;
}

export class RetirementApiResult implements IRetirementApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Retirement;
    totalCount!: number;

    constructor(data?: IRetirementApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? Retirement.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RetirementApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RetirementApiResult {
        const json = this.toJSON();
        let result = new RetirementApiResult();
        result.init(json);
        return result;
    }
}

export interface IRetirementApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Retirement;
    totalCount: number;
}

export class AddRequestViewModel implements IAddRequestViewModel {
    id!: number;
    name!: string | undefined;
    typeId!: string | undefined;
    approval!: string | undefined;
    processid!: number;
    code!: string | undefined;
    enable_step_notify!: boolean;
    is_system_requirement!: boolean;

    constructor(data?: IAddRequestViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.approval = _data["approval"];
            this.processid = _data["processid"];
            this.code = _data["code"];
            this.enable_step_notify = _data["enable_step_notify"];
            this.is_system_requirement = _data["is_system_requirement"];
        }
    }

    static fromJS(data: any): AddRequestViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddRequestViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["approval"] = this.approval;
        data["processid"] = this.processid;
        data["code"] = this.code;
        data["enable_step_notify"] = this.enable_step_notify;
        data["is_system_requirement"] = this.is_system_requirement;
        return data; 
    }

    clone(): AddRequestViewModel {
        const json = this.toJSON();
        let result = new AddRequestViewModel();
        result.init(json);
        return result;
    }
}

export interface IAddRequestViewModel {
    id: number;
    name: string | undefined;
    typeId: string | undefined;
    approval: string | undefined;
    processid: number;
    code: string | undefined;
    enable_step_notify: boolean;
    is_system_requirement: boolean;
}

export class RequestItemViewModel implements IRequestItemViewModel {
    requestType!: string | undefined;
    employeeName!: string | undefined;
    refNo!: string | undefined;
    title!: string | undefined;
    request_date!: Date;
    log_status!: number;
    resolution!: string | undefined;
    dateCreated!: Date;
    id!: number;

    constructor(data?: IRequestItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestType = _data["requestType"];
            this.employeeName = _data["employeeName"];
            this.refNo = _data["refNo"];
            this.title = _data["title"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.log_status = _data["log_status"];
            this.resolution = _data["resolution"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RequestItemViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestItemViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestType"] = this.requestType;
        data["employeeName"] = this.employeeName;
        data["refNo"] = this.refNo;
        data["title"] = this.title;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["log_status"] = this.log_status;
        data["resolution"] = this.resolution;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RequestItemViewModel {
        const json = this.toJSON();
        let result = new RequestItemViewModel();
        result.init(json);
        return result;
    }
}

export interface IRequestItemViewModel {
    requestType: string | undefined;
    employeeName: string | undefined;
    refNo: string | undefined;
    title: string | undefined;
    request_date: Date;
    log_status: number;
    resolution: string | undefined;
    dateCreated: Date;
    id: number;
}

export class RequestViewModel implements IRequestViewModel {
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    log_Status!: number;
    lstOfRequests!: RequestItemViewModel[] | undefined;

    constructor(data?: IRequestViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.log_Status = _data["log_Status"];
            if (Array.isArray(_data["lstOfRequests"])) {
                this.lstOfRequests = [] as any;
                for (let item of _data["lstOfRequests"])
                    this.lstOfRequests!.push(RequestItemViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["log_Status"] = this.log_Status;
        if (Array.isArray(this.lstOfRequests)) {
            data["lstOfRequests"] = [];
            for (let item of this.lstOfRequests)
                data["lstOfRequests"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RequestViewModel {
        const json = this.toJSON();
        let result = new RequestViewModel();
        result.init(json);
        return result;
    }
}

export interface IRequestViewModel {
    startDate: Date | undefined;
    endDate: Date | undefined;
    log_Status: number;
    lstOfRequests: RequestItemViewModel[] | undefined;
}

export class RequestViewModelIListApiResult implements IRequestViewModelIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestViewModel[] | undefined;
    totalCount!: number;

    constructor(data?: IRequestViewModelIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RequestViewModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RequestViewModelIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestViewModelIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RequestViewModelIListApiResult {
        const json = this.toJSON();
        let result = new RequestViewModelIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestViewModelIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestViewModel[] | undefined;
    totalCount: number;
}

export class RequestFileDto implements IRequestFileDto {
    request!: RequestFile[] | undefined;
    processId!: number[] | undefined;
    employee!: string | undefined;
    itemId!: number;
    employeeName!: string | undefined;

    constructor(data?: IRequestFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["request"])) {
                this.request = [] as any;
                for (let item of _data["request"])
                    this.request!.push(RequestFile.fromJS(item));
            }
            if (Array.isArray(_data["processId"])) {
                this.processId = [] as any;
                for (let item of _data["processId"])
                    this.processId!.push(item);
            }
            this.employee = _data["employee"];
            this.itemId = _data["itemId"];
            this.employeeName = _data["employeeName"];
        }
    }

    static fromJS(data: any): RequestFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.request)) {
            data["request"] = [];
            for (let item of this.request)
                data["request"].push(item.toJSON());
        }
        if (Array.isArray(this.processId)) {
            data["processId"] = [];
            for (let item of this.processId)
                data["processId"].push(item);
        }
        data["employee"] = this.employee;
        data["itemId"] = this.itemId;
        data["employeeName"] = this.employeeName;
        return data; 
    }

    clone(): RequestFileDto {
        const json = this.toJSON();
        let result = new RequestFileDto();
        result.init(json);
        return result;
    }
}

export interface IRequestFileDto {
    request: RequestFile[] | undefined;
    processId: number[] | undefined;
    employee: string | undefined;
    itemId: number;
    employeeName: string | undefined;
}

export class RequestFileDtoIListApiResult implements IRequestFileDtoIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestFileDto[] | undefined;
    totalCount!: number;

    constructor(data?: IRequestFileDtoIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RequestFileDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RequestFileDtoIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestFileDtoIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RequestFileDtoIListApiResult {
        const json = this.toJSON();
        let result = new RequestFileDtoIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestFileDtoIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestFileDto[] | undefined;
    totalCount: number;
}

export class ApplicationRoleDTO implements IApplicationRoleDTO {
    id!: number;
    name!: string;
    description!: string | undefined;
    isSystemRole!: boolean;

    constructor(data?: IApplicationRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isSystemRole = _data["isSystemRole"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isSystemRole"] = this.isSystemRole;
        return data; 
    }

    clone(): ApplicationRoleDTO {
        const json = this.toJSON();
        let result = new ApplicationRoleDTO();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTO {
    id: number;
    name: string;
    description: string | undefined;
    isSystemRole: boolean;
}

export class ApplicationRoleDTOIListApiResult implements IApplicationRoleDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationRoleDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IApplicationRoleDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApplicationRoleDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApplicationRoleDTOIListApiResult {
        const json = this.toJSON();
        let result = new ApplicationRoleDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationRoleDTO[] | undefined;
    totalCount: number;
}

export class ApplicationRoleDTOApiResult implements IApplicationRoleDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationRoleDTO;
    totalCount!: number;

    constructor(data?: IApplicationRoleDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? ApplicationRoleDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApplicationRoleDTOApiResult {
        const json = this.toJSON();
        let result = new ApplicationRoleDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationRoleDTO;
    totalCount: number;
}

export class PermissionDTO implements IPermissionDTO {
    id!: number;
    name!: string | undefined;
    applicationName!: string | undefined;
    code!: string | undefined;

    constructor(data?: IPermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.applicationName = _data["applicationName"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): PermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["applicationName"] = this.applicationName;
        data["code"] = this.code;
        return data; 
    }

    clone(): PermissionDTO {
        const json = this.toJSON();
        let result = new PermissionDTO();
        result.init(json);
        return result;
    }
}

export interface IPermissionDTO {
    id: number;
    name: string | undefined;
    applicationName: string | undefined;
    code: string | undefined;
}

export class RolePermissionDTO implements IRolePermissionDTO {
    roleId!: number;
    roleName!: string | undefined;
    permissions!: PermissionDTO[] | undefined;

    constructor(data?: IRolePermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolePermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RolePermissionDTO {
        const json = this.toJSON();
        let result = new RolePermissionDTO();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTO {
    roleId: number;
    roleName: string | undefined;
    permissions: PermissionDTO[] | undefined;
}

export class RolePermissionDTOIListApiResult implements IRolePermissionDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RolePermissionDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IRolePermissionDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RolePermissionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RolePermissionDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RolePermissionDTOIListApiResult {
        const json = this.toJSON();
        let result = new RolePermissionDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RolePermissionDTO[] | undefined;
    totalCount: number;
}

export class RolePermissionDTOApiResult implements IRolePermissionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RolePermissionDTO;
    totalCount!: number;

    constructor(data?: IRolePermissionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? RolePermissionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RolePermissionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RolePermissionDTOApiResult {
        const json = this.toJSON();
        let result = new RolePermissionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RolePermissionDTO;
    totalCount: number;
}

export class RolePermissionMappingDTO implements IRolePermissionMappingDTO {
    roleId!: number;
    permissionIds!: number[];

    constructor(data?: IRolePermissionMappingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permissionIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            if (Array.isArray(_data["permissionIds"])) {
                this.permissionIds = [] as any;
                for (let item of _data["permissionIds"])
                    this.permissionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): RolePermissionMappingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionMappingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        if (Array.isArray(this.permissionIds)) {
            data["permissionIds"] = [];
            for (let item of this.permissionIds)
                data["permissionIds"].push(item);
        }
        return data; 
    }

    clone(): RolePermissionMappingDTO {
        const json = this.toJSON();
        let result = new RolePermissionMappingDTO();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionMappingDTO {
    roleId: number;
    permissionIds: number[];
}

export class ManageSalaryscaleDTO implements IManageSalaryscaleDTO {
    id!: number;
    name!: string;
    code!: string;
    isActive!: boolean;

    constructor(data?: IManageSalaryscaleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ManageSalaryscaleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageSalaryscaleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ManageSalaryscaleDTO {
        const json = this.toJSON();
        let result = new ManageSalaryscaleDTO();
        result.init(json);
        return result;
    }
}

export interface IManageSalaryscaleDTO {
    id: number;
    name: string;
    code: string;
    isActive: boolean;
}

export class SalaryscaleDTO implements ISalaryscaleDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISalaryscaleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): SalaryscaleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryscaleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): SalaryscaleDTO {
        const json = this.toJSON();
        let result = new SalaryscaleDTO();
        result.init(json);
        return result;
    }
}

export interface ISalaryscaleDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class SalaryscaleDTOListApiResult implements ISalaryscaleDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SalaryscaleDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ISalaryscaleDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SalaryscaleDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SalaryscaleDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryscaleDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SalaryscaleDTOListApiResult {
        const json = this.toJSON();
        let result = new SalaryscaleDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISalaryscaleDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SalaryscaleDTO[] | undefined;
    totalCount: number;
}

export class SalaryscaleDTOApiResult implements ISalaryscaleDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SalaryscaleDTO;
    totalCount!: number;

    constructor(data?: ISalaryscaleDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? SalaryscaleDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SalaryscaleDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryscaleDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SalaryscaleDTOApiResult {
        const json = this.toJSON();
        let result = new SalaryscaleDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ISalaryscaleDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SalaryscaleDTO;
    totalCount: number;
}

export class Modular implements IModular {
    id!: number;
    name!: string | undefined;
    defaultEnabled!: boolean;
    makeAvailable!: boolean;
    subscriptionPlanModules!: SubscriptionPlanModule[] | undefined;

    constructor(data?: IModular) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.defaultEnabled = _data["defaultEnabled"];
            this.makeAvailable = _data["makeAvailable"];
            if (Array.isArray(_data["subscriptionPlanModules"])) {
                this.subscriptionPlanModules = [] as any;
                for (let item of _data["subscriptionPlanModules"])
                    this.subscriptionPlanModules!.push(SubscriptionPlanModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Modular {
        data = typeof data === 'object' ? data : {};
        let result = new Modular();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["defaultEnabled"] = this.defaultEnabled;
        data["makeAvailable"] = this.makeAvailable;
        if (Array.isArray(this.subscriptionPlanModules)) {
            data["subscriptionPlanModules"] = [];
            for (let item of this.subscriptionPlanModules)
                data["subscriptionPlanModules"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Modular {
        const json = this.toJSON();
        let result = new Modular();
        result.init(json);
        return result;
    }
}

export interface IModular {
    id: number;
    name: string | undefined;
    defaultEnabled: boolean;
    makeAvailable: boolean;
    subscriptionPlanModules: SubscriptionPlanModule[] | undefined;
}

export class SubscriptionPlanModule implements ISubscriptionPlanModule {
    id!: number;
    subscriptionPlanId!: number;
    modularId!: number;
    lastDateModified!: Date | undefined;
    modularDefaultEnabled!: boolean;
    subscriptionPlan!: SubscriptionPlan;
    modular!: Modular;

    constructor(data?: ISubscriptionPlanModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.modularId = _data["modularId"];
            this.lastDateModified = _data["lastDateModified"] ? new Date(_data["lastDateModified"].toString()) : <any>undefined;
            this.modularDefaultEnabled = _data["modularDefaultEnabled"];
            this.subscriptionPlan = _data["subscriptionPlan"] ? SubscriptionPlan.fromJS(_data["subscriptionPlan"]) : <any>undefined;
            this.modular = _data["modular"] ? Modular.fromJS(_data["modular"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SubscriptionPlanModule {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["modularId"] = this.modularId;
        data["lastDateModified"] = this.lastDateModified ? this.lastDateModified.toISOString() : <any>undefined;
        data["modularDefaultEnabled"] = this.modularDefaultEnabled;
        data["subscriptionPlan"] = this.subscriptionPlan ? this.subscriptionPlan.toJSON() : <any>undefined;
        data["modular"] = this.modular ? this.modular.toJSON() : <any>undefined;
        return data; 
    }

    clone(): SubscriptionPlanModule {
        const json = this.toJSON();
        let result = new SubscriptionPlanModule();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanModule {
    id: number;
    subscriptionPlanId: number;
    modularId: number;
    lastDateModified: Date | undefined;
    modularDefaultEnabled: boolean;
    subscriptionPlan: SubscriptionPlan;
    modular: Modular;
}

export class SubscriptionPlan implements ISubscriptionPlan {
    id!: number;
    planCode!: string | undefined;
    name!: string | undefined;
    paymentUrl!: string | undefined;
    amount!: number;
    licenseCount!: number;
    created!: Date | undefined;
    modified!: Date | undefined;
    subscriptionPlanModules!: SubscriptionPlanModule[] | undefined;

    constructor(data?: ISubscriptionPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.planCode = _data["planCode"];
            this.name = _data["name"];
            this.paymentUrl = _data["paymentUrl"];
            this.amount = _data["amount"];
            this.licenseCount = _data["licenseCount"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            if (Array.isArray(_data["subscriptionPlanModules"])) {
                this.subscriptionPlanModules = [] as any;
                for (let item of _data["subscriptionPlanModules"])
                    this.subscriptionPlanModules!.push(SubscriptionPlanModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubscriptionPlan {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["planCode"] = this.planCode;
        data["name"] = this.name;
        data["paymentUrl"] = this.paymentUrl;
        data["amount"] = this.amount;
        data["licenseCount"] = this.licenseCount;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        if (Array.isArray(this.subscriptionPlanModules)) {
            data["subscriptionPlanModules"] = [];
            for (let item of this.subscriptionPlanModules)
                data["subscriptionPlanModules"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SubscriptionPlan {
        const json = this.toJSON();
        let result = new SubscriptionPlan();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlan {
    id: number;
    planCode: string | undefined;
    name: string | undefined;
    paymentUrl: string | undefined;
    amount: number;
    licenseCount: number;
    created: Date | undefined;
    modified: Date | undefined;
    subscriptionPlanModules: SubscriptionPlanModule[] | undefined;
}

export class SubscriptionPlanIListApiResult implements ISubscriptionPlanIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubscriptionPlan[] | undefined;
    totalCount!: number;

    constructor(data?: ISubscriptionPlanIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SubscriptionPlan.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SubscriptionPlanIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SubscriptionPlanIListApiResult {
        const json = this.toJSON();
        let result = new SubscriptionPlanIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubscriptionPlan[] | undefined;
    totalCount: number;
}

export class SubscriptionPlanApiResult implements ISubscriptionPlanApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubscriptionPlan;
    totalCount!: number;

    constructor(data?: ISubscriptionPlanApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? SubscriptionPlan.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SubscriptionPlanApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SubscriptionPlanApiResult {
        const json = this.toJSON();
        let result = new SubscriptionPlanApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubscriptionPlan;
    totalCount: number;
}

export class SubscriptionPlanModuleIListApiResult implements ISubscriptionPlanModuleIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubscriptionPlanModule[] | undefined;
    totalCount!: number;

    constructor(data?: ISubscriptionPlanModuleIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SubscriptionPlanModule.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SubscriptionPlanModuleIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanModuleIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SubscriptionPlanModuleIListApiResult {
        const json = this.toJSON();
        let result = new SubscriptionPlanModuleIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanModuleIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubscriptionPlanModule[] | undefined;
    totalCount: number;
}

export class CompanySignUpDTO implements ICompanySignUpDTO {
    email!: string;
    phoneNumber!: string;
    password!: string;

    constructor(data?: ICompanySignUpDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CompanySignUpDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanySignUpDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        return data; 
    }

    clone(): CompanySignUpDTO {
        const json = this.toJSON();
        let result = new CompanySignUpDTO();
        result.init(json);
        return result;
    }
}

export interface ICompanySignUpDTO {
    email: string;
    phoneNumber: string;
    password: string;
}

export class CompanyDTO implements ICompanyDTO {
    id!: number;
    userId!: number;
    name!: string;
    rcNo!: string | undefined;
    logoName!: string | undefined;
    shortText!: string | undefined;
    email!: string;
    phoneNumber!: string;
    firstName!: string | undefined;
    lastName!: string | undefined;
    address!: string | undefined;
    administratorEmail!: string;
    domainName!: string | undefined;
    auditorEmail!: string | undefined;
    maxEmployeeCount!: number;
    subscriptionPlanId!: number;
    password!: string | undefined;

    constructor(data?: ICompanyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.rcNo = _data["rcNo"];
            this.logoName = _data["logoName"];
            this.shortText = _data["shortText"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.address = _data["address"];
            this.administratorEmail = _data["administratorEmail"];
            this.domainName = _data["domainName"];
            this.auditorEmail = _data["auditorEmail"];
            this.maxEmployeeCount = _data["maxEmployeeCount"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CompanyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["rcNo"] = this.rcNo;
        data["logoName"] = this.logoName;
        data["shortText"] = this.shortText;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["address"] = this.address;
        data["administratorEmail"] = this.administratorEmail;
        data["domainName"] = this.domainName;
        data["auditorEmail"] = this.auditorEmail;
        data["maxEmployeeCount"] = this.maxEmployeeCount;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["password"] = this.password;
        return data; 
    }

    clone(): CompanyDTO {
        const json = this.toJSON();
        let result = new CompanyDTO();
        result.init(json);
        return result;
    }
}

export interface ICompanyDTO {
    id: number;
    userId: number;
    name: string;
    rcNo: string | undefined;
    logoName: string | undefined;
    shortText: string | undefined;
    email: string;
    phoneNumber: string;
    firstName: string | undefined;
    lastName: string | undefined;
    address: string | undefined;
    administratorEmail: string;
    domainName: string | undefined;
    auditorEmail: string | undefined;
    maxEmployeeCount: number;
    subscriptionPlanId: number;
    password: string | undefined;
}

export class Company implements ICompany {
    id!: number;
    name!: string | undefined;
    rcNo!: string | undefined;
    logoName!: string | undefined;
    landingImageBGName!: string | undefined;
    shortText!: string | undefined;
    email!: string | undefined;
    address!: string | undefined;
    phoneNumber!: string | undefined;
    adminEmail!: string | undefined;
    subscriptionPlanId!: number;
    lastBillingDate!: Date | undefined;
    lastPaymtDate!: Date | undefined;
    licenseUsuage!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    auditorEmail!: string | undefined;
    isActiveByAdmin!: boolean;
    created!: Date | undefined;
    modified!: Date | undefined;
    code!: string | undefined;
    colorBackGround!: string | undefined;
    domainName!: string | undefined;
    isTrial!: boolean;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.rcNo = _data["rcNo"];
            this.logoName = _data["logoName"];
            this.landingImageBGName = _data["landingImageBGName"];
            this.shortText = _data["shortText"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.adminEmail = _data["adminEmail"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.lastBillingDate = _data["lastBillingDate"] ? new Date(_data["lastBillingDate"].toString()) : <any>undefined;
            this.lastPaymtDate = _data["lastPaymtDate"] ? new Date(_data["lastPaymtDate"].toString()) : <any>undefined;
            this.licenseUsuage = _data["licenseUsuage"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.auditorEmail = _data["auditorEmail"];
            this.isActiveByAdmin = _data["isActiveByAdmin"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.colorBackGround = _data["colorBackGround"];
            this.domainName = _data["domainName"];
            this.isTrial = _data["isTrial"];
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["rcNo"] = this.rcNo;
        data["logoName"] = this.logoName;
        data["landingImageBGName"] = this.landingImageBGName;
        data["shortText"] = this.shortText;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["adminEmail"] = this.adminEmail;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["lastBillingDate"] = this.lastBillingDate ? this.lastBillingDate.toISOString() : <any>undefined;
        data["lastPaymtDate"] = this.lastPaymtDate ? this.lastPaymtDate.toISOString() : <any>undefined;
        data["licenseUsuage"] = this.licenseUsuage;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["auditorEmail"] = this.auditorEmail;
        data["isActiveByAdmin"] = this.isActiveByAdmin;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["colorBackGround"] = this.colorBackGround;
        data["domainName"] = this.domainName;
        data["isTrial"] = this.isTrial;
        return data; 
    }

    clone(): Company {
        const json = this.toJSON();
        let result = new Company();
        result.init(json);
        return result;
    }
}

export interface ICompany {
    id: number;
    name: string | undefined;
    rcNo: string | undefined;
    logoName: string | undefined;
    landingImageBGName: string | undefined;
    shortText: string | undefined;
    email: string | undefined;
    address: string | undefined;
    phoneNumber: string | undefined;
    adminEmail: string | undefined;
    subscriptionPlanId: number;
    lastBillingDate: Date | undefined;
    lastPaymtDate: Date | undefined;
    licenseUsuage: number;
    isActive: boolean;
    isDeleted: boolean;
    auditorEmail: string | undefined;
    isActiveByAdmin: boolean;
    created: Date | undefined;
    modified: Date | undefined;
    code: string | undefined;
    colorBackGround: string | undefined;
    domainName: string | undefined;
    isTrial: boolean;
}

export class CompanyIListApiResult implements ICompanyIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Company[] | undefined;
    totalCount!: number;

    constructor(data?: ICompanyIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Company.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CompanyIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CompanyIListApiResult {
        const json = this.toJSON();
        let result = new CompanyIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICompanyIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Company[] | undefined;
    totalCount: number;
}

export class CompanyModuleDTO implements ICompanyModuleDTO {
    id!: number;
    moduleId!: number;
    companyId!: number;
    isEnabled!: boolean;
    moduleName!: string | undefined;
    icon!: string | undefined;
    isReadonly!: boolean;

    constructor(data?: ICompanyModuleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.moduleId = _data["moduleId"];
            this.companyId = _data["companyId"];
            this.isEnabled = _data["isEnabled"];
            this.moduleName = _data["moduleName"];
            this.icon = _data["icon"];
            this.isReadonly = _data["isReadonly"];
        }
    }

    static fromJS(data: any): CompanyModuleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyModuleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["moduleId"] = this.moduleId;
        data["companyId"] = this.companyId;
        data["isEnabled"] = this.isEnabled;
        data["moduleName"] = this.moduleName;
        data["icon"] = this.icon;
        data["isReadonly"] = this.isReadonly;
        return data; 
    }

    clone(): CompanyModuleDTO {
        const json = this.toJSON();
        let result = new CompanyModuleDTO();
        result.init(json);
        return result;
    }
}

export interface ICompanyModuleDTO {
    id: number;
    moduleId: number;
    companyId: number;
    isEnabled: boolean;
    moduleName: string | undefined;
    icon: string | undefined;
    isReadonly: boolean;
}

export class CompanyModuleDTOIListApiResult implements ICompanyModuleDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CompanyModuleDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ICompanyModuleDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CompanyModuleDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CompanyModuleDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyModuleDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CompanyModuleDTOIListApiResult {
        const json = this.toJSON();
        let result = new CompanyModuleDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICompanyModuleDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CompanyModuleDTO[] | undefined;
    totalCount: number;
}

export class TrainingVendorPayload implements ITrainingVendorPayload {
    id!: number;
    name!: string;
    contactPerson!: string;
    phoneNo!: string;
    email!: string;
    website!: string | undefined;
    description!: string | undefined;
    trainingSpecializationId!: number;
    trainingTag!: string | undefined;

    constructor(data?: ITrainingVendorPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.contactPerson = _data["contactPerson"];
            this.phoneNo = _data["phoneNo"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.description = _data["description"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.trainingTag = _data["trainingTag"];
        }
    }

    static fromJS(data: any): TrainingVendorPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendorPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["contactPerson"] = this.contactPerson;
        data["phoneNo"] = this.phoneNo;
        data["email"] = this.email;
        data["website"] = this.website;
        data["description"] = this.description;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["trainingTag"] = this.trainingTag;
        return data; 
    }

    clone(): TrainingVendorPayload {
        const json = this.toJSON();
        let result = new TrainingVendorPayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendorPayload {
    id: number;
    name: string;
    contactPerson: string;
    phoneNo: string;
    email: string;
    website: string | undefined;
    description: string | undefined;
    trainingSpecializationId: number;
    trainingTag: string | undefined;
}

export class TrainingSpecialization implements ITrainingSpecialization {
    id!: number;
    name!: string | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingSpecialization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingSpecialization {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecialization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingSpecialization {
        const json = this.toJSON();
        let result = new TrainingSpecialization();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecialization {
    id: number;
    name: string | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingVendorResource implements ITrainingVendorResource {
    id!: number;
    name!: string | undefined;
    phoneNo!: string | undefined;
    email!: string | undefined;
    website!: string | undefined;
    description!: string | undefined;
    expertees!: string | undefined;
    trainingTag!: string | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;
    trainingSpecializationId!: number;
    trainingSpecialization!: TrainingSpecialization;

    constructor(data?: ITrainingVendorResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.phoneNo = _data["phoneNo"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.description = _data["description"];
            this.expertees = _data["expertees"];
            this.trainingTag = _data["trainingTag"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.trainingSpecialization = _data["trainingSpecialization"] ? TrainingSpecialization.fromJS(_data["trainingSpecialization"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingVendorResource {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendorResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["phoneNo"] = this.phoneNo;
        data["email"] = this.email;
        data["website"] = this.website;
        data["description"] = this.description;
        data["expertees"] = this.expertees;
        data["trainingTag"] = this.trainingTag;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["trainingSpecialization"] = this.trainingSpecialization ? this.trainingSpecialization.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TrainingVendorResource {
        const json = this.toJSON();
        let result = new TrainingVendorResource();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendorResource {
    id: number;
    name: string | undefined;
    phoneNo: string | undefined;
    email: string | undefined;
    website: string | undefined;
    description: string | undefined;
    expertees: string | undefined;
    trainingTag: string | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
    trainingSpecializationId: number;
    trainingSpecialization: TrainingSpecialization;
}

export class TrainingVendorResourceListApiResult implements ITrainingVendorResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingVendorResource[] | undefined;
    totalCount!: number;

    constructor(data?: ITrainingVendorResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingVendorResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingVendorResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendorResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingVendorResourceListApiResult {
        const json = this.toJSON();
        let result = new TrainingVendorResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendorResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingVendorResource[] | undefined;
    totalCount: number;
}

export class TrainingVendorResourceApiResult implements ITrainingVendorResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingVendorResource;
    totalCount!: number;

    constructor(data?: ITrainingVendorResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? TrainingVendorResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingVendorResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendorResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingVendorResourceApiResult {
        const json = this.toJSON();
        let result = new TrainingVendorResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendorResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingVendorResource;
    totalCount: number;
}

export class TrainingTypePayload implements ITrainingTypePayload {
    costPer_Head!: number;
    no_Of_Trainees!: number;
    overAll_Budget!: number;
    trainingTypeId!: number;
    employeeId!: number;
    trainingVendorId!: number;
    trainingSpecializationId!: number;
    name!: string | undefined;
    file!: string | undefined;
    trainingCategoryId!: number;

    constructor(data?: ITrainingTypePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.costPer_Head = _data["costPer_Head"];
            this.no_Of_Trainees = _data["no_Of_Trainees"];
            this.overAll_Budget = _data["overAll_Budget"];
            this.trainingTypeId = _data["trainingTypeId"];
            this.employeeId = _data["employeeId"];
            this.trainingVendorId = _data["trainingVendorId"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.name = _data["name"];
            this.file = _data["file"];
            this.trainingCategoryId = _data["trainingCategoryId"];
        }
    }

    static fromJS(data: any): TrainingTypePayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingTypePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["costPer_Head"] = this.costPer_Head;
        data["no_Of_Trainees"] = this.no_Of_Trainees;
        data["overAll_Budget"] = this.overAll_Budget;
        data["trainingTypeId"] = this.trainingTypeId;
        data["employeeId"] = this.employeeId;
        data["trainingVendorId"] = this.trainingVendorId;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["name"] = this.name;
        data["file"] = this.file;
        data["trainingCategoryId"] = this.trainingCategoryId;
        return data; 
    }

    clone(): TrainingTypePayload {
        const json = this.toJSON();
        let result = new TrainingTypePayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingTypePayload {
    costPer_Head: number;
    no_Of_Trainees: number;
    overAll_Budget: number;
    trainingTypeId: number;
    employeeId: number;
    trainingVendorId: number;
    trainingSpecializationId: number;
    name: string | undefined;
    file: string | undefined;
    trainingCategoryId: number;
}

export class TrainingVendor implements ITrainingVendor {
    id!: number;
    name!: string;
    phoneNo!: string | undefined;
    trainingSpecializationId!: number;
    email!: string | undefined;
    website!: string | undefined;
    description!: string | undefined;
    expertees!: string | undefined;
    trainingTag!: string | undefined;
    trainingSpecialization!: TrainingSpecialization;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingVendor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.phoneNo = _data["phoneNo"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.description = _data["description"];
            this.expertees = _data["expertees"];
            this.trainingTag = _data["trainingTag"];
            this.trainingSpecialization = _data["trainingSpecialization"] ? TrainingSpecialization.fromJS(_data["trainingSpecialization"]) : <any>undefined;
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingVendor {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["phoneNo"] = this.phoneNo;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["email"] = this.email;
        data["website"] = this.website;
        data["description"] = this.description;
        data["expertees"] = this.expertees;
        data["trainingTag"] = this.trainingTag;
        data["trainingSpecialization"] = this.trainingSpecialization ? this.trainingSpecialization.toJSON() : <any>undefined;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingVendor {
        const json = this.toJSON();
        let result = new TrainingVendor();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendor {
    id: number;
    name: string;
    phoneNo: string | undefined;
    trainingSpecializationId: number;
    email: string | undefined;
    website: string | undefined;
    description: string | undefined;
    expertees: string | undefined;
    trainingTag: string | undefined;
    trainingSpecialization: TrainingSpecialization;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingCategory implements ITrainingCategory {
    id!: number;
    name!: string;
    trainingLocationFlagId!: number;
    locationFlag!: string | undefined;
    tags!: string | undefined;
    numberOfMonthsInterval!: number;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.trainingLocationFlagId = _data["trainingLocationFlagId"];
            this.locationFlag = _data["locationFlag"];
            this.tags = _data["tags"];
            this.numberOfMonthsInterval = _data["numberOfMonthsInterval"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingCategory {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["trainingLocationFlagId"] = this.trainingLocationFlagId;
        data["locationFlag"] = this.locationFlag;
        data["tags"] = this.tags;
        data["numberOfMonthsInterval"] = this.numberOfMonthsInterval;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingCategory {
        const json = this.toJSON();
        let result = new TrainingCategory();
        result.init(json);
        return result;
    }
}

export interface ITrainingCategory {
    id: number;
    name: string;
    trainingLocationFlagId: number;
    locationFlag: string | undefined;
    tags: string | undefined;
    numberOfMonthsInterval: number;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingType implements ITrainingType {
    id!: number;
    description!: string | undefined;
    summary!: string | undefined;
    outline!: string | undefined;
    contentUrl!: string | undefined;
    name!: string | undefined;
    maxCount!: number;
    remainingCount!: number;
    maxDays!: number;
    remainingDays!: number;
    isLocalTraining!: boolean;
    tags!: string | undefined;
    costPer_Head!: number;
    no_Of_Trainees!: number;
    overAll_Budget!: number;
    employeeId!: number;
    trainingVendorId!: number;
    trainingSpecializationId!: number;
    trainingCategoryId!: number;
    trainings!: Training[] | undefined;
    trainingSpecialization!: TrainingSpecialization;
    trainingCategory!: TrainingCategory;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.summary = _data["summary"];
            this.outline = _data["outline"];
            this.contentUrl = _data["contentUrl"];
            this.name = _data["name"];
            this.maxCount = _data["maxCount"];
            this.remainingCount = _data["remainingCount"];
            this.maxDays = _data["maxDays"];
            this.remainingDays = _data["remainingDays"];
            this.isLocalTraining = _data["isLocalTraining"];
            this.tags = _data["tags"];
            this.costPer_Head = _data["costPer_Head"];
            this.no_Of_Trainees = _data["no_Of_Trainees"];
            this.overAll_Budget = _data["overAll_Budget"];
            this.employeeId = _data["employeeId"];
            this.trainingVendorId = _data["trainingVendorId"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.trainingCategoryId = _data["trainingCategoryId"];
            if (Array.isArray(_data["trainings"])) {
                this.trainings = [] as any;
                for (let item of _data["trainings"])
                    this.trainings!.push(Training.fromJS(item));
            }
            this.trainingSpecialization = _data["trainingSpecialization"] ? TrainingSpecialization.fromJS(_data["trainingSpecialization"]) : <any>undefined;
            this.trainingCategory = _data["trainingCategory"] ? TrainingCategory.fromJS(_data["trainingCategory"]) : <any>undefined;
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingType {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["summary"] = this.summary;
        data["outline"] = this.outline;
        data["contentUrl"] = this.contentUrl;
        data["name"] = this.name;
        data["maxCount"] = this.maxCount;
        data["remainingCount"] = this.remainingCount;
        data["maxDays"] = this.maxDays;
        data["remainingDays"] = this.remainingDays;
        data["isLocalTraining"] = this.isLocalTraining;
        data["tags"] = this.tags;
        data["costPer_Head"] = this.costPer_Head;
        data["no_Of_Trainees"] = this.no_Of_Trainees;
        data["overAll_Budget"] = this.overAll_Budget;
        data["employeeId"] = this.employeeId;
        data["trainingVendorId"] = this.trainingVendorId;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["trainingCategoryId"] = this.trainingCategoryId;
        if (Array.isArray(this.trainings)) {
            data["trainings"] = [];
            for (let item of this.trainings)
                data["trainings"].push(item.toJSON());
        }
        data["trainingSpecialization"] = this.trainingSpecialization ? this.trainingSpecialization.toJSON() : <any>undefined;
        data["trainingCategory"] = this.trainingCategory ? this.trainingCategory.toJSON() : <any>undefined;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingType {
        const json = this.toJSON();
        let result = new TrainingType();
        result.init(json);
        return result;
    }
}

export interface ITrainingType {
    id: number;
    description: string | undefined;
    summary: string | undefined;
    outline: string | undefined;
    contentUrl: string | undefined;
    name: string | undefined;
    maxCount: number;
    remainingCount: number;
    maxDays: number;
    remainingDays: number;
    isLocalTraining: boolean;
    tags: string | undefined;
    costPer_Head: number;
    no_Of_Trainees: number;
    overAll_Budget: number;
    employeeId: number;
    trainingVendorId: number;
    trainingSpecializationId: number;
    trainingCategoryId: number;
    trainings: Training[] | undefined;
    trainingSpecialization: TrainingSpecialization;
    trainingCategory: TrainingCategory;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class Training implements ITraining {
    id!: number;
    name!: string;
    description!: string | undefined;
    point!: number | undefined;
    log_status!: number;
    startDate!: Date;
    endDate!: Date;
    trainingTypeId!: number;
    vendorId!: number;
    specializationId!: number;
    trainingCategoryId!: number;
    strStartDate!: string | undefined;
    strEndDate!: string | undefined;
    totalCost!: number | undefined;
    costPerEmployee!: number | undefined;
    attachment!: string | undefined;
    trainingType!: TrainingType;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITraining) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.point = _data["point"];
            this.log_status = _data["log_status"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.trainingTypeId = _data["trainingTypeId"];
            this.vendorId = _data["vendorId"];
            this.specializationId = _data["specializationId"];
            this.trainingCategoryId = _data["trainingCategoryId"];
            this.strStartDate = _data["strStartDate"];
            this.strEndDate = _data["strEndDate"];
            this.totalCost = _data["totalCost"];
            this.costPerEmployee = _data["costPerEmployee"];
            this.attachment = _data["attachment"];
            this.trainingType = _data["trainingType"] ? TrainingType.fromJS(_data["trainingType"]) : <any>undefined;
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): Training {
        data = typeof data === 'object' ? data : {};
        let result = new Training();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["point"] = this.point;
        data["log_status"] = this.log_status;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["trainingTypeId"] = this.trainingTypeId;
        data["vendorId"] = this.vendorId;
        data["specializationId"] = this.specializationId;
        data["trainingCategoryId"] = this.trainingCategoryId;
        data["strStartDate"] = this.strStartDate;
        data["strEndDate"] = this.strEndDate;
        data["totalCost"] = this.totalCost;
        data["costPerEmployee"] = this.costPerEmployee;
        data["attachment"] = this.attachment;
        data["trainingType"] = this.trainingType ? this.trainingType.toJSON() : <any>undefined;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): Training {
        const json = this.toJSON();
        let result = new Training();
        result.init(json);
        return result;
    }
}

export interface ITraining {
    id: number;
    name: string;
    description: string | undefined;
    point: number | undefined;
    log_status: number;
    startDate: Date;
    endDate: Date;
    trainingTypeId: number;
    vendorId: number;
    specializationId: number;
    trainingCategoryId: number;
    strStartDate: string | undefined;
    strEndDate: string | undefined;
    totalCost: number | undefined;
    costPerEmployee: number | undefined;
    attachment: string | undefined;
    trainingType: TrainingType;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingTypeResource implements ITrainingTypeResource {
    id!: number;
    description!: string | undefined;
    contentUrl!: string | undefined;
    summary!: string | undefined;
    outline!: string | undefined;
    name!: string | undefined;
    maxCount!: number;
    remainingCount!: number;
    maxDays!: number;
    remainingDays!: number;
    isLocalTraining!: boolean;
    tags!: string | undefined;
    employeeId!: number;
    trainingVendorId!: number;
    trainingSpecializationId!: number;
    trainingCategoryId!: number;
    employee!: Employee;
    trainingVendor!: TrainingVendor;
    trainingSpecialization!: TrainingSpecialization;
    trainingCategory!: TrainingCategory;
    trainings!: Training[] | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingTypeResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.contentUrl = _data["contentUrl"];
            this.summary = _data["summary"];
            this.outline = _data["outline"];
            this.name = _data["name"];
            this.maxCount = _data["maxCount"];
            this.remainingCount = _data["remainingCount"];
            this.maxDays = _data["maxDays"];
            this.remainingDays = _data["remainingDays"];
            this.isLocalTraining = _data["isLocalTraining"];
            this.tags = _data["tags"];
            this.employeeId = _data["employeeId"];
            this.trainingVendorId = _data["trainingVendorId"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.trainingCategoryId = _data["trainingCategoryId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.trainingVendor = _data["trainingVendor"] ? TrainingVendor.fromJS(_data["trainingVendor"]) : <any>undefined;
            this.trainingSpecialization = _data["trainingSpecialization"] ? TrainingSpecialization.fromJS(_data["trainingSpecialization"]) : <any>undefined;
            this.trainingCategory = _data["trainingCategory"] ? TrainingCategory.fromJS(_data["trainingCategory"]) : <any>undefined;
            if (Array.isArray(_data["trainings"])) {
                this.trainings = [] as any;
                for (let item of _data["trainings"])
                    this.trainings!.push(Training.fromJS(item));
            }
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingTypeResource {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingTypeResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["contentUrl"] = this.contentUrl;
        data["summary"] = this.summary;
        data["outline"] = this.outline;
        data["name"] = this.name;
        data["maxCount"] = this.maxCount;
        data["remainingCount"] = this.remainingCount;
        data["maxDays"] = this.maxDays;
        data["remainingDays"] = this.remainingDays;
        data["isLocalTraining"] = this.isLocalTraining;
        data["tags"] = this.tags;
        data["employeeId"] = this.employeeId;
        data["trainingVendorId"] = this.trainingVendorId;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["trainingCategoryId"] = this.trainingCategoryId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["trainingVendor"] = this.trainingVendor ? this.trainingVendor.toJSON() : <any>undefined;
        data["trainingSpecialization"] = this.trainingSpecialization ? this.trainingSpecialization.toJSON() : <any>undefined;
        data["trainingCategory"] = this.trainingCategory ? this.trainingCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.trainings)) {
            data["trainings"] = [];
            for (let item of this.trainings)
                data["trainings"].push(item.toJSON());
        }
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingTypeResource {
        const json = this.toJSON();
        let result = new TrainingTypeResource();
        result.init(json);
        return result;
    }
}

export interface ITrainingTypeResource {
    id: number;
    description: string | undefined;
    contentUrl: string | undefined;
    summary: string | undefined;
    outline: string | undefined;
    name: string | undefined;
    maxCount: number;
    remainingCount: number;
    maxDays: number;
    remainingDays: number;
    isLocalTraining: boolean;
    tags: string | undefined;
    employeeId: number;
    trainingVendorId: number;
    trainingSpecializationId: number;
    trainingCategoryId: number;
    employee: Employee;
    trainingVendor: TrainingVendor;
    trainingSpecialization: TrainingSpecialization;
    trainingCategory: TrainingCategory;
    trainings: Training[] | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingTypeResourceListApiResult implements ITrainingTypeResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingTypeResource[] | undefined;
    totalCount!: number;

    constructor(data?: ITrainingTypeResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingTypeResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingTypeResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingTypeResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingTypeResourceListApiResult {
        const json = this.toJSON();
        let result = new TrainingTypeResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingTypeResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingTypeResource[] | undefined;
    totalCount: number;
}

export class TrainingTypeResourceApiResult implements ITrainingTypeResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingTypeResource;
    totalCount!: number;

    constructor(data?: ITrainingTypeResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? TrainingTypeResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingTypeResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingTypeResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingTypeResourceApiResult {
        const json = this.toJSON();
        let result = new TrainingTypeResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingTypeResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingTypeResource;
    totalCount: number;
}

export class ToggleTrainingType implements IToggleTrainingType {
    id!: number;
    status!: boolean;

    constructor(data?: IToggleTrainingType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ToggleTrainingType {
        data = typeof data === 'object' ? data : {};
        let result = new ToggleTrainingType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }

    clone(): ToggleTrainingType {
        const json = this.toJSON();
        let result = new ToggleTrainingType();
        result.init(json);
        return result;
    }
}

export interface IToggleTrainingType {
    id: number;
    status: boolean;
}

export class TrainingCategoryPayload implements ITrainingCategoryPayload {
    id!: number;
    name!: string;

    constructor(data?: ITrainingCategoryPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TrainingCategoryPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCategoryPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): TrainingCategoryPayload {
        const json = this.toJSON();
        let result = new TrainingCategoryPayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingCategoryPayload {
    id: number;
    name: string;
}

export class TrainingCategoryResource implements ITrainingCategoryResource {
    id!: number;
    name!: string | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingCategoryResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingCategoryResource {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCategoryResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingCategoryResource {
        const json = this.toJSON();
        let result = new TrainingCategoryResource();
        result.init(json);
        return result;
    }
}

export interface ITrainingCategoryResource {
    id: number;
    name: string | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingCategoryResourceListApiResult implements ITrainingCategoryResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingCategoryResource[] | undefined;
    totalCount!: number;

    constructor(data?: ITrainingCategoryResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingCategoryResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingCategoryResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCategoryResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingCategoryResourceListApiResult {
        const json = this.toJSON();
        let result = new TrainingCategoryResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingCategoryResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingCategoryResource[] | undefined;
    totalCount: number;
}

export class TrainingSpecializationPayload implements ITrainingSpecializationPayload {
    id!: number;
    name!: string;
    companyId!: number;
    subId!: number;

    constructor(data?: ITrainingSpecializationPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
        }
    }

    static fromJS(data: any): TrainingSpecializationPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecializationPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        return data; 
    }

    clone(): TrainingSpecializationPayload {
        const json = this.toJSON();
        let result = new TrainingSpecializationPayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecializationPayload {
    id: number;
    name: string;
    companyId: number;
    subId: number;
}

export class TrainingSpecializationDTO implements ITrainingSpecializationDTO {
    id!: number;
    name!: string | undefined;
    companyId!: number;
    subId!: number;
    is_Active!: boolean;
    is_Deleted!: boolean;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingSpecializationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.is_Active = _data["is_Active"];
            this.is_Deleted = _data["is_Deleted"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingSpecializationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecializationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["is_Active"] = this.is_Active;
        data["is_Deleted"] = this.is_Deleted;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingSpecializationDTO {
        const json = this.toJSON();
        let result = new TrainingSpecializationDTO();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecializationDTO {
    id: number;
    name: string | undefined;
    companyId: number;
    subId: number;
    is_Active: boolean;
    is_Deleted: boolean;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingSpecializationDTOListApiResult implements ITrainingSpecializationDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingSpecializationDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ITrainingSpecializationDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingSpecializationDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingSpecializationDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecializationDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingSpecializationDTOListApiResult {
        const json = this.toJSON();
        let result = new TrainingSpecializationDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecializationDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingSpecializationDTO[] | undefined;
    totalCount: number;
}

export class TrainingSpecializationDTOApiResult implements ITrainingSpecializationDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingSpecializationDTO;
    totalCount!: number;

    constructor(data?: ITrainingSpecializationDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? TrainingSpecializationDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingSpecializationDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecializationDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingSpecializationDTOApiResult {
        const json = this.toJSON();
        let result = new TrainingSpecializationDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecializationDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingSpecializationDTO;
    totalCount: number;
}

export class ManageTrainingDTO implements IManageTrainingDTO {
    id!: number;
    name!: string;
    description!: string;
    status!: boolean;
    startDate!: Date;
    endDate!: Date;
    trainingTypeId!: number;
    specializationId!: number;
    vendorId!: number;
    totalCost!: number | undefined;
    costPerEmployee!: number | undefined;
    selectedEmployees!: string | undefined;
    attachment!: string | undefined;

    constructor(data?: IManageTrainingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.trainingTypeId = _data["trainingTypeId"];
            this.specializationId = _data["specializationId"];
            this.vendorId = _data["vendorId"];
            this.totalCost = _data["totalCost"];
            this.costPerEmployee = _data["costPerEmployee"];
            this.selectedEmployees = _data["selectedEmployees"];
            this.attachment = _data["attachment"];
        }
    }

    static fromJS(data: any): ManageTrainingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageTrainingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["status"] = this.status;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["trainingTypeId"] = this.trainingTypeId;
        data["specializationId"] = this.specializationId;
        data["vendorId"] = this.vendorId;
        data["totalCost"] = this.totalCost;
        data["costPerEmployee"] = this.costPerEmployee;
        data["selectedEmployees"] = this.selectedEmployees;
        data["attachment"] = this.attachment;
        return data; 
    }

    clone(): ManageTrainingDTO {
        const json = this.toJSON();
        let result = new ManageTrainingDTO();
        result.init(json);
        return result;
    }
}

export interface IManageTrainingDTO {
    id: number;
    name: string;
    description: string;
    status: boolean;
    startDate: Date;
    endDate: Date;
    trainingTypeId: number;
    specializationId: number;
    vendorId: number;
    totalCost: number | undefined;
    costPerEmployee: number | undefined;
    selectedEmployees: string | undefined;
    attachment: string | undefined;
}

export class TrainingFilterDTO implements ITrainingFilterDTO {
    pageSize!: number;
    pageNumber!: number;
    trainingTypeId!: number;
    specializationId!: number;
    vendorId!: number;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    totalCost!: number;
    costPerEmployee!: number;

    constructor(data?: ITrainingFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
            this.trainingTypeId = _data["trainingTypeId"];
            this.specializationId = _data["specializationId"];
            this.vendorId = _data["vendorId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.totalCost = _data["totalCost"];
            this.costPerEmployee = _data["costPerEmployee"];
        }
    }

    static fromJS(data: any): TrainingFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        data["trainingTypeId"] = this.trainingTypeId;
        data["specializationId"] = this.specializationId;
        data["vendorId"] = this.vendorId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["totalCost"] = this.totalCost;
        data["costPerEmployee"] = this.costPerEmployee;
        return data; 
    }

    clone(): TrainingFilterDTO {
        const json = this.toJSON();
        let result = new TrainingFilterDTO();
        result.init(json);
        return result;
    }
}

export interface ITrainingFilterDTO {
    pageSize: number;
    pageNumber: number;
    trainingTypeId: number;
    specializationId: number;
    vendorId: number;
    startDate: Date | undefined;
    endDate: Date | undefined;
    totalCost: number;
    costPerEmployee: number;
}

export class TrainingDTO implements ITrainingDTO {
    id!: number;
    name!: string | undefined;
    companyId!: number;
    subId!: number;
    description!: string | undefined;
    log_status!: number;
    startDate!: Date;
    endDate!: Date;
    trainingTypeId!: number;
    specializationId!: number;
    vendorId!: number;
    specialization!: string | undefined;
    trainingType!: string | undefined;
    trainingVendor!: string | undefined;
    totalCost!: number | undefined;
    costPerEmployee!: number | undefined;
    date_Created!: Date;
    created_By!: string | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.description = _data["description"];
            this.log_status = _data["log_status"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.trainingTypeId = _data["trainingTypeId"];
            this.specializationId = _data["specializationId"];
            this.vendorId = _data["vendorId"];
            this.specialization = _data["specialization"];
            this.trainingType = _data["trainingType"];
            this.trainingVendor = _data["trainingVendor"];
            this.totalCost = _data["totalCost"];
            this.costPerEmployee = _data["costPerEmployee"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["description"] = this.description;
        data["log_status"] = this.log_status;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["trainingTypeId"] = this.trainingTypeId;
        data["specializationId"] = this.specializationId;
        data["vendorId"] = this.vendorId;
        data["specialization"] = this.specialization;
        data["trainingType"] = this.trainingType;
        data["trainingVendor"] = this.trainingVendor;
        data["totalCost"] = this.totalCost;
        data["costPerEmployee"] = this.costPerEmployee;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingDTO {
        const json = this.toJSON();
        let result = new TrainingDTO();
        result.init(json);
        return result;
    }
}

export interface ITrainingDTO {
    id: number;
    name: string | undefined;
    companyId: number;
    subId: number;
    description: string | undefined;
    log_status: number;
    startDate: Date;
    endDate: Date;
    trainingTypeId: number;
    specializationId: number;
    vendorId: number;
    specialization: string | undefined;
    trainingType: string | undefined;
    trainingVendor: string | undefined;
    totalCost: number | undefined;
    costPerEmployee: number | undefined;
    date_Created: Date;
    created_By: string | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingDTOListApiResult implements ITrainingDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ITrainingDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingDTOListApiResult {
        const json = this.toJSON();
        let result = new TrainingDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingDTO[] | undefined;
    totalCount: number;
}

export class TrainingDTOApiResult implements ITrainingDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingDTO;
    totalCount!: number;

    constructor(data?: ITrainingDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? TrainingDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingDTOApiResult {
        const json = this.toJSON();
        let result = new TrainingDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingDTO;
    totalCount: number;
}

export class TrainingCriteriaPayload implements ITrainingCriteriaPayload {
    id!: number;
    name!: string;
    gradeId!: number | undefined;
    locationId!: number | undefined;
    employmentCategoryId!: number;
    ministryId!: number | undefined;
    departmentId!: number | undefined;
    trainingTypeId!: number | undefined;
    min_Age!: number;
    min_LengthOfService!: number;
    employmentTypeId!: number | undefined;
    salaryScaleId!: number | undefined;
    positionId!: number | undefined;

    constructor(data?: ITrainingCriteriaPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.gradeId = _data["gradeId"];
            this.locationId = _data["locationId"];
            this.employmentCategoryId = _data["employmentCategoryId"];
            this.ministryId = _data["ministryId"];
            this.departmentId = _data["departmentId"];
            this.trainingTypeId = _data["trainingTypeId"];
            this.min_Age = _data["min_Age"];
            this.min_LengthOfService = _data["min_LengthOfService"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.positionId = _data["positionId"];
        }
    }

    static fromJS(data: any): TrainingCriteriaPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCriteriaPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["gradeId"] = this.gradeId;
        data["locationId"] = this.locationId;
        data["employmentCategoryId"] = this.employmentCategoryId;
        data["ministryId"] = this.ministryId;
        data["departmentId"] = this.departmentId;
        data["trainingTypeId"] = this.trainingTypeId;
        data["min_Age"] = this.min_Age;
        data["min_LengthOfService"] = this.min_LengthOfService;
        data["employmentTypeId"] = this.employmentTypeId;
        data["salaryScaleId"] = this.salaryScaleId;
        data["positionId"] = this.positionId;
        return data; 
    }

    clone(): TrainingCriteriaPayload {
        const json = this.toJSON();
        let result = new TrainingCriteriaPayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingCriteriaPayload {
    id: number;
    name: string;
    gradeId: number | undefined;
    locationId: number | undefined;
    employmentCategoryId: number;
    ministryId: number | undefined;
    departmentId: number | undefined;
    trainingTypeId: number | undefined;
    min_Age: number;
    min_LengthOfService: number;
    employmentTypeId: number | undefined;
    salaryScaleId: number | undefined;
    positionId: number | undefined;
}

export class Ministry implements IMinistry {
    name!: string | undefined;
    code!: string | undefined;
    address!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IMinistry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.address = _data["address"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Ministry {
        data = typeof data === 'object' ? data : {};
        let result = new Ministry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["address"] = this.address;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Ministry {
        const json = this.toJSON();
        let result = new Ministry();
        result.init(json);
        return result;
    }
}

export interface IMinistry {
    name: string | undefined;
    code: string | undefined;
    address: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class TrainingCriteriaResource implements ITrainingCriteriaResource {
    id!: number;
    name!: string | undefined;
    gradeId!: number | undefined;
    locationId!: number | undefined;
    employmentCategoryId!: number;
    ministryId!: number | undefined;
    departmentId!: number | undefined;
    min_Age!: number;
    min_LengthOfService!: number;
    employmentTypeId!: number | undefined;
    salaryScaleId!: number | undefined;
    positionId!: number | undefined;
    trainingTypeId!: number | undefined;
    trainingType!: TrainingType;
    salaryScale!: SalaryScale;
    grade!: Grade;
    department!: Department;
    location!: Location;
    ministry!: Ministry;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingCriteriaResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.gradeId = _data["gradeId"];
            this.locationId = _data["locationId"];
            this.employmentCategoryId = _data["employmentCategoryId"];
            this.ministryId = _data["ministryId"];
            this.departmentId = _data["departmentId"];
            this.min_Age = _data["min_Age"];
            this.min_LengthOfService = _data["min_LengthOfService"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.positionId = _data["positionId"];
            this.trainingTypeId = _data["trainingTypeId"];
            this.trainingType = _data["trainingType"] ? TrainingType.fromJS(_data["trainingType"]) : <any>undefined;
            this.salaryScale = _data["salaryScale"] ? SalaryScale.fromJS(_data["salaryScale"]) : <any>undefined;
            this.grade = _data["grade"] ? Grade.fromJS(_data["grade"]) : <any>undefined;
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            this.ministry = _data["ministry"] ? Ministry.fromJS(_data["ministry"]) : <any>undefined;
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingCriteriaResource {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCriteriaResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["gradeId"] = this.gradeId;
        data["locationId"] = this.locationId;
        data["employmentCategoryId"] = this.employmentCategoryId;
        data["ministryId"] = this.ministryId;
        data["departmentId"] = this.departmentId;
        data["min_Age"] = this.min_Age;
        data["min_LengthOfService"] = this.min_LengthOfService;
        data["employmentTypeId"] = this.employmentTypeId;
        data["salaryScaleId"] = this.salaryScaleId;
        data["positionId"] = this.positionId;
        data["trainingTypeId"] = this.trainingTypeId;
        data["trainingType"] = this.trainingType ? this.trainingType.toJSON() : <any>undefined;
        data["salaryScale"] = this.salaryScale ? this.salaryScale.toJSON() : <any>undefined;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["ministry"] = this.ministry ? this.ministry.toJSON() : <any>undefined;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingCriteriaResource {
        const json = this.toJSON();
        let result = new TrainingCriteriaResource();
        result.init(json);
        return result;
    }
}

export interface ITrainingCriteriaResource {
    id: number;
    name: string | undefined;
    gradeId: number | undefined;
    locationId: number | undefined;
    employmentCategoryId: number;
    ministryId: number | undefined;
    departmentId: number | undefined;
    min_Age: number;
    min_LengthOfService: number;
    employmentTypeId: number | undefined;
    salaryScaleId: number | undefined;
    positionId: number | undefined;
    trainingTypeId: number | undefined;
    trainingType: TrainingType;
    salaryScale: SalaryScale;
    grade: Grade;
    department: Department;
    location: Location;
    ministry: Ministry;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingCriteriaResourceListApiResult implements ITrainingCriteriaResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingCriteriaResource[] | undefined;
    totalCount!: number;

    constructor(data?: ITrainingCriteriaResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingCriteriaResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingCriteriaResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCriteriaResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingCriteriaResourceListApiResult {
        const json = this.toJSON();
        let result = new TrainingCriteriaResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingCriteriaResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingCriteriaResource[] | undefined;
    totalCount: number;
}

export class AssignTrainingToEmpPayload implements IAssignTrainingToEmpPayload {
    selectedEmpIds!: string;
    trainingId!: number;
    training!: string | undefined;
    file!: string | undefined;

    constructor(data?: IAssignTrainingToEmpPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.selectedEmpIds = _data["selectedEmpIds"];
            this.trainingId = _data["trainingId"];
            this.training = _data["training"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): AssignTrainingToEmpPayload {
        data = typeof data === 'object' ? data : {};
        let result = new AssignTrainingToEmpPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["selectedEmpIds"] = this.selectedEmpIds;
        data["trainingId"] = this.trainingId;
        data["training"] = this.training;
        data["file"] = this.file;
        return data; 
    }

    clone(): AssignTrainingToEmpPayload {
        const json = this.toJSON();
        let result = new AssignTrainingToEmpPayload();
        result.init(json);
        return result;
    }
}

export interface IAssignTrainingToEmpPayload {
    selectedEmpIds: string;
    trainingId: number;
    training: string | undefined;
    file: string | undefined;
}

export class Document implements IDocument {
    employee_Id!: number;
    employeeNo!: string | undefined;
    name!: string;
    docUrl!: string | undefined;
    directory!: string | undefined;
    docType!: string | undefined;
    lastModifiedDate!: Date;
    comment!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employee_Id = _data["employee_Id"];
            this.employeeNo = _data["employeeNo"];
            this.name = _data["name"];
            this.docUrl = _data["docUrl"];
            this.directory = _data["directory"];
            this.docType = _data["docType"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employee_Id"] = this.employee_Id;
        data["employeeNo"] = this.employeeNo;
        data["name"] = this.name;
        data["docUrl"] = this.docUrl;
        data["directory"] = this.directory;
        data["docType"] = this.docType;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Document {
        const json = this.toJSON();
        let result = new Document();
        result.init(json);
        return result;
    }
}

export interface IDocument {
    employee_Id: number;
    employeeNo: string | undefined;
    name: string;
    docUrl: string | undefined;
    directory: string | undefined;
    docType: string | undefined;
    lastModifiedDate: Date;
    comment: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmpTrainingResource implements IEmpTrainingResource {
    id!: number;
    contractId!: number;
    employeeName!: string | undefined;
    assignmentNo!: string | undefined;
    dateAssigned!: Date;
    trainingName!: string | undefined;
    trainingTypeName!: string | undefined;
    vendorName!: string | undefined;
    grade!: string | undefined;
    log_status!: number;
    trainingCategoryId!: number;
    vendorId!: number;
    trainindId!: number;
    workemail!: string | undefined;
    personalemail!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    feedback!: string | undefined;
    feedbackDate!: Date | undefined;
    trainingCategoryObj!: TrainingCategory;
    is_selected!: boolean;
    vendorObj!: TrainingVendor;
    documents!: Document[] | undefined;
    ministry!: string | undefined;
    department!: string | undefined;
    location!: string | undefined;
    jobRole!: string | undefined;
    position!: string | undefined;

    constructor(data?: IEmpTrainingResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contractId = _data["contractId"];
            this.employeeName = _data["employeeName"];
            this.assignmentNo = _data["assignmentNo"];
            this.dateAssigned = _data["dateAssigned"] ? new Date(_data["dateAssigned"].toString()) : <any>undefined;
            this.trainingName = _data["trainingName"];
            this.trainingTypeName = _data["trainingTypeName"];
            this.vendorName = _data["vendorName"];
            this.grade = _data["grade"];
            this.log_status = _data["log_status"];
            this.trainingCategoryId = _data["trainingCategoryId"];
            this.vendorId = _data["vendorId"];
            this.trainindId = _data["trainindId"];
            this.workemail = _data["workemail"];
            this.personalemail = _data["personalemail"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.feedback = _data["feedback"];
            this.feedbackDate = _data["feedbackDate"] ? new Date(_data["feedbackDate"].toString()) : <any>undefined;
            this.trainingCategoryObj = _data["trainingCategoryObj"] ? TrainingCategory.fromJS(_data["trainingCategoryObj"]) : <any>undefined;
            this.is_selected = _data["is_selected"];
            this.vendorObj = _data["vendorObj"] ? TrainingVendor.fromJS(_data["vendorObj"]) : <any>undefined;
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(Document.fromJS(item));
            }
            this.ministry = _data["ministry"];
            this.department = _data["department"];
            this.location = _data["location"];
            this.jobRole = _data["jobRole"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): EmpTrainingResource {
        data = typeof data === 'object' ? data : {};
        let result = new EmpTrainingResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contractId"] = this.contractId;
        data["employeeName"] = this.employeeName;
        data["assignmentNo"] = this.assignmentNo;
        data["dateAssigned"] = this.dateAssigned ? this.dateAssigned.toISOString() : <any>undefined;
        data["trainingName"] = this.trainingName;
        data["trainingTypeName"] = this.trainingTypeName;
        data["vendorName"] = this.vendorName;
        data["grade"] = this.grade;
        data["log_status"] = this.log_status;
        data["trainingCategoryId"] = this.trainingCategoryId;
        data["vendorId"] = this.vendorId;
        data["trainindId"] = this.trainindId;
        data["workemail"] = this.workemail;
        data["personalemail"] = this.personalemail;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["feedback"] = this.feedback;
        data["feedbackDate"] = this.feedbackDate ? this.feedbackDate.toISOString() : <any>undefined;
        data["trainingCategoryObj"] = this.trainingCategoryObj ? this.trainingCategoryObj.toJSON() : <any>undefined;
        data["is_selected"] = this.is_selected;
        data["vendorObj"] = this.vendorObj ? this.vendorObj.toJSON() : <any>undefined;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["ministry"] = this.ministry;
        data["department"] = this.department;
        data["location"] = this.location;
        data["jobRole"] = this.jobRole;
        data["position"] = this.position;
        return data; 
    }

    clone(): EmpTrainingResource {
        const json = this.toJSON();
        let result = new EmpTrainingResource();
        result.init(json);
        return result;
    }
}

export interface IEmpTrainingResource {
    id: number;
    contractId: number;
    employeeName: string | undefined;
    assignmentNo: string | undefined;
    dateAssigned: Date;
    trainingName: string | undefined;
    trainingTypeName: string | undefined;
    vendorName: string | undefined;
    grade: string | undefined;
    log_status: number;
    trainingCategoryId: number;
    vendorId: number;
    trainindId: number;
    workemail: string | undefined;
    personalemail: string | undefined;
    startDate: Date;
    endDate: Date;
    feedback: string | undefined;
    feedbackDate: Date | undefined;
    trainingCategoryObj: TrainingCategory;
    is_selected: boolean;
    vendorObj: TrainingVendor;
    documents: Document[] | undefined;
    ministry: string | undefined;
    department: string | undefined;
    location: string | undefined;
    jobRole: string | undefined;
    position: string | undefined;
}

export class EmpTrainingResourceListApiResult implements IEmpTrainingResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmpTrainingResource[] | undefined;
    totalCount!: number;

    constructor(data?: IEmpTrainingResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmpTrainingResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmpTrainingResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmpTrainingResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmpTrainingResourceListApiResult {
        const json = this.toJSON();
        let result = new EmpTrainingResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmpTrainingResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmpTrainingResource[] | undefined;
    totalCount: number;
}

export class AssignTrainingToOneEmpPayload implements IAssignTrainingToOneEmpPayload {
    emplogId!: number;
    trainingId!: number;

    constructor(data?: IAssignTrainingToOneEmpPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emplogId = _data["emplogId"];
            this.trainingId = _data["trainingId"];
        }
    }

    static fromJS(data: any): AssignTrainingToOneEmpPayload {
        data = typeof data === 'object' ? data : {};
        let result = new AssignTrainingToOneEmpPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emplogId"] = this.emplogId;
        data["trainingId"] = this.trainingId;
        return data; 
    }

    clone(): AssignTrainingToOneEmpPayload {
        const json = this.toJSON();
        let result = new AssignTrainingToOneEmpPayload();
        result.init(json);
        return result;
    }
}

export interface IAssignTrainingToOneEmpPayload {
    emplogId: number;
    trainingId: number;
}

export class EmpTrainingResourceApiResult implements IEmpTrainingResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmpTrainingResource;
    totalCount!: number;

    constructor(data?: IEmpTrainingResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmpTrainingResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmpTrainingResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmpTrainingResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmpTrainingResourceApiResult {
        const json = this.toJSON();
        let result = new EmpTrainingResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmpTrainingResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmpTrainingResource;
    totalCount: number;
}

export class EmpFeedBack implements IEmpFeedBack {
    emplogId!: number;
    feedBack!: string | undefined;

    constructor(data?: IEmpFeedBack) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emplogId = _data["emplogId"];
            this.feedBack = _data["feedBack"];
        }
    }

    static fromJS(data: any): EmpFeedBack {
        data = typeof data === 'object' ? data : {};
        let result = new EmpFeedBack();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emplogId"] = this.emplogId;
        data["feedBack"] = this.feedBack;
        return data; 
    }

    clone(): EmpFeedBack {
        const json = this.toJSON();
        let result = new EmpFeedBack();
        result.init(json);
        return result;
    }
}

export interface IEmpFeedBack {
    emplogId: number;
    feedBack: string | undefined;
}

export class EmployeeTrainingDTO implements IEmployeeTrainingDTO {
    employeeTrainingLogId!: number;
    contractId!: number | undefined;
    trainingTypeId!: number | undefined;
    trainingId!: number | undefined;
    gradeId!: number | undefined;
    log_status!: number;
    dateAssigned!: Date | undefined;
    dateReviewed!: Date | undefined;
    positionId!: number | undefined;
    dateofBirth!: Date | undefined;
    dateofAppointment!: Date | undefined;
    age!: number | undefined;
    yearsOfService!: number | undefined;
    hasAttended!: boolean | undefined;

    constructor(data?: IEmployeeTrainingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeTrainingLogId = _data["employeeTrainingLogId"];
            this.contractId = _data["contractId"];
            this.trainingTypeId = _data["trainingTypeId"];
            this.trainingId = _data["trainingId"];
            this.gradeId = _data["gradeId"];
            this.log_status = _data["log_status"];
            this.dateAssigned = _data["dateAssigned"] ? new Date(_data["dateAssigned"].toString()) : <any>undefined;
            this.dateReviewed = _data["dateReviewed"] ? new Date(_data["dateReviewed"].toString()) : <any>undefined;
            this.positionId = _data["positionId"];
            this.dateofBirth = _data["dateofBirth"] ? new Date(_data["dateofBirth"].toString()) : <any>undefined;
            this.dateofAppointment = _data["dateofAppointment"] ? new Date(_data["dateofAppointment"].toString()) : <any>undefined;
            this.age = _data["age"];
            this.yearsOfService = _data["yearsOfService"];
            this.hasAttended = _data["hasAttended"];
        }
    }

    static fromJS(data: any): EmployeeTrainingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTrainingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeTrainingLogId"] = this.employeeTrainingLogId;
        data["contractId"] = this.contractId;
        data["trainingTypeId"] = this.trainingTypeId;
        data["trainingId"] = this.trainingId;
        data["gradeId"] = this.gradeId;
        data["log_status"] = this.log_status;
        data["dateAssigned"] = this.dateAssigned ? this.dateAssigned.toISOString() : <any>undefined;
        data["dateReviewed"] = this.dateReviewed ? this.dateReviewed.toISOString() : <any>undefined;
        data["positionId"] = this.positionId;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["dateofAppointment"] = this.dateofAppointment ? this.dateofAppointment.toISOString() : <any>undefined;
        data["age"] = this.age;
        data["yearsOfService"] = this.yearsOfService;
        data["hasAttended"] = this.hasAttended;
        return data; 
    }

    clone(): EmployeeTrainingDTO {
        const json = this.toJSON();
        let result = new EmployeeTrainingDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeTrainingDTO {
    employeeTrainingLogId: number;
    contractId: number | undefined;
    trainingTypeId: number | undefined;
    trainingId: number | undefined;
    gradeId: number | undefined;
    log_status: number;
    dateAssigned: Date | undefined;
    dateReviewed: Date | undefined;
    positionId: number | undefined;
    dateofBirth: Date | undefined;
    dateofAppointment: Date | undefined;
    age: number | undefined;
    yearsOfService: number | undefined;
    hasAttended: boolean | undefined;
}

export class ApplicationPermission implements IApplicationPermission {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    moduleID!: number;
    applicationRolePermissions!: ApplicationRolePermission[] | undefined;

    constructor(data?: IApplicationPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.moduleID = _data["moduleID"];
            if (Array.isArray(_data["applicationRolePermissions"])) {
                this.applicationRolePermissions = [] as any;
                for (let item of _data["applicationRolePermissions"])
                    this.applicationRolePermissions!.push(ApplicationRolePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationPermission {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["moduleID"] = this.moduleID;
        if (Array.isArray(this.applicationRolePermissions)) {
            data["applicationRolePermissions"] = [];
            for (let item of this.applicationRolePermissions)
                data["applicationRolePermissions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ApplicationPermission {
        const json = this.toJSON();
        let result = new ApplicationPermission();
        result.init(json);
        return result;
    }
}

export interface IApplicationPermission {
    id: number;
    name: string | undefined;
    code: string | undefined;
    moduleID: number;
    applicationRolePermissions: ApplicationRolePermission[] | undefined;
}

export class ApplicationRolePermission implements IApplicationRolePermission {
    id!: number;
    dateCreated!: Date;
    applicationRoleId!: number;
    applicationPermissionId!: number;
    applicationRole!: ApplicationRole;
    applicationPermission!: ApplicationPermission;

    constructor(data?: IApplicationRolePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.applicationRoleId = _data["applicationRoleId"];
            this.applicationPermissionId = _data["applicationPermissionId"];
            this.applicationRole = _data["applicationRole"] ? ApplicationRole.fromJS(_data["applicationRole"]) : <any>undefined;
            this.applicationPermission = _data["applicationPermission"] ? ApplicationPermission.fromJS(_data["applicationPermission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationRolePermission {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRolePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["applicationRoleId"] = this.applicationRoleId;
        data["applicationPermissionId"] = this.applicationPermissionId;
        data["applicationRole"] = this.applicationRole ? this.applicationRole.toJSON() : <any>undefined;
        data["applicationPermission"] = this.applicationPermission ? this.applicationPermission.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ApplicationRolePermission {
        const json = this.toJSON();
        let result = new ApplicationRolePermission();
        result.init(json);
        return result;
    }
}

export interface IApplicationRolePermission {
    id: number;
    dateCreated: Date;
    applicationRoleId: number;
    applicationPermissionId: number;
    applicationRole: ApplicationRole;
    applicationPermission: ApplicationPermission;
}

export class ApplicationRole implements IApplicationRole {
    description!: string | undefined;
    isSystemRole!: boolean;
    applicationRolePermissions!: ApplicationRolePermission[] | undefined;
    id!: number;
    name!: string | undefined;
    normalizedName!: string | undefined;
    concurrencyStamp!: string | undefined;

    constructor(data?: IApplicationRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.isSystemRole = _data["isSystemRole"];
            if (Array.isArray(_data["applicationRolePermissions"])) {
                this.applicationRolePermissions = [] as any;
                for (let item of _data["applicationRolePermissions"])
                    this.applicationRolePermissions!.push(ApplicationRolePermission.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): ApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["isSystemRole"] = this.isSystemRole;
        if (Array.isArray(this.applicationRolePermissions)) {
            data["applicationRolePermissions"] = [];
            for (let item of this.applicationRolePermissions)
                data["applicationRolePermissions"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data; 
    }

    clone(): ApplicationRole {
        const json = this.toJSON();
        let result = new ApplicationRole();
        result.init(json);
        return result;
    }
}

export interface IApplicationRole {
    description: string | undefined;
    isSystemRole: boolean;
    applicationRolePermissions: ApplicationRolePermission[] | undefined;
    id: number;
    name: string | undefined;
    normalizedName: string | undefined;
    concurrencyStamp: string | undefined;
}

export class RegisterUserDTO implements IRegisterUserDTO {
    firstName!: string;
    lastName!: string;
    email!: string;
    password!: string | undefined;
    phoneNumber!: string | undefined;
    locationID!: number | undefined;
    lgaid!: number | undefined;
    approvalAmtLimit!: number;
    approvalAmtMTD!: number;
    locationCol!: SelectListItem[] | undefined;
    lgaCol!: SelectListItem[] | undefined;
    selectedRoles!: string[];
    applicationRoles!: ApplicationRole[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRegisterUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectedRoles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.locationID = _data["locationID"];
            this.lgaid = _data["lgaid"];
            this.approvalAmtLimit = _data["approvalAmtLimit"];
            this.approvalAmtMTD = _data["approvalAmtMTD"];
            if (Array.isArray(_data["locationCol"])) {
                this.locationCol = [] as any;
                for (let item of _data["locationCol"])
                    this.locationCol!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["lgaCol"])) {
                this.lgaCol = [] as any;
                for (let item of _data["lgaCol"])
                    this.lgaCol!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["selectedRoles"])) {
                this.selectedRoles = [] as any;
                for (let item of _data["selectedRoles"])
                    this.selectedRoles!.push(item);
            }
            if (Array.isArray(_data["applicationRoles"])) {
                this.applicationRoles = [] as any;
                for (let item of _data["applicationRoles"])
                    this.applicationRoles!.push(ApplicationRole.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RegisterUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["locationID"] = this.locationID;
        data["lgaid"] = this.lgaid;
        data["approvalAmtLimit"] = this.approvalAmtLimit;
        data["approvalAmtMTD"] = this.approvalAmtMTD;
        if (Array.isArray(this.locationCol)) {
            data["locationCol"] = [];
            for (let item of this.locationCol)
                data["locationCol"].push(item.toJSON());
        }
        if (Array.isArray(this.lgaCol)) {
            data["lgaCol"] = [];
            for (let item of this.lgaCol)
                data["lgaCol"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedRoles)) {
            data["selectedRoles"] = [];
            for (let item of this.selectedRoles)
                data["selectedRoles"].push(item);
        }
        if (Array.isArray(this.applicationRoles)) {
            data["applicationRoles"] = [];
            for (let item of this.applicationRoles)
                data["applicationRoles"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RegisterUserDTO {
        const json = this.toJSON();
        let result = new RegisterUserDTO();
        result.init(json);
        return result;
    }
}

export interface IRegisterUserDTO {
    firstName: string;
    lastName: string;
    email: string;
    password: string | undefined;
    phoneNumber: string | undefined;
    locationID: number | undefined;
    lgaid: number | undefined;
    approvalAmtLimit: number;
    approvalAmtMTD: number;
    locationCol: SelectListItem[] | undefined;
    lgaCol: SelectListItem[] | undefined;
    selectedRoles: string[];
    applicationRoles: ApplicationRole[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ApplicationUserDTO implements IApplicationUserDTO {
    id!: number;
    email!: string | undefined;
    username!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    isAdmin!: boolean;
    isTenantAdmin!: boolean;
    isEnabled!: boolean | undefined;
    lastLogin!: Date | undefined;
    companyId!: number;
    subsidiaryId!: number;
    token!: string | undefined;
    apiSessionId!: string | undefined;
    lastComputerName!: string | undefined;

    constructor(data?: IApplicationUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.isAdmin = _data["isAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.isEnabled = _data["isEnabled"];
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>undefined;
            this.companyId = _data["companyId"];
            this.subsidiaryId = _data["subsidiaryId"];
            this.token = _data["token"];
            this.apiSessionId = _data["apiSessionId"];
            this.lastComputerName = _data["lastComputerName"];
        }
    }

    static fromJS(data: any): ApplicationUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["username"] = this.username;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["isAdmin"] = this.isAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["isEnabled"] = this.isEnabled;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        data["companyId"] = this.companyId;
        data["subsidiaryId"] = this.subsidiaryId;
        data["token"] = this.token;
        data["apiSessionId"] = this.apiSessionId;
        data["lastComputerName"] = this.lastComputerName;
        return data; 
    }

    clone(): ApplicationUserDTO {
        const json = this.toJSON();
        let result = new ApplicationUserDTO();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserDTO {
    id: number;
    email: string | undefined;
    username: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    isAdmin: boolean;
    isTenantAdmin: boolean;
    isEnabled: boolean | undefined;
    lastLogin: Date | undefined;
    companyId: number;
    subsidiaryId: number;
    token: string | undefined;
    apiSessionId: string | undefined;
    lastComputerName: string | undefined;
}

export class ApplicationUserDTOIListApiResult implements IApplicationUserDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationUserDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IApplicationUserDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApplicationUserDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ApplicationUserDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApplicationUserDTOIListApiResult {
        const json = this.toJSON();
        let result = new ApplicationUserDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationUserDTO[] | undefined;
    totalCount: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}