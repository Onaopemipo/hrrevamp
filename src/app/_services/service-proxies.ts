/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.2.0 (NJsonSchema v10.3.4.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class GetTokenServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getToken(body: UserLoginDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/GetToken/GetToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ValidateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param key_token (optional) 
     * @return Success
     */
    validate(key_token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/Validate/Validate?";
        if (key_token !== undefined && key_token !== null)
            url_ += "key_token=" + encodeURIComponent("" + key_token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidate(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processValidate(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class ForgotPasswordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    forgotPassword(email: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ForgotPassword/ForgotPassword?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ResetPasswordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResestPasswordDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ConfirmEmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param userId (optional) 
     * @param token (optional) 
     * @return Success
     */
    confirmEmail(userId: string | null | undefined, token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/ConfirmEmail/ConfirmEmail?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmail(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmEmail(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class FetchActivityLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param id (optional) 
     * @param moduleName (optional) 
     * @param operationType (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getActivityLog(id: number | undefined, moduleName: string | null | undefined, operationType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ActivityLogIListApiResult> {
        let url_ = this.baseUrl + "/api/ActivityLog/FetchActivityLog/GetActivityLog?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (moduleName !== undefined && moduleName !== null)
            url_ += "ModuleName=" + encodeURIComponent("" + moduleName) + "&";
        if (operationType !== undefined && operationType !== null)
            url_ += "OperationType=" + encodeURIComponent("" + operationType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityLog(<any>response_);
                } catch (e) {
                    return <Observable<ActivityLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityLog(response: HttpResponseBase): Observable<ActivityLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class AssetManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetType(body: AssetTypeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addDeperciationProfile(body: AssetDeperciationProfileDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AddDeperciationProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDeperciationProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDeperciationProfile(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddDeperciationProfile(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetSubType(body: AssetSubTypeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetSubType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetSubType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetSubType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCatergory(body: AssetCategoryDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCatergory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCatergory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCatergory(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCatergory(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetStatus(body: AssetStatusDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetStatus(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetStatus(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetMake(body: AssetMakeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetMake";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetMake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetMake(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetMake(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetModel(body: AssetModelDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetModel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetModel(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetModel(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAsset(body: AssetDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AddAsset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAsset(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddAsset(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAssetRequest(body: AssetRequestDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AddAssetRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAssetRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAssetRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddAssetRequest(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assignment(body: AssignmentDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/Assignment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssignment(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCallback(body: AssetCallbackDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCallback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCallback(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCallback(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCheckIn(body: AssetcheckInFilter | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCheckIn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCheckIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCheckIn(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCheckIn(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCheckInComfirmation(body: AssetcheckInFilter | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCheckInComfirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCheckInComfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCheckInComfirmation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCheckInComfirmation(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAssetRequest(body: UpdateAssetRequest | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/UpdateAssetRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAssetRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAssetRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAssetRequest(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetType(body: AssetTypeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetSubType(body: AssetSubTypeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetSubType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetSubType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetSubType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetCategory(body: AssetCategoryDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetCategory(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetCategory(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetMake(body: AssetMakeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetMake";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetMake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetMake(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetMake(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetModel(body: AssetModelDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetModel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetModel(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetModel(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetStatus(body: AssetStatusDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetStatus(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetStatus(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getActivateAsset(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetActivateAsset?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivateAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivateAsset(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivateAsset(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getDeactivateAsset(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetDeactivateAsset?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeactivateAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeactivateAsset(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeactivateAsset(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetType(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetType?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetType(<any>response_);
                } catch (e) {
                    return <Observable<AssetTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetType(response: HttpResponseBase): Observable<AssetTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetTypeDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetSubType(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetSubTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetSubType?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetSubType(<any>response_);
                } catch (e) {
                    return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetSubType(response: HttpResponseBase): Observable<AssetSubTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetSubTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetSubTypeDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetCategory(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetCategoryDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetCategory?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetCategory(<any>response_);
                } catch (e) {
                    return <Observable<AssetCategoryDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetCategoryDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetCategory(response: HttpResponseBase): Observable<AssetCategoryDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetCategoryDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetCategoryDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetMake(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetMakeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetMake?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetMake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetMake(<any>response_);
                } catch (e) {
                    return <Observable<AssetMakeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetMakeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetMake(response: HttpResponseBase): Observable<AssetMakeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetMakeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetMakeDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetModel(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetModelDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetModel?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetModel(<any>response_);
                } catch (e) {
                    return <Observable<AssetModelDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetModelDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetModel(response: HttpResponseBase): Observable<AssetModelDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetModelDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetModelDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetStatus(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetStatusDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetStatus?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetStatus(<any>response_);
                } catch (e) {
                    return <Observable<AssetStatusDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetStatusDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetStatus(response: HttpResponseBase): Observable<AssetStatusDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetStatusDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetStatusDTOIListApiResult>(<any>null);
    }

    /**
     * @param assetTypeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetSubTypeByAssetTypeId(assetTypeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetSubTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetSubTypeByAssetTypeId?";
        if (assetTypeId === null)
            throw new Error("The parameter 'assetTypeId' cannot be null.");
        else if (assetTypeId !== undefined)
            url_ += "AssetTypeId=" + encodeURIComponent("" + assetTypeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetSubTypeByAssetTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetSubTypeByAssetTypeId(<any>response_);
                } catch (e) {
                    return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetSubTypeByAssetTypeId(response: HttpResponseBase): Observable<AssetSubTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetSubTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetSubTypeDTOIListApiResult>(<any>null);
    }

    /**
     * @param assetSubTypeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetbyAssetSubtypeId(assetSubTypeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetbyAssetSubtypeId?";
        if (assetSubTypeId === null)
            throw new Error("The parameter 'assetSubTypeId' cannot be null.");
        else if (assetSubTypeId !== undefined)
            url_ += "AssetSubTypeId=" + encodeURIComponent("" + assetSubTypeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetbyAssetSubtypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetbyAssetSubtypeId(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetbyAssetSubtypeId(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param assetmakeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetModelByAssetMakeId(assetmakeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetModelByAssetMakeId?";
        if (assetmakeId === null)
            throw new Error("The parameter 'assetmakeId' cannot be null.");
        else if (assetmakeId !== undefined)
            url_ += "AssetmakeId=" + encodeURIComponent("" + assetmakeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetModelByAssetMakeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetModelByAssetMakeId(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetModelByAssetMakeId(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getDepreciationProfile(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDeperciationProfileDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetDepreciationProfile?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepreciationProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepreciationProfile(<any>response_);
                } catch (e) {
                    return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepreciationProfile(response: HttpResponseBase): Observable<AssetDeperciationProfileDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDeperciationProfileDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDeperciationProfileDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getActiveassetlist(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDeperciationProfileDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetActiveassetlist?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveassetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveassetlist(<any>response_);
                } catch (e) {
                    return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveassetlist(response: HttpResponseBase): Observable<AssetDeperciationProfileDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDeperciationProfileDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDeperciationProfileDTOIListApiResult>(<any>null);
    }

    /**
     * @param employeeId (optional) 
     * @param assetId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetByAssigedEmployee(employeeId: number | undefined, assetId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetHistoryDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetByAssigedEmployee?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        if (assetId === null)
            throw new Error("The parameter 'assetId' cannot be null.");
        else if (assetId !== undefined)
            url_ += "AssetId=" + encodeURIComponent("" + assetId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetByAssigedEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetByAssigedEmployee(<any>response_);
                } catch (e) {
                    return <Observable<AssetHistoryDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetHistoryDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetByAssigedEmployee(response: HttpResponseBase): Observable<AssetHistoryDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetHistoryDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetHistoryDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class DataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for getting the list of different Generics/Common Dropdowns on the System by their Constant Name
    Some of the Constant names for the Dropdowns are;
    1: employment_status
    2: department
    3: bank
    4: marital_status
    8: religion
    10: title
    12: gender
     * @param dropDownName (optional) 
     * @return Success
     */
    getDropDownValues(dropDownName: string | null | undefined): Observable<DropdownValueIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetDropDownValues?";
        if (dropDownName !== undefined && dropDownName !== null)
            url_ += "dropDownName=" + encodeURIComponent("" + dropDownName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDropDownValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDropDownValues(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDropDownValues(response: HttpResponseBase): Observable<DropdownValueIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of different Generics/Common Dropdowns on the System by their Constant Value
    Some of the Constant names for the Dropdowns are;
    employment_status: 1
    department: 2
    bank: 3
    marital_status: 4
    religion: 8
    title: 10
    gender: 12
     * @param dropDownId (optional) 
     * @return Success
     */
    getDropDownValuesById(dropDownId: number | undefined): Observable<DropdownValueIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetDropDownValuesById?";
        if (dropDownId === null)
            throw new Error("The parameter 'dropDownId' cannot be null.");
        else if (dropDownId !== undefined)
            url_ += "dropDownId=" + encodeURIComponent("" + dropDownId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDropDownValuesById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDropDownValuesById(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDropDownValuesById(response: HttpResponseBase): Observable<DropdownValueIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of all Countries on the System
     * @return Success
     */
    getCountries(): Observable<CountryIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<CountryIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<CountryIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of an enumerable Employee Contract Status that can be use for dropdown values in filter
     * @return Success
     */
    getEmployeeContractStatus(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetEmployeeContractStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeContractStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeContractStatus(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeContractStatus(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmailLogsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for retrieving all Email Logs by email log filtering parameter
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param emailTo (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getEmailLogs(startDate: Date | null | undefined, endDate: Date | null | undefined, emailTo: string | null | undefined, pageSize: number | undefined): Observable<EmailLogDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/EmailLog/FetchEmailLogs/GetEmailLogs?";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (emailTo !== undefined && emailTo !== null)
            url_ += "EmailTo=" + encodeURIComponent("" + emailTo) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailLogs(<any>response_);
                } catch (e) {
                    return <Observable<EmailLogDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailLogDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailLogs(response: HttpResponseBase): Observable<EmailLogDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailLogDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailLogDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmailLogByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for getting Single EmailLog Details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getEmailLogById(id: number | undefined): Observable<EmailLogDTOApiResult> {
        let url_ = this.baseUrl + "/api/EmailLog/FetchEmailLogById/GetEmailLogById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailLogById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailLogById(<any>response_);
                } catch (e) {
                    return <Observable<EmailLogDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailLogDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailLogById(response: HttpResponseBase): Observable<EmailLogDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailLogDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailLogDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmailTemplateByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for getting Email Template by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getEmailTemplateById(id: number | undefined): Observable<EmailTemplateDTOApiResult> {
        let url_ = this.baseUrl + "/api/EmailTemplate/FetchEmailTemplateById/GetEmailTemplateById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailTemplateById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailTemplateById(<any>response_);
                } catch (e) {
                    return <Observable<EmailTemplateDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailTemplateDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailTemplateById(response: HttpResponseBase): Observable<EmailTemplateDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailTemplateDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailTemplateDTOApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateEmailTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for updating Email Template
     * @param body (optional) 
     * @return Success
     */
    updateEmailTemplate(body: EmailTemplateDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/EmailTemplate/UpdateEmailTemplate/UpdateEmailTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmailTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmailTemplate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEmailTemplate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CreateEmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for adding a single Employee profile
     * @param body (optional) 
     * @return Success
     */
    addEmployee(body: EmployeeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Employee/CreateEmployee/AddEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEmployee(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddEmployee(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeesDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for retrieving all Employees by Employee number (i.e. for specific Employee) or
    empty string (i.e. for all Employee
    with their few details for further CRUD operation
     * @param searchText (optional) 
     * @param contractStatus (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getEmployeesDetails(searchText: string | null | undefined, contractStatus: number | undefined, pageSize: number | undefined): Observable<DropdownValueDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeesDetails/GetEmployeesDetails?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (contractStatus === null)
            throw new Error("The parameter 'contractStatus' cannot be null.");
        else if (contractStatus !== undefined)
            url_ += "ContractStatus=" + encodeURIComponent("" + contractStatus) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesDetails(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeesDetails(response: HttpResponseBase): Observable<DropdownValueDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for retrieving single Employee's record
     * @param employeeId (optional) 
     * @return Success
     */
    getEmployeeById(employeeId: number | undefined): Observable<EmployeeDTOApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeeById/GetEmployeeById?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeById(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeById(response: HttpResponseBase): Observable<EmployeeDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllEmployeesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for retrieving All Tenant's registered Employees
     * @param searchText (optional) 
     * @param contractStatus (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllEmployees(searchText: string | null | undefined, contractStatus: number | undefined, pageSize: number | undefined): Observable<EmployeeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchAllEmployees/GetAllEmployees?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (contractStatus === null)
            throw new Error("The parameter 'contractStatus' cannot be null.");
        else if (contractStatus !== undefined)
            url_ += "ContractStatus=" + encodeURIComponent("" + contractStatus) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmployees(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEmployees(response: HttpResponseBase): Observable<EmployeeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeContractByEmployeeIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for retrieving Employee's Contract profile by Employee Id
     * @param employeeId (optional) 
     * @return Success
     */
    fetchEmployeeContractByEmployeeId(employeeId: number | undefined): Observable<EmployeeContractAssignmentDTOApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeeContractByEmployeeId/FetchEmployeeContractByEmployeeId?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEmployeeContractByEmployeeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEmployeeContractByEmployeeId(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeContractAssignmentDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeContractAssignmentDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEmployeeContractByEmployeeId(response: HttpResponseBase): Observable<EmployeeContractAssignmentDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeContractAssignmentDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeContractAssignmentDTOApiResult>(<any>null);
    }
}

@Injectable()
export class LeaveEntitlementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used to fetch all the leave entitlements. no param for now
     * @return Success
     */
    get(): Observable<LeaveEntitlementResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LeaveEntitlementResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveEntitlementResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LeaveEntitlementResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveEntitlementResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveEntitlementResourceListApiResult>(<any>null);
    }

    /**
     * this method is get leave entitlement by Id. Id is required
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<LeavePlanResourceApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(<any>response_);
                } catch (e) {
                    return <Observable<LeavePlanResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeavePlanResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<LeavePlanResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeavePlanResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeavePlanResourceApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createoredit(body: LeaveEntitlementPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/createoredit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateoredit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateoredit(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateoredit(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave entitlement
     * @return Success
     */
    delete(id: number): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to fetch all grades for a particular company. it uses authenticated user comapyid
     * @return Success
     */
    getgrades(): Observable<GradeListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/getgrades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetgrades(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetgrades(<any>response_);
                } catch (e) {
                    return <Observable<GradeListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetgrades(response: HttpResponseBase): Observable<GradeListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeListApiResult>(<any>null);
    }
}

@Injectable()
export class LeaveHolidayDateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used to fetch all or by Id. no param for now
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<HolidateDatesApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<HolidateDatesApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<HolidateDatesApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HolidateDatesApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HolidateDatesApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HolidateDatesApiResult>(<any>null);
    }

    /**
     * this method is get leave holidaydate by Id. Id is required
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<LeaveHolidayDateResourceApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(<any>response_);
                } catch (e) {
                    return <Observable<LeaveHolidayDateResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveHolidayDateResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<LeaveHolidayDateResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveHolidayDateResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveHolidayDateResourceApiResult>(<any>null);
    }

    /**
     * this method is used to used to create and edit leave holidaydate. Note all fields are requiered.
     * @param body (optional) 
     * @return Success
     */
    createoredit(body: LeaveHolidayDateServiceDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/createoredit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateoredit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateoredit(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateoredit(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave holidaydate
     * @return Success
     */
    delete(id: number): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class PostServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used to ceate  leave plan. Note all fields are requiered
     * @param body (optional) 
     * @return Success
     */
    createleaveplan(body: LeavePlanDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/Post/createleaveplan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateleaveplan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateleaveplan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateleaveplan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to ceate and edit leave type. Note all fields are requiered
     * @param body (optional) 
     * @return Success
     */
    createLeaveType(body: LeaveTypeCreatePayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/Post/createLeaveType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLeaveType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLeaveType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLeaveType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to ceate and edit leave year. Note: all fields are requiered
     * @param body (optional) 
     * @return Success
     */
    createnewsyear(body: LeaveYearCreatePayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/Post/createnewsyear";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatenewsyear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatenewsyear(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreatenewsyear(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchLeavePlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used fetch leave plans. all filter are optional
     * @param isApproved (optional) 
     * @param leaveYearId (optional) 
     * @param empno (optional) 
     * @param strStartDate (optional) 
     * @param strEndDate (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchleaveplans(isApproved: number | null | undefined, leaveYearId: number | null | undefined, empno: string | null | undefined, strStartDate: string | null | undefined, strEndDate: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<LeavePlanResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/FetchLeavePlan/fetchleaveplans?";
        if (isApproved !== undefined && isApproved !== null)
            url_ += "IsApproved=" + encodeURIComponent("" + isApproved) + "&";
        if (leaveYearId !== undefined && leaveYearId !== null)
            url_ += "LeaveYearId=" + encodeURIComponent("" + leaveYearId) + "&";
        if (empno !== undefined && empno !== null)
            url_ += "Empno=" + encodeURIComponent("" + empno) + "&";
        if (strStartDate !== undefined && strStartDate !== null)
            url_ += "StrStartDate=" + encodeURIComponent("" + strStartDate) + "&";
        if (strEndDate !== undefined && strEndDate !== null)
            url_ += "StrEndDate=" + encodeURIComponent("" + strEndDate) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchleaveplans(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchleaveplans(<any>response_);
                } catch (e) {
                    return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchleaveplans(response: HttpResponseBase): Observable<LeavePlanResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeavePlanResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeavePlanResourceListApiResult>(<any>null);
    }
}

@Injectable()
export class LeaveplaneEventServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used fetch events using calender type.calender type include: LeavePlan, ActiveLeaveRequests
     * @param calenderType (optional) 
     * @return Success
     */
    leaveplanevent(calenderType: string | null | undefined): Observable<LeavePlanResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/LeaveplaneEvent/leaveplanevent?";
        if (calenderType !== undefined && calenderType !== null)
            url_ += "calenderType=" + encodeURIComponent("" + calenderType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLeaveplanevent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLeaveplanevent(<any>response_);
                } catch (e) {
                    return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processLeaveplanevent(response: HttpResponseBase): Observable<LeavePlanResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeavePlanResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeavePlanResourceListApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used to delete leave plan
     * @return Success
     */
    leavePlanDelete(id: number): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/Delete/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processleavePlanDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processleavePlanDelete(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processleavePlanDelete(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete. leave request Id is required
     * @return Success
     */
    leaveRequestDelete(id: number): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/Delete/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processleaveRequestDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processleaveRequestDelete(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processleaveRequestDelete(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave type
     * @param idQuery (optional) 
     * @return Success
     */
    leaveTypeDelete(idQuery: number | undefined, idPath: string): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/Delete/delete/{id}?";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        if (idQuery === null)
            throw new Error("The parameter 'idQuery' cannot be null.");
        else if (idQuery !== undefined)
            url_ += "id=" + encodeURIComponent("" + idQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processleaveTypeDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processleaveTypeDelete(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processleaveTypeDelete(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave year
     * @param idQuery (optional) 
     * @return Success
     */
    leaveYearDelete(idQuery: number | undefined, idPath: string): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/Delete/delete/{id}?";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        if (idQuery === null)
            throw new Error("The parameter 'idQuery' cannot be null.");
        else if (idQuery !== undefined)
            url_ += "id=" + encodeURIComponent("" + idQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processleaveYearDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processleaveYearDelete(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processleaveYearDelete(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AproveorRejectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used to approve or reject leave plan. Note all fields are requiered except companyId
    it uses Enum Leaveplan status : Approved = 1, Reject = 2, Pending =3
     * @param body (optional) 
     * @return Success
     */
    approveorrejectleaveplan(body: ApproveOrRejectPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/AproveorReject/approveorrejectleaveplan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveorrejectleaveplan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveorrejectleaveplan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processApproveorrejectleaveplan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class PostReviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used to review leave plan. Note all fields are requiered except companyId
    it uses Enum Leaveplan status : Approved = 1, Reject = 2, Pending =3
     * @param body (optional) 
     * @return Success
     */
    postReview(body: ApproveOrRejectPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/PostReview/postReview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostReview(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostReview(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CreateLeaveByAdminServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used to ceate and edit leave by admin.
     * @param body (optional) 
     * @return Success
     */
    createleavebyadmin(body: LeaveRequestPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/CreateLeaveByAdmin/createleavebyadmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateleavebyadmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateleavebyadmin(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateleavebyadmin(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CreateLeaveByEmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used to ceate and edit leave by employee.
     * @param body (optional) 
     * @return Success
     */
    createleavebyemployee(body: LeaveRequestPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/CreateLeaveByEmployee/createleavebyemployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateleavebyemployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateleavebyemployee(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateleavebyemployee(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ModifyLeaveRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used to modify leave request.
    it has an enum which include  Recall = 1,Cancel = 2 for HRActionOptionsList
     * @param body (optional) 
     * @return Success
     */
    modifyleaverequestbyHr(body: EditLeaveRequestpayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/ModifyLeaveRequest/modifyleaverequestbyHr";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModifyleaverequestbyHr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModifyleaverequestbyHr(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processModifyleaverequestbyHr(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used to get leave report.
    all filter is optional
     * @param departmentId (optional) 
     * @param leaveYearId (optional) 
     * @param leaveTypeId (optional) 
     * @param locationId (optional) 
     * @return Success
     */
    getleavereport(departmentId: string | null | undefined, leaveYearId: string | null | undefined, leaveTypeId: string | null | undefined, locationId: string | null | undefined): Observable<LeaveReportListDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/GetLeaveRequest/getleavereport?";
        if (departmentId !== undefined && departmentId !== null)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (leaveYearId !== undefined && leaveYearId !== null)
            url_ += "LeaveYearId=" + encodeURIComponent("" + leaveYearId) + "&";
        if (leaveTypeId !== undefined && leaveTypeId !== null)
            url_ += "LeaveTypeId=" + encodeURIComponent("" + leaveTypeId) + "&";
        if (locationId !== undefined && locationId !== null)
            url_ += "LocationId=" + encodeURIComponent("" + locationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetleavereport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetleavereport(<any>response_);
                } catch (e) {
                    return <Observable<LeaveReportListDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveReportListDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetleavereport(response: HttpResponseBase): Observable<LeaveReportListDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveReportListDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveReportListDTOListApiResult>(<any>null);
    }

    /**
     * this method is used to get leave by Id.
    Id is required
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<LeaveRequestApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/GetLeaveRequest/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(<any>response_);
                } catch (e) {
                    return <Observable<LeaveRequestApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveRequestApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<LeaveRequestApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveRequestApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveRequestApiResult>(<any>null);
    }
}

@Injectable()
export class CancelLeaveRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used to cancel leave request by initiator. leave request Id is required
     * @return Success
     */
    cancel(id: number): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/CancelLeaveRequest/cancel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * fetch leavetypes.
    Note: all filter are opyional
     * @param isAnnualLeave (optional) 
     * @param maxDays (optional) 
     * @param isGradeDependent (optional) 
     * @param minDays (optional) 
     * @return Success
     */
    getleavetypes(isAnnualLeave: boolean | undefined, maxDays: number | null | undefined, isGradeDependent: boolean | undefined, minDays: number | null | undefined): Observable<LeaveTypeDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/GetLeaveTypes/getleavetypes?";
        if (isAnnualLeave === null)
            throw new Error("The parameter 'isAnnualLeave' cannot be null.");
        else if (isAnnualLeave !== undefined)
            url_ += "IsAnnualLeave=" + encodeURIComponent("" + isAnnualLeave) + "&";
        if (maxDays !== undefined && maxDays !== null)
            url_ += "MaxDays=" + encodeURIComponent("" + maxDays) + "&";
        if (isGradeDependent === null)
            throw new Error("The parameter 'isGradeDependent' cannot be null.");
        else if (isGradeDependent !== undefined)
            url_ += "IsGradeDependent=" + encodeURIComponent("" + isGradeDependent) + "&";
        if (minDays !== undefined && minDays !== null)
            url_ += "MinDays=" + encodeURIComponent("" + minDays) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetleavetypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetleavetypes(<any>response_);
                } catch (e) {
                    return <Observable<LeaveTypeDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveTypeDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetleavetypes(response: HttpResponseBase): Observable<LeaveTypeDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveTypeDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveTypeDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class DetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used to get leavetype by id leave type
     * @param idQuery (optional) 
     * @return Success
     */
    leavetypedetailGet(idQuery: number | undefined, idPath: string): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/Detail/detail/{id}?";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        if (idQuery === null)
            throw new Error("The parameter 'idQuery' cannot be null.");
        else if (idQuery !== undefined)
            url_ += "id=" + encodeURIComponent("" + idQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processleavetypeDetailGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processleavetypeDetailGet(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processleavetypeDetailGet(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave year
     * @param idQuery (optional) 
     * @return Success
     */
    detailGet(idQuery: number | undefined, idPath: string): Observable<LeaveYearDTOApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/Detail/detail/{id}?";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        if (idQuery === null)
            throw new Error("The parameter 'idQuery' cannot be null.");
        else if (idQuery !== undefined)
            url_ += "id=" + encodeURIComponent("" + idQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailGet(<any>response_);
                } catch (e) {
                    return <Observable<LeaveYearDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveYearDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDetailGet(response: HttpResponseBase): Observable<LeaveYearDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveYearDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveYearDTOApiResult>(<any>null);
    }
}

@Injectable()
export class LeaveWorkFlowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * this method is used to fetch all the leave workflow. no param for now
     * @return Success
     */
    get(): Observable<LeaveWorkFlowResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LeaveWorkFlowResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveWorkFlowResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LeaveWorkFlowResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveWorkFlowResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveWorkFlowResourceListApiResult>(<any>null);
    }

    /**
     * this method is get leave workflow by Id. Id is required
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<LeaveWorkFlowResourceApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(<any>response_);
                } catch (e) {
                    return <Observable<LeaveWorkFlowResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveWorkFlowResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<LeaveWorkFlowResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveWorkFlowResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveWorkFlowResourceApiResult>(<any>null);
    }

    /**
     * this method is used to used to create and edit leave workflow. Note all fields are requiered.
     * @param body (optional) 
     * @return Success
     */
    createoredit(body: LeaveworkFlowPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/createoredit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateoredit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateoredit(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateoredit(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave workflow
     * @return Success
     */
    delete(id: number): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveYearServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * Gets leave years
     * @param yearStartDate (optional) 
     * @param yearName (optional) 
     * @param yearEndDate (optional) 
     * @param companyID (optional) 
     * @return Success
     */
    getleaveyear(yearStartDate: Date | null | undefined, yearName: string | null | undefined, yearEndDate: Date | null | undefined, companyID: number | undefined): Observable<LeaveYearDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/GetLeaveYear/getleaveyear?";
        if (yearStartDate !== undefined && yearStartDate !== null)
            url_ += "YearStartDate=" + encodeURIComponent(yearStartDate ? "" + yearStartDate.toJSON() : "") + "&";
        if (yearName !== undefined && yearName !== null)
            url_ += "YearName=" + encodeURIComponent("" + yearName) + "&";
        if (yearEndDate !== undefined && yearEndDate !== null)
            url_ += "YearEndDate=" + encodeURIComponent(yearEndDate ? "" + yearEndDate.toJSON() : "") + "&";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetleaveyear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetleaveyear(<any>response_);
                } catch (e) {
                    return <Observable<LeaveYearDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveYearDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetleaveyear(response: HttpResponseBase): Observable<LeaveYearDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveYearDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveYearDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateLoanTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateLoanRequest(body: LoanRequestDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/AddUpdateLoanType/Add-Update-Loan-Request";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateLoanRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateLoanRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateLoanRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateLoanType(body: LoanTypeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/AddUpdateLoanType/Add-Update-LoanType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateLoanType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateLoanType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateLoanType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class PostFullRepaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postFullRepayment(body: PostLoanDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/PostFullRepayment/Post-Full-Repayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostFullRepayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostFullRepayment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostFullRepayment(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class SimulatePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param principal (optional) 
     * @param interestType (optional) 
     * @param tenor (optional) 
     * @param interestRate (optional) 
     * @param effectiveDate (optional) 
     * @return Success
     */
    simulatePayment(principal: number | undefined, interestType: number | undefined, tenor: number | undefined, interestRate: number | undefined, effectiveDate: string | null | undefined): Observable<LoanRepaymentLogIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/SimulatePayment/SimulatePayment?";
        if (principal === null)
            throw new Error("The parameter 'principal' cannot be null.");
        else if (principal !== undefined)
            url_ += "principal=" + encodeURIComponent("" + principal) + "&";
        if (interestType === null)
            throw new Error("The parameter 'interestType' cannot be null.");
        else if (interestType !== undefined)
            url_ += "interestType=" + encodeURIComponent("" + interestType) + "&";
        if (tenor === null)
            throw new Error("The parameter 'tenor' cannot be null.");
        else if (tenor !== undefined)
            url_ += "tenor=" + encodeURIComponent("" + tenor) + "&";
        if (interestRate === null)
            throw new Error("The parameter 'interestRate' cannot be null.");
        else if (interestRate !== undefined)
            url_ += "interestRate=" + encodeURIComponent("" + interestRate) + "&";
        if (effectiveDate !== undefined && effectiveDate !== null)
            url_ += "effectiveDate=" + encodeURIComponent("" + effectiveDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimulatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimulatePayment(<any>response_);
                } catch (e) {
                    return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSimulatePayment(response: HttpResponseBase): Observable<LoanRepaymentLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRepaymentLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRepaymentLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanRequestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param userid (optional) 
     * @param companyid (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchType (optional) 
     * @param page (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getLoanRequests(userid: number | undefined, companyid: number | undefined, startDate: Date | undefined, endDate: Date | undefined, searchType: number | undefined, page: number | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<LoanRequestDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/GetLoanRequests/GetLoanRequests?";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        if (companyid === null)
            throw new Error("The parameter 'companyid' cannot be null.");
        else if (companyid !== undefined)
            url_ += "companyid=" + encodeURIComponent("" + companyid) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanRequests(<any>response_);
                } catch (e) {
                    return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanRequests(response: HttpResponseBase): Observable<LoanRequestDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRequestDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRequestDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanSummaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param loanId (optional) 
     * @return Success
     */
    getLoanSummary(loanId: string | null | undefined): Observable<IdNameObjIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/GetLoanSummary/GetLoanSummary?";
        if (loanId !== undefined && loanId !== null)
            url_ += "LoanId=" + encodeURIComponent("" + loanId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanSummary(<any>response_);
                } catch (e) {
                    return <Observable<IdNameObjIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameObjIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanSummary(response: HttpResponseBase): Observable<IdNameObjIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdNameObjIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameObjIListApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateLoanRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLoanRequest(body: UpdateLoadRequestDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/UpdateLoanRequest/UpdateLoanRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLoanRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLoanRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLoanRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class LoadRepaymentScheduleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param loanId (optional) 
     * @param recompute (optional) 
     * @return Success
     */
    loadRepaymentSchedule(loanId: number | undefined, recompute: number | undefined): Observable<LoanRepaymentLogIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/LoadRepaymentSchedule/LoadRepaymentSchedule?";
        if (loanId === null)
            throw new Error("The parameter 'loanId' cannot be null.");
        else if (loanId !== undefined)
            url_ += "loanId=" + encodeURIComponent("" + loanId) + "&";
        if (recompute === null)
            throw new Error("The parameter 'recompute' cannot be null.");
        else if (recompute !== undefined)
            url_ += "recompute=" + encodeURIComponent("" + recompute) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadRepaymentSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadRepaymentSchedule(<any>response_);
                } catch (e) {
                    return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processLoadRepaymentSchedule(response: HttpResponseBase): Observable<LoanRepaymentLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRepaymentLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRepaymentLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchLoanRequestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param userid (optional) 
     * @param companyid (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchType (optional) 
     * @param page (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchLoanRequests(userid: number | undefined, companyid: number | undefined, startDate: Date | undefined, endDate: Date | undefined, searchType: number | undefined, page: number | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<LoanRequestDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/FetchLoanRequests/FetchLoanRequests?";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        if (companyid === null)
            throw new Error("The parameter 'companyid' cannot be null.");
        else if (companyid !== undefined)
            url_ += "companyid=" + encodeURIComponent("" + companyid) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchLoanRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchLoanRequests(<any>response_);
                } catch (e) {
                    return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchLoanRequests(response: HttpResponseBase): Observable<LoanRequestDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRequestDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRequestDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param companyId (optional) 
     * @param loanreqId (optional) 
     * @param userid (optional) 
     * @return Success
     */
    getLoanRequest(companyId: number | undefined, loanreqId: number | undefined, userid: number | undefined): Observable<LoanRequestApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/GetLoanRequest/GetLoanRequest?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (loanreqId === null)
            throw new Error("The parameter 'loanreqId' cannot be null.");
        else if (loanreqId !== undefined)
            url_ += "loanreqId=" + encodeURIComponent("" + loanreqId) + "&";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanRequest(<any>response_);
                } catch (e) {
                    return <Observable<LoanRequestApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRequestApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanRequest(response: HttpResponseBase): Observable<LoanRequestApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRequestApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRequestApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleLoanTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    toggleLoanType(body: LoadTypeById | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/ToggleLoanType/Toggle-Loan-Type";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleLoanType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleLoanType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleLoanType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanTypesByCriteriaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param iD (optional) 
     * @param code (optional) 
     * @param ledgerNo (optional) 
     * @param name (optional) 
     * @param minTenor (optional) 
     * @param maxTenor (optional) 
     * @param minAmount (optional) 
     * @param maxAmount (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getLoanTypesByCriteria(iD: number | undefined, code: string | null | undefined, ledgerNo: string | null | undefined, name: string | null | undefined, minTenor: number | undefined, maxTenor: number | undefined, minAmount: number | undefined, maxAmount: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<LoanTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/GetLoanTypesByCriteria/GetLoanTypesByCriteria?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (ledgerNo !== undefined && ledgerNo !== null)
            url_ += "LedgerNo=" + encodeURIComponent("" + ledgerNo) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (minTenor === null)
            throw new Error("The parameter 'minTenor' cannot be null.");
        else if (minTenor !== undefined)
            url_ += "MinTenor=" + encodeURIComponent("" + minTenor) + "&";
        if (maxTenor === null)
            throw new Error("The parameter 'maxTenor' cannot be null.");
        else if (maxTenor !== undefined)
            url_ += "MaxTenor=" + encodeURIComponent("" + maxTenor) + "&";
        if (minAmount === null)
            throw new Error("The parameter 'minAmount' cannot be null.");
        else if (minAmount !== undefined)
            url_ += "MinAmount=" + encodeURIComponent("" + minAmount) + "&";
        if (maxAmount === null)
            throw new Error("The parameter 'maxAmount' cannot be null.");
        else if (maxAmount !== undefined)
            url_ += "MaxAmount=" + encodeURIComponent("" + maxAmount) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanTypesByCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanTypesByCriteria(<any>response_);
                } catch (e) {
                    return <Observable<LoanTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanTypesByCriteria(response: HttpResponseBase): Observable<LoanTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchLoanTypeByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param iD (optional) 
     * @param companyID (optional) 
     * @return Success
     */
    fetchLoanTypeById(iD: number | undefined, companyID: number | undefined): Observable<LoanTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/FetchLoanTypeById/FetchLoanTypeById?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchLoanTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchLoanTypeById(<any>response_);
                } catch (e) {
                    return <Observable<LoanTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchLoanTypeById(response: HttpResponseBase): Observable<LoanTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for getting all Roles for creating/updating Admin User as a Tenant Admin
     * @return Success
     */
    getRoles(): Observable<ApplicationRoleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchRoles/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ApplicationRoleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllRolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for getting all Roles for CRUD operation as a Super Admin that possesses
    'Role Management' Privilege
     * @return Success
     */
    getAllRoles(): Observable<ApplicationRoleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchAllRoles/GetAllRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<ApplicationRoleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for getting single Role for CRUD operation as a Super Admin that possesses
    'Role Management' Privilege
     * @param id (optional) 
     * @return Success
     */
    getRole(id: number | undefined): Observable<ApplicationRoleDTOApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchRole/GetRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRole(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRole(response: HttpResponseBase): Observable<ApplicationRoleDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOApiResult>(<any>null);
    }
}

@Injectable()
export class CreateRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for Adding/Updating Roles as a Super Admin that possesses
    'Role Management' Privilege
     * @param body (optional) 
     * @return Success
     */
    createRole(body: ApplicationRoleDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Role/CreateRole/CreateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolePermissionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @return Success
     */
    getRolePermissions(): Observable<RolePermissionDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/FetchRolePermissions/GetRolePermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermissions(<any>response_);
                } catch (e) {
                    return <Observable<RolePermissionDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RolePermissionDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolePermissions(response: HttpResponseBase): Observable<RolePermissionDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermissionDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RolePermissionDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolePermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param roleId (optional) 
     * @return Success
     */
    getRolePermission(roleId: number | undefined): Observable<RolePermissionDTOApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/FetchRolePermission/GetRolePermission?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermission(<any>response_);
                } catch (e) {
                    return <Observable<RolePermissionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RolePermissionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolePermission(response: HttpResponseBase): Observable<RolePermissionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermissionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RolePermissionDTOApiResult>(<any>null);
    }
}

@Injectable()
export class RolePermissionMappingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolePermissionMapping(body: RolePermissionMappingDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/RolePermissionMapping/RolePermissionMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePermissionMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePermissionMapping(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRolePermissionMapping(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class SetUpsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addandUpdateLocation(body: VwLocation | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/AddandUpdateLocation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddandUpdateLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddandUpdateLocation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddandUpdateLocation(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdated(body: VwLocation | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/CreateOrUpdated";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdated(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdated(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteRecord(body: VwLocation | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/DeleteRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRecord(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRecord(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param stateid (optional) 
     * @param companyId (optional) 
     * @param locId (optional) 
     * @param subId (optional) 
     * @param id (optional) 
     * @param _SubsidiaryId (optional) 
     * @param eventID (optional) 
     * @return Success
     */
    fetchLocation(pageNumber: number | undefined, pageSize: number | undefined, stateid: number | undefined, companyId: number | undefined, locId: number | undefined, subId: number | undefined, id: number | undefined, _SubsidiaryId: number | undefined, eventID: number | undefined): Observable<VwLocationIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/FetchLocation?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (stateid === null)
            throw new Error("The parameter 'stateid' cannot be null.");
        else if (stateid !== undefined)
            url_ += "stateid=" + encodeURIComponent("" + stateid) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (locId === null)
            throw new Error("The parameter 'locId' cannot be null.");
        else if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (_SubsidiaryId === null)
            throw new Error("The parameter '_SubsidiaryId' cannot be null.");
        else if (_SubsidiaryId !== undefined)
            url_ += "_SubsidiaryId=" + encodeURIComponent("" + _SubsidiaryId) + "&";
        if (eventID === null)
            throw new Error("The parameter 'eventID' cannot be null.");
        else if (eventID !== undefined)
            url_ += "eventID=" + encodeURIComponent("" + eventID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchLocation(<any>response_);
                } catch (e) {
                    return <Observable<VwLocationIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwLocationIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchLocation(response: HttpResponseBase): Observable<VwLocationIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwLocationIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwLocationIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param stateid (optional) 
     * @param companyId (optional) 
     * @param locId (optional) 
     * @param subId (optional) 
     * @param id (optional) 
     * @param _SubsidiaryId (optional) 
     * @param eventID (optional) 
     * @return Success
     */
    fetchLocationS(pageNumber: number | undefined, pageSize: number | undefined, stateid: number | undefined, companyId: number | undefined, locId: number | undefined, subId: number | undefined, id: number | undefined, _SubsidiaryId: number | undefined, eventID: number | undefined): Observable<VwLocationIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/FetchLocationS?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (stateid === null)
            throw new Error("The parameter 'stateid' cannot be null.");
        else if (stateid !== undefined)
            url_ += "stateid=" + encodeURIComponent("" + stateid) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (locId === null)
            throw new Error("The parameter 'locId' cannot be null.");
        else if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (_SubsidiaryId === null)
            throw new Error("The parameter '_SubsidiaryId' cannot be null.");
        else if (_SubsidiaryId !== undefined)
            url_ += "_SubsidiaryId=" + encodeURIComponent("" + _SubsidiaryId) + "&";
        if (eventID === null)
            throw new Error("The parameter 'eventID' cannot be null.");
        else if (eventID !== undefined)
            url_ += "eventID=" + encodeURIComponent("" + eventID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchLocationS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchLocationS(<any>response_);
                } catch (e) {
                    return <Observable<VwLocationIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwLocationIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchLocationS(response: HttpResponseBase): Observable<VwLocationIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwLocationIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwLocationIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param stateid (optional) 
     * @param companyId (optional) 
     * @param locId (optional) 
     * @param subId (optional) 
     * @param id (optional) 
     * @param _SubsidiaryId (optional) 
     * @param eventID (optional) 
     * @return Success
     */
    getLocationByIds(pageNumber: number | undefined, pageSize: number | undefined, stateid: number | undefined, companyId: number | undefined, locId: number | undefined, subId: number | undefined, id: number | undefined, _SubsidiaryId: number | undefined, eventID: number | undefined): Observable<VwLocationIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/GetLocationByIds?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (stateid === null)
            throw new Error("The parameter 'stateid' cannot be null.");
        else if (stateid !== undefined)
            url_ += "stateid=" + encodeURIComponent("" + stateid) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (locId === null)
            throw new Error("The parameter 'locId' cannot be null.");
        else if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (_SubsidiaryId === null)
            throw new Error("The parameter '_SubsidiaryId' cannot be null.");
        else if (_SubsidiaryId !== undefined)
            url_ += "_SubsidiaryId=" + encodeURIComponent("" + _SubsidiaryId) + "&";
        if (eventID === null)
            throw new Error("The parameter 'eventID' cannot be null.");
        else if (eventID !== undefined)
            url_ += "eventID=" + encodeURIComponent("" + eventID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocationByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocationByIds(<any>response_);
                } catch (e) {
                    return <Observable<VwLocationIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwLocationIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocationByIds(response: HttpResponseBase): Observable<VwLocationIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwLocationIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwLocationIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param stateid (optional) 
     * @param companyId (optional) 
     * @param locId (optional) 
     * @param subId (optional) 
     * @param id (optional) 
     * @param _SubsidiaryId (optional) 
     * @param eventID (optional) 
     * @return Success
     */
    getLocationBYId(pageNumber: number | undefined, pageSize: number | undefined, stateid: number | undefined, companyId: number | undefined, locId: number | undefined, subId: number | undefined, id: number | undefined, _SubsidiaryId: number | undefined, eventID: number | undefined): Observable<LocationIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/GetLocationBYId?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (stateid === null)
            throw new Error("The parameter 'stateid' cannot be null.");
        else if (stateid !== undefined)
            url_ += "stateid=" + encodeURIComponent("" + stateid) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (locId === null)
            throw new Error("The parameter 'locId' cannot be null.");
        else if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (_SubsidiaryId === null)
            throw new Error("The parameter '_SubsidiaryId' cannot be null.");
        else if (_SubsidiaryId !== undefined)
            url_ += "_SubsidiaryId=" + encodeURIComponent("" + _SubsidiaryId) + "&";
        if (eventID === null)
            throw new Error("The parameter 'eventID' cannot be null.");
        else if (eventID !== undefined)
            url_ += "eventID=" + encodeURIComponent("" + eventID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocationBYId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocationBYId(<any>response_);
                } catch (e) {
                    return <Observable<LocationIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocationBYId(response: HttpResponseBase): Observable<LocationIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param stateid (optional) 
     * @param companyId (optional) 
     * @param locId (optional) 
     * @param subId (optional) 
     * @param id (optional) 
     * @param _SubsidiaryId (optional) 
     * @param eventID (optional) 
     * @return Success
     */
    getAllLocations(pageNumber: number | undefined, pageSize: number | undefined, stateid: number | undefined, companyId: number | undefined, locId: number | undefined, subId: number | undefined, id: number | undefined, _SubsidiaryId: number | undefined, eventID: number | undefined): Observable<LocationIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/GetAllLocations?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (stateid === null)
            throw new Error("The parameter 'stateid' cannot be null.");
        else if (stateid !== undefined)
            url_ += "stateid=" + encodeURIComponent("" + stateid) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (locId === null)
            throw new Error("The parameter 'locId' cannot be null.");
        else if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (_SubsidiaryId === null)
            throw new Error("The parameter '_SubsidiaryId' cannot be null.");
        else if (_SubsidiaryId !== undefined)
            url_ += "_SubsidiaryId=" + encodeURIComponent("" + _SubsidiaryId) + "&";
        if (eventID === null)
            throw new Error("The parameter 'eventID' cannot be null.");
        else if (eventID !== undefined)
            url_ += "eventID=" + encodeURIComponent("" + eventID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLocations(<any>response_);
                } catch (e) {
                    return <Observable<LocationIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLocations(response: HttpResponseBase): Observable<LocationIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addandUpdateDepartment(body: VwDepartment | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/AddandUpdateDepartment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddandUpdateDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddandUpdateDepartment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddandUpdateDepartment(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteRecordDepartment(body: Department | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/deleteRecordDepartment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRecordDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRecordDepartment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRecordDepartment(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param stateid (optional) 
     * @param companyId (optional) 
     * @param locId (optional) 
     * @param subId (optional) 
     * @param id (optional) 
     * @param _SubsidiaryId (optional) 
     * @param eventID (optional) 
     * @return Success
     */
    getDepartmentById(pageNumber: number | undefined, pageSize: number | undefined, stateid: number | undefined, companyId: number | undefined, locId: number | undefined, subId: number | undefined, id: number | undefined, _SubsidiaryId: number | undefined, eventID: number | undefined): Observable<DepartmentIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/GetDepartmentById?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (stateid === null)
            throw new Error("The parameter 'stateid' cannot be null.");
        else if (stateid !== undefined)
            url_ += "stateid=" + encodeURIComponent("" + stateid) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (locId === null)
            throw new Error("The parameter 'locId' cannot be null.");
        else if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (_SubsidiaryId === null)
            throw new Error("The parameter '_SubsidiaryId' cannot be null.");
        else if (_SubsidiaryId !== undefined)
            url_ += "_SubsidiaryId=" + encodeURIComponent("" + _SubsidiaryId) + "&";
        if (eventID === null)
            throw new Error("The parameter 'eventID' cannot be null.");
        else if (eventID !== undefined)
            url_ += "eventID=" + encodeURIComponent("" + eventID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentById(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartmentById(response: HttpResponseBase): Observable<DepartmentIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param stateid (optional) 
     * @param companyId (optional) 
     * @param locId (optional) 
     * @param subId (optional) 
     * @param id (optional) 
     * @param _SubsidiaryId (optional) 
     * @param eventID (optional) 
     * @return Success
     */
    getDepartment(pageNumber: number | undefined, pageSize: number | undefined, stateid: number | undefined, companyId: number | undefined, locId: number | undefined, subId: number | undefined, id: number | undefined, _SubsidiaryId: number | undefined, eventID: number | undefined): Observable<VwDepartmentIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/GetDepartment?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (stateid === null)
            throw new Error("The parameter 'stateid' cannot be null.");
        else if (stateid !== undefined)
            url_ += "stateid=" + encodeURIComponent("" + stateid) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (locId === null)
            throw new Error("The parameter 'locId' cannot be null.");
        else if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (_SubsidiaryId === null)
            throw new Error("The parameter '_SubsidiaryId' cannot be null.");
        else if (_SubsidiaryId !== undefined)
            url_ += "_SubsidiaryId=" + encodeURIComponent("" + _SubsidiaryId) + "&";
        if (eventID === null)
            throw new Error("The parameter 'eventID' cannot be null.");
        else if (eventID !== undefined)
            url_ += "eventID=" + encodeURIComponent("" + eventID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartment(<any>response_);
                } catch (e) {
                    return <Observable<VwDepartmentIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwDepartmentIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartment(response: HttpResponseBase): Observable<VwDepartmentIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwDepartmentIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwDepartmentIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param stateid (optional) 
     * @param companyId (optional) 
     * @param locId (optional) 
     * @param subId (optional) 
     * @param id (optional) 
     * @param _SubsidiaryId (optional) 
     * @param eventID (optional) 
     * @return Success
     */
    getAllDepartment(pageNumber: number | undefined, pageSize: number | undefined, stateid: number | undefined, companyId: number | undefined, locId: number | undefined, subId: number | undefined, id: number | undefined, _SubsidiaryId: number | undefined, eventID: number | undefined): Observable<DepartmentIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/GetAllDepartment?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (stateid === null)
            throw new Error("The parameter 'stateid' cannot be null.");
        else if (stateid !== undefined)
            url_ += "stateid=" + encodeURIComponent("" + stateid) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (locId === null)
            throw new Error("The parameter 'locId' cannot be null.");
        else if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (_SubsidiaryId === null)
            throw new Error("The parameter '_SubsidiaryId' cannot be null.");
        else if (_SubsidiaryId !== undefined)
            url_ += "_SubsidiaryId=" + encodeURIComponent("" + _SubsidiaryId) + "&";
        if (eventID === null)
            throw new Error("The parameter 'eventID' cannot be null.");
        else if (eventID !== undefined)
            url_ += "eventID=" + encodeURIComponent("" + eventID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDepartment(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDepartment(response: HttpResponseBase): Observable<DepartmentIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param stateid (optional) 
     * @param companyId (optional) 
     * @param locId (optional) 
     * @param subId (optional) 
     * @param id (optional) 
     * @param _SubsidiaryId (optional) 
     * @param eventID (optional) 
     * @return Success
     */
    fetchDepartment(pageNumber: number | undefined, pageSize: number | undefined, stateid: number | undefined, companyId: number | undefined, locId: number | undefined, subId: number | undefined, id: number | undefined, _SubsidiaryId: number | undefined, eventID: number | undefined): Observable<VwDepartmentIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/FetchDepartment?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (stateid === null)
            throw new Error("The parameter 'stateid' cannot be null.");
        else if (stateid !== undefined)
            url_ += "stateid=" + encodeURIComponent("" + stateid) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (locId === null)
            throw new Error("The parameter 'locId' cannot be null.");
        else if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (_SubsidiaryId === null)
            throw new Error("The parameter '_SubsidiaryId' cannot be null.");
        else if (_SubsidiaryId !== undefined)
            url_ += "_SubsidiaryId=" + encodeURIComponent("" + _SubsidiaryId) + "&";
        if (eventID === null)
            throw new Error("The parameter 'eventID' cannot be null.");
        else if (eventID !== undefined)
            url_ += "eventID=" + encodeURIComponent("" + eventID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchDepartment(<any>response_);
                } catch (e) {
                    return <Observable<VwDepartmentIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwDepartmentIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchDepartment(response: HttpResponseBase): Observable<VwDepartmentIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwDepartmentIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwDepartmentIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addandUpdateJobRoles(body: VwJobRole | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/AddandUpdateJobRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddandUpdateJobRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddandUpdateJobRoles(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddandUpdateJobRoles(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteRecordJobRole(body: JobRole | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/deleteRecordJobRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRecordJobRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRecordJobRole(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRecordJobRole(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param stateid (optional) 
     * @param companyId (optional) 
     * @param locId (optional) 
     * @param subId (optional) 
     * @param id (optional) 
     * @param _SubsidiaryId (optional) 
     * @param eventID (optional) 
     * @return Success
     */
    getJobRoleById(pageNumber: number | undefined, pageSize: number | undefined, stateid: number | undefined, companyId: number | undefined, locId: number | undefined, subId: number | undefined, id: number | undefined, _SubsidiaryId: number | undefined, eventID: number | undefined): Observable<JobRoleIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/GetJobRoleById?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (stateid === null)
            throw new Error("The parameter 'stateid' cannot be null.");
        else if (stateid !== undefined)
            url_ += "stateid=" + encodeURIComponent("" + stateid) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (locId === null)
            throw new Error("The parameter 'locId' cannot be null.");
        else if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (_SubsidiaryId === null)
            throw new Error("The parameter '_SubsidiaryId' cannot be null.");
        else if (_SubsidiaryId !== undefined)
            url_ += "_SubsidiaryId=" + encodeURIComponent("" + _SubsidiaryId) + "&";
        if (eventID === null)
            throw new Error("The parameter 'eventID' cannot be null.");
        else if (eventID !== undefined)
            url_ += "eventID=" + encodeURIComponent("" + eventID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobRoleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobRoleById(<any>response_);
                } catch (e) {
                    return <Observable<JobRoleIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobRoleIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobRoleById(response: HttpResponseBase): Observable<JobRoleIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobRoleIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobRoleIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param stateid (optional) 
     * @param companyId (optional) 
     * @param locId (optional) 
     * @param subId (optional) 
     * @param id (optional) 
     * @param _SubsidiaryId (optional) 
     * @param eventID (optional) 
     * @return Success
     */
    getAllJobRoles(pageNumber: number | undefined, pageSize: number | undefined, stateid: number | undefined, companyId: number | undefined, locId: number | undefined, subId: number | undefined, id: number | undefined, _SubsidiaryId: number | undefined, eventID: number | undefined): Observable<VwJobRoleIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/GetAllJobRoles?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (stateid === null)
            throw new Error("The parameter 'stateid' cannot be null.");
        else if (stateid !== undefined)
            url_ += "stateid=" + encodeURIComponent("" + stateid) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (locId === null)
            throw new Error("The parameter 'locId' cannot be null.");
        else if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (_SubsidiaryId === null)
            throw new Error("The parameter '_SubsidiaryId' cannot be null.");
        else if (_SubsidiaryId !== undefined)
            url_ += "_SubsidiaryId=" + encodeURIComponent("" + _SubsidiaryId) + "&";
        if (eventID === null)
            throw new Error("The parameter 'eventID' cannot be null.");
        else if (eventID !== undefined)
            url_ += "eventID=" + encodeURIComponent("" + eventID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllJobRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllJobRoles(<any>response_);
                } catch (e) {
                    return <Observable<VwJobRoleIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwJobRoleIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllJobRoles(response: HttpResponseBase): Observable<VwJobRoleIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwJobRoleIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwJobRoleIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param stateid (optional) 
     * @param companyId (optional) 
     * @param locId (optional) 
     * @param subId (optional) 
     * @param id (optional) 
     * @param _SubsidiaryId (optional) 
     * @param eventID (optional) 
     * @return Success
     */
    getJobRoles(pageNumber: number | undefined, pageSize: number | undefined, stateid: number | undefined, companyId: number | undefined, locId: number | undefined, subId: number | undefined, id: number | undefined, _SubsidiaryId: number | undefined, eventID: number | undefined): Observable<VwJobRoleIListApiResult> {
        let url_ = this.baseUrl + "/api/setUps/GetJobRoles?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (stateid === null)
            throw new Error("The parameter 'stateid' cannot be null.");
        else if (stateid !== undefined)
            url_ += "stateid=" + encodeURIComponent("" + stateid) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (locId === null)
            throw new Error("The parameter 'locId' cannot be null.");
        else if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (_SubsidiaryId === null)
            throw new Error("The parameter '_SubsidiaryId' cannot be null.");
        else if (_SubsidiaryId !== undefined)
            url_ += "_SubsidiaryId=" + encodeURIComponent("" + _SubsidiaryId) + "&";
        if (eventID === null)
            throw new Error("The parameter 'eventID' cannot be null.");
        else if (eventID !== undefined)
            url_ += "eventID=" + encodeURIComponent("" + eventID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobRoles(<any>response_);
                } catch (e) {
                    return <Observable<VwJobRoleIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwJobRoleIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobRoles(response: HttpResponseBase): Observable<VwJobRoleIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwJobRoleIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwJobRoleIListApiResult>(<any>null);
    }
}

@Injectable()
export class CreateSubscriptionPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSubscriptionPlan(body: SubscriptionPlan | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/CreateSubscriptionPlan/CreateSubscriptionPlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubscriptionPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubscriptionPlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubscriptionPlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchSubscriptionPlansServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @return Success
     */
    getSubscriptionPlans(): Observable<SubscriptionPlanIListApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/FetchSubscriptionPlans/GetSubscriptionPlans";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionPlans(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionPlans(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPlanIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPlanIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionPlans(response: HttpResponseBase): Observable<SubscriptionPlanIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPlanIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchSubscriptionPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param planId (optional) 
     * @return Success
     */
    getSubscriptionPlan(planId: number | undefined): Observable<SubscriptionPlanApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/FetchSubscriptionPlan/GetSubscriptionPlan?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionPlan(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPlanApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPlanApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionPlan(response: HttpResponseBase): Observable<SubscriptionPlanApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPlanApiResult>(<any>null);
    }
}

@Injectable()
export class FetchSubscriptionPlanModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param planId (optional) 
     * @return Success
     */
    getSubscriptionPlanModules(planId: number | undefined): Observable<SubscriptionPlanModuleIListApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/FetchSubscriptionPlanModules/GetSubscriptionPlanModules?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionPlanModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionPlanModules(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPlanModuleIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPlanModuleIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionPlanModules(response: HttpResponseBase): Observable<SubscriptionPlanModuleIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanModuleIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPlanModuleIListApiResult>(<any>null);
    }
}

@Injectable()
export class RegisterCompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerCompany(body: CompanyDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/RegisterCompany/RegisterCompany";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterCompany(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterCompany(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchTenantModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for retrieving Tenant's registered modules based on their subscription plan
     * @return Success
     */
    getTenantModules(): Observable<CompanyModuleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/FetchTenantModules/GetTenantModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantModules(<any>response_);
                } catch (e) {
                    return <Observable<CompanyModuleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyModuleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantModules(response: HttpResponseBase): Observable<CompanyModuleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyModuleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyModuleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateTenantModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for updating Tenant's Modules
     * @param payload (optional) 
     * @return Success
     */
    updateTenantModules(payload: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/UpdateTenantModules/UpdateTenantModules?";
        if (payload !== undefined && payload !== null)
            url_ += "payload=" + encodeURIComponent("" + payload) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantModules(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantModules(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddTenantModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * API for creating Tenant's Modules
     * @param payload (optional) 
     * @return Success
     */
    createTenantModules(payload: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/AddTenantModules/CreateTenantModules?";
        if (payload !== undefined && payload !== null)
            url_ += "payload=" + encodeURIComponent("" + payload) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenantModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenantModules(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenantModules(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RegisterUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerUser(body: RegisterUserDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/RegisterUser/RegisterUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body: RegisterUserDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/UpdateUser/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllUsersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/smartaceapi";
    }

    /**
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param email (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllUsers(firstName: string | null | undefined, lastName: string | null | undefined, email: string | null | undefined, pageSize: number | undefined): Observable<ApplicationUserDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/FetchAllUsers/GetAllUsers?";
        if (firstName !== undefined && firstName !== null)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName !== undefined && lastName !== null)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationUserDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationUserDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<ApplicationUserDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUserDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUserDTOIListApiResult>(<any>null);
    }
}

export class UserLoginDTO implements IUserLoginDTO {
    email!: string | undefined;
    password!: string | undefined;

    constructor(data?: IUserLoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UserLoginDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }

    clone(): UserLoginDTO {
        const json = this.toJSON();
        let result = new UserLoginDTO();
        result.init(json);
        return result;
    }
}

export interface IUserLoginDTO {
    email: string | undefined;
    password: string | undefined;
}

export class MessageOut implements IMessageOut {
    message!: string | undefined;
    isSuccessful!: boolean;
    retId!: number;
    redirectUrl!: string | undefined;
    errors!: string[] | undefined;

    constructor(data?: IMessageOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.isSuccessful = _data["isSuccessful"];
            this.retId = _data["retId"];
            this.redirectUrl = _data["redirectUrl"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MessageOut {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["isSuccessful"] = this.isSuccessful;
        data["retId"] = this.retId;
        data["redirectUrl"] = this.redirectUrl;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }

    clone(): MessageOut {
        const json = this.toJSON();
        let result = new MessageOut();
        result.init(json);
        return result;
    }
}

export interface IMessageOut {
    message: string | undefined;
    isSuccessful: boolean;
    retId: number;
    redirectUrl: string | undefined;
    errors: string[] | undefined;
}

export class MessageOutApiResult implements IMessageOutApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MessageOut;
    totalCount!: number;

    constructor(data?: IMessageOutApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? MessageOut.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MessageOutApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOutApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): MessageOutApiResult {
        const json = this.toJSON();
        let result = new MessageOutApiResult();
        result.init(json);
        return result;
    }
}

export interface IMessageOutApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MessageOut;
    totalCount: number;
}

export class VwUserObj implements IVwUserObj {
    user_id!: number;
    employee_id!: number;
    employee_contract_id!: number;
    serial_no!: string | undefined;
    first_name!: string | undefined;
    last_name!: string | undefined;
    readonly full_name!: string | undefined;
    other_name!: string | undefined;
    department!: string | undefined;
    department_id!: number;
    email!: string | undefined;
    session_token!: string | undefined;
    jwt_token!: string | undefined;
    user_token!: string | undefined;
    company_id!: number;
    licenseUsuage!: number;
    licenseCount!: number;
    company_name!: string | undefined;
    sub_id!: number;
    isAdmin!: boolean;
    isSuperAdmin!: boolean;
    isTenantAdmin!: boolean;
    isActiveBySysOrAdmin!: boolean;
    lstPermissions!: string[] | undefined;
    message!: string | undefined;
    isSuccessful!: boolean;
    retId!: number;
    redirectUrl!: string | undefined;
    errors!: string[] | undefined;

    constructor(data?: IVwUserObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user_id = _data["user_id"];
            this.employee_id = _data["employee_id"];
            this.employee_contract_id = _data["employee_contract_id"];
            this.serial_no = _data["serial_no"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            (<any>this).full_name = _data["full_name"];
            this.other_name = _data["other_name"];
            this.department = _data["department"];
            this.department_id = _data["department_id"];
            this.email = _data["email"];
            this.session_token = _data["session_token"];
            this.jwt_token = _data["jwt_token"];
            this.user_token = _data["user_token"];
            this.company_id = _data["company_id"];
            this.licenseUsuage = _data["licenseUsuage"];
            this.licenseCount = _data["licenseCount"];
            this.company_name = _data["company_name"];
            this.sub_id = _data["sub_id"];
            this.isAdmin = _data["isAdmin"];
            this.isSuperAdmin = _data["isSuperAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.isActiveBySysOrAdmin = _data["isActiveBySysOrAdmin"];
            if (Array.isArray(_data["lstPermissions"])) {
                this.lstPermissions = [] as any;
                for (let item of _data["lstPermissions"])
                    this.lstPermissions!.push(item);
            }
            this.message = _data["message"];
            this.isSuccessful = _data["isSuccessful"];
            this.retId = _data["retId"];
            this.redirectUrl = _data["redirectUrl"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): VwUserObj {
        data = typeof data === 'object' ? data : {};
        let result = new VwUserObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_id"] = this.user_id;
        data["employee_id"] = this.employee_id;
        data["employee_contract_id"] = this.employee_contract_id;
        data["serial_no"] = this.serial_no;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["full_name"] = this.full_name;
        data["other_name"] = this.other_name;
        data["department"] = this.department;
        data["department_id"] = this.department_id;
        data["email"] = this.email;
        data["session_token"] = this.session_token;
        data["jwt_token"] = this.jwt_token;
        data["user_token"] = this.user_token;
        data["company_id"] = this.company_id;
        data["licenseUsuage"] = this.licenseUsuage;
        data["licenseCount"] = this.licenseCount;
        data["company_name"] = this.company_name;
        data["sub_id"] = this.sub_id;
        data["isAdmin"] = this.isAdmin;
        data["isSuperAdmin"] = this.isSuperAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["isActiveBySysOrAdmin"] = this.isActiveBySysOrAdmin;
        if (Array.isArray(this.lstPermissions)) {
            data["lstPermissions"] = [];
            for (let item of this.lstPermissions)
                data["lstPermissions"].push(item);
        }
        data["message"] = this.message;
        data["isSuccessful"] = this.isSuccessful;
        data["retId"] = this.retId;
        data["redirectUrl"] = this.redirectUrl;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }

    clone(): VwUserObj {
        const json = this.toJSON();
        let result = new VwUserObj();
        result.init(json);
        return result;
    }
}

export interface IVwUserObj {
    user_id: number;
    employee_id: number;
    employee_contract_id: number;
    serial_no: string | undefined;
    first_name: string | undefined;
    last_name: string | undefined;
    full_name: string | undefined;
    other_name: string | undefined;
    department: string | undefined;
    department_id: number;
    email: string | undefined;
    session_token: string | undefined;
    jwt_token: string | undefined;
    user_token: string | undefined;
    company_id: number;
    licenseUsuage: number;
    licenseCount: number;
    company_name: string | undefined;
    sub_id: number;
    isAdmin: boolean;
    isSuperAdmin: boolean;
    isTenantAdmin: boolean;
    isActiveBySysOrAdmin: boolean;
    lstPermissions: string[] | undefined;
    message: string | undefined;
    isSuccessful: boolean;
    retId: number;
    redirectUrl: string | undefined;
    errors: string[] | undefined;
}

export class VwUserObjApiResult implements IVwUserObjApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwUserObj;
    totalCount!: number;

    constructor(data?: IVwUserObjApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? VwUserObj.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VwUserObjApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwUserObjApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VwUserObjApiResult {
        const json = this.toJSON();
        let result = new VwUserObjApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwUserObjApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwUserObj;
    totalCount: number;
}

export class ResestPasswordDTO implements IResestPasswordDTO {
    token!: string | undefined;
    email!: string;
    password!: string;
    confirmPassword!: string | undefined;

    constructor(data?: IResestPasswordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResestPasswordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResestPasswordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }

    clone(): ResestPasswordDTO {
        const json = this.toJSON();
        let result = new ResestPasswordDTO();
        result.init(json);
        return result;
    }
}

export interface IResestPasswordDTO {
    token: string | undefined;
    email: string;
    password: string;
    confirmPassword: string | undefined;
}

export class ActivityLog implements IActivityLog {
    userId!: number | undefined;
    moduleName!: string | undefined;
    moduleAction!: string | undefined;
    description!: string | undefined;
    record!: string | undefined;
    ipAdress!: string | undefined;
    operationType!: string | undefined;
    employeeId!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IActivityLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.moduleName = _data["moduleName"];
            this.moduleAction = _data["moduleAction"];
            this.description = _data["description"];
            this.record = _data["record"];
            this.ipAdress = _data["ipAdress"];
            this.operationType = _data["operationType"];
            this.employeeId = _data["employeeId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ActivityLog {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["moduleName"] = this.moduleName;
        data["moduleAction"] = this.moduleAction;
        data["description"] = this.description;
        data["record"] = this.record;
        data["ipAdress"] = this.ipAdress;
        data["operationType"] = this.operationType;
        data["employeeId"] = this.employeeId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ActivityLog {
        const json = this.toJSON();
        let result = new ActivityLog();
        result.init(json);
        return result;
    }
}

export interface IActivityLog {
    userId: number | undefined;
    moduleName: string | undefined;
    moduleAction: string | undefined;
    description: string | undefined;
    record: string | undefined;
    ipAdress: string | undefined;
    operationType: string | undefined;
    employeeId: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ActivityLogIListApiResult implements IActivityLogIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ActivityLog[] | undefined;
    totalCount!: number;

    constructor(data?: IActivityLogIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ActivityLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ActivityLogIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLogIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ActivityLogIListApiResult {
        const json = this.toJSON();
        let result = new ActivityLogIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IActivityLogIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ActivityLog[] | undefined;
    totalCount: number;
}

export class AssetTypeDTO implements IAssetTypeDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetTypeDTO {
        const json = this.toJSON();
        let result = new AssetTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetTypeDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class MessageOutIListApiResult implements IMessageOutIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MessageOut[] | undefined;
    totalCount!: number;

    constructor(data?: IMessageOutIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MessageOut.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MessageOutIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOutIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): MessageOutIListApiResult {
        const json = this.toJSON();
        let result = new MessageOutIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IMessageOutIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MessageOut[] | undefined;
    totalCount: number;
}

export class AssetDeperciationProfileDTO implements IAssetDeperciationProfileDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    code!: number;
    deperciationDate!: Date | undefined;
    purchaseYear!: number | undefined;
    depriciationType!: string | undefined;
    peroidicity!: Date | undefined;
    deperciationPercentage!: number | undefined;

    constructor(data?: IAssetDeperciationProfileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
            this.deperciationDate = _data["deperciationDate"] ? new Date(_data["deperciationDate"].toString()) : <any>undefined;
            this.purchaseYear = _data["purchaseYear"];
            this.depriciationType = _data["depriciationType"];
            this.peroidicity = _data["peroidicity"] ? new Date(_data["peroidicity"].toString()) : <any>undefined;
            this.deperciationPercentage = _data["deperciationPercentage"];
        }
    }

    static fromJS(data: any): AssetDeperciationProfileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDeperciationProfileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        data["deperciationDate"] = this.deperciationDate ? this.deperciationDate.toISOString() : <any>undefined;
        data["purchaseYear"] = this.purchaseYear;
        data["depriciationType"] = this.depriciationType;
        data["peroidicity"] = this.peroidicity ? this.peroidicity.toISOString() : <any>undefined;
        data["deperciationPercentage"] = this.deperciationPercentage;
        return data; 
    }

    clone(): AssetDeperciationProfileDTO {
        const json = this.toJSON();
        let result = new AssetDeperciationProfileDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetDeperciationProfileDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    code: number;
    deperciationDate: Date | undefined;
    purchaseYear: number | undefined;
    depriciationType: string | undefined;
    peroidicity: Date | undefined;
    deperciationPercentage: number | undefined;
}

export class AssetSubTypeDTO implements IAssetSubTypeDTO {
    id!: number;
    assetTypeId!: number;
    assetid!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    code!: number;

    constructor(data?: IAssetSubTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetTypeId = _data["assetTypeId"];
            this.assetid = _data["assetid"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): AssetSubTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetSubTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetTypeId"] = this.assetTypeId;
        data["assetid"] = this.assetid;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        return data; 
    }

    clone(): AssetSubTypeDTO {
        const json = this.toJSON();
        let result = new AssetSubTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetSubTypeDTO {
    id: number;
    assetTypeId: number;
    assetid: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    code: number;
}

export class AssetCategoryDTO implements IAssetCategoryDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetCategoryDTO {
        const json = this.toJSON();
        let result = new AssetCategoryDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetCategoryDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetStatusDTO implements IAssetStatusDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    assetid!: number;
    statusName!: string | undefined;
    subID!: number;
    description!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetStatusDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.assetid = _data["assetid"];
            this.statusName = _data["statusName"];
            this.subID = _data["subID"];
            this.description = _data["description"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetStatusDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetStatusDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["assetid"] = this.assetid;
        data["statusName"] = this.statusName;
        data["subID"] = this.subID;
        data["description"] = this.description;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetStatusDTO {
        const json = this.toJSON();
        let result = new AssetStatusDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetStatusDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    assetid: number;
    statusName: string | undefined;
    subID: number;
    description: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetMakeDTO implements IAssetMakeDTO {
    id!: number;
    companyID!: number;
    brandModel!: string | undefined;
    makeName!: string | undefined;
    assetid!: number;
    depreciation!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetMakeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.brandModel = _data["brandModel"];
            this.makeName = _data["makeName"];
            this.assetid = _data["assetid"];
            this.depreciation = _data["depreciation"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetMakeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetMakeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["brandModel"] = this.brandModel;
        data["makeName"] = this.makeName;
        data["assetid"] = this.assetid;
        data["depreciation"] = this.depreciation;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetMakeDTO {
        const json = this.toJSON();
        let result = new AssetMakeDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetMakeDTO {
    id: number;
    companyID: number;
    brandModel: string | undefined;
    makeName: string | undefined;
    assetid: number;
    depreciation: string | undefined;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetModelDTO implements IAssetModelDTO {
    id!: number;
    assetMakeId!: number | undefined;
    companyID!: number;
    description!: string | undefined;
    modelname!: string | undefined;
    assetid!: number;
    name!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetModelDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetMakeId = _data["assetMakeId"];
            this.companyID = _data["companyID"];
            this.description = _data["description"];
            this.modelname = _data["modelname"];
            this.assetid = _data["assetid"];
            this.name = _data["name"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetModelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetModelDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetMakeId"] = this.assetMakeId;
        data["companyID"] = this.companyID;
        data["description"] = this.description;
        data["modelname"] = this.modelname;
        data["assetid"] = this.assetid;
        data["name"] = this.name;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetModelDTO {
        const json = this.toJSON();
        let result = new AssetModelDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetModelDTO {
    id: number;
    assetMakeId: number | undefined;
    companyID: number;
    description: string | undefined;
    modelname: string | undefined;
    assetid: number;
    name: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetDTO implements IAssetDTO {
    referenceNumber!: string | undefined;
    employeeFullName!: string | undefined;
    modelName!: string | undefined;
    depreciationName!: string | undefined;
    assetTypeName!: string | undefined;
    assetSubTypeName!: string | undefined;
    statusName!: string | undefined;
    locationName!: string | undefined;
    makeName!: string | undefined;
    assetid!: number;
    assignedEmployeeid!: number;
    name!: string | undefined;
    assetNumber!: string | undefined;
    serialNumber!: string | undefined;
    custodianDepartmentId!: number;
    custodianId!: number;
    assetStatusId!: number;
    assetCategoryId!: number;
    assetSubTypeId!: number;
    deperciationMethod!: number;
    depreciationFrequency!: number;
    createdBy!: string | undefined;
    assetTypeId!: number;
    assetModelId!: number;
    assetModelName!: string | undefined;
    assetDepreciationProfileId!: number;
    assetMakeId!: number;
    assetMakeName!: string | undefined;
    locationId!: number;
    manufactureDate!: Date | undefined;
    purchaseDate!: Date | undefined;
    purchaseAmount!: number;
    description!: string | undefined;
    barCode!: string | undefined;
    qrCode!: string | undefined;
    depreciationDate!: Date | undefined;
    lostAsset!: boolean | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date | undefined;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.referenceNumber = _data["referenceNumber"];
            this.employeeFullName = _data["employeeFullName"];
            this.modelName = _data["modelName"];
            this.depreciationName = _data["depreciationName"];
            this.assetTypeName = _data["assetTypeName"];
            this.assetSubTypeName = _data["assetSubTypeName"];
            this.statusName = _data["statusName"];
            this.locationName = _data["locationName"];
            this.makeName = _data["makeName"];
            this.assetid = _data["assetid"];
            this.assignedEmployeeid = _data["assignedEmployeeid"];
            this.name = _data["name"];
            this.assetNumber = _data["assetNumber"];
            this.serialNumber = _data["serialNumber"];
            this.custodianDepartmentId = _data["custodianDepartmentId"];
            this.custodianId = _data["custodianId"];
            this.assetStatusId = _data["assetStatusId"];
            this.assetCategoryId = _data["assetCategoryId"];
            this.assetSubTypeId = _data["assetSubTypeId"];
            this.deperciationMethod = _data["deperciationMethod"];
            this.depreciationFrequency = _data["depreciationFrequency"];
            this.createdBy = _data["createdBy"];
            this.assetTypeId = _data["assetTypeId"];
            this.assetModelId = _data["assetModelId"];
            this.assetModelName = _data["assetModelName"];
            this.assetDepreciationProfileId = _data["assetDepreciationProfileId"];
            this.assetMakeId = _data["assetMakeId"];
            this.assetMakeName = _data["assetMakeName"];
            this.locationId = _data["locationId"];
            this.manufactureDate = _data["manufactureDate"] ? new Date(_data["manufactureDate"].toString()) : <any>undefined;
            this.purchaseDate = _data["purchaseDate"] ? new Date(_data["purchaseDate"].toString()) : <any>undefined;
            this.purchaseAmount = _data["purchaseAmount"];
            this.description = _data["description"];
            this.barCode = _data["barCode"];
            this.qrCode = _data["qrCode"];
            this.depreciationDate = _data["depreciationDate"] ? new Date(_data["depreciationDate"].toString()) : <any>undefined;
            this.lostAsset = _data["lostAsset"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceNumber"] = this.referenceNumber;
        data["employeeFullName"] = this.employeeFullName;
        data["modelName"] = this.modelName;
        data["depreciationName"] = this.depreciationName;
        data["assetTypeName"] = this.assetTypeName;
        data["assetSubTypeName"] = this.assetSubTypeName;
        data["statusName"] = this.statusName;
        data["locationName"] = this.locationName;
        data["makeName"] = this.makeName;
        data["assetid"] = this.assetid;
        data["assignedEmployeeid"] = this.assignedEmployeeid;
        data["name"] = this.name;
        data["assetNumber"] = this.assetNumber;
        data["serialNumber"] = this.serialNumber;
        data["custodianDepartmentId"] = this.custodianDepartmentId;
        data["custodianId"] = this.custodianId;
        data["assetStatusId"] = this.assetStatusId;
        data["assetCategoryId"] = this.assetCategoryId;
        data["assetSubTypeId"] = this.assetSubTypeId;
        data["deperciationMethod"] = this.deperciationMethod;
        data["depreciationFrequency"] = this.depreciationFrequency;
        data["createdBy"] = this.createdBy;
        data["assetTypeId"] = this.assetTypeId;
        data["assetModelId"] = this.assetModelId;
        data["assetModelName"] = this.assetModelName;
        data["assetDepreciationProfileId"] = this.assetDepreciationProfileId;
        data["assetMakeId"] = this.assetMakeId;
        data["assetMakeName"] = this.assetMakeName;
        data["locationId"] = this.locationId;
        data["manufactureDate"] = this.manufactureDate ? this.manufactureDate.toISOString() : <any>undefined;
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>undefined;
        data["purchaseAmount"] = this.purchaseAmount;
        data["description"] = this.description;
        data["barCode"] = this.barCode;
        data["qrCode"] = this.qrCode;
        data["depreciationDate"] = this.depreciationDate ? this.depreciationDate.toISOString() : <any>undefined;
        data["lostAsset"] = this.lostAsset;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetDTO {
        const json = this.toJSON();
        let result = new AssetDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetDTO {
    referenceNumber: string | undefined;
    employeeFullName: string | undefined;
    modelName: string | undefined;
    depreciationName: string | undefined;
    assetTypeName: string | undefined;
    assetSubTypeName: string | undefined;
    statusName: string | undefined;
    locationName: string | undefined;
    makeName: string | undefined;
    assetid: number;
    assignedEmployeeid: number;
    name: string | undefined;
    assetNumber: string | undefined;
    serialNumber: string | undefined;
    custodianDepartmentId: number;
    custodianId: number;
    assetStatusId: number;
    assetCategoryId: number;
    assetSubTypeId: number;
    deperciationMethod: number;
    depreciationFrequency: number;
    createdBy: string | undefined;
    assetTypeId: number;
    assetModelId: number;
    assetModelName: string | undefined;
    assetDepreciationProfileId: number;
    assetMakeId: number;
    assetMakeName: string | undefined;
    locationId: number;
    manufactureDate: Date | undefined;
    purchaseDate: Date | undefined;
    purchaseAmount: number;
    description: string | undefined;
    barCode: string | undefined;
    qrCode: string | undefined;
    depreciationDate: Date | undefined;
    lostAsset: boolean | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date | undefined;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetRequestDTO implements IAssetRequestDTO {
    assetid!: number | undefined;
    assetTypeid!: number | undefined;
    assetName!: string | undefined;
    employeeid!: number;
    employeeName!: string | undefined;
    assetSubTypeName!: string | undefined;
    expectedusedate!: Date | undefined;
    assetSubTypeid!: number;
    returndate!: Date | undefined;
    purpose!: string | undefined;
    decisionComment!: string | undefined;
    departmentId!: number;
    location!: number;
    prioity!: number;
    justification!: string | undefined;
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    status!: number;
    assignedbyId!: number;
    approvedId!: number;
    statusName!: string | undefined;
    assignedbyName!: string | undefined;
    approveedbyName!: string | undefined;
    dateCreated!: Date | undefined;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assetid = _data["assetid"];
            this.assetTypeid = _data["assetTypeid"];
            this.assetName = _data["assetName"];
            this.employeeid = _data["employeeid"];
            this.employeeName = _data["employeeName"];
            this.assetSubTypeName = _data["assetSubTypeName"];
            this.expectedusedate = _data["expectedusedate"] ? new Date(_data["expectedusedate"].toString()) : <any>undefined;
            this.assetSubTypeid = _data["assetSubTypeid"];
            this.returndate = _data["returndate"] ? new Date(_data["returndate"].toString()) : <any>undefined;
            this.purpose = _data["purpose"];
            this.decisionComment = _data["decisionComment"];
            this.departmentId = _data["departmentId"];
            this.location = _data["location"];
            this.prioity = _data["prioity"];
            this.justification = _data["justification"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.status = _data["status"];
            this.assignedbyId = _data["assignedbyId"];
            this.approvedId = _data["approvedId"];
            this.statusName = _data["statusName"];
            this.assignedbyName = _data["assignedbyName"];
            this.approveedbyName = _data["approveedbyName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetid"] = this.assetid;
        data["assetTypeid"] = this.assetTypeid;
        data["assetName"] = this.assetName;
        data["employeeid"] = this.employeeid;
        data["employeeName"] = this.employeeName;
        data["assetSubTypeName"] = this.assetSubTypeName;
        data["expectedusedate"] = this.expectedusedate ? this.expectedusedate.toISOString() : <any>undefined;
        data["assetSubTypeid"] = this.assetSubTypeid;
        data["returndate"] = this.returndate ? this.returndate.toISOString() : <any>undefined;
        data["purpose"] = this.purpose;
        data["decisionComment"] = this.decisionComment;
        data["departmentId"] = this.departmentId;
        data["location"] = this.location;
        data["prioity"] = this.prioity;
        data["justification"] = this.justification;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["status"] = this.status;
        data["assignedbyId"] = this.assignedbyId;
        data["approvedId"] = this.approvedId;
        data["statusName"] = this.statusName;
        data["assignedbyName"] = this.assignedbyName;
        data["approveedbyName"] = this.approveedbyName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetRequestDTO {
        const json = this.toJSON();
        let result = new AssetRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetRequestDTO {
    assetid: number | undefined;
    assetTypeid: number | undefined;
    assetName: string | undefined;
    employeeid: number;
    employeeName: string | undefined;
    assetSubTypeName: string | undefined;
    expectedusedate: Date | undefined;
    assetSubTypeid: number;
    returndate: Date | undefined;
    purpose: string | undefined;
    decisionComment: string | undefined;
    departmentId: number;
    location: number;
    prioity: number;
    justification: string | undefined;
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    status: number;
    assignedbyId: number;
    approvedId: number;
    statusName: string | undefined;
    assignedbyName: string | undefined;
    approveedbyName: string | undefined;
    dateCreated: Date | undefined;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssignmentDTO implements IAssignmentDTO {
    id!: number;
    assetid!: number;
    comment!: string | undefined;

    constructor(data?: IAssignmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetid = _data["assetid"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): AssignmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssignmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetid"] = this.assetid;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): AssignmentDTO {
        const json = this.toJSON();
        let result = new AssignmentDTO();
        result.init(json);
        return result;
    }
}

export interface IAssignmentDTO {
    id: number;
    assetid: number;
    comment: string | undefined;
}

export class AssetCallbackDTO implements IAssetCallbackDTO {
    companyID!: number;
    message!: string | undefined;
    processcode!: number;
    itemId!: number;
    approvalProcessId!: number;
    isapproved!: boolean;

    constructor(data?: IAssetCallbackDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyID = _data["companyID"];
            this.message = _data["message"];
            this.processcode = _data["processcode"];
            this.itemId = _data["itemId"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.isapproved = _data["isapproved"];
        }
    }

    static fromJS(data: any): AssetCallbackDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCallbackDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyID"] = this.companyID;
        data["message"] = this.message;
        data["processcode"] = this.processcode;
        data["itemId"] = this.itemId;
        data["approvalProcessId"] = this.approvalProcessId;
        data["isapproved"] = this.isapproved;
        return data; 
    }

    clone(): AssetCallbackDTO {
        const json = this.toJSON();
        let result = new AssetCallbackDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetCallbackDTO {
    companyID: number;
    message: string | undefined;
    processcode: number;
    itemId: number;
    approvalProcessId: number;
    isapproved: boolean;
}

export class AssetcheckInFilter implements IAssetcheckInFilter {
    id!: number;
    pageNumber!: number;
    pageSize!: number;
    name!: string | undefined;
    isFilter!: boolean;
    isActive!: boolean | undefined;

    constructor(data?: IAssetcheckInFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.name = _data["name"];
            this.isFilter = _data["isFilter"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetcheckInFilter {
        data = typeof data === 'object' ? data : {};
        let result = new AssetcheckInFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["name"] = this.name;
        data["isFilter"] = this.isFilter;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetcheckInFilter {
        const json = this.toJSON();
        let result = new AssetcheckInFilter();
        result.init(json);
        return result;
    }
}

export interface IAssetcheckInFilter {
    id: number;
    pageNumber: number;
    pageSize: number;
    name: string | undefined;
    isFilter: boolean;
    isActive: boolean | undefined;
}

export class UpdateAssetRequest implements IUpdateAssetRequest {
    id!: number;
    assetid!: number;
    assetRequestDTO!: AssetRequestDTO;
    pageNumber!: number;
    pageSize!: number;
    name!: string | undefined;
    isFilter!: boolean;
    isActive!: boolean | undefined;

    constructor(data?: IUpdateAssetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetid = _data["assetid"];
            this.assetRequestDTO = _data["assetRequestDTO"] ? AssetRequestDTO.fromJS(_data["assetRequestDTO"]) : <any>undefined;
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.name = _data["name"];
            this.isFilter = _data["isFilter"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateAssetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAssetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetid"] = this.assetid;
        data["assetRequestDTO"] = this.assetRequestDTO ? this.assetRequestDTO.toJSON() : <any>undefined;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["name"] = this.name;
        data["isFilter"] = this.isFilter;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): UpdateAssetRequest {
        const json = this.toJSON();
        let result = new UpdateAssetRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateAssetRequest {
    id: number;
    assetid: number;
    assetRequestDTO: AssetRequestDTO;
    pageNumber: number;
    pageSize: number;
    name: string | undefined;
    isFilter: boolean;
    isActive: boolean | undefined;
}

export class AssetDTOIListApiResult implements IAssetDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetDTO[] | undefined;
    totalCount: number;
}

export class AssetTypeDTOIListApiResult implements IAssetTypeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetTypeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetTypeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetTypeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetTypeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetTypeDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetTypeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetTypeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetTypeDTO[] | undefined;
    totalCount: number;
}

export class AssetSubTypeDTOIListApiResult implements IAssetSubTypeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetSubTypeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetSubTypeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetSubTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetSubTypeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetSubTypeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetSubTypeDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetSubTypeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetSubTypeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetSubTypeDTO[] | undefined;
    totalCount: number;
}

export class AssetCategoryDTOIListApiResult implements IAssetCategoryDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetCategoryDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetCategoryDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetCategoryDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetCategoryDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCategoryDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetCategoryDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetCategoryDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetCategoryDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetCategoryDTO[] | undefined;
    totalCount: number;
}

export class AssetMakeDTOIListApiResult implements IAssetMakeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetMakeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetMakeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetMakeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetMakeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetMakeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetMakeDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetMakeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetMakeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetMakeDTO[] | undefined;
    totalCount: number;
}

export class AssetModelDTOIListApiResult implements IAssetModelDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetModelDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetModelDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetModelDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetModelDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetModelDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetModelDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetModelDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetModelDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetModelDTO[] | undefined;
    totalCount: number;
}

export class AssetStatusDTOIListApiResult implements IAssetStatusDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetStatusDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetStatusDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetStatusDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetStatusDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetStatusDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetStatusDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetStatusDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetStatusDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetStatusDTO[] | undefined;
    totalCount: number;
}

export class AssetDeperciationProfileDTOIListApiResult implements IAssetDeperciationProfileDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetDeperciationProfileDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetDeperciationProfileDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetDeperciationProfileDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetDeperciationProfileDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDeperciationProfileDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetDeperciationProfileDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetDeperciationProfileDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetDeperciationProfileDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetDeperciationProfileDTO[] | undefined;
    totalCount: number;
}

export class AssetHistoryDTO implements IAssetHistoryDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    assignedEmployeeName!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    assetId!: number;
    status!: number;
    assignedEmployeeid!: number;
    assetName!: string | undefined;
    statusName!: string | undefined;
    employeeId!: number;
    employeeName!: string | undefined;
    departmentAssignedTo!: number;
    departmentNameAssignedTo!: string | undefined;
    assignedDate!: Date;
    employeelocationName!: string | undefined;

    constructor(data?: IAssetHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.assignedEmployeeName = _data["assignedEmployeeName"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.assetId = _data["assetId"];
            this.status = _data["status"];
            this.assignedEmployeeid = _data["assignedEmployeeid"];
            this.assetName = _data["assetName"];
            this.statusName = _data["statusName"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.departmentAssignedTo = _data["departmentAssignedTo"];
            this.departmentNameAssignedTo = _data["departmentNameAssignedTo"];
            this.assignedDate = _data["assignedDate"] ? new Date(_data["assignedDate"].toString()) : <any>undefined;
            this.employeelocationName = _data["employeelocationName"];
        }
    }

    static fromJS(data: any): AssetHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["assignedEmployeeName"] = this.assignedEmployeeName;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["assetId"] = this.assetId;
        data["status"] = this.status;
        data["assignedEmployeeid"] = this.assignedEmployeeid;
        data["assetName"] = this.assetName;
        data["statusName"] = this.statusName;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["departmentAssignedTo"] = this.departmentAssignedTo;
        data["departmentNameAssignedTo"] = this.departmentNameAssignedTo;
        data["assignedDate"] = this.assignedDate ? this.assignedDate.toISOString() : <any>undefined;
        data["employeelocationName"] = this.employeelocationName;
        return data; 
    }

    clone(): AssetHistoryDTO {
        const json = this.toJSON();
        let result = new AssetHistoryDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetHistoryDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    assignedEmployeeName: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    assetId: number;
    status: number;
    assignedEmployeeid: number;
    assetName: string | undefined;
    statusName: string | undefined;
    employeeId: number;
    employeeName: string | undefined;
    departmentAssignedTo: number;
    departmentNameAssignedTo: string | undefined;
    assignedDate: Date;
    employeelocationName: string | undefined;
}

export class AssetHistoryDTOIListApiResult implements IAssetHistoryDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetHistoryDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetHistoryDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetHistoryDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetHistoryDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetHistoryDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetHistoryDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetHistoryDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetHistoryDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetHistoryDTO[] | undefined;
    totalCount: number;
}

export class DropdownValue implements IDropdownValue {
    dropdown_id!: number;
    option_text!: string;
    option_value!: number;
    is_deleted!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDropdownValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dropdown_id = _data["dropdown_id"];
            this.option_text = _data["option_text"];
            this.option_value = _data["option_value"];
            this.is_deleted = _data["is_deleted"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DropdownValue {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dropdown_id"] = this.dropdown_id;
        data["option_text"] = this.option_text;
        data["option_value"] = this.option_value;
        data["is_deleted"] = this.is_deleted;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DropdownValue {
        const json = this.toJSON();
        let result = new DropdownValue();
        result.init(json);
        return result;
    }
}

export interface IDropdownValue {
    dropdown_id: number;
    option_text: string;
    option_value: number;
    is_deleted: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DropdownValueIListApiResult implements IDropdownValueIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DropdownValue[] | undefined;
    totalCount!: number;

    constructor(data?: IDropdownValueIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DropdownValue.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DropdownValueIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValueIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DropdownValueIListApiResult {
        const json = this.toJSON();
        let result = new DropdownValueIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDropdownValueIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DropdownValue[] | undefined;
    totalCount: number;
}

export class Country implements ICountry {
    name!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export interface ICountry {
    name: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CountryIListApiResult implements ICountryIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Country[] | undefined;
    totalCount!: number;

    constructor(data?: ICountryIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Country.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CountryIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CountryIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CountryIListApiResult {
        const json = this.toJSON();
        let result = new CountryIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICountryIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Country[] | undefined;
    totalCount: number;
}

export class IDTextViewModel implements IIDTextViewModel {
    id!: number;
    text!: string | undefined;

    constructor(data?: IIDTextViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): IDTextViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new IDTextViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        return data; 
    }

    clone(): IDTextViewModel {
        const json = this.toJSON();
        let result = new IDTextViewModel();
        result.init(json);
        return result;
    }
}

export interface IIDTextViewModel {
    id: number;
    text: string | undefined;
}

export class IDTextViewModelIListApiResult implements IIDTextViewModelIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: IDTextViewModel[] | undefined;
    totalCount!: number;

    constructor(data?: IIDTextViewModelIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(IDTextViewModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): IDTextViewModelIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new IDTextViewModelIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): IDTextViewModelIListApiResult {
        const json = this.toJSON();
        let result = new IDTextViewModelIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IIDTextViewModelIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: IDTextViewModel[] | undefined;
    totalCount: number;
}

export class EmailLog implements IEmailLog {
    sender!: string | undefined;
    receiver!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    messageBody!: string | undefined;
    hasAttachment!: boolean;
    isSent!: boolean;
    retires!: number;
    dateSent!: Date | undefined;
    dateToSend!: Date | undefined;
    emailAttachments!: EmailLogAttachment[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmailLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sender = _data["sender"];
            this.receiver = _data["receiver"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.messageBody = _data["messageBody"];
            this.hasAttachment = _data["hasAttachment"];
            this.isSent = _data["isSent"];
            this.retires = _data["retires"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.dateToSend = _data["dateToSend"] ? new Date(_data["dateToSend"].toString()) : <any>undefined;
            if (Array.isArray(_data["emailAttachments"])) {
                this.emailAttachments = [] as any;
                for (let item of _data["emailAttachments"])
                    this.emailAttachments!.push(EmailLogAttachment.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmailLog {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sender"] = this.sender;
        data["receiver"] = this.receiver;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["messageBody"] = this.messageBody;
        data["hasAttachment"] = this.hasAttachment;
        data["isSent"] = this.isSent;
        data["retires"] = this.retires;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["dateToSend"] = this.dateToSend ? this.dateToSend.toISOString() : <any>undefined;
        if (Array.isArray(this.emailAttachments)) {
            data["emailAttachments"] = [];
            for (let item of this.emailAttachments)
                data["emailAttachments"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmailLog {
        const json = this.toJSON();
        let result = new EmailLog();
        result.init(json);
        return result;
    }
}

export interface IEmailLog {
    sender: string | undefined;
    receiver: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    messageBody: string | undefined;
    hasAttachment: boolean;
    isSent: boolean;
    retires: number;
    dateSent: Date | undefined;
    dateToSend: Date | undefined;
    emailAttachments: EmailLogAttachment[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmailLogAttachment implements IEmailLogAttachment {
    id!: number;
    emailLogID!: number;
    emailLog!: EmailLog;
    folderOnServer!: string | undefined;
    fileNameOnServer!: string | undefined;
    emailFileName!: string | undefined;
    dateCreated!: Date;

    constructor(data?: IEmailLogAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailLogID = _data["emailLogID"];
            this.emailLog = _data["emailLog"] ? EmailLog.fromJS(_data["emailLog"]) : <any>undefined;
            this.folderOnServer = _data["folderOnServer"];
            this.fileNameOnServer = _data["fileNameOnServer"];
            this.emailFileName = _data["emailFileName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmailLogAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailLogID"] = this.emailLogID;
        data["emailLog"] = this.emailLog ? this.emailLog.toJSON() : <any>undefined;
        data["folderOnServer"] = this.folderOnServer;
        data["fileNameOnServer"] = this.fileNameOnServer;
        data["emailFileName"] = this.emailFileName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        return data; 
    }

    clone(): EmailLogAttachment {
        const json = this.toJSON();
        let result = new EmailLogAttachment();
        result.init(json);
        return result;
    }
}

export interface IEmailLogAttachment {
    id: number;
    emailLogID: number;
    emailLog: EmailLog;
    folderOnServer: string | undefined;
    fileNameOnServer: string | undefined;
    emailFileName: string | undefined;
    dateCreated: Date;
}

export class EmailLogDTO implements IEmailLogDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    sender!: string | undefined;
    receiver!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    messageBody!: string | undefined;
    hasAttachment!: boolean;
    isSent!: boolean;
    retires!: number;
    dateSent!: Date | undefined;
    dateToSend!: Date | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    emailAttachments!: EmailLogAttachment[] | undefined;

    constructor(data?: IEmailLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.sender = _data["sender"];
            this.receiver = _data["receiver"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.messageBody = _data["messageBody"];
            this.hasAttachment = _data["hasAttachment"];
            this.isSent = _data["isSent"];
            this.retires = _data["retires"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.dateToSend = _data["dateToSend"] ? new Date(_data["dateToSend"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            if (Array.isArray(_data["emailAttachments"])) {
                this.emailAttachments = [] as any;
                for (let item of _data["emailAttachments"])
                    this.emailAttachments!.push(EmailLogAttachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["sender"] = this.sender;
        data["receiver"] = this.receiver;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["messageBody"] = this.messageBody;
        data["hasAttachment"] = this.hasAttachment;
        data["isSent"] = this.isSent;
        data["retires"] = this.retires;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["dateToSend"] = this.dateToSend ? this.dateToSend.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        if (Array.isArray(this.emailAttachments)) {
            data["emailAttachments"] = [];
            for (let item of this.emailAttachments)
                data["emailAttachments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EmailLogDTO {
        const json = this.toJSON();
        let result = new EmailLogDTO();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTO {
    id: number;
    companyID: number;
    subID: number;
    sender: string | undefined;
    receiver: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    messageBody: string | undefined;
    hasAttachment: boolean;
    isSent: boolean;
    retires: number;
    dateSent: Date | undefined;
    dateToSend: Date | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    emailAttachments: EmailLogAttachment[] | undefined;
}

export class EmailLogDTOIListApiResult implements IEmailLogDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailLogDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IEmailLogDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmailLogDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmailLogDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmailLogDTOIListApiResult {
        const json = this.toJSON();
        let result = new EmailLogDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailLogDTO[] | undefined;
    totalCount: number;
}

export class EmailLogDTOApiResult implements IEmailLogDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailLogDTO;
    totalCount!: number;

    constructor(data?: IEmailLogDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmailLogDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmailLogDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmailLogDTOApiResult {
        const json = this.toJSON();
        let result = new EmailLogDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailLogDTO;
    totalCount: number;
}

export class EmailTemplateDTO implements IEmailTemplateDTO {
    id!: number;
    name!: string | undefined;
    subject!: string;
    text!: string;
    emailTemplateCol!: IDTextViewModel[] | undefined;

    constructor(data?: IEmailTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.subject = _data["subject"];
            this.text = _data["text"];
            if (Array.isArray(_data["emailTemplateCol"])) {
                this.emailTemplateCol = [] as any;
                for (let item of _data["emailTemplateCol"])
                    this.emailTemplateCol!.push(IDTextViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["subject"] = this.subject;
        data["text"] = this.text;
        if (Array.isArray(this.emailTemplateCol)) {
            data["emailTemplateCol"] = [];
            for (let item of this.emailTemplateCol)
                data["emailTemplateCol"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EmailTemplateDTO {
        const json = this.toJSON();
        let result = new EmailTemplateDTO();
        result.init(json);
        return result;
    }
}

export interface IEmailTemplateDTO {
    id: number;
    name: string | undefined;
    subject: string;
    text: string;
    emailTemplateCol: IDTextViewModel[] | undefined;
}

export class EmailTemplateDTOApiResult implements IEmailTemplateDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailTemplateDTO;
    totalCount!: number;

    constructor(data?: IEmailTemplateDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmailTemplateDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmailTemplateDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTemplateDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmailTemplateDTOApiResult {
        const json = this.toJSON();
        let result = new EmailTemplateDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailTemplateDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailTemplateDTO;
    totalCount: number;
}

export class EmployeeDTO implements IEmployeeDTO {
    id!: number;
    employeeContractId!: number;
    companyId!: number;
    subID!: number;
    userId!: number;
    userEmail!: string | undefined;
    titleId!: number;
    religionId!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    serialNo!: string | undefined;
    firstName!: string;
    lastName!: string;
    otherNames!: string | undefined;
    employeeNumber!: string;
    assignmentNumber!: string | undefined;
    dateOfBirth!: Date | undefined;
    maritalStatusId!: number;
    genderId!: number;
    lasraaNumber!: string | undefined;
    regNo!: string | undefined;
    estabFileNo!: string | undefined;
    personalEmail!: string | undefined;
    workEmail!: string;
    fullName!: string | undefined;
    peopleGroupId!: number | undefined;
    niNumber!: string | undefined;
    profilePic!: string | undefined;
    workMobile!: string | undefined;
    defaultMobile!: string;
    dialingCode!: string | undefined;
    subjectSpecialization!: string | undefined;
    selfServiceStatus!: string | undefined;
    employmentStatusId!: number;
    employmentStatus!: number;
    departmentName!: string | undefined;
    jobRoleName!: string | undefined;
    locationName!: string | undefined;
    pensionerFileNo!: string | undefined;
    pfaId!: number | undefined;
    rsaNumber!: string | undefined;
    stateOfOrigion!: string | undefined;
    lgaOfOrigion!: string | undefined;
    internalAddressLine!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    originCountry!: number | undefined;
    originState!: number | undefined;
    residentialCountry!: number | undefined;
    residentialState!: number | undefined;
    residentialLga!: number | undefined;
    residentialAddress!: string | undefined;
    created_by!: string | undefined;
    bvn!: string | undefined;
    bvnStatus!: number;
    bvnValidationResponse!: string | undefined;
    lastBVNValidation!: Date | undefined;
    deviceId!: number | undefined;

    constructor(data?: IEmployeeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeContractId = _data["employeeContractId"];
            this.companyId = _data["companyId"];
            this.subID = _data["subID"];
            this.userId = _data["userId"];
            this.userEmail = _data["userEmail"];
            this.titleId = _data["titleId"];
            this.religionId = _data["religionId"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.serialNo = _data["serialNo"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherNames = _data["otherNames"];
            this.employeeNumber = _data["employeeNumber"];
            this.assignmentNumber = _data["assignmentNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.maritalStatusId = _data["maritalStatusId"];
            this.genderId = _data["genderId"];
            this.lasraaNumber = _data["lasraaNumber"];
            this.regNo = _data["regNo"];
            this.estabFileNo = _data["estabFileNo"];
            this.personalEmail = _data["personalEmail"];
            this.workEmail = _data["workEmail"];
            this.fullName = _data["fullName"];
            this.peopleGroupId = _data["peopleGroupId"];
            this.niNumber = _data["niNumber"];
            this.profilePic = _data["profilePic"];
            this.workMobile = _data["workMobile"];
            this.defaultMobile = _data["defaultMobile"];
            this.dialingCode = _data["dialingCode"];
            this.subjectSpecialization = _data["subjectSpecialization"];
            this.selfServiceStatus = _data["selfServiceStatus"];
            this.employmentStatusId = _data["employmentStatusId"];
            this.employmentStatus = _data["employmentStatus"];
            this.departmentName = _data["departmentName"];
            this.jobRoleName = _data["jobRoleName"];
            this.locationName = _data["locationName"];
            this.pensionerFileNo = _data["pensionerFileNo"];
            this.pfaId = _data["pfaId"];
            this.rsaNumber = _data["rsaNumber"];
            this.stateOfOrigion = _data["stateOfOrigion"];
            this.lgaOfOrigion = _data["lgaOfOrigion"];
            this.internalAddressLine = _data["internalAddressLine"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.originCountry = _data["originCountry"];
            this.originState = _data["originState"];
            this.residentialCountry = _data["residentialCountry"];
            this.residentialState = _data["residentialState"];
            this.residentialLga = _data["residentialLga"];
            this.residentialAddress = _data["residentialAddress"];
            this.created_by = _data["created_by"];
            this.bvn = _data["bvn"];
            this.bvnStatus = _data["bvnStatus"];
            this.bvnValidationResponse = _data["bvnValidationResponse"];
            this.lastBVNValidation = _data["lastBVNValidation"] ? new Date(_data["lastBVNValidation"].toString()) : <any>undefined;
            this.deviceId = _data["deviceId"];
        }
    }

    static fromJS(data: any): EmployeeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeContractId"] = this.employeeContractId;
        data["companyId"] = this.companyId;
        data["subID"] = this.subID;
        data["userId"] = this.userId;
        data["userEmail"] = this.userEmail;
        data["titleId"] = this.titleId;
        data["religionId"] = this.religionId;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["serialNo"] = this.serialNo;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherNames"] = this.otherNames;
        data["employeeNumber"] = this.employeeNumber;
        data["assignmentNumber"] = this.assignmentNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["maritalStatusId"] = this.maritalStatusId;
        data["genderId"] = this.genderId;
        data["lasraaNumber"] = this.lasraaNumber;
        data["regNo"] = this.regNo;
        data["estabFileNo"] = this.estabFileNo;
        data["personalEmail"] = this.personalEmail;
        data["workEmail"] = this.workEmail;
        data["fullName"] = this.fullName;
        data["peopleGroupId"] = this.peopleGroupId;
        data["niNumber"] = this.niNumber;
        data["profilePic"] = this.profilePic;
        data["workMobile"] = this.workMobile;
        data["defaultMobile"] = this.defaultMobile;
        data["dialingCode"] = this.dialingCode;
        data["subjectSpecialization"] = this.subjectSpecialization;
        data["selfServiceStatus"] = this.selfServiceStatus;
        data["employmentStatusId"] = this.employmentStatusId;
        data["employmentStatus"] = this.employmentStatus;
        data["departmentName"] = this.departmentName;
        data["jobRoleName"] = this.jobRoleName;
        data["locationName"] = this.locationName;
        data["pensionerFileNo"] = this.pensionerFileNo;
        data["pfaId"] = this.pfaId;
        data["rsaNumber"] = this.rsaNumber;
        data["stateOfOrigion"] = this.stateOfOrigion;
        data["lgaOfOrigion"] = this.lgaOfOrigion;
        data["internalAddressLine"] = this.internalAddressLine;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["originCountry"] = this.originCountry;
        data["originState"] = this.originState;
        data["residentialCountry"] = this.residentialCountry;
        data["residentialState"] = this.residentialState;
        data["residentialLga"] = this.residentialLga;
        data["residentialAddress"] = this.residentialAddress;
        data["created_by"] = this.created_by;
        data["bvn"] = this.bvn;
        data["bvnStatus"] = this.bvnStatus;
        data["bvnValidationResponse"] = this.bvnValidationResponse;
        data["lastBVNValidation"] = this.lastBVNValidation ? this.lastBVNValidation.toISOString() : <any>undefined;
        data["deviceId"] = this.deviceId;
        return data; 
    }

    clone(): EmployeeDTO {
        const json = this.toJSON();
        let result = new EmployeeDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDTO {
    id: number;
    employeeContractId: number;
    companyId: number;
    subID: number;
    userId: number;
    userEmail: string | undefined;
    titleId: number;
    religionId: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    serialNo: string | undefined;
    firstName: string;
    lastName: string;
    otherNames: string | undefined;
    employeeNumber: string;
    assignmentNumber: string | undefined;
    dateOfBirth: Date | undefined;
    maritalStatusId: number;
    genderId: number;
    lasraaNumber: string | undefined;
    regNo: string | undefined;
    estabFileNo: string | undefined;
    personalEmail: string | undefined;
    workEmail: string;
    fullName: string | undefined;
    peopleGroupId: number | undefined;
    niNumber: string | undefined;
    profilePic: string | undefined;
    workMobile: string | undefined;
    defaultMobile: string;
    dialingCode: string | undefined;
    subjectSpecialization: string | undefined;
    selfServiceStatus: string | undefined;
    employmentStatusId: number;
    employmentStatus: number;
    departmentName: string | undefined;
    jobRoleName: string | undefined;
    locationName: string | undefined;
    pensionerFileNo: string | undefined;
    pfaId: number | undefined;
    rsaNumber: string | undefined;
    stateOfOrigion: string | undefined;
    lgaOfOrigion: string | undefined;
    internalAddressLine: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    originCountry: number | undefined;
    originState: number | undefined;
    residentialCountry: number | undefined;
    residentialState: number | undefined;
    residentialLga: number | undefined;
    residentialAddress: string | undefined;
    created_by: string | undefined;
    bvn: string | undefined;
    bvnStatus: number;
    bvnValidationResponse: string | undefined;
    lastBVNValidation: Date | undefined;
    deviceId: number | undefined;
}

export class DropdownValueDTO implements IDropdownValueDTO {
    option_text!: string | undefined;
    option_value!: number;
    employee_number!: string | undefined;
    company_id!: number;
    subsidary_id!: number;

    constructor(data?: IDropdownValueDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.option_text = _data["option_text"];
            this.option_value = _data["option_value"];
            this.employee_number = _data["employee_number"];
            this.company_id = _data["company_id"];
            this.subsidary_id = _data["subsidary_id"];
        }
    }

    static fromJS(data: any): DropdownValueDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValueDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["option_text"] = this.option_text;
        data["option_value"] = this.option_value;
        data["employee_number"] = this.employee_number;
        data["company_id"] = this.company_id;
        data["subsidary_id"] = this.subsidary_id;
        return data; 
    }

    clone(): DropdownValueDTO {
        const json = this.toJSON();
        let result = new DropdownValueDTO();
        result.init(json);
        return result;
    }
}

export interface IDropdownValueDTO {
    option_text: string | undefined;
    option_value: number;
    employee_number: string | undefined;
    company_id: number;
    subsidary_id: number;
}

export class DropdownValueDTOIListApiResult implements IDropdownValueDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DropdownValueDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IDropdownValueDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DropdownValueDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DropdownValueDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValueDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DropdownValueDTOIListApiResult {
        const json = this.toJSON();
        let result = new DropdownValueDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDropdownValueDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DropdownValueDTO[] | undefined;
    totalCount: number;
}

export class EmployeeDTOApiResult implements IEmployeeDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeDTO;
    totalCount!: number;

    constructor(data?: IEmployeeDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmployeeDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmployeeDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmployeeDTOApiResult {
        const json = this.toJSON();
        let result = new EmployeeDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeDTO;
    totalCount: number;
}

export class EmployeeDTOIListApiResult implements IEmployeeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IEmployeeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmployeeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmployeeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmployeeDTOIListApiResult {
        const json = this.toJSON();
        let result = new EmployeeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeDTO[] | undefined;
    totalCount: number;
}

export class EmployeeContractAssignmentDTO implements IEmployeeContractAssignmentDTO {
    sn!: number;
    id!: number;
    _id!: string | undefined;
    companyID!: number;
    subID!: number;
    supNumber!: string | undefined;
    assignmentNumber!: string;
    firstName!: string | undefined;
    lastName!: string | undefined;
    otherName!: string | undefined;
    employeeId!: number;
    employmentTypeId!: number;
    contractEndDate!: Date | undefined;
    supervisorId!: number;
    supervisorName!: string | undefined;
    fullName!: string | undefined;
    departmentId!: number;
    departmentName!: string | undefined;
    jobId!: number;
    jobName!: string | undefined;
    gradeId!: number | undefined;
    gradeName!: string | undefined;
    gradeStepId!: number | undefined;
    stepNo!: string | undefined;
    locationId!: number;
    locationName!: string | undefined;
    locationCode!: string | undefined;
    positionId!: number | undefined;
    positionName!: string | undefined;
    ministryId!: number | undefined;
    ministryName!: string | undefined;
    salaryScaleId!: number | undefined;
    salaryScaleName!: string | undefined;
    dateofPresentAppointment!: Date;
    dateofPresentAppointmentStr!: string | undefined;
    dateOfAppointment!: Date;
    dateOfAppointmentStr!: string | undefined;
    dateOfLastDeployment!: Date | undefined;
    dateOfLastDeploymentStr!: string | undefined;
    dateOfConversion!: Date | undefined;
    dateOfConversionStr!: string | undefined;
    dateOfConfirmation!: Date | undefined;
    dateOfConfirmationStr!: string | undefined;
    dateDeployed!: Date | undefined;
    dateDeployedStr!: string | undefined;
    contractEndDateStr!: string | undefined;
    datePromotion!: Date | undefined;
    datePromotionStr!: string | undefined;
    dateOfRetirement!: Date | undefined;
    dateOfRetirementStr!: string | undefined;
    totalEarnings!: number | undefined;
    totalDeductions!: number | undefined;
    netPayment!: number | undefined;
    isContractActive!: boolean;
    isDefaultContract!: boolean;
    noOfLeaveDays!: number | undefined;
    peopleGroupId!: number | undefined;
    lastPromotionDate!: Date | undefined;
    url!: string | undefined;
    payRollTypeId!: number;
    cadreId!: number;
    directorate_id!: number;
    lcda_id!: number;
    lga_id!: number;

    constructor(data?: IEmployeeContractAssignmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sn = _data["sn"];
            this.id = _data["id"];
            this._id = _data["_id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.supNumber = _data["supNumber"];
            this.assignmentNumber = _data["assignmentNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherName = _data["otherName"];
            this.employeeId = _data["employeeId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.contractEndDate = _data["contractEndDate"] ? new Date(_data["contractEndDate"].toString()) : <any>undefined;
            this.supervisorId = _data["supervisorId"];
            this.supervisorName = _data["supervisorName"];
            this.fullName = _data["fullName"];
            this.departmentId = _data["departmentId"];
            this.departmentName = _data["departmentName"];
            this.jobId = _data["jobId"];
            this.jobName = _data["jobName"];
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.gradeStepId = _data["gradeStepId"];
            this.stepNo = _data["stepNo"];
            this.locationId = _data["locationId"];
            this.locationName = _data["locationName"];
            this.locationCode = _data["locationCode"];
            this.positionId = _data["positionId"];
            this.positionName = _data["positionName"];
            this.ministryId = _data["ministryId"];
            this.ministryName = _data["ministryName"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.salaryScaleName = _data["salaryScaleName"];
            this.dateofPresentAppointment = _data["dateofPresentAppointment"] ? new Date(_data["dateofPresentAppointment"].toString()) : <any>undefined;
            this.dateofPresentAppointmentStr = _data["dateofPresentAppointmentStr"];
            this.dateOfAppointment = _data["dateOfAppointment"] ? new Date(_data["dateOfAppointment"].toString()) : <any>undefined;
            this.dateOfAppointmentStr = _data["dateOfAppointmentStr"];
            this.dateOfLastDeployment = _data["dateOfLastDeployment"] ? new Date(_data["dateOfLastDeployment"].toString()) : <any>undefined;
            this.dateOfLastDeploymentStr = _data["dateOfLastDeploymentStr"];
            this.dateOfConversion = _data["dateOfConversion"] ? new Date(_data["dateOfConversion"].toString()) : <any>undefined;
            this.dateOfConversionStr = _data["dateOfConversionStr"];
            this.dateOfConfirmation = _data["dateOfConfirmation"] ? new Date(_data["dateOfConfirmation"].toString()) : <any>undefined;
            this.dateOfConfirmationStr = _data["dateOfConfirmationStr"];
            this.dateDeployed = _data["dateDeployed"] ? new Date(_data["dateDeployed"].toString()) : <any>undefined;
            this.dateDeployedStr = _data["dateDeployedStr"];
            this.contractEndDateStr = _data["contractEndDateStr"];
            this.datePromotion = _data["datePromotion"] ? new Date(_data["datePromotion"].toString()) : <any>undefined;
            this.datePromotionStr = _data["datePromotionStr"];
            this.dateOfRetirement = _data["dateOfRetirement"] ? new Date(_data["dateOfRetirement"].toString()) : <any>undefined;
            this.dateOfRetirementStr = _data["dateOfRetirementStr"];
            this.totalEarnings = _data["totalEarnings"];
            this.totalDeductions = _data["totalDeductions"];
            this.netPayment = _data["netPayment"];
            this.isContractActive = _data["isContractActive"];
            this.isDefaultContract = _data["isDefaultContract"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.peopleGroupId = _data["peopleGroupId"];
            this.lastPromotionDate = _data["lastPromotionDate"] ? new Date(_data["lastPromotionDate"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.payRollTypeId = _data["payRollTypeId"];
            this.cadreId = _data["cadreId"];
            this.directorate_id = _data["directorate_id"];
            this.lcda_id = _data["lcda_id"];
            this.lga_id = _data["lga_id"];
        }
    }

    static fromJS(data: any): EmployeeContractAssignmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeContractAssignmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sn"] = this.sn;
        data["id"] = this.id;
        data["_id"] = this._id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["supNumber"] = this.supNumber;
        data["assignmentNumber"] = this.assignmentNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherName"] = this.otherName;
        data["employeeId"] = this.employeeId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["contractEndDate"] = this.contractEndDate ? this.contractEndDate.toISOString() : <any>undefined;
        data["supervisorId"] = this.supervisorId;
        data["supervisorName"] = this.supervisorName;
        data["fullName"] = this.fullName;
        data["departmentId"] = this.departmentId;
        data["departmentName"] = this.departmentName;
        data["jobId"] = this.jobId;
        data["jobName"] = this.jobName;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["gradeStepId"] = this.gradeStepId;
        data["stepNo"] = this.stepNo;
        data["locationId"] = this.locationId;
        data["locationName"] = this.locationName;
        data["locationCode"] = this.locationCode;
        data["positionId"] = this.positionId;
        data["positionName"] = this.positionName;
        data["ministryId"] = this.ministryId;
        data["ministryName"] = this.ministryName;
        data["salaryScaleId"] = this.salaryScaleId;
        data["salaryScaleName"] = this.salaryScaleName;
        data["dateofPresentAppointment"] = this.dateofPresentAppointment ? this.dateofPresentAppointment.toISOString() : <any>undefined;
        data["dateofPresentAppointmentStr"] = this.dateofPresentAppointmentStr;
        data["dateOfAppointment"] = this.dateOfAppointment ? this.dateOfAppointment.toISOString() : <any>undefined;
        data["dateOfAppointmentStr"] = this.dateOfAppointmentStr;
        data["dateOfLastDeployment"] = this.dateOfLastDeployment ? this.dateOfLastDeployment.toISOString() : <any>undefined;
        data["dateOfLastDeploymentStr"] = this.dateOfLastDeploymentStr;
        data["dateOfConversion"] = this.dateOfConversion ? this.dateOfConversion.toISOString() : <any>undefined;
        data["dateOfConversionStr"] = this.dateOfConversionStr;
        data["dateOfConfirmation"] = this.dateOfConfirmation ? this.dateOfConfirmation.toISOString() : <any>undefined;
        data["dateOfConfirmationStr"] = this.dateOfConfirmationStr;
        data["dateDeployed"] = this.dateDeployed ? this.dateDeployed.toISOString() : <any>undefined;
        data["dateDeployedStr"] = this.dateDeployedStr;
        data["contractEndDateStr"] = this.contractEndDateStr;
        data["datePromotion"] = this.datePromotion ? this.datePromotion.toISOString() : <any>undefined;
        data["datePromotionStr"] = this.datePromotionStr;
        data["dateOfRetirement"] = this.dateOfRetirement ? this.dateOfRetirement.toISOString() : <any>undefined;
        data["dateOfRetirementStr"] = this.dateOfRetirementStr;
        data["totalEarnings"] = this.totalEarnings;
        data["totalDeductions"] = this.totalDeductions;
        data["netPayment"] = this.netPayment;
        data["isContractActive"] = this.isContractActive;
        data["isDefaultContract"] = this.isDefaultContract;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["peopleGroupId"] = this.peopleGroupId;
        data["lastPromotionDate"] = this.lastPromotionDate ? this.lastPromotionDate.toISOString() : <any>undefined;
        data["url"] = this.url;
        data["payRollTypeId"] = this.payRollTypeId;
        data["cadreId"] = this.cadreId;
        data["directorate_id"] = this.directorate_id;
        data["lcda_id"] = this.lcda_id;
        data["lga_id"] = this.lga_id;
        return data; 
    }

    clone(): EmployeeContractAssignmentDTO {
        const json = this.toJSON();
        let result = new EmployeeContractAssignmentDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeContractAssignmentDTO {
    sn: number;
    id: number;
    _id: string | undefined;
    companyID: number;
    subID: number;
    supNumber: string | undefined;
    assignmentNumber: string;
    firstName: string | undefined;
    lastName: string | undefined;
    otherName: string | undefined;
    employeeId: number;
    employmentTypeId: number;
    contractEndDate: Date | undefined;
    supervisorId: number;
    supervisorName: string | undefined;
    fullName: string | undefined;
    departmentId: number;
    departmentName: string | undefined;
    jobId: number;
    jobName: string | undefined;
    gradeId: number | undefined;
    gradeName: string | undefined;
    gradeStepId: number | undefined;
    stepNo: string | undefined;
    locationId: number;
    locationName: string | undefined;
    locationCode: string | undefined;
    positionId: number | undefined;
    positionName: string | undefined;
    ministryId: number | undefined;
    ministryName: string | undefined;
    salaryScaleId: number | undefined;
    salaryScaleName: string | undefined;
    dateofPresentAppointment: Date;
    dateofPresentAppointmentStr: string | undefined;
    dateOfAppointment: Date;
    dateOfAppointmentStr: string | undefined;
    dateOfLastDeployment: Date | undefined;
    dateOfLastDeploymentStr: string | undefined;
    dateOfConversion: Date | undefined;
    dateOfConversionStr: string | undefined;
    dateOfConfirmation: Date | undefined;
    dateOfConfirmationStr: string | undefined;
    dateDeployed: Date | undefined;
    dateDeployedStr: string | undefined;
    contractEndDateStr: string | undefined;
    datePromotion: Date | undefined;
    datePromotionStr: string | undefined;
    dateOfRetirement: Date | undefined;
    dateOfRetirementStr: string | undefined;
    totalEarnings: number | undefined;
    totalDeductions: number | undefined;
    netPayment: number | undefined;
    isContractActive: boolean;
    isDefaultContract: boolean;
    noOfLeaveDays: number | undefined;
    peopleGroupId: number | undefined;
    lastPromotionDate: Date | undefined;
    url: string | undefined;
    payRollTypeId: number;
    cadreId: number;
    directorate_id: number;
    lcda_id: number;
    lga_id: number;
}

export class EmployeeContractAssignmentDTOApiResult implements IEmployeeContractAssignmentDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeContractAssignmentDTO;
    totalCount!: number;

    constructor(data?: IEmployeeContractAssignmentDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmployeeContractAssignmentDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmployeeContractAssignmentDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeContractAssignmentDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmployeeContractAssignmentDTOApiResult {
        const json = this.toJSON();
        let result = new EmployeeContractAssignmentDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeContractAssignmentDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeContractAssignmentDTO;
    totalCount: number;
}

export class LeaveType implements ILeaveType {
    description!: string;
    isDeductableFromAnualLeave!: boolean;
    excludeWeekendInCalculation!: boolean;
    isOnlyAvailableToAdmin!: boolean;
    isAnnualLeave!: boolean;
    allowedGender!: number;
    maxDays!: number;
    minDays!: number;
    isSystemDefault!: boolean;
    maxNoofPossibleApplication!: number;
    maxNoofYearlyApplication!: number;
    isGradeDependent!: boolean;
    pro_rateLeaveDays!: boolean;
    onlyForConfirmStaff!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.maxDays = 0;
            this.minDays = 0;
            this.maxNoofPossibleApplication = 0;
            this.maxNoofYearlyApplication = 0;
            this.isGradeDependent = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.isDeductableFromAnualLeave = _data["isDeductableFromAnualLeave"];
            this.excludeWeekendInCalculation = _data["excludeWeekendInCalculation"];
            this.isOnlyAvailableToAdmin = _data["isOnlyAvailableToAdmin"];
            this.isAnnualLeave = _data["isAnnualLeave"];
            this.allowedGender = _data["allowedGender"];
            this.maxDays = _data["maxDays"] !== undefined ? _data["maxDays"] : 0;
            this.minDays = _data["minDays"] !== undefined ? _data["minDays"] : 0;
            this.isSystemDefault = _data["isSystemDefault"];
            this.maxNoofPossibleApplication = _data["maxNoofPossibleApplication"] !== undefined ? _data["maxNoofPossibleApplication"] : 0;
            this.maxNoofYearlyApplication = _data["maxNoofYearlyApplication"] !== undefined ? _data["maxNoofYearlyApplication"] : 0;
            this.isGradeDependent = _data["isGradeDependent"] !== undefined ? _data["isGradeDependent"] : false;
            this.pro_rateLeaveDays = _data["pro_rateLeaveDays"];
            this.onlyForConfirmStaff = _data["onlyForConfirmStaff"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveType {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["isDeductableFromAnualLeave"] = this.isDeductableFromAnualLeave;
        data["excludeWeekendInCalculation"] = this.excludeWeekendInCalculation;
        data["isOnlyAvailableToAdmin"] = this.isOnlyAvailableToAdmin;
        data["isAnnualLeave"] = this.isAnnualLeave;
        data["allowedGender"] = this.allowedGender;
        data["maxDays"] = this.maxDays;
        data["minDays"] = this.minDays;
        data["isSystemDefault"] = this.isSystemDefault;
        data["maxNoofPossibleApplication"] = this.maxNoofPossibleApplication;
        data["maxNoofYearlyApplication"] = this.maxNoofYearlyApplication;
        data["isGradeDependent"] = this.isGradeDependent;
        data["pro_rateLeaveDays"] = this.pro_rateLeaveDays;
        data["onlyForConfirmStaff"] = this.onlyForConfirmStaff;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveType {
        const json = this.toJSON();
        let result = new LeaveType();
        result.init(json);
        return result;
    }
}

export interface ILeaveType {
    description: string;
    isDeductableFromAnualLeave: boolean;
    excludeWeekendInCalculation: boolean;
    isOnlyAvailableToAdmin: boolean;
    isAnnualLeave: boolean;
    allowedGender: number;
    maxDays: number;
    minDays: number;
    isSystemDefault: boolean;
    maxNoofPossibleApplication: number;
    maxNoofYearlyApplication: number;
    isGradeDependent: boolean;
    pro_rateLeaveDays: boolean;
    onlyForConfirmStaff: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Grade implements IGrade {
    name!: string;
    code!: string | undefined;
    created_by!: string | undefined;
    promotion_min_years!: number;
    promotion_min_in_days!: number | undefined;
    noOfLeaveDays!: number;
    salaryScaleId!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IGrade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Grade {
        data = typeof data === 'object' ? data : {};
        let result = new Grade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["promotion_min_years"] = this.promotion_min_years;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["salaryScaleId"] = this.salaryScaleId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Grade {
        const json = this.toJSON();
        let result = new Grade();
        result.init(json);
        return result;
    }
}

export interface IGrade {
    name: string;
    code: string | undefined;
    created_by: string | undefined;
    promotion_min_years: number;
    promotion_min_in_days: number | undefined;
    noOfLeaveDays: number;
    salaryScaleId: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveEntitlementResource implements ILeaveEntitlementResource {
    gradeID!: number;
    leaveTypeID!: number;
    entitlement!: number;
    daysUsed!: number;
    daysRemaining!: number;
    leaveType!: LeaveType;
    grades!: Grade;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveEntitlementResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeID = _data["gradeID"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.entitlement = _data["entitlement"];
            this.daysUsed = _data["daysUsed"];
            this.daysRemaining = _data["daysRemaining"];
            this.leaveType = _data["leaveType"] ? LeaveType.fromJS(_data["leaveType"]) : <any>undefined;
            this.grades = _data["grades"] ? Grade.fromJS(_data["grades"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveEntitlementResource {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeID"] = this.gradeID;
        data["leaveTypeID"] = this.leaveTypeID;
        data["entitlement"] = this.entitlement;
        data["daysUsed"] = this.daysUsed;
        data["daysRemaining"] = this.daysRemaining;
        data["leaveType"] = this.leaveType ? this.leaveType.toJSON() : <any>undefined;
        data["grades"] = this.grades ? this.grades.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveEntitlementResource {
        const json = this.toJSON();
        let result = new LeaveEntitlementResource();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementResource {
    gradeID: number;
    leaveTypeID: number;
    entitlement: number;
    daysUsed: number;
    daysRemaining: number;
    leaveType: LeaveType;
    grades: Grade;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveEntitlementResourceListApiResult implements ILeaveEntitlementResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveEntitlementResource[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveEntitlementResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveEntitlementResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveEntitlementResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveEntitlementResourceListApiResult {
        const json = this.toJSON();
        let result = new LeaveEntitlementResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveEntitlementResource[] | undefined;
    totalCount: number;
}

export class LeavePlanResource implements ILeavePlanResource {
    strApprovalStatus!: string | undefined;
    isApproved!: number;
    dateCreated!: Date;
    id!: number;
    employeeContractId!: number;
    leaveTypeId!: number;
    leaveYearId!: number;
    comment!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    noOfDays!: number;
    locationName!: string | undefined;
    locationId!: number;
    employeeNo!: string | undefined;
    fullName!: string | undefined;
    leaveType!: string | undefined;
    leaveYear!: string | undefined;
    companyId!: number;
    subId!: number;

    constructor(data?: ILeavePlanResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.strApprovalStatus = _data["strApprovalStatus"];
            this.isApproved = _data["isApproved"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.employeeContractId = _data["employeeContractId"];
            this.leaveTypeId = _data["leaveTypeId"];
            this.leaveYearId = _data["leaveYearId"];
            this.comment = _data["comment"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.locationName = _data["locationName"];
            this.locationId = _data["locationId"];
            this.employeeNo = _data["employeeNo"];
            this.fullName = _data["fullName"];
            this.leaveType = _data["leaveType"];
            this.leaveYear = _data["leaveYear"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
        }
    }

    static fromJS(data: any): LeavePlanResource {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePlanResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["strApprovalStatus"] = this.strApprovalStatus;
        data["isApproved"] = this.isApproved;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["employeeContractId"] = this.employeeContractId;
        data["leaveTypeId"] = this.leaveTypeId;
        data["leaveYearId"] = this.leaveYearId;
        data["comment"] = this.comment;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["locationName"] = this.locationName;
        data["locationId"] = this.locationId;
        data["employeeNo"] = this.employeeNo;
        data["fullName"] = this.fullName;
        data["leaveType"] = this.leaveType;
        data["leaveYear"] = this.leaveYear;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        return data; 
    }

    clone(): LeavePlanResource {
        const json = this.toJSON();
        let result = new LeavePlanResource();
        result.init(json);
        return result;
    }
}

export interface ILeavePlanResource {
    strApprovalStatus: string | undefined;
    isApproved: number;
    dateCreated: Date;
    id: number;
    employeeContractId: number;
    leaveTypeId: number;
    leaveYearId: number;
    comment: string | undefined;
    startDate: Date;
    endDate: Date;
    noOfDays: number;
    locationName: string | undefined;
    locationId: number;
    employeeNo: string | undefined;
    fullName: string | undefined;
    leaveType: string | undefined;
    leaveYear: string | undefined;
    companyId: number;
    subId: number;
}

export class LeavePlanResourceApiResult implements ILeavePlanResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeavePlanResource;
    totalCount!: number;

    constructor(data?: ILeavePlanResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeavePlanResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeavePlanResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePlanResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeavePlanResourceApiResult {
        const json = this.toJSON();
        let result = new LeavePlanResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeavePlanResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeavePlanResource;
    totalCount: number;
}

export class LeaveEntitlementPayload implements ILeaveEntitlementPayload {
    gradeID!: number;
    leaveTypeID!: number;
    entitlement!: number;
    id!: number;

    constructor(data?: ILeaveEntitlementPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeID = _data["gradeID"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.entitlement = _data["entitlement"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LeaveEntitlementPayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeID"] = this.gradeID;
        data["leaveTypeID"] = this.leaveTypeID;
        data["entitlement"] = this.entitlement;
        data["id"] = this.id;
        return data; 
    }

    clone(): LeaveEntitlementPayload {
        const json = this.toJSON();
        let result = new LeaveEntitlementPayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementPayload {
    gradeID: number;
    leaveTypeID: number;
    entitlement: number;
    id: number;
}

export class GradeListApiResult implements IGradeListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Grade[] | undefined;
    totalCount!: number;

    constructor(data?: IGradeListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Grade.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GradeListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): GradeListApiResult {
        const json = this.toJSON();
        let result = new GradeListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Grade[] | undefined;
    totalCount: number;
}

export class LeaveYear implements ILeaveYear {
    yearName!: string;
    isActiveYear!: boolean;
    yearStartDate!: Date;
    yearEndDate!: Date;
    yearEndDateString!: string | undefined;
    yearStartDateString!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveYear) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.yearName = _data["yearName"];
            this.isActiveYear = _data["isActiveYear"];
            this.yearStartDate = _data["yearStartDate"] ? new Date(_data["yearStartDate"].toString()) : <any>undefined;
            this.yearEndDate = _data["yearEndDate"] ? new Date(_data["yearEndDate"].toString()) : <any>undefined;
            this.yearEndDateString = _data["yearEndDateString"];
            this.yearStartDateString = _data["yearStartDateString"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveYear {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYear();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yearName"] = this.yearName;
        data["isActiveYear"] = this.isActiveYear;
        data["yearStartDate"] = this.yearStartDate ? this.yearStartDate.toISOString() : <any>undefined;
        data["yearEndDate"] = this.yearEndDate ? this.yearEndDate.toISOString() : <any>undefined;
        data["yearEndDateString"] = this.yearEndDateString;
        data["yearStartDateString"] = this.yearStartDateString;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveYear {
        const json = this.toJSON();
        let result = new LeaveYear();
        result.init(json);
        return result;
    }
}

export interface ILeaveYear {
    yearName: string;
    isActiveYear: boolean;
    yearStartDate: Date;
    yearEndDate: Date;
    yearEndDateString: string | undefined;
    yearStartDateString: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveHolidayDateResource implements ILeaveHolidayDateResource {
    holiday_date!: Date;
    holiday_desc!: string | undefined;
    leaveYearID!: number;
    leaveYear!: LeaveYear;
    str_holiday_date!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveHolidayDateResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holiday_date = _data["holiday_date"] ? new Date(_data["holiday_date"].toString()) : <any>undefined;
            this.holiday_desc = _data["holiday_desc"];
            this.leaveYearID = _data["leaveYearID"];
            this.leaveYear = _data["leaveYear"] ? LeaveYear.fromJS(_data["leaveYear"]) : <any>undefined;
            this.str_holiday_date = _data["str_holiday_date"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveHolidayDateResource {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveHolidayDateResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holiday_date"] = this.holiday_date ? this.holiday_date.toISOString() : <any>undefined;
        data["holiday_desc"] = this.holiday_desc;
        data["leaveYearID"] = this.leaveYearID;
        data["leaveYear"] = this.leaveYear ? this.leaveYear.toJSON() : <any>undefined;
        data["str_holiday_date"] = this.str_holiday_date;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveHolidayDateResource {
        const json = this.toJSON();
        let result = new LeaveHolidayDateResource();
        result.init(json);
        return result;
    }
}

export interface ILeaveHolidayDateResource {
    holiday_date: Date;
    holiday_desc: string | undefined;
    leaveYearID: number;
    leaveYear: LeaveYear;
    str_holiday_date: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveHolidayDateResources implements ILeaveHolidayDateResources {
    holiday_date!: Date;
    holiday_desc!: string | undefined;
    leaveYearID!: number;
    leaveYear!: LeaveYear;
    str_holiday_date!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveHolidayDateResources) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holiday_date = _data["holiday_date"] ? new Date(_data["holiday_date"].toString()) : <any>undefined;
            this.holiday_desc = _data["holiday_desc"];
            this.leaveYearID = _data["leaveYearID"];
            this.leaveYear = _data["leaveYear"] ? LeaveYear.fromJS(_data["leaveYear"]) : <any>undefined;
            this.str_holiday_date = _data["str_holiday_date"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveHolidayDateResources {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveHolidayDateResources();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holiday_date"] = this.holiday_date ? this.holiday_date.toISOString() : <any>undefined;
        data["holiday_desc"] = this.holiday_desc;
        data["leaveYearID"] = this.leaveYearID;
        data["leaveYear"] = this.leaveYear ? this.leaveYear.toJSON() : <any>undefined;
        data["str_holiday_date"] = this.str_holiday_date;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveHolidayDateResources {
        const json = this.toJSON();
        let result = new LeaveHolidayDateResources();
        result.init(json);
        return result;
    }
}

export interface ILeaveHolidayDateResources {
    holiday_date: Date;
    holiday_desc: string | undefined;
    leaveYearID: number;
    leaveYear: LeaveYear;
    str_holiday_date: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class HolidateDates implements IHolidateDates {
    leaveHolidayDateResource!: LeaveHolidayDateResource;
    leaveHolidayDateResources!: LeaveHolidayDateResources[] | undefined;

    constructor(data?: IHolidateDates) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leaveHolidayDateResource = _data["leaveHolidayDateResource"] ? LeaveHolidayDateResource.fromJS(_data["leaveHolidayDateResource"]) : <any>undefined;
            if (Array.isArray(_data["leaveHolidayDateResources"])) {
                this.leaveHolidayDateResources = [] as any;
                for (let item of _data["leaveHolidayDateResources"])
                    this.leaveHolidayDateResources!.push(LeaveHolidayDateResources.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HolidateDates {
        data = typeof data === 'object' ? data : {};
        let result = new HolidateDates();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaveHolidayDateResource"] = this.leaveHolidayDateResource ? this.leaveHolidayDateResource.toJSON() : <any>undefined;
        if (Array.isArray(this.leaveHolidayDateResources)) {
            data["leaveHolidayDateResources"] = [];
            for (let item of this.leaveHolidayDateResources)
                data["leaveHolidayDateResources"].push(item.toJSON());
        }
        return data; 
    }

    clone(): HolidateDates {
        const json = this.toJSON();
        let result = new HolidateDates();
        result.init(json);
        return result;
    }
}

export interface IHolidateDates {
    leaveHolidayDateResource: LeaveHolidayDateResource;
    leaveHolidayDateResources: LeaveHolidayDateResources[] | undefined;
}

export class HolidateDatesApiResult implements IHolidateDatesApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: HolidateDates;
    totalCount!: number;

    constructor(data?: IHolidateDatesApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? HolidateDates.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): HolidateDatesApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new HolidateDatesApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): HolidateDatesApiResult {
        const json = this.toJSON();
        let result = new HolidateDatesApiResult();
        result.init(json);
        return result;
    }
}

export interface IHolidateDatesApiResult {
    hasError: boolean;
    message: string | undefined;
    result: HolidateDates;
    totalCount: number;
}

export class LeaveHolidayDateResourceApiResult implements ILeaveHolidayDateResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveHolidayDateResource;
    totalCount!: number;

    constructor(data?: ILeaveHolidayDateResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveHolidayDateResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveHolidayDateResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveHolidayDateResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveHolidayDateResourceApiResult {
        const json = this.toJSON();
        let result = new LeaveHolidayDateResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveHolidayDateResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveHolidayDateResource;
    totalCount: number;
}

export class LeaveHolidayDateServiceDTO implements ILeaveHolidayDateServiceDTO {
    holiday_date!: Date;
    leaveYearID!: number;
    holiday_desc!: string;
    id!: number;

    constructor(data?: ILeaveHolidayDateServiceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holiday_date = _data["holiday_date"] ? new Date(_data["holiday_date"].toString()) : <any>undefined;
            this.leaveYearID = _data["leaveYearID"];
            this.holiday_desc = _data["holiday_desc"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LeaveHolidayDateServiceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveHolidayDateServiceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holiday_date"] = this.holiday_date ? this.holiday_date.toISOString() : <any>undefined;
        data["leaveYearID"] = this.leaveYearID;
        data["holiday_desc"] = this.holiday_desc;
        data["id"] = this.id;
        return data; 
    }

    clone(): LeaveHolidayDateServiceDTO {
        const json = this.toJSON();
        let result = new LeaveHolidayDateServiceDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveHolidayDateServiceDTO {
    holiday_date: Date;
    leaveYearID: number;
    holiday_desc: string;
    id: number;
}

export class LeavePlanDTO implements ILeavePlanDTO {
    employeeContractId!: number;
    leaveTypeId!: number;
    leaveYearId!: number;
    comment!: string;
    startDate!: Date;
    endDate!: Date;
    noOfDays!: number;
    locationId!: number;

    constructor(data?: ILeavePlanDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeContractId = _data["employeeContractId"];
            this.leaveTypeId = _data["leaveTypeId"];
            this.leaveYearId = _data["leaveYearId"];
            this.comment = _data["comment"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.locationId = _data["locationId"];
        }
    }

    static fromJS(data: any): LeavePlanDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePlanDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeContractId"] = this.employeeContractId;
        data["leaveTypeId"] = this.leaveTypeId;
        data["leaveYearId"] = this.leaveYearId;
        data["comment"] = this.comment;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["locationId"] = this.locationId;
        return data; 
    }

    clone(): LeavePlanDTO {
        const json = this.toJSON();
        let result = new LeavePlanDTO();
        result.init(json);
        return result;
    }
}

export interface ILeavePlanDTO {
    employeeContractId: number;
    leaveTypeId: number;
    leaveYearId: number;
    comment: string;
    startDate: Date;
    endDate: Date;
    noOfDays: number;
    locationId: number;
}

export class LeavePlanResourceListApiResult implements ILeavePlanResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeavePlanResource[] | undefined;
    totalCount!: number;

    constructor(data?: ILeavePlanResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeavePlanResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeavePlanResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePlanResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeavePlanResourceListApiResult {
        const json = this.toJSON();
        let result = new LeavePlanResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeavePlanResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeavePlanResource[] | undefined;
    totalCount: number;
}

export enum LeavePlaneStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ApproveOrRejectPayload implements IApproveOrRejectPayload {
    id!: number;
    companyId!: number | undefined;
    leavePlaneStatus!: LeavePlaneStatus;

    constructor(data?: IApproveOrRejectPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.leavePlaneStatus = _data["leavePlaneStatus"];
        }
    }

    static fromJS(data: any): ApproveOrRejectPayload {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveOrRejectPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["leavePlaneStatus"] = this.leavePlaneStatus;
        return data; 
    }

    clone(): ApproveOrRejectPayload {
        const json = this.toJSON();
        let result = new ApproveOrRejectPayload();
        result.init(json);
        return result;
    }
}

export interface IApproveOrRejectPayload {
    id: number;
    companyId: number | undefined;
    leavePlaneStatus: LeavePlaneStatus;
}

export class LeaveRequestPayload implements ILeaveRequestPayload {
    leaveTypeID!: number;
    file!: string | undefined;
    id!: number;
    employeeID!: number;
    employeeContractID!: number | undefined;
    employeeNumber!: string | undefined;
    leaveYearID!: number;
    leaveCalendarID!: number;
    initiatorComment!: string;
    contactInfoOnLeave!: string;
    reliefOfficer!: string;
    reliefOfficerId!: number;
    startDate!: Date;
    enddate!: Date;
    noOfDays!: number;
    resumptionDate!: Date;
    dateApplied!: Date;

    constructor(data?: ILeaveRequestPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leaveTypeID = _data["leaveTypeID"];
            this.file = _data["file"];
            this.id = _data["id"];
            this.employeeID = _data["employeeID"];
            this.employeeContractID = _data["employeeContractID"];
            this.employeeNumber = _data["employeeNumber"];
            this.leaveYearID = _data["leaveYearID"];
            this.leaveCalendarID = _data["leaveCalendarID"];
            this.initiatorComment = _data["initiatorComment"];
            this.contactInfoOnLeave = _data["contactInfoOnLeave"];
            this.reliefOfficer = _data["reliefOfficer"];
            this.reliefOfficerId = _data["reliefOfficerId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.enddate = _data["enddate"] ? new Date(_data["enddate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.resumptionDate = _data["resumptionDate"] ? new Date(_data["resumptionDate"].toString()) : <any>undefined;
            this.dateApplied = _data["dateApplied"] ? new Date(_data["dateApplied"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LeaveRequestPayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveRequestPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaveTypeID"] = this.leaveTypeID;
        data["file"] = this.file;
        data["id"] = this.id;
        data["employeeID"] = this.employeeID;
        data["employeeContractID"] = this.employeeContractID;
        data["employeeNumber"] = this.employeeNumber;
        data["leaveYearID"] = this.leaveYearID;
        data["leaveCalendarID"] = this.leaveCalendarID;
        data["initiatorComment"] = this.initiatorComment;
        data["contactInfoOnLeave"] = this.contactInfoOnLeave;
        data["reliefOfficer"] = this.reliefOfficer;
        data["reliefOfficerId"] = this.reliefOfficerId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["enddate"] = this.enddate ? this.enddate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["resumptionDate"] = this.resumptionDate ? this.resumptionDate.toISOString() : <any>undefined;
        data["dateApplied"] = this.dateApplied ? this.dateApplied.toISOString() : <any>undefined;
        return data; 
    }

    clone(): LeaveRequestPayload {
        const json = this.toJSON();
        let result = new LeaveRequestPayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveRequestPayload {
    leaveTypeID: number;
    file: string | undefined;
    id: number;
    employeeID: number;
    employeeContractID: number | undefined;
    employeeNumber: string | undefined;
    leaveYearID: number;
    leaveCalendarID: number;
    initiatorComment: string;
    contactInfoOnLeave: string;
    reliefOfficer: string;
    reliefOfficerId: number;
    startDate: Date;
    enddate: Date;
    noOfDays: number;
    resumptionDate: Date;
    dateApplied: Date;
}

export enum HRActionOptionsList {
    _1 = 1,
    _2 = 2,
}

export class EditLeaveRequestpayload implements IEditLeaveRequestpayload {
    requestID!: number;
    selectedAction!: HRActionOptionsList;
    newapprovalID!: string | undefined;

    constructor(data?: IEditLeaveRequestpayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestID = _data["requestID"];
            this.selectedAction = _data["selectedAction"];
            this.newapprovalID = _data["newapprovalID"];
        }
    }

    static fromJS(data: any): EditLeaveRequestpayload {
        data = typeof data === 'object' ? data : {};
        let result = new EditLeaveRequestpayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestID"] = this.requestID;
        data["selectedAction"] = this.selectedAction;
        data["newapprovalID"] = this.newapprovalID;
        return data; 
    }

    clone(): EditLeaveRequestpayload {
        const json = this.toJSON();
        let result = new EditLeaveRequestpayload();
        result.init(json);
        return result;
    }
}

export interface IEditLeaveRequestpayload {
    requestID: number;
    selectedAction: HRActionOptionsList;
    newapprovalID: string | undefined;
}

export class LeaveReportListDTO implements ILeaveReportListDTO {
    sn!: number;
    id!: number;
    fullName!: string | undefined;
    position!: string | undefined;
    yearName!: string | undefined;
    leaveType!: string | undefined;
    approvalStatus!: string | undefined;
    employeeID!: number | undefined;
    employeeContractID!: number | undefined;
    startDate!: string | undefined;
    enddate!: string | undefined;
    resumptionDate!: string | undefined;
    entitlement!: number;
    assignmentNumber!: string | undefined;
    daysRem!: number;
    noOfDays!: number;

    constructor(data?: ILeaveReportListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sn = _data["sn"];
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.position = _data["position"];
            this.yearName = _data["yearName"];
            this.leaveType = _data["leaveType"];
            this.approvalStatus = _data["approvalStatus"];
            this.employeeID = _data["employeeID"];
            this.employeeContractID = _data["employeeContractID"];
            this.startDate = _data["startDate"];
            this.enddate = _data["enddate"];
            this.resumptionDate = _data["resumptionDate"];
            this.entitlement = _data["entitlement"];
            this.assignmentNumber = _data["assignmentNumber"];
            this.daysRem = _data["daysRem"];
            this.noOfDays = _data["noOfDays"];
        }
    }

    static fromJS(data: any): LeaveReportListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveReportListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sn"] = this.sn;
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["position"] = this.position;
        data["yearName"] = this.yearName;
        data["leaveType"] = this.leaveType;
        data["approvalStatus"] = this.approvalStatus;
        data["employeeID"] = this.employeeID;
        data["employeeContractID"] = this.employeeContractID;
        data["startDate"] = this.startDate;
        data["enddate"] = this.enddate;
        data["resumptionDate"] = this.resumptionDate;
        data["entitlement"] = this.entitlement;
        data["assignmentNumber"] = this.assignmentNumber;
        data["daysRem"] = this.daysRem;
        data["noOfDays"] = this.noOfDays;
        return data; 
    }

    clone(): LeaveReportListDTO {
        const json = this.toJSON();
        let result = new LeaveReportListDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveReportListDTO {
    sn: number;
    id: number;
    fullName: string | undefined;
    position: string | undefined;
    yearName: string | undefined;
    leaveType: string | undefined;
    approvalStatus: string | undefined;
    employeeID: number | undefined;
    employeeContractID: number | undefined;
    startDate: string | undefined;
    enddate: string | undefined;
    resumptionDate: string | undefined;
    entitlement: number;
    assignmentNumber: string | undefined;
    daysRem: number;
    noOfDays: number;
}

export class LeaveReportListDTOListApiResult implements ILeaveReportListDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveReportListDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveReportListDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveReportListDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveReportListDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveReportListDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveReportListDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveReportListDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveReportListDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveReportListDTO[] | undefined;
    totalCount: number;
}

export class Skill implements ISkill {
    name!: string | undefined;
    point!: number | undefined;
    employeeSkills!: EmployeeSkill[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISkill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.point = _data["point"];
            if (Array.isArray(_data["employeeSkills"])) {
                this.employeeSkills = [] as any;
                for (let item of _data["employeeSkills"])
                    this.employeeSkills!.push(EmployeeSkill.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Skill {
        data = typeof data === 'object' ? data : {};
        let result = new Skill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["point"] = this.point;
        if (Array.isArray(this.employeeSkills)) {
            data["employeeSkills"] = [];
            for (let item of this.employeeSkills)
                data["employeeSkills"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Skill {
        const json = this.toJSON();
        let result = new Skill();
        result.init(json);
        return result;
    }
}

export interface ISkill {
    name: string | undefined;
    point: number | undefined;
    employeeSkills: EmployeeSkill[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeSkill implements IEmployeeSkill {
    employeeId!: number;
    skillId!: number;
    startDate!: Date | undefined;
    numberOfExperienceInMonth!: number | undefined;
    point!: number | undefined;
    employee!: Employee;
    skill!: Skill;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeSkill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.skillId = _data["skillId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.numberOfExperienceInMonth = _data["numberOfExperienceInMonth"];
            this.point = _data["point"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.skill = _data["skill"] ? Skill.fromJS(_data["skill"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeSkill {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeSkill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["skillId"] = this.skillId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["numberOfExperienceInMonth"] = this.numberOfExperienceInMonth;
        data["point"] = this.point;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["skill"] = this.skill ? this.skill.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeSkill {
        const json = this.toJSON();
        let result = new EmployeeSkill();
        result.init(json);
        return result;
    }
}

export interface IEmployeeSkill {
    employeeId: number;
    skillId: number;
    startDate: Date | undefined;
    numberOfExperienceInMonth: number | undefined;
    point: number | undefined;
    employee: Employee;
    skill: Skill;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Course implements ICourse {
    name!: string | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Course {
        const json = this.toJSON();
        let result = new Course();
        result.init(json);
        return result;
    }
}

export interface ICourse {
    name: string | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class QualificationGrade implements IQualificationGrade {
    name!: string | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IQualificationGrade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): QualificationGrade {
        data = typeof data === 'object' ? data : {};
        let result = new QualificationGrade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): QualificationGrade {
        const json = this.toJSON();
        let result = new QualificationGrade();
        result.init(json);
        return result;
    }
}

export interface IQualificationGrade {
    name: string | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Qualification implements IQualification {
    categoryId!: number;
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IQualification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Qualification {
        data = typeof data === 'object' ? data : {};
        let result = new Qualification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Qualification {
        const json = this.toJSON();
        let result = new Qualification();
        result.init(json);
        return result;
    }
}

export interface IQualification {
    categoryId: number;
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeQualification implements IEmployeeQualification {
    employeeId!: number;
    name!: string;
    type!: string;
    qualificationId!: number;
    qualificationGradeId!: number;
    courseId!: number;
    courseName!: string | undefined;
    institution!: string | undefined;
    grade!: string | undefined;
    startdate!: Date | undefined;
    stopdate!: Date | undefined;
    comment!: string | undefined;
    is_professional!: number | undefined;
    employee!: Employee;
    course!: Course;
    qualificationGrade!: QualificationGrade;
    qualification!: Qualification;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeQualification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.qualificationId = _data["qualificationId"];
            this.qualificationGradeId = _data["qualificationGradeId"];
            this.courseId = _data["courseId"];
            this.courseName = _data["courseName"];
            this.institution = _data["institution"];
            this.grade = _data["grade"];
            this.startdate = _data["startdate"] ? new Date(_data["startdate"].toString()) : <any>undefined;
            this.stopdate = _data["stopdate"] ? new Date(_data["stopdate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.is_professional = _data["is_professional"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.qualificationGrade = _data["qualificationGrade"] ? QualificationGrade.fromJS(_data["qualificationGrade"]) : <any>undefined;
            this.qualification = _data["qualification"] ? Qualification.fromJS(_data["qualification"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeQualification {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeQualification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["qualificationId"] = this.qualificationId;
        data["qualificationGradeId"] = this.qualificationGradeId;
        data["courseId"] = this.courseId;
        data["courseName"] = this.courseName;
        data["institution"] = this.institution;
        data["grade"] = this.grade;
        data["startdate"] = this.startdate ? this.startdate.toISOString() : <any>undefined;
        data["stopdate"] = this.stopdate ? this.stopdate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["is_professional"] = this.is_professional;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["qualificationGrade"] = this.qualificationGrade ? this.qualificationGrade.toJSON() : <any>undefined;
        data["qualification"] = this.qualification ? this.qualification.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeQualification {
        const json = this.toJSON();
        let result = new EmployeeQualification();
        result.init(json);
        return result;
    }
}

export interface IEmployeeQualification {
    employeeId: number;
    name: string;
    type: string;
    qualificationId: number;
    qualificationGradeId: number;
    courseId: number;
    courseName: string | undefined;
    institution: string | undefined;
    grade: string | undefined;
    startdate: Date | undefined;
    stopdate: Date | undefined;
    comment: string | undefined;
    is_professional: number | undefined;
    employee: Employee;
    course: Course;
    qualificationGrade: QualificationGrade;
    qualification: Qualification;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Certification implements ICertification {
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    completionDate!: Date | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            this.completionDate = _data["completionDate"] ? new Date(_data["completionDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Certification {
        data = typeof data === 'object' ? data : {};
        let result = new Certification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        data["completionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Certification {
        const json = this.toJSON();
        let result = new Certification();
        result.init(json);
        return result;
    }
}

export interface ICertification {
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    completionDate: Date | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeCertification implements IEmployeeCertification {
    employeeId!: number;
    certificationId!: number;
    institution!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    comment!: string | undefined;
    numberOfExperienceInMonth!: number | undefined;
    certification!: Certification;
    employee!: Employee;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeCertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.certificationId = _data["certificationId"];
            this.institution = _data["institution"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.numberOfExperienceInMonth = _data["numberOfExperienceInMonth"];
            this.certification = _data["certification"] ? Certification.fromJS(_data["certification"]) : <any>undefined;
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeCertification {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeCertification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["certificationId"] = this.certificationId;
        data["institution"] = this.institution;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["numberOfExperienceInMonth"] = this.numberOfExperienceInMonth;
        data["certification"] = this.certification ? this.certification.toJSON() : <any>undefined;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeCertification {
        const json = this.toJSON();
        let result = new EmployeeCertification();
        result.init(json);
        return result;
    }
}

export interface IEmployeeCertification {
    employeeId: number;
    certificationId: number;
    institution: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    comment: string | undefined;
    numberOfExperienceInMonth: number | undefined;
    certification: Certification;
    employee: Employee;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Employee implements IEmployee {
    userId!: number;
    titleId!: number;
    religionId!: number | undefined;
    serialNo!: string | undefined;
    firstName!: string;
    lastName!: string;
    otherNames!: string | undefined;
    employeeNumber!: string;
    dateOfBirth!: Date | undefined;
    maritalStatusId!: number;
    genderId!: number;
    lasraaNumber!: string | undefined;
    regNo!: string | undefined;
    estabFileNo!: string | undefined;
    personalEmail!: string | undefined;
    workEmail!: string | undefined;
    fullName!: string | undefined;
    peopleGroupId!: number | undefined;
    niNumber!: string | undefined;
    profilePic!: string | undefined;
    workMobile!: string | undefined;
    defaultMobile!: string | undefined;
    subjectSpecialization!: string | undefined;
    selfServiceStatus!: string | undefined;
    employmentStatusId!: number | undefined;
    pensionerFileNo!: string | undefined;
    pfaId!: number | undefined;
    rsaNumber!: string | undefined;
    stateOfOrigion!: string | undefined;
    lgaOfOrigion!: string | undefined;
    internalAddressLine!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    originCountry!: number | undefined;
    originState!: number | undefined;
    residentialCountry!: number | undefined;
    residentialState!: number | undefined;
    residentialLga!: number | undefined;
    residentialAddress!: string | undefined;
    created_by!: string | undefined;
    bvn!: string | undefined;
    bvnStatus!: number;
    bvnValidationResponse!: string | undefined;
    lastBVNValidation!: Date | undefined;
    deviceId!: number | undefined;
    employeeSkills!: EmployeeSkill[] | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    employeeCertifications!: EmployeeCertification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.titleId = _data["titleId"];
            this.religionId = _data["religionId"];
            this.serialNo = _data["serialNo"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherNames = _data["otherNames"];
            this.employeeNumber = _data["employeeNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.maritalStatusId = _data["maritalStatusId"];
            this.genderId = _data["genderId"];
            this.lasraaNumber = _data["lasraaNumber"];
            this.regNo = _data["regNo"];
            this.estabFileNo = _data["estabFileNo"];
            this.personalEmail = _data["personalEmail"];
            this.workEmail = _data["workEmail"];
            this.fullName = _data["fullName"];
            this.peopleGroupId = _data["peopleGroupId"];
            this.niNumber = _data["niNumber"];
            this.profilePic = _data["profilePic"];
            this.workMobile = _data["workMobile"];
            this.defaultMobile = _data["defaultMobile"];
            this.subjectSpecialization = _data["subjectSpecialization"];
            this.selfServiceStatus = _data["selfServiceStatus"];
            this.employmentStatusId = _data["employmentStatusId"];
            this.pensionerFileNo = _data["pensionerFileNo"];
            this.pfaId = _data["pfaId"];
            this.rsaNumber = _data["rsaNumber"];
            this.stateOfOrigion = _data["stateOfOrigion"];
            this.lgaOfOrigion = _data["lgaOfOrigion"];
            this.internalAddressLine = _data["internalAddressLine"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.originCountry = _data["originCountry"];
            this.originState = _data["originState"];
            this.residentialCountry = _data["residentialCountry"];
            this.residentialState = _data["residentialState"];
            this.residentialLga = _data["residentialLga"];
            this.residentialAddress = _data["residentialAddress"];
            this.created_by = _data["created_by"];
            this.bvn = _data["bvn"];
            this.bvnStatus = _data["bvnStatus"];
            this.bvnValidationResponse = _data["bvnValidationResponse"];
            this.lastBVNValidation = _data["lastBVNValidation"] ? new Date(_data["lastBVNValidation"].toString()) : <any>undefined;
            this.deviceId = _data["deviceId"];
            if (Array.isArray(_data["employeeSkills"])) {
                this.employeeSkills = [] as any;
                for (let item of _data["employeeSkills"])
                    this.employeeSkills!.push(EmployeeSkill.fromJS(item));
            }
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            if (Array.isArray(_data["employeeCertifications"])) {
                this.employeeCertifications = [] as any;
                for (let item of _data["employeeCertifications"])
                    this.employeeCertifications!.push(EmployeeCertification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Employee {
        data = typeof data === 'object' ? data : {};
        let result = new Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["titleId"] = this.titleId;
        data["religionId"] = this.religionId;
        data["serialNo"] = this.serialNo;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherNames"] = this.otherNames;
        data["employeeNumber"] = this.employeeNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["maritalStatusId"] = this.maritalStatusId;
        data["genderId"] = this.genderId;
        data["lasraaNumber"] = this.lasraaNumber;
        data["regNo"] = this.regNo;
        data["estabFileNo"] = this.estabFileNo;
        data["personalEmail"] = this.personalEmail;
        data["workEmail"] = this.workEmail;
        data["fullName"] = this.fullName;
        data["peopleGroupId"] = this.peopleGroupId;
        data["niNumber"] = this.niNumber;
        data["profilePic"] = this.profilePic;
        data["workMobile"] = this.workMobile;
        data["defaultMobile"] = this.defaultMobile;
        data["subjectSpecialization"] = this.subjectSpecialization;
        data["selfServiceStatus"] = this.selfServiceStatus;
        data["employmentStatusId"] = this.employmentStatusId;
        data["pensionerFileNo"] = this.pensionerFileNo;
        data["pfaId"] = this.pfaId;
        data["rsaNumber"] = this.rsaNumber;
        data["stateOfOrigion"] = this.stateOfOrigion;
        data["lgaOfOrigion"] = this.lgaOfOrigion;
        data["internalAddressLine"] = this.internalAddressLine;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["originCountry"] = this.originCountry;
        data["originState"] = this.originState;
        data["residentialCountry"] = this.residentialCountry;
        data["residentialState"] = this.residentialState;
        data["residentialLga"] = this.residentialLga;
        data["residentialAddress"] = this.residentialAddress;
        data["created_by"] = this.created_by;
        data["bvn"] = this.bvn;
        data["bvnStatus"] = this.bvnStatus;
        data["bvnValidationResponse"] = this.bvnValidationResponse;
        data["lastBVNValidation"] = this.lastBVNValidation ? this.lastBVNValidation.toISOString() : <any>undefined;
        data["deviceId"] = this.deviceId;
        if (Array.isArray(this.employeeSkills)) {
            data["employeeSkills"] = [];
            for (let item of this.employeeSkills)
                data["employeeSkills"].push(item.toJSON());
        }
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        if (Array.isArray(this.employeeCertifications)) {
            data["employeeCertifications"] = [];
            for (let item of this.employeeCertifications)
                data["employeeCertifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Employee {
        const json = this.toJSON();
        let result = new Employee();
        result.init(json);
        return result;
    }
}

export interface IEmployee {
    userId: number;
    titleId: number;
    religionId: number | undefined;
    serialNo: string | undefined;
    firstName: string;
    lastName: string;
    otherNames: string | undefined;
    employeeNumber: string;
    dateOfBirth: Date | undefined;
    maritalStatusId: number;
    genderId: number;
    lasraaNumber: string | undefined;
    regNo: string | undefined;
    estabFileNo: string | undefined;
    personalEmail: string | undefined;
    workEmail: string | undefined;
    fullName: string | undefined;
    peopleGroupId: number | undefined;
    niNumber: string | undefined;
    profilePic: string | undefined;
    workMobile: string | undefined;
    defaultMobile: string | undefined;
    subjectSpecialization: string | undefined;
    selfServiceStatus: string | undefined;
    employmentStatusId: number | undefined;
    pensionerFileNo: string | undefined;
    pfaId: number | undefined;
    rsaNumber: string | undefined;
    stateOfOrigion: string | undefined;
    lgaOfOrigion: string | undefined;
    internalAddressLine: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    originCountry: number | undefined;
    originState: number | undefined;
    residentialCountry: number | undefined;
    residentialState: number | undefined;
    residentialLga: number | undefined;
    residentialAddress: string | undefined;
    created_by: string | undefined;
    bvn: string | undefined;
    bvnStatus: number;
    bvnValidationResponse: string | undefined;
    lastBVNValidation: Date | undefined;
    deviceId: number | undefined;
    employeeSkills: EmployeeSkill[] | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    employeeCertifications: EmployeeCertification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveEntitlement implements ILeaveEntitlement {
    gradeID!: number;
    leaveTypeID!: number;
    entitlement!: number;
    daysUsed!: number;
    daysRemaining!: number;
    leaveType!: LeaveType;
    grades!: Grade;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveEntitlement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeID = _data["gradeID"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.entitlement = _data["entitlement"];
            this.daysUsed = _data["daysUsed"];
            this.daysRemaining = _data["daysRemaining"];
            this.leaveType = _data["leaveType"] ? LeaveType.fromJS(_data["leaveType"]) : <any>undefined;
            this.grades = _data["grades"] ? Grade.fromJS(_data["grades"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveEntitlement {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeID"] = this.gradeID;
        data["leaveTypeID"] = this.leaveTypeID;
        data["entitlement"] = this.entitlement;
        data["daysUsed"] = this.daysUsed;
        data["daysRemaining"] = this.daysRemaining;
        data["leaveType"] = this.leaveType ? this.leaveType.toJSON() : <any>undefined;
        data["grades"] = this.grades ? this.grades.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveEntitlement {
        const json = this.toJSON();
        let result = new LeaveEntitlement();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlement {
    gradeID: number;
    leaveTypeID: number;
    entitlement: number;
    daysUsed: number;
    daysRemaining: number;
    leaveType: LeaveType;
    grades: Grade;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveRequest implements ILeaveRequest {
    leaveTypeID!: number;
    employeeID!: number;
    employeeContractID!: number | undefined;
    employeeNumber!: string | undefined;
    leaveYearID!: number;
    leaveCalendarID!: number;
    initiatorComment!: string;
    contactInfoOnLeave!: string;
    reliefOfficer!: string;
    reliefOfficerId!: number;
    startDate!: Date;
    startDateString!: string | undefined;
    enddate!: Date;
    noOfDays!: number;
    resumptionDate!: Date;
    dateApplied!: Date;
    gradeID!: number;
    dateApproved!: Date | undefined;
    rejectedBy!: string | undefined;
    employee!: Employee;
    leaveYear!: LeaveYear;
    leaveType!: LeaveType;
    grade!: Grade;
    file!: string | undefined;
    leaveHistory!: LeaveRequest[] | undefined;
    leaveEntitlement!: LeaveEntitlement[] | undefined;
    approvalDecision!: string | undefined;
    approvalStatus!: string | undefined;
    log_status!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leaveTypeID = _data["leaveTypeID"];
            this.employeeID = _data["employeeID"];
            this.employeeContractID = _data["employeeContractID"];
            this.employeeNumber = _data["employeeNumber"];
            this.leaveYearID = _data["leaveYearID"];
            this.leaveCalendarID = _data["leaveCalendarID"];
            this.initiatorComment = _data["initiatorComment"];
            this.contactInfoOnLeave = _data["contactInfoOnLeave"];
            this.reliefOfficer = _data["reliefOfficer"];
            this.reliefOfficerId = _data["reliefOfficerId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.startDateString = _data["startDateString"];
            this.enddate = _data["enddate"] ? new Date(_data["enddate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.resumptionDate = _data["resumptionDate"] ? new Date(_data["resumptionDate"].toString()) : <any>undefined;
            this.dateApplied = _data["dateApplied"] ? new Date(_data["dateApplied"].toString()) : <any>undefined;
            this.gradeID = _data["gradeID"];
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.rejectedBy = _data["rejectedBy"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.leaveYear = _data["leaveYear"] ? LeaveYear.fromJS(_data["leaveYear"]) : <any>undefined;
            this.leaveType = _data["leaveType"] ? LeaveType.fromJS(_data["leaveType"]) : <any>undefined;
            this.grade = _data["grade"] ? Grade.fromJS(_data["grade"]) : <any>undefined;
            this.file = _data["file"];
            if (Array.isArray(_data["leaveHistory"])) {
                this.leaveHistory = [] as any;
                for (let item of _data["leaveHistory"])
                    this.leaveHistory!.push(LeaveRequest.fromJS(item));
            }
            if (Array.isArray(_data["leaveEntitlement"])) {
                this.leaveEntitlement = [] as any;
                for (let item of _data["leaveEntitlement"])
                    this.leaveEntitlement!.push(LeaveEntitlement.fromJS(item));
            }
            this.approvalDecision = _data["approvalDecision"];
            this.approvalStatus = _data["approvalStatus"];
            this.log_status = _data["log_status"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaveTypeID"] = this.leaveTypeID;
        data["employeeID"] = this.employeeID;
        data["employeeContractID"] = this.employeeContractID;
        data["employeeNumber"] = this.employeeNumber;
        data["leaveYearID"] = this.leaveYearID;
        data["leaveCalendarID"] = this.leaveCalendarID;
        data["initiatorComment"] = this.initiatorComment;
        data["contactInfoOnLeave"] = this.contactInfoOnLeave;
        data["reliefOfficer"] = this.reliefOfficer;
        data["reliefOfficerId"] = this.reliefOfficerId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["startDateString"] = this.startDateString;
        data["enddate"] = this.enddate ? this.enddate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["resumptionDate"] = this.resumptionDate ? this.resumptionDate.toISOString() : <any>undefined;
        data["dateApplied"] = this.dateApplied ? this.dateApplied.toISOString() : <any>undefined;
        data["gradeID"] = this.gradeID;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["rejectedBy"] = this.rejectedBy;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["leaveYear"] = this.leaveYear ? this.leaveYear.toJSON() : <any>undefined;
        data["leaveType"] = this.leaveType ? this.leaveType.toJSON() : <any>undefined;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        data["file"] = this.file;
        if (Array.isArray(this.leaveHistory)) {
            data["leaveHistory"] = [];
            for (let item of this.leaveHistory)
                data["leaveHistory"].push(item.toJSON());
        }
        if (Array.isArray(this.leaveEntitlement)) {
            data["leaveEntitlement"] = [];
            for (let item of this.leaveEntitlement)
                data["leaveEntitlement"].push(item.toJSON());
        }
        data["approvalDecision"] = this.approvalDecision;
        data["approvalStatus"] = this.approvalStatus;
        data["log_status"] = this.log_status;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveRequest {
        const json = this.toJSON();
        let result = new LeaveRequest();
        result.init(json);
        return result;
    }
}

export interface ILeaveRequest {
    leaveTypeID: number;
    employeeID: number;
    employeeContractID: number | undefined;
    employeeNumber: string | undefined;
    leaveYearID: number;
    leaveCalendarID: number;
    initiatorComment: string;
    contactInfoOnLeave: string;
    reliefOfficer: string;
    reliefOfficerId: number;
    startDate: Date;
    startDateString: string | undefined;
    enddate: Date;
    noOfDays: number;
    resumptionDate: Date;
    dateApplied: Date;
    gradeID: number;
    dateApproved: Date | undefined;
    rejectedBy: string | undefined;
    employee: Employee;
    leaveYear: LeaveYear;
    leaveType: LeaveType;
    grade: Grade;
    file: string | undefined;
    leaveHistory: LeaveRequest[] | undefined;
    leaveEntitlement: LeaveEntitlement[] | undefined;
    approvalDecision: string | undefined;
    approvalStatus: string | undefined;
    log_status: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveRequestApiResult implements ILeaveRequestApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveRequest;
    totalCount!: number;

    constructor(data?: ILeaveRequestApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveRequest.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveRequestApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveRequestApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveRequestApiResult {
        const json = this.toJSON();
        let result = new LeaveRequestApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveRequestApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveRequest;
    totalCount: number;
}

export class LeaveTypeDTO implements ILeaveTypeDTO {
    description!: string | undefined;
    isDeductableFromAnualLeave!: boolean;
    excludeWeekendInCalculation!: boolean;
    isOnlyAvailableToAdmin!: boolean;
    isAnnualLeave!: boolean;
    allowedGender!: number;
    maxDays!: number;
    minDays!: number;
    isSystemDefault!: boolean;
    maxNoofPossibleApplication!: number;
    maxNoofYearlyApplication!: number;
    isGradeDependent!: boolean;
    pro_rateLeaveDays!: boolean;
    onlyForConfirmStaff!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.isDeductableFromAnualLeave = _data["isDeductableFromAnualLeave"];
            this.excludeWeekendInCalculation = _data["excludeWeekendInCalculation"];
            this.isOnlyAvailableToAdmin = _data["isOnlyAvailableToAdmin"];
            this.isAnnualLeave = _data["isAnnualLeave"];
            this.allowedGender = _data["allowedGender"];
            this.maxDays = _data["maxDays"];
            this.minDays = _data["minDays"];
            this.isSystemDefault = _data["isSystemDefault"];
            this.maxNoofPossibleApplication = _data["maxNoofPossibleApplication"];
            this.maxNoofYearlyApplication = _data["maxNoofYearlyApplication"];
            this.isGradeDependent = _data["isGradeDependent"];
            this.pro_rateLeaveDays = _data["pro_rateLeaveDays"];
            this.onlyForConfirmStaff = _data["onlyForConfirmStaff"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["isDeductableFromAnualLeave"] = this.isDeductableFromAnualLeave;
        data["excludeWeekendInCalculation"] = this.excludeWeekendInCalculation;
        data["isOnlyAvailableToAdmin"] = this.isOnlyAvailableToAdmin;
        data["isAnnualLeave"] = this.isAnnualLeave;
        data["allowedGender"] = this.allowedGender;
        data["maxDays"] = this.maxDays;
        data["minDays"] = this.minDays;
        data["isSystemDefault"] = this.isSystemDefault;
        data["maxNoofPossibleApplication"] = this.maxNoofPossibleApplication;
        data["maxNoofYearlyApplication"] = this.maxNoofYearlyApplication;
        data["isGradeDependent"] = this.isGradeDependent;
        data["pro_rateLeaveDays"] = this.pro_rateLeaveDays;
        data["onlyForConfirmStaff"] = this.onlyForConfirmStaff;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveTypeDTO {
        const json = this.toJSON();
        let result = new LeaveTypeDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeDTO {
    description: string | undefined;
    isDeductableFromAnualLeave: boolean;
    excludeWeekendInCalculation: boolean;
    isOnlyAvailableToAdmin: boolean;
    isAnnualLeave: boolean;
    allowedGender: number;
    maxDays: number;
    minDays: number;
    isSystemDefault: boolean;
    maxNoofPossibleApplication: number;
    maxNoofYearlyApplication: number;
    isGradeDependent: boolean;
    pro_rateLeaveDays: boolean;
    onlyForConfirmStaff: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveTypeDTOListApiResult implements ILeaveTypeDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveTypeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveTypeDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveTypeDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveTypeDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveTypeDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveTypeDTO[] | undefined;
    totalCount: number;
}

export class LeaveTypeCreatePayload implements ILeaveTypeCreatePayload {
    id!: number;
    description!: string;
    allowedGender!: number;
    maxDays!: number;
    minDays!: number;
    maxNoofPossibleApplication!: number;
    maxNoofYearlyApplication!: number;

    constructor(data?: ILeaveTypeCreatePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.allowedGender = _data["allowedGender"];
            this.maxDays = _data["maxDays"];
            this.minDays = _data["minDays"];
            this.maxNoofPossibleApplication = _data["maxNoofPossibleApplication"];
            this.maxNoofYearlyApplication = _data["maxNoofYearlyApplication"];
        }
    }

    static fromJS(data: any): LeaveTypeCreatePayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeCreatePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["allowedGender"] = this.allowedGender;
        data["maxDays"] = this.maxDays;
        data["minDays"] = this.minDays;
        data["maxNoofPossibleApplication"] = this.maxNoofPossibleApplication;
        data["maxNoofYearlyApplication"] = this.maxNoofYearlyApplication;
        return data; 
    }

    clone(): LeaveTypeCreatePayload {
        const json = this.toJSON();
        let result = new LeaveTypeCreatePayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeCreatePayload {
    id: number;
    description: string;
    allowedGender: number;
    maxDays: number;
    minDays: number;
    maxNoofPossibleApplication: number;
    maxNoofYearlyApplication: number;
}

export class JobRole implements IJobRole {
    name!: string;
    code!: string | undefined;
    amount!: number | undefined;
    promotion_min_years!: number | undefined;
    next_job_role_id!: number | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    parent_id!: number | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IJobRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.amount = _data["amount"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.next_job_role_id = _data["next_job_role_id"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.parent_id = _data["parent_id"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): JobRole {
        data = typeof data === 'object' ? data : {};
        let result = new JobRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["amount"] = this.amount;
        data["promotion_min_years"] = this.promotion_min_years;
        data["next_job_role_id"] = this.next_job_role_id;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["parent_id"] = this.parent_id;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): JobRole {
        const json = this.toJSON();
        let result = new JobRole();
        result.init(json);
        return result;
    }
}

export interface IJobRole {
    name: string;
    code: string | undefined;
    amount: number | undefined;
    promotion_min_years: number | undefined;
    next_job_role_id: number | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    parent_id: number | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Department implements IDepartment {
    name!: string;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    headOfDepartment!: number;
    scheduleOfDuties!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDepartment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.headOfDepartment = _data["headOfDepartment"];
            this.scheduleOfDuties = _data["scheduleOfDuties"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Department {
        data = typeof data === 'object' ? data : {};
        let result = new Department();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["headOfDepartment"] = this.headOfDepartment;
        data["scheduleOfDuties"] = this.scheduleOfDuties;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Department {
        const json = this.toJSON();
        let result = new Department();
        result.init(json);
        return result;
    }
}

export interface IDepartment {
    name: string;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    headOfDepartment: number;
    scheduleOfDuties: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveWorkFlow implements ILeaveWorkFlow {
    departmentID!: number;
    workFlowName!: string | undefined;
    workFlowItems!: LeaveWorkFlowItem[] | undefined;
    department!: Department;
    workFlowString!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveWorkFlow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentID = _data["departmentID"];
            this.workFlowName = _data["workFlowName"];
            if (Array.isArray(_data["workFlowItems"])) {
                this.workFlowItems = [] as any;
                for (let item of _data["workFlowItems"])
                    this.workFlowItems!.push(LeaveWorkFlowItem.fromJS(item));
            }
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.workFlowString = _data["workFlowString"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveWorkFlow {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentID"] = this.departmentID;
        data["workFlowName"] = this.workFlowName;
        if (Array.isArray(this.workFlowItems)) {
            data["workFlowItems"] = [];
            for (let item of this.workFlowItems)
                data["workFlowItems"].push(item.toJSON());
        }
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["workFlowString"] = this.workFlowString;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveWorkFlow {
        const json = this.toJSON();
        let result = new LeaveWorkFlow();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlow {
    departmentID: number;
    workFlowName: string | undefined;
    workFlowItems: LeaveWorkFlowItem[] | undefined;
    department: Department;
    workFlowString: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveWorkFlowItem implements ILeaveWorkFlowItem {
    stepName!: string | undefined;
    jobRoleID!: number;
    leaveWorkFlowID!: number;
    rank!: number;
    isFinalApproval!: boolean;
    recipientName!: string | undefined;
    jobRole!: JobRole;
    leaveWorkFlow!: LeaveWorkFlow;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveWorkFlowItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stepName = _data["stepName"];
            this.jobRoleID = _data["jobRoleID"];
            this.leaveWorkFlowID = _data["leaveWorkFlowID"];
            this.rank = _data["rank"];
            this.isFinalApproval = _data["isFinalApproval"];
            this.recipientName = _data["recipientName"];
            this.jobRole = _data["jobRole"] ? JobRole.fromJS(_data["jobRole"]) : <any>undefined;
            this.leaveWorkFlow = _data["leaveWorkFlow"] ? LeaveWorkFlow.fromJS(_data["leaveWorkFlow"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowItem {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stepName"] = this.stepName;
        data["jobRoleID"] = this.jobRoleID;
        data["leaveWorkFlowID"] = this.leaveWorkFlowID;
        data["rank"] = this.rank;
        data["isFinalApproval"] = this.isFinalApproval;
        data["recipientName"] = this.recipientName;
        data["jobRole"] = this.jobRole ? this.jobRole.toJSON() : <any>undefined;
        data["leaveWorkFlow"] = this.leaveWorkFlow ? this.leaveWorkFlow.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveWorkFlowItem {
        const json = this.toJSON();
        let result = new LeaveWorkFlowItem();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowItem {
    stepName: string | undefined;
    jobRoleID: number;
    leaveWorkFlowID: number;
    rank: number;
    isFinalApproval: boolean;
    recipientName: string | undefined;
    jobRole: JobRole;
    leaveWorkFlow: LeaveWorkFlow;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveWorkFlowResource implements ILeaveWorkFlowResource {
    departmentID!: number;
    workFlowName!: string | undefined;
    workFlowItems!: LeaveWorkFlowItem[] | undefined;
    department!: Department;
    workFlowString!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;

    constructor(data?: ILeaveWorkFlowResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentID = _data["departmentID"];
            this.workFlowName = _data["workFlowName"];
            if (Array.isArray(_data["workFlowItems"])) {
                this.workFlowItems = [] as any;
                for (let item of _data["workFlowItems"])
                    this.workFlowItems!.push(LeaveWorkFlowItem.fromJS(item));
            }
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.workFlowString = _data["workFlowString"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowResource {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentID"] = this.departmentID;
        data["workFlowName"] = this.workFlowName;
        if (Array.isArray(this.workFlowItems)) {
            data["workFlowItems"] = [];
            for (let item of this.workFlowItems)
                data["workFlowItems"].push(item.toJSON());
        }
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["workFlowString"] = this.workFlowString;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        return data; 
    }

    clone(): LeaveWorkFlowResource {
        const json = this.toJSON();
        let result = new LeaveWorkFlowResource();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowResource {
    departmentID: number;
    workFlowName: string | undefined;
    workFlowItems: LeaveWorkFlowItem[] | undefined;
    department: Department;
    workFlowString: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
}

export class LeaveWorkFlowResourceListApiResult implements ILeaveWorkFlowResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveWorkFlowResource[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveWorkFlowResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveWorkFlowResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveWorkFlowResourceListApiResult {
        const json = this.toJSON();
        let result = new LeaveWorkFlowResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveWorkFlowResource[] | undefined;
    totalCount: number;
}

export class LeaveWorkFlowResourceApiResult implements ILeaveWorkFlowResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveWorkFlowResource;
    totalCount!: number;

    constructor(data?: ILeaveWorkFlowResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveWorkFlowResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveWorkFlowResourceApiResult {
        const json = this.toJSON();
        let result = new LeaveWorkFlowResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveWorkFlowResource;
    totalCount: number;
}

export class LeaveworkFlowPayload implements ILeaveworkFlowPayload {
    leaveWorkFlowID!: number;
    departmentID!: number;
    workFlowName!: string;
    workFlowString!: string;

    constructor(data?: ILeaveworkFlowPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leaveWorkFlowID = _data["leaveWorkFlowID"];
            this.departmentID = _data["departmentID"];
            this.workFlowName = _data["workFlowName"];
            this.workFlowString = _data["workFlowString"];
        }
    }

    static fromJS(data: any): LeaveworkFlowPayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveworkFlowPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaveWorkFlowID"] = this.leaveWorkFlowID;
        data["departmentID"] = this.departmentID;
        data["workFlowName"] = this.workFlowName;
        data["workFlowString"] = this.workFlowString;
        return data; 
    }

    clone(): LeaveworkFlowPayload {
        const json = this.toJSON();
        let result = new LeaveworkFlowPayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveworkFlowPayload {
    leaveWorkFlowID: number;
    departmentID: number;
    workFlowName: string;
    workFlowString: string;
}

export class LeaveYearDTO implements ILeaveYearDTO {
    yearName!: string | undefined;
    isActiveYear!: boolean;
    yearStartDate!: Date;
    yearEndDate!: Date;
    log_status!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    create_contextyId!: number;
    dateModified!: Date | undefined;
    modifie_contextyId!: number | undefined;

    constructor(data?: ILeaveYearDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.yearName = _data["yearName"];
            this.isActiveYear = _data["isActiveYear"];
            this.yearStartDate = _data["yearStartDate"] ? new Date(_data["yearStartDate"].toString()) : <any>undefined;
            this.yearEndDate = _data["yearEndDate"] ? new Date(_data["yearEndDate"].toString()) : <any>undefined;
            this.log_status = _data["log_status"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.create_contextyId = _data["create_contextyId"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifie_contextyId = _data["modifie_contextyId"];
        }
    }

    static fromJS(data: any): LeaveYearDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yearName"] = this.yearName;
        data["isActiveYear"] = this.isActiveYear;
        data["yearStartDate"] = this.yearStartDate ? this.yearStartDate.toISOString() : <any>undefined;
        data["yearEndDate"] = this.yearEndDate ? this.yearEndDate.toISOString() : <any>undefined;
        data["log_status"] = this.log_status;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["create_contextyId"] = this.create_contextyId;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifie_contextyId"] = this.modifie_contextyId;
        return data; 
    }

    clone(): LeaveYearDTO {
        const json = this.toJSON();
        let result = new LeaveYearDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearDTO {
    yearName: string | undefined;
    isActiveYear: boolean;
    yearStartDate: Date;
    yearEndDate: Date;
    log_status: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    create_contextyId: number;
    dateModified: Date | undefined;
    modifie_contextyId: number | undefined;
}

export class LeaveYearDTOListApiResult implements ILeaveYearDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveYearDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveYearDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveYearDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveYearDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveYearDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveYearDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveYearDTO[] | undefined;
    totalCount: number;
}

export class LeaveYearCreatePayload implements ILeaveYearCreatePayload {
    yearName!: string;
    isActiveYear!: boolean;
    yearStartDate!: Date;
    yearEndDate!: Date;

    constructor(data?: ILeaveYearCreatePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.yearName = _data["yearName"];
            this.isActiveYear = _data["isActiveYear"];
            this.yearStartDate = _data["yearStartDate"] ? new Date(_data["yearStartDate"].toString()) : <any>undefined;
            this.yearEndDate = _data["yearEndDate"] ? new Date(_data["yearEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LeaveYearCreatePayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearCreatePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yearName"] = this.yearName;
        data["isActiveYear"] = this.isActiveYear;
        data["yearStartDate"] = this.yearStartDate ? this.yearStartDate.toISOString() : <any>undefined;
        data["yearEndDate"] = this.yearEndDate ? this.yearEndDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): LeaveYearCreatePayload {
        const json = this.toJSON();
        let result = new LeaveYearCreatePayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearCreatePayload {
    yearName: string;
    isActiveYear: boolean;
    yearStartDate: Date;
    yearEndDate: Date;
}

export class LeaveYearDTOApiResult implements ILeaveYearDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveYearDTO;
    totalCount!: number;

    constructor(data?: ILeaveYearDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveYearDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveYearDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveYearDTOApiResult {
        const json = this.toJSON();
        let result = new LeaveYearDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveYearDTO;
    totalCount: number;
}

export class LoanRequestDTO implements ILoanRequestDTO {
    id!: number;
    loanTypeId!: number;
    refNo!: string | undefined;
    employeeNo!: string | undefined;
    employeeName!: string | undefined;
    loanTypeName!: string | undefined;
    employeeId!: number;
    log_status!: number;
    is_disbursed!: boolean;
    is_active!: boolean;
    amount!: number;
    tenor!: number;
    totalPrincipalRepaid!: number;
    approvalProcessId!: number;
    requestedTenor!: number;
    approvedTenor!: number;
    strRequestedAmount!: string | undefined;
    strEffectiveDate!: string | undefined;
    tempRef!: string | undefined;
    strApprovedAmount!: string | undefined;
    strMaturityDate!: string | undefined;
    _ServerDocURL!: string | undefined;
    strGuarantorIds!: string | undefined;
    effectiveDate!: Date | undefined;
    outstandingPrincipal!: number;
    outstandingInterest!: number;
    requestedAmount!: number;
    approvedAmount!: number;
    autoDeduction!: boolean;
    customAnswer!: string | undefined;
    loggedForEmployeeId!: string | undefined;
    justification!: string | undefined;
    submittedByUserId!: number;

    constructor(data?: ILoanRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.loanTypeId = _data["loanTypeId"];
            this.refNo = _data["refNo"];
            this.employeeNo = _data["employeeNo"];
            this.employeeName = _data["employeeName"];
            this.loanTypeName = _data["loanTypeName"];
            this.employeeId = _data["employeeId"];
            this.log_status = _data["log_status"];
            this.is_disbursed = _data["is_disbursed"];
            this.is_active = _data["is_active"];
            this.amount = _data["amount"];
            this.tenor = _data["tenor"];
            this.totalPrincipalRepaid = _data["totalPrincipalRepaid"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.requestedTenor = _data["requestedTenor"];
            this.approvedTenor = _data["approvedTenor"];
            this.strRequestedAmount = _data["strRequestedAmount"];
            this.strEffectiveDate = _data["strEffectiveDate"];
            this.tempRef = _data["tempRef"];
            this.strApprovedAmount = _data["strApprovedAmount"];
            this.strMaturityDate = _data["strMaturityDate"];
            this._ServerDocURL = _data["_ServerDocURL"];
            this.strGuarantorIds = _data["strGuarantorIds"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.outstandingPrincipal = _data["outstandingPrincipal"];
            this.outstandingInterest = _data["outstandingInterest"];
            this.requestedAmount = _data["requestedAmount"];
            this.approvedAmount = _data["approvedAmount"];
            this.autoDeduction = _data["autoDeduction"];
            this.customAnswer = _data["customAnswer"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.justification = _data["justification"];
            this.submittedByUserId = _data["submittedByUserId"];
        }
    }

    static fromJS(data: any): LoanRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["loanTypeId"] = this.loanTypeId;
        data["refNo"] = this.refNo;
        data["employeeNo"] = this.employeeNo;
        data["employeeName"] = this.employeeName;
        data["loanTypeName"] = this.loanTypeName;
        data["employeeId"] = this.employeeId;
        data["log_status"] = this.log_status;
        data["is_disbursed"] = this.is_disbursed;
        data["is_active"] = this.is_active;
        data["amount"] = this.amount;
        data["tenor"] = this.tenor;
        data["totalPrincipalRepaid"] = this.totalPrincipalRepaid;
        data["approvalProcessId"] = this.approvalProcessId;
        data["requestedTenor"] = this.requestedTenor;
        data["approvedTenor"] = this.approvedTenor;
        data["strRequestedAmount"] = this.strRequestedAmount;
        data["strEffectiveDate"] = this.strEffectiveDate;
        data["tempRef"] = this.tempRef;
        data["strApprovedAmount"] = this.strApprovedAmount;
        data["strMaturityDate"] = this.strMaturityDate;
        data["_ServerDocURL"] = this._ServerDocURL;
        data["strGuarantorIds"] = this.strGuarantorIds;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["outstandingPrincipal"] = this.outstandingPrincipal;
        data["outstandingInterest"] = this.outstandingInterest;
        data["requestedAmount"] = this.requestedAmount;
        data["approvedAmount"] = this.approvedAmount;
        data["autoDeduction"] = this.autoDeduction;
        data["customAnswer"] = this.customAnswer;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["justification"] = this.justification;
        data["submittedByUserId"] = this.submittedByUserId;
        return data; 
    }

    clone(): LoanRequestDTO {
        const json = this.toJSON();
        let result = new LoanRequestDTO();
        result.init(json);
        return result;
    }
}

export interface ILoanRequestDTO {
    id: number;
    loanTypeId: number;
    refNo: string | undefined;
    employeeNo: string | undefined;
    employeeName: string | undefined;
    loanTypeName: string | undefined;
    employeeId: number;
    log_status: number;
    is_disbursed: boolean;
    is_active: boolean;
    amount: number;
    tenor: number;
    totalPrincipalRepaid: number;
    approvalProcessId: number;
    requestedTenor: number;
    approvedTenor: number;
    strRequestedAmount: string | undefined;
    strEffectiveDate: string | undefined;
    tempRef: string | undefined;
    strApprovedAmount: string | undefined;
    strMaturityDate: string | undefined;
    _ServerDocURL: string | undefined;
    strGuarantorIds: string | undefined;
    effectiveDate: Date | undefined;
    outstandingPrincipal: number;
    outstandingInterest: number;
    requestedAmount: number;
    approvedAmount: number;
    autoDeduction: boolean;
    customAnswer: string | undefined;
    loggedForEmployeeId: string | undefined;
    justification: string | undefined;
    submittedByUserId: number;
}

export class PostLoanDto implements IPostLoanDto {
    loan_id!: number;
    repaymentcomment!: string | undefined;
    repaymenttotalamt!: string | undefined;
    repaymenttype!: string | undefined;
    partamt!: string | undefined;
    repytdate!: string | undefined;

    constructor(data?: IPostLoanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loan_id = _data["loan_id"];
            this.repaymentcomment = _data["repaymentcomment"];
            this.repaymenttotalamt = _data["repaymenttotalamt"];
            this.repaymenttype = _data["repaymenttype"];
            this.partamt = _data["partamt"];
            this.repytdate = _data["repytdate"];
        }
    }

    static fromJS(data: any): PostLoanDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostLoanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loan_id"] = this.loan_id;
        data["repaymentcomment"] = this.repaymentcomment;
        data["repaymenttotalamt"] = this.repaymenttotalamt;
        data["repaymenttype"] = this.repaymenttype;
        data["partamt"] = this.partamt;
        data["repytdate"] = this.repytdate;
        return data; 
    }

    clone(): PostLoanDto {
        const json = this.toJSON();
        let result = new PostLoanDto();
        result.init(json);
        return result;
    }
}

export interface IPostLoanDto {
    loan_id: number;
    repaymentcomment: string | undefined;
    repaymenttotalamt: string | undefined;
    repaymenttype: string | undefined;
    partamt: string | undefined;
    repytdate: string | undefined;
}

export class LoanRepaymentLog implements ILoanRepaymentLog {
    id!: number;
    loanRequestId!: number;
    amountRepaid!: number;
    principalRepayment!: number;
    interestRepayment!: number;
    repaymentDate!: Date;
    repaymentType!: string | undefined;
    comment!: string | undefined;
    isSchedule!: boolean;
    strRepaymentDate!: string | undefined;

    constructor(data?: ILoanRepaymentLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.loanRequestId = _data["loanRequestId"];
            this.amountRepaid = _data["amountRepaid"];
            this.principalRepayment = _data["principalRepayment"];
            this.interestRepayment = _data["interestRepayment"];
            this.repaymentDate = _data["repaymentDate"] ? new Date(_data["repaymentDate"].toString()) : <any>undefined;
            this.repaymentType = _data["repaymentType"];
            this.comment = _data["comment"];
            this.isSchedule = _data["isSchedule"];
            this.strRepaymentDate = _data["strRepaymentDate"];
        }
    }

    static fromJS(data: any): LoanRepaymentLog {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRepaymentLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["loanRequestId"] = this.loanRequestId;
        data["amountRepaid"] = this.amountRepaid;
        data["principalRepayment"] = this.principalRepayment;
        data["interestRepayment"] = this.interestRepayment;
        data["repaymentDate"] = this.repaymentDate ? this.repaymentDate.toISOString() : <any>undefined;
        data["repaymentType"] = this.repaymentType;
        data["comment"] = this.comment;
        data["isSchedule"] = this.isSchedule;
        data["strRepaymentDate"] = this.strRepaymentDate;
        return data; 
    }

    clone(): LoanRepaymentLog {
        const json = this.toJSON();
        let result = new LoanRepaymentLog();
        result.init(json);
        return result;
    }
}

export interface ILoanRepaymentLog {
    id: number;
    loanRequestId: number;
    amountRepaid: number;
    principalRepayment: number;
    interestRepayment: number;
    repaymentDate: Date;
    repaymentType: string | undefined;
    comment: string | undefined;
    isSchedule: boolean;
    strRepaymentDate: string | undefined;
}

export class LoanRepaymentLogIListApiResult implements ILoanRepaymentLogIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanRepaymentLog[] | undefined;
    totalCount!: number;

    constructor(data?: ILoanRepaymentLogIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LoanRepaymentLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LoanRepaymentLogIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRepaymentLogIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LoanRepaymentLogIListApiResult {
        const json = this.toJSON();
        let result = new LoanRepaymentLogIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanRepaymentLogIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanRepaymentLog[] | undefined;
    totalCount: number;
}

export class LoanRequestDTOIListApiResult implements ILoanRequestDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanRequestDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILoanRequestDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LoanRequestDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LoanRequestDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequestDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LoanRequestDTOIListApiResult {
        const json = this.toJSON();
        let result = new LoanRequestDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanRequestDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanRequestDTO[] | undefined;
    totalCount: number;
}

export class IdNameObj implements IIdNameObj {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: IIdNameObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameObj {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }

    clone(): IdNameObj {
        const json = this.toJSON();
        let result = new IdNameObj();
        result.init(json);
        return result;
    }
}

export interface IIdNameObj {
    id: number;
    code: string | undefined;
    name: string | undefined;
}

export class IdNameObjIListApiResult implements IIdNameObjIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: IdNameObj[] | undefined;
    totalCount!: number;

    constructor(data?: IIdNameObjIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(IdNameObj.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): IdNameObjIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameObjIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): IdNameObjIListApiResult {
        const json = this.toJSON();
        let result = new IdNameObjIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IIdNameObjIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: IdNameObj[] | undefined;
    totalCount: number;
}

export class UpdateLoadRequestDTO implements IUpdateLoadRequestDTO {
    effective_date!: string | undefined;
    loan_id!: number;
    approved_tenor!: string | undefined;
    approved_amt!: string | undefined;

    constructor(data?: IUpdateLoadRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.effective_date = _data["effective_date"];
            this.loan_id = _data["loan_id"];
            this.approved_tenor = _data["approved_tenor"];
            this.approved_amt = _data["approved_amt"];
        }
    }

    static fromJS(data: any): UpdateLoadRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLoadRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["effective_date"] = this.effective_date;
        data["loan_id"] = this.loan_id;
        data["approved_tenor"] = this.approved_tenor;
        data["approved_amt"] = this.approved_amt;
        return data; 
    }

    clone(): UpdateLoadRequestDTO {
        const json = this.toJSON();
        let result = new UpdateLoadRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IUpdateLoadRequestDTO {
    effective_date: string | undefined;
    loan_id: number;
    approved_tenor: string | undefined;
    approved_amt: string | undefined;
}

export class LoanRequest implements ILoanRequest {
    loanTypeId!: number;
    submittedByUserId!: number;
    loggedForEmployeeId!: number;
    refNo!: string | undefined;
    interestRate!: number;
    requestedAmount!: number;
    approvalProcessId!: number;
    interestType!: number;
    requestedTenor!: number;
    approvedTenor!: number;
    approvedAmount!: number;
    totalPrincipalRepaid!: number;
    totalInterestRepaid!: number;
    totalAmountRepaid!: number;
    lastRepaymentDate!: Date | undefined;
    effectiveDate!: Date | undefined;
    dateApproved!: Date | undefined;
    customAnswer!: string | undefined;
    justification!: string | undefined;
    log_status!: number;
    is_disbursed!: boolean;
    date_disbursed!: Date | undefined;
    autoDeduction!: boolean;
    maxLoanRepaytPercent!: number;
    maxLoanRepaytAmount!: number;
    is_repaid!: boolean;
    disbursementdetails!: string | undefined;
    disburseby!: string | undefined;
    disbursementType!: number | undefined;
    employeeNo!: string | undefined;
    employeeName!: string | undefined;
    loanTypeName!: string | undefined;
    strRequestedAmount!: string | undefined;
    strEffectiveDate!: string | undefined;
    tempRef!: string | undefined;
    strApprovedAmount!: string | undefined;
    strMaturityDate!: string | undefined;
    _ServerDocURL!: string | undefined;
    strGuarantorIds!: string | undefined;
    outstandingPrincipal!: number;
    outstandingInterest!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILoanRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loanTypeId = _data["loanTypeId"];
            this.submittedByUserId = _data["submittedByUserId"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.refNo = _data["refNo"];
            this.interestRate = _data["interestRate"];
            this.requestedAmount = _data["requestedAmount"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.interestType = _data["interestType"];
            this.requestedTenor = _data["requestedTenor"];
            this.approvedTenor = _data["approvedTenor"];
            this.approvedAmount = _data["approvedAmount"];
            this.totalPrincipalRepaid = _data["totalPrincipalRepaid"];
            this.totalInterestRepaid = _data["totalInterestRepaid"];
            this.totalAmountRepaid = _data["totalAmountRepaid"];
            this.lastRepaymentDate = _data["lastRepaymentDate"] ? new Date(_data["lastRepaymentDate"].toString()) : <any>undefined;
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.customAnswer = _data["customAnswer"];
            this.justification = _data["justification"];
            this.log_status = _data["log_status"];
            this.is_disbursed = _data["is_disbursed"];
            this.date_disbursed = _data["date_disbursed"] ? new Date(_data["date_disbursed"].toString()) : <any>undefined;
            this.autoDeduction = _data["autoDeduction"];
            this.maxLoanRepaytPercent = _data["maxLoanRepaytPercent"];
            this.maxLoanRepaytAmount = _data["maxLoanRepaytAmount"];
            this.is_repaid = _data["is_repaid"];
            this.disbursementdetails = _data["disbursementdetails"];
            this.disburseby = _data["disburseby"];
            this.disbursementType = _data["disbursementType"];
            this.employeeNo = _data["employeeNo"];
            this.employeeName = _data["employeeName"];
            this.loanTypeName = _data["loanTypeName"];
            this.strRequestedAmount = _data["strRequestedAmount"];
            this.strEffectiveDate = _data["strEffectiveDate"];
            this.tempRef = _data["tempRef"];
            this.strApprovedAmount = _data["strApprovedAmount"];
            this.strMaturityDate = _data["strMaturityDate"];
            this._ServerDocURL = _data["_ServerDocURL"];
            this.strGuarantorIds = _data["strGuarantorIds"];
            this.outstandingPrincipal = _data["outstandingPrincipal"];
            this.outstandingInterest = _data["outstandingInterest"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LoanRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loanTypeId"] = this.loanTypeId;
        data["submittedByUserId"] = this.submittedByUserId;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["refNo"] = this.refNo;
        data["interestRate"] = this.interestRate;
        data["requestedAmount"] = this.requestedAmount;
        data["approvalProcessId"] = this.approvalProcessId;
        data["interestType"] = this.interestType;
        data["requestedTenor"] = this.requestedTenor;
        data["approvedTenor"] = this.approvedTenor;
        data["approvedAmount"] = this.approvedAmount;
        data["totalPrincipalRepaid"] = this.totalPrincipalRepaid;
        data["totalInterestRepaid"] = this.totalInterestRepaid;
        data["totalAmountRepaid"] = this.totalAmountRepaid;
        data["lastRepaymentDate"] = this.lastRepaymentDate ? this.lastRepaymentDate.toISOString() : <any>undefined;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["customAnswer"] = this.customAnswer;
        data["justification"] = this.justification;
        data["log_status"] = this.log_status;
        data["is_disbursed"] = this.is_disbursed;
        data["date_disbursed"] = this.date_disbursed ? this.date_disbursed.toISOString() : <any>undefined;
        data["autoDeduction"] = this.autoDeduction;
        data["maxLoanRepaytPercent"] = this.maxLoanRepaytPercent;
        data["maxLoanRepaytAmount"] = this.maxLoanRepaytAmount;
        data["is_repaid"] = this.is_repaid;
        data["disbursementdetails"] = this.disbursementdetails;
        data["disburseby"] = this.disburseby;
        data["disbursementType"] = this.disbursementType;
        data["employeeNo"] = this.employeeNo;
        data["employeeName"] = this.employeeName;
        data["loanTypeName"] = this.loanTypeName;
        data["strRequestedAmount"] = this.strRequestedAmount;
        data["strEffectiveDate"] = this.strEffectiveDate;
        data["tempRef"] = this.tempRef;
        data["strApprovedAmount"] = this.strApprovedAmount;
        data["strMaturityDate"] = this.strMaturityDate;
        data["_ServerDocURL"] = this._ServerDocURL;
        data["strGuarantorIds"] = this.strGuarantorIds;
        data["outstandingPrincipal"] = this.outstandingPrincipal;
        data["outstandingInterest"] = this.outstandingInterest;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LoanRequest {
        const json = this.toJSON();
        let result = new LoanRequest();
        result.init(json);
        return result;
    }
}

export interface ILoanRequest {
    loanTypeId: number;
    submittedByUserId: number;
    loggedForEmployeeId: number;
    refNo: string | undefined;
    interestRate: number;
    requestedAmount: number;
    approvalProcessId: number;
    interestType: number;
    requestedTenor: number;
    approvedTenor: number;
    approvedAmount: number;
    totalPrincipalRepaid: number;
    totalInterestRepaid: number;
    totalAmountRepaid: number;
    lastRepaymentDate: Date | undefined;
    effectiveDate: Date | undefined;
    dateApproved: Date | undefined;
    customAnswer: string | undefined;
    justification: string | undefined;
    log_status: number;
    is_disbursed: boolean;
    date_disbursed: Date | undefined;
    autoDeduction: boolean;
    maxLoanRepaytPercent: number;
    maxLoanRepaytAmount: number;
    is_repaid: boolean;
    disbursementdetails: string | undefined;
    disburseby: string | undefined;
    disbursementType: number | undefined;
    employeeNo: string | undefined;
    employeeName: string | undefined;
    loanTypeName: string | undefined;
    strRequestedAmount: string | undefined;
    strEffectiveDate: string | undefined;
    tempRef: string | undefined;
    strApprovedAmount: string | undefined;
    strMaturityDate: string | undefined;
    _ServerDocURL: string | undefined;
    strGuarantorIds: string | undefined;
    outstandingPrincipal: number;
    outstandingInterest: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LoanRequestApiResult implements ILoanRequestApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanRequest;
    totalCount!: number;

    constructor(data?: ILoanRequestApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LoanRequest.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LoanRequestApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequestApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LoanRequestApiResult {
        const json = this.toJSON();
        let result = new LoanRequestApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanRequestApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanRequest;
    totalCount: number;
}

export class LoanTypeDTO implements ILoanTypeDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    code!: string | undefined;
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    approvalProcessId!: number;
    interestRate!: number;
    minTenor!: number;
    maxTenor!: number;
    minAmount!: number;
    maxAmount!: number;
    interestType!: number;
    requiresGuarantor!: boolean;
    requiredNoOfGuarantors!: number;
    eligibleGrades!: string | undefined;
    eligibleEmploymentStatus!: number;
    customQuestion!: string | undefined;
    maxLoanRepaytPercent!: number;
    strMinAmount!: string | undefined;
    strMaxAmount!: string | undefined;
    strRequiresGuarantor!: string | undefined;

    constructor(data?: ILoanTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.code = _data["code"];
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.interestRate = _data["interestRate"];
            this.minTenor = _data["minTenor"];
            this.maxTenor = _data["maxTenor"];
            this.minAmount = _data["minAmount"];
            this.maxAmount = _data["maxAmount"];
            this.interestType = _data["interestType"];
            this.requiresGuarantor = _data["requiresGuarantor"];
            this.requiredNoOfGuarantors = _data["requiredNoOfGuarantors"];
            this.eligibleGrades = _data["eligibleGrades"];
            this.eligibleEmploymentStatus = _data["eligibleEmploymentStatus"];
            this.customQuestion = _data["customQuestion"];
            this.maxLoanRepaytPercent = _data["maxLoanRepaytPercent"];
            this.strMinAmount = _data["strMinAmount"];
            this.strMaxAmount = _data["strMaxAmount"];
            this.strRequiresGuarantor = _data["strRequiresGuarantor"];
        }
    }

    static fromJS(data: any): LoanTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoanTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["code"] = this.code;
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["approvalProcessId"] = this.approvalProcessId;
        data["interestRate"] = this.interestRate;
        data["minTenor"] = this.minTenor;
        data["maxTenor"] = this.maxTenor;
        data["minAmount"] = this.minAmount;
        data["maxAmount"] = this.maxAmount;
        data["interestType"] = this.interestType;
        data["requiresGuarantor"] = this.requiresGuarantor;
        data["requiredNoOfGuarantors"] = this.requiredNoOfGuarantors;
        data["eligibleGrades"] = this.eligibleGrades;
        data["eligibleEmploymentStatus"] = this.eligibleEmploymentStatus;
        data["customQuestion"] = this.customQuestion;
        data["maxLoanRepaytPercent"] = this.maxLoanRepaytPercent;
        data["strMinAmount"] = this.strMinAmount;
        data["strMaxAmount"] = this.strMaxAmount;
        data["strRequiresGuarantor"] = this.strRequiresGuarantor;
        return data; 
    }

    clone(): LoanTypeDTO {
        const json = this.toJSON();
        let result = new LoanTypeDTO();
        result.init(json);
        return result;
    }
}

export interface ILoanTypeDTO {
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    code: string | undefined;
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    approvalProcessId: number;
    interestRate: number;
    minTenor: number;
    maxTenor: number;
    minAmount: number;
    maxAmount: number;
    interestType: number;
    requiresGuarantor: boolean;
    requiredNoOfGuarantors: number;
    eligibleGrades: string | undefined;
    eligibleEmploymentStatus: number;
    customQuestion: string | undefined;
    maxLoanRepaytPercent: number;
    strMinAmount: string | undefined;
    strMaxAmount: string | undefined;
    strRequiresGuarantor: string | undefined;
}

export class LoadTypeById implements ILoadTypeById {
    id!: number;
    companyID!: number;

    constructor(data?: ILoadTypeById) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
        }
    }

    static fromJS(data: any): LoadTypeById {
        data = typeof data === 'object' ? data : {};
        let result = new LoadTypeById();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        return data; 
    }

    clone(): LoadTypeById {
        const json = this.toJSON();
        let result = new LoadTypeById();
        result.init(json);
        return result;
    }
}

export interface ILoadTypeById {
    id: number;
    companyID: number;
}

export class LoanType implements ILoanType {
    code!: string | undefined;
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    approvalProcessId!: number;
    interestRate!: number;
    minTenor!: number;
    maxTenor!: number;
    minAmount!: number;
    maxAmount!: number;
    interestType!: number;
    requiresGuarantor!: boolean;
    requiredNoOfGuarantors!: number;
    eligibleGrades!: string | undefined;
    eligibleEmploymentStatus!: number;
    customQuestion!: string | undefined;
    maxLoanRepaytPercent!: number;
    strMinAmount!: string | undefined;
    strMaxAmount!: string | undefined;
    strRequiresGuarantor!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILoanType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.interestRate = _data["interestRate"];
            this.minTenor = _data["minTenor"];
            this.maxTenor = _data["maxTenor"];
            this.minAmount = _data["minAmount"];
            this.maxAmount = _data["maxAmount"];
            this.interestType = _data["interestType"];
            this.requiresGuarantor = _data["requiresGuarantor"];
            this.requiredNoOfGuarantors = _data["requiredNoOfGuarantors"];
            this.eligibleGrades = _data["eligibleGrades"];
            this.eligibleEmploymentStatus = _data["eligibleEmploymentStatus"];
            this.customQuestion = _data["customQuestion"];
            this.maxLoanRepaytPercent = _data["maxLoanRepaytPercent"];
            this.strMinAmount = _data["strMinAmount"];
            this.strMaxAmount = _data["strMaxAmount"];
            this.strRequiresGuarantor = _data["strRequiresGuarantor"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LoanType {
        data = typeof data === 'object' ? data : {};
        let result = new LoanType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["approvalProcessId"] = this.approvalProcessId;
        data["interestRate"] = this.interestRate;
        data["minTenor"] = this.minTenor;
        data["maxTenor"] = this.maxTenor;
        data["minAmount"] = this.minAmount;
        data["maxAmount"] = this.maxAmount;
        data["interestType"] = this.interestType;
        data["requiresGuarantor"] = this.requiresGuarantor;
        data["requiredNoOfGuarantors"] = this.requiredNoOfGuarantors;
        data["eligibleGrades"] = this.eligibleGrades;
        data["eligibleEmploymentStatus"] = this.eligibleEmploymentStatus;
        data["customQuestion"] = this.customQuestion;
        data["maxLoanRepaytPercent"] = this.maxLoanRepaytPercent;
        data["strMinAmount"] = this.strMinAmount;
        data["strMaxAmount"] = this.strMaxAmount;
        data["strRequiresGuarantor"] = this.strRequiresGuarantor;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LoanType {
        const json = this.toJSON();
        let result = new LoanType();
        result.init(json);
        return result;
    }
}

export interface ILoanType {
    code: string | undefined;
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    approvalProcessId: number;
    interestRate: number;
    minTenor: number;
    maxTenor: number;
    minAmount: number;
    maxAmount: number;
    interestType: number;
    requiresGuarantor: boolean;
    requiredNoOfGuarantors: number;
    eligibleGrades: string | undefined;
    eligibleEmploymentStatus: number;
    customQuestion: string | undefined;
    maxLoanRepaytPercent: number;
    strMinAmount: string | undefined;
    strMaxAmount: string | undefined;
    strRequiresGuarantor: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LoanTypeIListApiResult implements ILoanTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanType[] | undefined;
    totalCount!: number;

    constructor(data?: ILoanTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LoanType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LoanTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LoanTypeIListApiResult {
        const json = this.toJSON();
        let result = new LoanTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanType[] | undefined;
    totalCount: number;
}

export class ApplicationRoleDTO implements IApplicationRoleDTO {
    id!: number;
    name!: string;
    description!: string | undefined;
    isSystemRole!: boolean;

    constructor(data?: IApplicationRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isSystemRole = _data["isSystemRole"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isSystemRole"] = this.isSystemRole;
        return data; 
    }

    clone(): ApplicationRoleDTO {
        const json = this.toJSON();
        let result = new ApplicationRoleDTO();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTO {
    id: number;
    name: string;
    description: string | undefined;
    isSystemRole: boolean;
}

export class ApplicationRoleDTOIListApiResult implements IApplicationRoleDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationRoleDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IApplicationRoleDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApplicationRoleDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApplicationRoleDTOIListApiResult {
        const json = this.toJSON();
        let result = new ApplicationRoleDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationRoleDTO[] | undefined;
    totalCount: number;
}

export class ApplicationRoleDTOApiResult implements IApplicationRoleDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationRoleDTO;
    totalCount!: number;

    constructor(data?: IApplicationRoleDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? ApplicationRoleDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApplicationRoleDTOApiResult {
        const json = this.toJSON();
        let result = new ApplicationRoleDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationRoleDTO;
    totalCount: number;
}

export class PermissionDTO implements IPermissionDTO {
    id!: number;
    name!: string | undefined;
    applicationName!: string | undefined;
    code!: string | undefined;

    constructor(data?: IPermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.applicationName = _data["applicationName"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): PermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["applicationName"] = this.applicationName;
        data["code"] = this.code;
        return data; 
    }

    clone(): PermissionDTO {
        const json = this.toJSON();
        let result = new PermissionDTO();
        result.init(json);
        return result;
    }
}

export interface IPermissionDTO {
    id: number;
    name: string | undefined;
    applicationName: string | undefined;
    code: string | undefined;
}

export class RolePermissionDTO implements IRolePermissionDTO {
    roleId!: number;
    roleName!: string | undefined;
    permissions!: PermissionDTO[] | undefined;

    constructor(data?: IRolePermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolePermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RolePermissionDTO {
        const json = this.toJSON();
        let result = new RolePermissionDTO();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTO {
    roleId: number;
    roleName: string | undefined;
    permissions: PermissionDTO[] | undefined;
}

export class RolePermissionDTOIListApiResult implements IRolePermissionDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RolePermissionDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IRolePermissionDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RolePermissionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RolePermissionDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RolePermissionDTOIListApiResult {
        const json = this.toJSON();
        let result = new RolePermissionDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RolePermissionDTO[] | undefined;
    totalCount: number;
}

export class RolePermissionDTOApiResult implements IRolePermissionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RolePermissionDTO;
    totalCount!: number;

    constructor(data?: IRolePermissionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? RolePermissionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RolePermissionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RolePermissionDTOApiResult {
        const json = this.toJSON();
        let result = new RolePermissionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RolePermissionDTO;
    totalCount: number;
}

export class RolePermissionMappingDTO implements IRolePermissionMappingDTO {
    roleId!: number;
    permissionIds!: number[];

    constructor(data?: IRolePermissionMappingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permissionIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            if (Array.isArray(_data["permissionIds"])) {
                this.permissionIds = [] as any;
                for (let item of _data["permissionIds"])
                    this.permissionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): RolePermissionMappingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionMappingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        if (Array.isArray(this.permissionIds)) {
            data["permissionIds"] = [];
            for (let item of this.permissionIds)
                data["permissionIds"].push(item);
        }
        return data; 
    }

    clone(): RolePermissionMappingDTO {
        const json = this.toJSON();
        let result = new RolePermissionMappingDTO();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionMappingDTO {
    roleId: number;
    permissionIds: number[];
}

export class SelectListGroup implements ISelectListGroup {
    disabled!: boolean;
    name!: string | undefined;

    constructor(data?: ISelectListGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SelectListGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["name"] = this.name;
        return data; 
    }

    clone(): SelectListGroup {
        const json = this.toJSON();
        let result = new SelectListGroup();
        result.init(json);
        return result;
    }
}

export interface ISelectListGroup {
    disabled: boolean;
    name: string | undefined;
}

export class SelectListItem implements ISelectListItem {
    disabled!: boolean;
    group!: SelectListGroup;
    selected!: boolean;
    text!: string | undefined;
    value!: string | undefined;

    constructor(data?: ISelectListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.group = _data["group"] ? SelectListGroup.fromJS(_data["group"]) : <any>undefined;
            this.selected = _data["selected"];
            this.text = _data["text"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SelectListItem {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["selected"] = this.selected;
        data["text"] = this.text;
        data["value"] = this.value;
        return data; 
    }

    clone(): SelectListItem {
        const json = this.toJSON();
        let result = new SelectListItem();
        result.init(json);
        return result;
    }
}

export interface ISelectListItem {
    disabled: boolean;
    group: SelectListGroup;
    selected: boolean;
    text: string | undefined;
    value: string | undefined;
}

export class VwLocation implements IVwLocation {
    _id!: string | undefined;
    id!: number;
    company_id!: number;
    subsidiary_id!: number;
    location_name!: string;
    code!: string;
    lga_id!: number;
    lga_name!: string | undefined;
    is_enabled!: boolean;
    state_id!: number;
    state_name!: string | undefined;
    has_vacancy!: string | undefined;
    actionTitle!: string | undefined;
    states!: SelectListItem[] | undefined;
    lgas!: SelectListItem[] | undefined;

    constructor(data?: IVwLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this._id = _data["_id"];
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.subsidiary_id = _data["subsidiary_id"];
            this.location_name = _data["location_name"];
            this.code = _data["code"];
            this.lga_id = _data["lga_id"];
            this.lga_name = _data["lga_name"];
            this.is_enabled = _data["is_enabled"];
            this.state_id = _data["state_id"];
            this.state_name = _data["state_name"];
            this.has_vacancy = _data["has_vacancy"];
            this.actionTitle = _data["actionTitle"];
            if (Array.isArray(_data["states"])) {
                this.states = [] as any;
                for (let item of _data["states"])
                    this.states!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["lgas"])) {
                this.lgas = [] as any;
                for (let item of _data["lgas"])
                    this.lgas!.push(SelectListItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VwLocation {
        data = typeof data === 'object' ? data : {};
        let result = new VwLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_id"] = this._id;
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["subsidiary_id"] = this.subsidiary_id;
        data["location_name"] = this.location_name;
        data["code"] = this.code;
        data["lga_id"] = this.lga_id;
        data["lga_name"] = this.lga_name;
        data["is_enabled"] = this.is_enabled;
        data["state_id"] = this.state_id;
        data["state_name"] = this.state_name;
        data["has_vacancy"] = this.has_vacancy;
        data["actionTitle"] = this.actionTitle;
        if (Array.isArray(this.states)) {
            data["states"] = [];
            for (let item of this.states)
                data["states"].push(item.toJSON());
        }
        if (Array.isArray(this.lgas)) {
            data["lgas"] = [];
            for (let item of this.lgas)
                data["lgas"].push(item.toJSON());
        }
        return data; 
    }

    clone(): VwLocation {
        const json = this.toJSON();
        let result = new VwLocation();
        result.init(json);
        return result;
    }
}

export interface IVwLocation {
    _id: string | undefined;
    id: number;
    company_id: number;
    subsidiary_id: number;
    location_name: string;
    code: string;
    lga_id: number;
    lga_name: string | undefined;
    is_enabled: boolean;
    state_id: number;
    state_name: string | undefined;
    has_vacancy: string | undefined;
    actionTitle: string | undefined;
    states: SelectListItem[] | undefined;
    lgas: SelectListItem[] | undefined;
}

export class VwLocationIListApiResult implements IVwLocationIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwLocation[] | undefined;
    totalCount!: number;

    constructor(data?: IVwLocationIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(VwLocation.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VwLocationIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwLocationIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VwLocationIListApiResult {
        const json = this.toJSON();
        let result = new VwLocationIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwLocationIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwLocation[] | undefined;
    totalCount: number;
}

export class Location implements ILocation {
    location_name!: string;
    lga_id!: number | undefined;
    state_id!: number | undefined;
    is_enabled!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location_name = _data["location_name"];
            this.lga_id = _data["lga_id"];
            this.state_id = _data["state_id"];
            this.is_enabled = _data["is_enabled"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location_name"] = this.location_name;
        data["lga_id"] = this.lga_id;
        data["state_id"] = this.state_id;
        data["is_enabled"] = this.is_enabled;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Location {
        const json = this.toJSON();
        let result = new Location();
        result.init(json);
        return result;
    }
}

export interface ILocation {
    location_name: string;
    lga_id: number | undefined;
    state_id: number | undefined;
    is_enabled: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LocationIListApiResult implements ILocationIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Location[] | undefined;
    totalCount!: number;

    constructor(data?: ILocationIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Location.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LocationIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LocationIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LocationIListApiResult {
        const json = this.toJSON();
        let result = new LocationIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILocationIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Location[] | undefined;
    totalCount: number;
}

export class VwDepartment implements IVwDepartment {
    _id!: string | undefined;
    id!: number;
    company_id!: number;
    locationId!: number;
    subsidiary_id!: number;
    department_name!: string;
    code!: string | undefined;
    isActive!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    mdaCode!: string | undefined;
    actionTitle!: string | undefined;

    constructor(data?: IVwDepartment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this._id = _data["_id"];
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.locationId = _data["locationId"];
            this.subsidiary_id = _data["subsidiary_id"];
            this.department_name = _data["department_name"];
            this.code = _data["code"];
            this.isActive = _data["isActive"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.mdaCode = _data["mdaCode"];
            this.actionTitle = _data["actionTitle"];
        }
    }

    static fromJS(data: any): VwDepartment {
        data = typeof data === 'object' ? data : {};
        let result = new VwDepartment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_id"] = this._id;
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["locationId"] = this.locationId;
        data["subsidiary_id"] = this.subsidiary_id;
        data["department_name"] = this.department_name;
        data["code"] = this.code;
        data["isActive"] = this.isActive;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["mdaCode"] = this.mdaCode;
        data["actionTitle"] = this.actionTitle;
        return data; 
    }

    clone(): VwDepartment {
        const json = this.toJSON();
        let result = new VwDepartment();
        result.init(json);
        return result;
    }
}

export interface IVwDepartment {
    _id: string | undefined;
    id: number;
    company_id: number;
    locationId: number;
    subsidiary_id: number;
    department_name: string;
    code: string | undefined;
    isActive: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    mdaCode: string | undefined;
    actionTitle: string | undefined;
}

export class DepartmentIListApiResult implements IDepartmentIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Department[] | undefined;
    totalCount!: number;

    constructor(data?: IDepartmentIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Department.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DepartmentIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DepartmentIListApiResult {
        const json = this.toJSON();
        let result = new DepartmentIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDepartmentIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Department[] | undefined;
    totalCount: number;
}

export class VwDepartmentIListApiResult implements IVwDepartmentIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwDepartment[] | undefined;
    totalCount!: number;

    constructor(data?: IVwDepartmentIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(VwDepartment.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VwDepartmentIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwDepartmentIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VwDepartmentIListApiResult {
        const json = this.toJSON();
        let result = new VwDepartmentIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwDepartmentIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwDepartment[] | undefined;
    totalCount: number;
}

export class VwJobRole implements IVwJobRole {
    _id!: string | undefined;
    id!: number;
    companyID!: number;
    locationId!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    name!: string;
    code!: string | undefined;
    amount!: number | undefined;
    promotion_min_years!: number | undefined;
    next_job_role_id!: number;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    actionTitle!: string | undefined;
    parent_id!: number | undefined;
    mdaCode!: string | undefined;
    allJobRoles!: SelectListItem[] | undefined;

    constructor(data?: IVwJobRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this._id = _data["_id"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.locationId = _data["locationId"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.amount = _data["amount"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.next_job_role_id = _data["next_job_role_id"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.actionTitle = _data["actionTitle"];
            this.parent_id = _data["parent_id"];
            this.mdaCode = _data["mdaCode"];
            if (Array.isArray(_data["allJobRoles"])) {
                this.allJobRoles = [] as any;
                for (let item of _data["allJobRoles"])
                    this.allJobRoles!.push(SelectListItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VwJobRole {
        data = typeof data === 'object' ? data : {};
        let result = new VwJobRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_id"] = this._id;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["locationId"] = this.locationId;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["code"] = this.code;
        data["amount"] = this.amount;
        data["promotion_min_years"] = this.promotion_min_years;
        data["next_job_role_id"] = this.next_job_role_id;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["actionTitle"] = this.actionTitle;
        data["parent_id"] = this.parent_id;
        data["mdaCode"] = this.mdaCode;
        if (Array.isArray(this.allJobRoles)) {
            data["allJobRoles"] = [];
            for (let item of this.allJobRoles)
                data["allJobRoles"].push(item.toJSON());
        }
        return data; 
    }

    clone(): VwJobRole {
        const json = this.toJSON();
        let result = new VwJobRole();
        result.init(json);
        return result;
    }
}

export interface IVwJobRole {
    _id: string | undefined;
    id: number;
    companyID: number;
    locationId: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    name: string;
    code: string | undefined;
    amount: number | undefined;
    promotion_min_years: number | undefined;
    next_job_role_id: number;
    created_by: string | undefined;
    deleted_by: string | undefined;
    actionTitle: string | undefined;
    parent_id: number | undefined;
    mdaCode: string | undefined;
    allJobRoles: SelectListItem[] | undefined;
}

export class JobRoleIListApiResult implements IJobRoleIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: JobRole[] | undefined;
    totalCount!: number;

    constructor(data?: IJobRoleIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(JobRole.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): JobRoleIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobRoleIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): JobRoleIListApiResult {
        const json = this.toJSON();
        let result = new JobRoleIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IJobRoleIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: JobRole[] | undefined;
    totalCount: number;
}

export class VwJobRoleIListApiResult implements IVwJobRoleIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwJobRole[] | undefined;
    totalCount!: number;

    constructor(data?: IVwJobRoleIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(VwJobRole.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VwJobRoleIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwJobRoleIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VwJobRoleIListApiResult {
        const json = this.toJSON();
        let result = new VwJobRoleIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwJobRoleIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwJobRole[] | undefined;
    totalCount: number;
}

export class Modular implements IModular {
    id!: number;
    name!: string | undefined;
    defaultEnabled!: boolean;
    makeAvailable!: boolean;
    subscriptionPlanModules!: SubscriptionPlanModule[] | undefined;

    constructor(data?: IModular) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.defaultEnabled = _data["defaultEnabled"];
            this.makeAvailable = _data["makeAvailable"];
            if (Array.isArray(_data["subscriptionPlanModules"])) {
                this.subscriptionPlanModules = [] as any;
                for (let item of _data["subscriptionPlanModules"])
                    this.subscriptionPlanModules!.push(SubscriptionPlanModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Modular {
        data = typeof data === 'object' ? data : {};
        let result = new Modular();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["defaultEnabled"] = this.defaultEnabled;
        data["makeAvailable"] = this.makeAvailable;
        if (Array.isArray(this.subscriptionPlanModules)) {
            data["subscriptionPlanModules"] = [];
            for (let item of this.subscriptionPlanModules)
                data["subscriptionPlanModules"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Modular {
        const json = this.toJSON();
        let result = new Modular();
        result.init(json);
        return result;
    }
}

export interface IModular {
    id: number;
    name: string | undefined;
    defaultEnabled: boolean;
    makeAvailable: boolean;
    subscriptionPlanModules: SubscriptionPlanModule[] | undefined;
}

export class SubscriptionPlanModule implements ISubscriptionPlanModule {
    id!: number;
    subscriptionPlanId!: number;
    modularId!: number;
    lastDateModified!: Date | undefined;
    modularDefaultEnabled!: boolean;
    subscriptionPlan!: SubscriptionPlan;
    modular!: Modular;

    constructor(data?: ISubscriptionPlanModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.modularId = _data["modularId"];
            this.lastDateModified = _data["lastDateModified"] ? new Date(_data["lastDateModified"].toString()) : <any>undefined;
            this.modularDefaultEnabled = _data["modularDefaultEnabled"];
            this.subscriptionPlan = _data["subscriptionPlan"] ? SubscriptionPlan.fromJS(_data["subscriptionPlan"]) : <any>undefined;
            this.modular = _data["modular"] ? Modular.fromJS(_data["modular"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SubscriptionPlanModule {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["modularId"] = this.modularId;
        data["lastDateModified"] = this.lastDateModified ? this.lastDateModified.toISOString() : <any>undefined;
        data["modularDefaultEnabled"] = this.modularDefaultEnabled;
        data["subscriptionPlan"] = this.subscriptionPlan ? this.subscriptionPlan.toJSON() : <any>undefined;
        data["modular"] = this.modular ? this.modular.toJSON() : <any>undefined;
        return data; 
    }

    clone(): SubscriptionPlanModule {
        const json = this.toJSON();
        let result = new SubscriptionPlanModule();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanModule {
    id: number;
    subscriptionPlanId: number;
    modularId: number;
    lastDateModified: Date | undefined;
    modularDefaultEnabled: boolean;
    subscriptionPlan: SubscriptionPlan;
    modular: Modular;
}

export class SubscriptionPlan implements ISubscriptionPlan {
    id!: number;
    planCode!: string | undefined;
    name!: string | undefined;
    paymentUrl!: string | undefined;
    amount!: number;
    licenseCount!: number;
    created!: Date | undefined;
    modified!: Date | undefined;
    subscriptionPlanModules!: SubscriptionPlanModule[] | undefined;

    constructor(data?: ISubscriptionPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.planCode = _data["planCode"];
            this.name = _data["name"];
            this.paymentUrl = _data["paymentUrl"];
            this.amount = _data["amount"];
            this.licenseCount = _data["licenseCount"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            if (Array.isArray(_data["subscriptionPlanModules"])) {
                this.subscriptionPlanModules = [] as any;
                for (let item of _data["subscriptionPlanModules"])
                    this.subscriptionPlanModules!.push(SubscriptionPlanModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubscriptionPlan {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["planCode"] = this.planCode;
        data["name"] = this.name;
        data["paymentUrl"] = this.paymentUrl;
        data["amount"] = this.amount;
        data["licenseCount"] = this.licenseCount;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        if (Array.isArray(this.subscriptionPlanModules)) {
            data["subscriptionPlanModules"] = [];
            for (let item of this.subscriptionPlanModules)
                data["subscriptionPlanModules"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SubscriptionPlan {
        const json = this.toJSON();
        let result = new SubscriptionPlan();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlan {
    id: number;
    planCode: string | undefined;
    name: string | undefined;
    paymentUrl: string | undefined;
    amount: number;
    licenseCount: number;
    created: Date | undefined;
    modified: Date | undefined;
    subscriptionPlanModules: SubscriptionPlanModule[] | undefined;
}

export class SubscriptionPlanIListApiResult implements ISubscriptionPlanIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubscriptionPlan[] | undefined;
    totalCount!: number;

    constructor(data?: ISubscriptionPlanIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SubscriptionPlan.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SubscriptionPlanIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SubscriptionPlanIListApiResult {
        const json = this.toJSON();
        let result = new SubscriptionPlanIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubscriptionPlan[] | undefined;
    totalCount: number;
}

export class SubscriptionPlanApiResult implements ISubscriptionPlanApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubscriptionPlan;
    totalCount!: number;

    constructor(data?: ISubscriptionPlanApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? SubscriptionPlan.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SubscriptionPlanApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SubscriptionPlanApiResult {
        const json = this.toJSON();
        let result = new SubscriptionPlanApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubscriptionPlan;
    totalCount: number;
}

export class SubscriptionPlanModuleIListApiResult implements ISubscriptionPlanModuleIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubscriptionPlanModule[] | undefined;
    totalCount!: number;

    constructor(data?: ISubscriptionPlanModuleIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SubscriptionPlanModule.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SubscriptionPlanModuleIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanModuleIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SubscriptionPlanModuleIListApiResult {
        const json = this.toJSON();
        let result = new SubscriptionPlanModuleIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanModuleIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubscriptionPlanModule[] | undefined;
    totalCount: number;
}

export class CompanyDTO implements ICompanyDTO {
    name!: string;
    rcNo!: string | undefined;
    logoName!: string | undefined;
    shortText!: string | undefined;
    email!: string;
    phoneNumber!: string;
    address!: string | undefined;
    administratorEmail!: string;
    domainName!: string | undefined;
    auditorEmail!: string | undefined;
    maxEmployeeCount!: number;
    subscriptionPlanId!: number;
    password!: string | undefined;

    constructor(data?: ICompanyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.rcNo = _data["rcNo"];
            this.logoName = _data["logoName"];
            this.shortText = _data["shortText"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.administratorEmail = _data["administratorEmail"];
            this.domainName = _data["domainName"];
            this.auditorEmail = _data["auditorEmail"];
            this.maxEmployeeCount = _data["maxEmployeeCount"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CompanyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["rcNo"] = this.rcNo;
        data["logoName"] = this.logoName;
        data["shortText"] = this.shortText;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["administratorEmail"] = this.administratorEmail;
        data["domainName"] = this.domainName;
        data["auditorEmail"] = this.auditorEmail;
        data["maxEmployeeCount"] = this.maxEmployeeCount;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["password"] = this.password;
        return data; 
    }

    clone(): CompanyDTO {
        const json = this.toJSON();
        let result = new CompanyDTO();
        result.init(json);
        return result;
    }
}

export interface ICompanyDTO {
    name: string;
    rcNo: string | undefined;
    logoName: string | undefined;
    shortText: string | undefined;
    email: string;
    phoneNumber: string;
    address: string | undefined;
    administratorEmail: string;
    domainName: string | undefined;
    auditorEmail: string | undefined;
    maxEmployeeCount: number;
    subscriptionPlanId: number;
    password: string | undefined;
}

export class CompanyModuleDTO implements ICompanyModuleDTO {
    id!: number;
    moduleId!: number;
    companyId!: number;
    isEnabled!: boolean;
    moduleName!: string | undefined;
    icon!: string | undefined;
    isReadonly!: boolean;

    constructor(data?: ICompanyModuleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.moduleId = _data["moduleId"];
            this.companyId = _data["companyId"];
            this.isEnabled = _data["isEnabled"];
            this.moduleName = _data["moduleName"];
            this.icon = _data["icon"];
            this.isReadonly = _data["isReadonly"];
        }
    }

    static fromJS(data: any): CompanyModuleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyModuleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["moduleId"] = this.moduleId;
        data["companyId"] = this.companyId;
        data["isEnabled"] = this.isEnabled;
        data["moduleName"] = this.moduleName;
        data["icon"] = this.icon;
        data["isReadonly"] = this.isReadonly;
        return data; 
    }

    clone(): CompanyModuleDTO {
        const json = this.toJSON();
        let result = new CompanyModuleDTO();
        result.init(json);
        return result;
    }
}

export interface ICompanyModuleDTO {
    id: number;
    moduleId: number;
    companyId: number;
    isEnabled: boolean;
    moduleName: string | undefined;
    icon: string | undefined;
    isReadonly: boolean;
}

export class CompanyModuleDTOIListApiResult implements ICompanyModuleDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CompanyModuleDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ICompanyModuleDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CompanyModuleDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CompanyModuleDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyModuleDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CompanyModuleDTOIListApiResult {
        const json = this.toJSON();
        let result = new CompanyModuleDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICompanyModuleDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CompanyModuleDTO[] | undefined;
    totalCount: number;
}

export class ApplicationPermission implements IApplicationPermission {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    moduleID!: number;
    applicationRolePermissions!: ApplicationRolePermission[] | undefined;

    constructor(data?: IApplicationPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.moduleID = _data["moduleID"];
            if (Array.isArray(_data["applicationRolePermissions"])) {
                this.applicationRolePermissions = [] as any;
                for (let item of _data["applicationRolePermissions"])
                    this.applicationRolePermissions!.push(ApplicationRolePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationPermission {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["moduleID"] = this.moduleID;
        if (Array.isArray(this.applicationRolePermissions)) {
            data["applicationRolePermissions"] = [];
            for (let item of this.applicationRolePermissions)
                data["applicationRolePermissions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ApplicationPermission {
        const json = this.toJSON();
        let result = new ApplicationPermission();
        result.init(json);
        return result;
    }
}

export interface IApplicationPermission {
    id: number;
    name: string | undefined;
    code: string | undefined;
    moduleID: number;
    applicationRolePermissions: ApplicationRolePermission[] | undefined;
}

export class ApplicationRolePermission implements IApplicationRolePermission {
    id!: number;
    dateCreated!: Date;
    applicationRoleId!: number;
    applicationPermissionId!: number;
    applicationRole!: ApplicationRole;
    applicationPermission!: ApplicationPermission;

    constructor(data?: IApplicationRolePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.applicationRoleId = _data["applicationRoleId"];
            this.applicationPermissionId = _data["applicationPermissionId"];
            this.applicationRole = _data["applicationRole"] ? ApplicationRole.fromJS(_data["applicationRole"]) : <any>undefined;
            this.applicationPermission = _data["applicationPermission"] ? ApplicationPermission.fromJS(_data["applicationPermission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationRolePermission {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRolePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["applicationRoleId"] = this.applicationRoleId;
        data["applicationPermissionId"] = this.applicationPermissionId;
        data["applicationRole"] = this.applicationRole ? this.applicationRole.toJSON() : <any>undefined;
        data["applicationPermission"] = this.applicationPermission ? this.applicationPermission.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ApplicationRolePermission {
        const json = this.toJSON();
        let result = new ApplicationRolePermission();
        result.init(json);
        return result;
    }
}

export interface IApplicationRolePermission {
    id: number;
    dateCreated: Date;
    applicationRoleId: number;
    applicationPermissionId: number;
    applicationRole: ApplicationRole;
    applicationPermission: ApplicationPermission;
}

export class ApplicationRole implements IApplicationRole {
    description!: string | undefined;
    isSystemRole!: boolean;
    applicationRolePermissions!: ApplicationRolePermission[] | undefined;
    id!: number;
    name!: string | undefined;
    normalizedName!: string | undefined;
    concurrencyStamp!: string | undefined;

    constructor(data?: IApplicationRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.isSystemRole = _data["isSystemRole"];
            if (Array.isArray(_data["applicationRolePermissions"])) {
                this.applicationRolePermissions = [] as any;
                for (let item of _data["applicationRolePermissions"])
                    this.applicationRolePermissions!.push(ApplicationRolePermission.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): ApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["isSystemRole"] = this.isSystemRole;
        if (Array.isArray(this.applicationRolePermissions)) {
            data["applicationRolePermissions"] = [];
            for (let item of this.applicationRolePermissions)
                data["applicationRolePermissions"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data; 
    }

    clone(): ApplicationRole {
        const json = this.toJSON();
        let result = new ApplicationRole();
        result.init(json);
        return result;
    }
}

export interface IApplicationRole {
    description: string | undefined;
    isSystemRole: boolean;
    applicationRolePermissions: ApplicationRolePermission[] | undefined;
    id: number;
    name: string | undefined;
    normalizedName: string | undefined;
    concurrencyStamp: string | undefined;
}

export class RegisterUserDTO implements IRegisterUserDTO {
    firstName!: string;
    lastName!: string;
    email!: string;
    password!: string | undefined;
    phoneNumber!: string | undefined;
    locationID!: number | undefined;
    lgaid!: number | undefined;
    approvalAmtLimit!: number;
    approvalAmtMTD!: number;
    locationCol!: SelectListItem[] | undefined;
    lgaCol!: SelectListItem[] | undefined;
    selectedRoles!: string[];
    applicationRoles!: ApplicationRole[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRegisterUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectedRoles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.locationID = _data["locationID"];
            this.lgaid = _data["lgaid"];
            this.approvalAmtLimit = _data["approvalAmtLimit"];
            this.approvalAmtMTD = _data["approvalAmtMTD"];
            if (Array.isArray(_data["locationCol"])) {
                this.locationCol = [] as any;
                for (let item of _data["locationCol"])
                    this.locationCol!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["lgaCol"])) {
                this.lgaCol = [] as any;
                for (let item of _data["lgaCol"])
                    this.lgaCol!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["selectedRoles"])) {
                this.selectedRoles = [] as any;
                for (let item of _data["selectedRoles"])
                    this.selectedRoles!.push(item);
            }
            if (Array.isArray(_data["applicationRoles"])) {
                this.applicationRoles = [] as any;
                for (let item of _data["applicationRoles"])
                    this.applicationRoles!.push(ApplicationRole.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RegisterUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["locationID"] = this.locationID;
        data["lgaid"] = this.lgaid;
        data["approvalAmtLimit"] = this.approvalAmtLimit;
        data["approvalAmtMTD"] = this.approvalAmtMTD;
        if (Array.isArray(this.locationCol)) {
            data["locationCol"] = [];
            for (let item of this.locationCol)
                data["locationCol"].push(item.toJSON());
        }
        if (Array.isArray(this.lgaCol)) {
            data["lgaCol"] = [];
            for (let item of this.lgaCol)
                data["lgaCol"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedRoles)) {
            data["selectedRoles"] = [];
            for (let item of this.selectedRoles)
                data["selectedRoles"].push(item);
        }
        if (Array.isArray(this.applicationRoles)) {
            data["applicationRoles"] = [];
            for (let item of this.applicationRoles)
                data["applicationRoles"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RegisterUserDTO {
        const json = this.toJSON();
        let result = new RegisterUserDTO();
        result.init(json);
        return result;
    }
}

export interface IRegisterUserDTO {
    firstName: string;
    lastName: string;
    email: string;
    password: string | undefined;
    phoneNumber: string | undefined;
    locationID: number | undefined;
    lgaid: number | undefined;
    approvalAmtLimit: number;
    approvalAmtMTD: number;
    locationCol: SelectListItem[] | undefined;
    lgaCol: SelectListItem[] | undefined;
    selectedRoles: string[];
    applicationRoles: ApplicationRole[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ApplicationUserDTO implements IApplicationUserDTO {
    id!: number;
    email!: string | undefined;
    username!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    isAdmin!: boolean;
    isTenantAdmin!: boolean;
    isEnabled!: boolean | undefined;
    lastLogin!: Date | undefined;
    companyId!: number;
    subsidiaryId!: number;
    token!: string | undefined;
    apiSessionId!: string | undefined;
    lastComputerName!: string | undefined;

    constructor(data?: IApplicationUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.isAdmin = _data["isAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.isEnabled = _data["isEnabled"];
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>undefined;
            this.companyId = _data["companyId"];
            this.subsidiaryId = _data["subsidiaryId"];
            this.token = _data["token"];
            this.apiSessionId = _data["apiSessionId"];
            this.lastComputerName = _data["lastComputerName"];
        }
    }

    static fromJS(data: any): ApplicationUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["username"] = this.username;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["isAdmin"] = this.isAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["isEnabled"] = this.isEnabled;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        data["companyId"] = this.companyId;
        data["subsidiaryId"] = this.subsidiaryId;
        data["token"] = this.token;
        data["apiSessionId"] = this.apiSessionId;
        data["lastComputerName"] = this.lastComputerName;
        return data; 
    }

    clone(): ApplicationUserDTO {
        const json = this.toJSON();
        let result = new ApplicationUserDTO();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserDTO {
    id: number;
    email: string | undefined;
    username: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    isAdmin: boolean;
    isTenantAdmin: boolean;
    isEnabled: boolean | undefined;
    lastLogin: Date | undefined;
    companyId: number;
    subsidiaryId: number;
    token: string | undefined;
    apiSessionId: string | undefined;
    lastComputerName: string | undefined;
}

export class ApplicationUserDTOIListApiResult implements IApplicationUserDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationUserDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IApplicationUserDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApplicationUserDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ApplicationUserDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApplicationUserDTOIListApiResult {
        const json = this.toJSON();
        let result = new ApplicationUserDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationUserDTO[] | undefined;
    totalCount: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}