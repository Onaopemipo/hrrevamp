/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class GetTokenServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getToken(body: UserLoginDTO | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/GetToken/GetToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class ValidateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param key_token (optional) 
     * @return Success
     */
    validate(key_token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/Validate/Validate?";
        if (key_token !== undefined && key_token !== null)
            url_ += "key_token=" + encodeURIComponent("" + key_token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidate(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processValidate(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class ForgotPasswordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    forgotPassword(email: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ForgotPassword/ForgotPassword?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ResetPasswordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResestPasswordDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ConfirmEmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param userId (optional) 
     * @param token (optional) 
     * @return Success
     */
    confirmEmail(userId: string | null | undefined, token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/ConfirmEmail/ConfirmEmail?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmail(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmEmail(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class FetchActivityLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param moduleName (optional) 
     * @param operationType (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getActivityLog(id: number | undefined, moduleName: string | null | undefined, operationType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ActivityLogIListApiResult> {
        let url_ = this.baseUrl + "/api/ActivityLog/FetchActivityLog/GetActivityLog?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (moduleName !== undefined && moduleName !== null)
            url_ += "ModuleName=" + encodeURIComponent("" + moduleName) + "&";
        if (operationType !== undefined && operationType !== null)
            url_ += "OperationType=" + encodeURIComponent("" + operationType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityLog(<any>response_);
                } catch (e) {
                    return <Observable<ActivityLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityLog(response: HttpResponseBase): Observable<ActivityLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class PostServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateIAnnouncementType(body: AnnouncementTypeDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Announcement/Post/AddUpdateIAnnouncementType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateIAnnouncementType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateIAnnouncementType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateIAnnouncementType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateAnnouncement(body: AnnouncementDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Announcement/Post/AddUpdateAnnouncement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateAnnouncement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateAnnouncement(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateAnnouncement(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create and edit leave type. Note all fields are required
     * @param body (optional) 
     * @return Success
     */
    createLeaveType(body: LeaveTypeCreatePayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/Post/CreateLeaveType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLeaveType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLeaveType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLeaveType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateOnboardingPersonnalData(body: OnboardingPersonalDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/Post/AddUpdateOnboardingPersonnalData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateOnboardingPersonnalData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateOnboardingPersonnalData(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateOnboardingPersonnalData(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateOnboardingPaymentData(body: OnboardingBankDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/Post/AddUpdateOnboardingPaymentData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateOnboardingPaymentData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateOnboardingPaymentData(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateOnboardingPaymentData(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateOnboardingWorkData(body: OnboardingWorkDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/Post/AddUpdateOnboardingWorkData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateOnboardingWorkData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateOnboardingWorkData(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateOnboardingWorkData(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateOnboardingTaxData(body: OnboardingTaxDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/Post/AddUpdateOnboardingTaxData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateOnboardingTaxData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateOnboardingTaxData(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateOnboardingTaxData(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param iD (optional) 
     * @param companyId (optional) 
     * @param subID (optional) 
     * @param onboardingId (optional) 
     * @param createdById (optional) 
     * @param userId (optional) 
     * @param tempRef (optional) 
     * @return Success
     */
    addUpdateOnboardingDocummentData(iD: number | undefined, companyId: number | undefined, subID: number | undefined, onboardingId: number | undefined, createdById: number | undefined, userId: number | undefined, tempRef: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/Post/AddUpdateOnboardingDocummentData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (iD === null || iD === undefined)
            throw new Error("The parameter 'iD' cannot be null.");
        else
            content_.append("ID", iD.toString());
        if (companyId === null || companyId === undefined)
            throw new Error("The parameter 'companyId' cannot be null.");
        else
            content_.append("CompanyId", companyId.toString());
        if (subID === null || subID === undefined)
            throw new Error("The parameter 'subID' cannot be null.");
        else
            content_.append("SubID", subID.toString());
        if (onboardingId === null || onboardingId === undefined)
            throw new Error("The parameter 'onboardingId' cannot be null.");
        else
            content_.append("OnboardingId", onboardingId.toString());
        if (createdById === null || createdById === undefined)
            throw new Error("The parameter 'createdById' cannot be null.");
        else
            content_.append("CreatedById", createdById.toString());
        if (userId === null || userId === undefined)
            throw new Error("The parameter 'userId' cannot be null.");
        else
            content_.append("UserId", userId.toString());
        if (tempRef !== null && tempRef !== undefined)
            content_.append("TempRef", tempRef.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateOnboardingDocummentData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateOnboardingDocummentData(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateOnboardingDocummentData(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateOnboardingMedicalDisclosureData(body: OnboardingMedicalDisclosureDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/Post/AddUpdateOnboardingMedicalDisclosureData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateOnboardingMedicalDisclosureData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateOnboardingMedicalDisclosureData(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateOnboardingMedicalDisclosureData(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAnnouncementTypeByCriteriaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param iD (optional) 
     * @param catalog (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAnnouncementTypeByCriteria(iD: number | undefined, catalog: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<AnnouncementTypeListApiResult> {
        let url_ = this.baseUrl + "/api/Announcement/GetAnnouncementTypeByCriteria/GetAnnouncementTypeByCriteria?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (catalog !== undefined && catalog !== null)
            url_ += "Catalog=" + encodeURIComponent("" + catalog) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnnouncementTypeByCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnnouncementTypeByCriteria(<any>response_);
                } catch (e) {
                    return <Observable<AnnouncementTypeListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AnnouncementTypeListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAnnouncementTypeByCriteria(response: HttpResponseBase): Observable<AnnouncementTypeListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnnouncementTypeListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnnouncementTypeListApiResult>(<any>null);
    }

    /**
     * @param iD (optional) 
     * @param announcementMessage (optional) 
     * @param catalog (optional) 
     * @param departmentId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAnnouncementByCriteria(iD: number | undefined, announcementMessage: string | null | undefined, catalog: string | null | undefined, departmentId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<AnnouncementListApiResult> {
        let url_ = this.baseUrl + "/api/Announcement/GetAnnouncementTypeByCriteria/GetAnnouncementByCriteria?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (announcementMessage !== undefined && announcementMessage !== null)
            url_ += "AnnouncementMessage=" + encodeURIComponent("" + announcementMessage) + "&";
        if (catalog !== undefined && catalog !== null)
            url_ += "Catalog=" + encodeURIComponent("" + catalog) + "&";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnnouncementByCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnnouncementByCriteria(<any>response_);
                } catch (e) {
                    return <Observable<AnnouncementListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AnnouncementListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAnnouncementByCriteria(response: HttpResponseBase): Observable<AnnouncementListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnnouncementListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnnouncementListApiResult>(<any>null);
    }
}

@Injectable()
export class SubordinateAppraisalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving all Current Appraisal for Review by Line-Managers
     * @param cycleId (optional) 
     * @return Success
     */
    subordinateAppraisalLists(cycleId: number | undefined): Observable<AppraisalReviewerListDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Appraisal/SubordinateAppraisals/SubordinateAppraisalLists?";
        if (cycleId === null)
            throw new Error("The parameter 'cycleId' cannot be null.");
        else if (cycleId !== undefined)
            url_ += "cycleId=" + encodeURIComponent("" + cycleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubordinateAppraisalLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubordinateAppraisalLists(<any>response_);
                } catch (e) {
                    return <Observable<AppraisalReviewerListDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppraisalReviewerListDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSubordinateAppraisalLists(response: HttpResponseBase): Observable<AppraisalReviewerListDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppraisalReviewerListDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppraisalReviewerListDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetEmployeePerformanceReviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving Current Employees Appraisal for Review by Reviewer
     * @param reviewerContractId (optional) 
     * @param employeeContractId (optional) 
     * @param cycleId (optional) 
     * @param kraId (optional) 
     * @return Success
     */
    getEmployeePerformanceReview(reviewerContractId: number | undefined, employeeContractId: number | undefined, cycleId: number | undefined, kraId: number | undefined): Observable<KpiReviewDTOApiResult> {
        let url_ = this.baseUrl + "/api/Appraisal/GetEmployeePerformanceReview/GetEmployeePerformanceReview?";
        if (reviewerContractId === null)
            throw new Error("The parameter 'reviewerContractId' cannot be null.");
        else if (reviewerContractId !== undefined)
            url_ += "ReviewerContractId=" + encodeURIComponent("" + reviewerContractId) + "&";
        if (employeeContractId === null)
            throw new Error("The parameter 'employeeContractId' cannot be null.");
        else if (employeeContractId !== undefined)
            url_ += "EmployeeContractId=" + encodeURIComponent("" + employeeContractId) + "&";
        if (cycleId === null)
            throw new Error("The parameter 'cycleId' cannot be null.");
        else if (cycleId !== undefined)
            url_ += "CycleId=" + encodeURIComponent("" + cycleId) + "&";
        if (kraId === null)
            throw new Error("The parameter 'kraId' cannot be null.");
        else if (kraId !== undefined)
            url_ += "KraId=" + encodeURIComponent("" + kraId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeePerformanceReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeePerformanceReview(<any>response_);
                } catch (e) {
                    return <Observable<KpiReviewDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KpiReviewDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeePerformanceReview(response: HttpResponseBase): Observable<KpiReviewDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KpiReviewDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KpiReviewDTOApiResult>(<any>null);
    }
}

@Injectable()
export class SubmitEmployeeAppraisalReviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for submitting Employee's Appraisal Performance review for
    the KPIs under the assigned KRA by Reviewer
     * @param body (optional) 
     * @return Success
     */
    submitEmployeeAppraisalReview(body: PerformanceReviewDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Appraisal/SubmitEmployeeAppraisalReview/SubmitEmployeeAppraisalReview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitEmployeeAppraisalReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitEmployeeAppraisalReview(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitEmployeeAppraisalReview(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class EmployeePerformanceReviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving Current Appraisal for Review by Employee
     * @param reviewerContractId (optional) 
     * @param employeeContractId (optional) 
     * @param cycleId (optional) 
     * @param kraId (optional) 
     * @return Success
     */
    employeePerformanceReview(reviewerContractId: number | undefined, employeeContractId: number | undefined, cycleId: number | undefined, kraId: number | undefined): Observable<KpiReviewDTOApiResult> {
        let url_ = this.baseUrl + "/api/Appraisal/EmployeePerformanceReview/EmployeePerformanceReview?";
        if (reviewerContractId === null)
            throw new Error("The parameter 'reviewerContractId' cannot be null.");
        else if (reviewerContractId !== undefined)
            url_ += "ReviewerContractId=" + encodeURIComponent("" + reviewerContractId) + "&";
        if (employeeContractId === null)
            throw new Error("The parameter 'employeeContractId' cannot be null.");
        else if (employeeContractId !== undefined)
            url_ += "EmployeeContractId=" + encodeURIComponent("" + employeeContractId) + "&";
        if (cycleId === null)
            throw new Error("The parameter 'cycleId' cannot be null.");
        else if (cycleId !== undefined)
            url_ += "CycleId=" + encodeURIComponent("" + cycleId) + "&";
        if (kraId === null)
            throw new Error("The parameter 'kraId' cannot be null.");
        else if (kraId !== undefined)
            url_ += "KraId=" + encodeURIComponent("" + kraId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeePerformanceReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeePerformanceReview(<any>response_);
                } catch (e) {
                    return <Observable<KpiReviewDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KpiReviewDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeePerformanceReview(response: HttpResponseBase): Observable<KpiReviewDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KpiReviewDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KpiReviewDTOApiResult>(<any>null);
    }
}

@Injectable()
export class SubmitPerformanceReviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for submitting Employee's Performance review for the KPIs under the assigned KRA
     * @param body (optional) 
     * @return Success
     */
    submitEmployeePerformanceReview(body: PerformanceReviewDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Appraisal/SubmitPerformanceReview/SubmitEmployeePerformanceReview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitEmployeePerformanceReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitEmployeePerformanceReview(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitEmployeePerformanceReview(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetEmployeeAppraisalHistoriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving all Past Employee Appraisal Histories
     * @param cycleId (optional) 
     * @return Success
     */
    employeeAppraisalHistories(cycleId: number | undefined): Observable<EmployeeAppraisalHistoryDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Appraisal/GetEmployeeAppraisalHistories/EmployeeAppraisalHistories?";
        if (cycleId === null)
            throw new Error("The parameter 'cycleId' cannot be null.");
        else if (cycleId !== undefined)
            url_ += "cycleId=" + encodeURIComponent("" + cycleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeAppraisalHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeAppraisalHistories(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeAppraisalHistoryDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeAppraisalHistoryDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeAppraisalHistories(response: HttpResponseBase): Observable<EmployeeAppraisalHistoryDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeAppraisalHistoryDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeAppraisalHistoryDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchApprovalProcessServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching approval processes
     * @param id (optional) 
     * @return Success
     */
    fetchApprovalProcess(id: number | undefined): Observable<ApprovalProcessListApiResult> {
        let url_ = this.baseUrl + "/api/ApprovalProcess/FetchApprovalProcess/FetchApprovalProcess?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchApprovalProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchApprovalProcess(<any>response_);
                } catch (e) {
                    return <Observable<ApprovalProcessListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApprovalProcessListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchApprovalProcess(response: HttpResponseBase): Observable<ApprovalProcessListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalProcessListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalProcessListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchApprovalProcessStepsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching approval processes steps
     * @param processId (optional) 
     * @param stepId (optional) 
     * @return Success
     */
    fetchApprovalProcessSteps(processId: number | undefined, stepId: number | undefined): Observable<ApprovalStepListApiResult> {
        let url_ = this.baseUrl + "/api/ApprovalProcess/FetchApprovalProcessSteps/FetchApprovalProcessSteps?";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "processId=" + encodeURIComponent("" + processId) + "&";
        if (stepId === null)
            throw new Error("The parameter 'stepId' cannot be null.");
        else if (stepId !== undefined)
            url_ += "stepId=" + encodeURIComponent("" + stepId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchApprovalProcessSteps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchApprovalProcessSteps(<any>response_);
                } catch (e) {
                    return <Observable<ApprovalStepListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApprovalStepListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchApprovalProcessSteps(response: HttpResponseBase): Observable<ApprovalStepListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalStepListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalStepListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchPendingItemsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching my pending approval items
     * @param processId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    fetchPendingItems(processId: number | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined): Observable<VwPendingApprovalListApiResult> {
        let url_ = this.baseUrl + "/api/ApprovalProcess/FetchPendingItems/FetchPendingItems?";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "processId=" + encodeURIComponent("" + processId) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchPendingItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchPendingItems(<any>response_);
                } catch (e) {
                    return <Observable<VwPendingApprovalListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwPendingApprovalListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchPendingItems(response: HttpResponseBase): Observable<VwPendingApprovalListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwPendingApprovalListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwPendingApprovalListApiResult>(<any>null);
    }
}

@Injectable()
export class SaveApprovalProcessServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for saving and updating an approval process
     * @param body (optional) 
     * @return Success
     */
    saveApprovalProcess(body: ApprovalProcess | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ApprovalProcess/SaveApprovalProcess/SaveApprovalProcess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveApprovalProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveApprovalProcess(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSaveApprovalProcess(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class SaveApprovalProcessStepServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for saving and updating an approval process step
     * @param body (optional) 
     * @return Success
     */
    saveApprovalProcessStep(body: ApprovalStep | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ApprovalProcess/SaveApprovalProcessStep/SaveApprovalProcessStep";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveApprovalProcessStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveApprovalProcessStep(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSaveApprovalProcessStep(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RemoveApprovalProcessStepServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for removing an approval process step
     * @param body (optional) 
     * @return Success
     */
    removeApprovalProcessStep(body: ApprovalStep | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ApprovalProcess/RemoveApprovalProcessStep/RemoveApprovalProcessStep";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveApprovalProcessStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveApprovalProcessStep(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveApprovalProcessStep(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchApprovalLogViewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param processId (optional) 
     * @param itemId (optional) 
     * @return Success
     */
    fetchApprovalLogView(processId: number | undefined, itemId: number | undefined): Observable<ApprovalLogViewModelApiResult> {
        let url_ = this.baseUrl + "/api/ApprovalProcess/FetchApprovalLogView/FetchApprovalLogView?";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "processId=" + encodeURIComponent("" + processId) + "&";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchApprovalLogView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchApprovalLogView(<any>response_);
                } catch (e) {
                    return <Observable<ApprovalLogViewModelApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApprovalLogViewModelApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchApprovalLogView(response: HttpResponseBase): Observable<ApprovalLogViewModelApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalLogViewModelApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalLogViewModelApiResult>(<any>null);
    }
}

@Injectable()
export class PostApprovalLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postApprovalLog(body: ApprovalLog | undefined): Observable<ApprovalResponseObjApiResult> {
        let url_ = this.baseUrl + "/api/ApprovalProcess/PostApprovalLog/PostApprovalLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApprovalLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApprovalLog(<any>response_);
                } catch (e) {
                    return <Observable<ApprovalResponseObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApprovalResponseObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostApprovalLog(response: HttpResponseBase): Observable<ApprovalResponseObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalResponseObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalResponseObjApiResult>(<any>null);
    }
}

@Injectable()
export class AssetManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetType(body: AssetTypeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addDeperciationProfile(body: AssetDeperciationProfileDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AddDeperciationProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDeperciationProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDeperciationProfile(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddDeperciationProfile(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetSubType(body: AssetSubTypeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetSubType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetSubType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetSubType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCatergory(body: AssetCategoryDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCatergory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCatergory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCatergory(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCatergory(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetStatus(body: AssetStatusDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetStatus(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetStatus(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetMake(body: AssetMakeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetMake";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetMake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetMake(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetMake(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetModel(body: AssetModelDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetModel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetModel(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetModel(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAsset(body: AssetDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AddAsset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAsset(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddAsset(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAssetRequest(body: AssetRequestDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AddAssetRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAssetRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAssetRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddAssetRequest(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assignment(body: AssignmentDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/Assignment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssignment(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCallback(body: AssetCallbackDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCallback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCallback(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCallback(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCheckIn(body: AssetcheckInFilter | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCheckIn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCheckIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCheckIn(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCheckIn(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCheckInComfirmation(body: AssetcheckInFilter | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCheckInComfirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCheckInComfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCheckInComfirmation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCheckInComfirmation(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAssetRequest(body: UpdateAssetRequest | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/UpdateAssetRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAssetRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAssetRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAssetRequest(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetType(body: number | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param iD (optional) 
     * @return Success
     */
    deleteAssetSubType(iD: number | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetSubType?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetSubType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetSubType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetCategory(body: number | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetCategory(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetCategory(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetMake(body: AssetMakeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetMake";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetMake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetMake(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetMake(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetModel(body: AssetModelDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetModel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetModel(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetModel(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetStatus(body: AssetStatusDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetStatus(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetStatus(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getActivateAsset(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetActivateAsset?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivateAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivateAsset(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivateAsset(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getDeactivateAsset(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetDeactivateAsset?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeactivateAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeactivateAsset(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeactivateAsset(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetType(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetType?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetType(<any>response_);
                } catch (e) {
                    return <Observable<AssetTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetType(response: HttpResponseBase): Observable<AssetTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetTypeDTOIListApiResult>(<any>null);
    }

    /**
     * @param assetTypeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAssetSubType(assetTypeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<AssetSubTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetSubType?";
        if (assetTypeId === null)
            throw new Error("The parameter 'assetTypeId' cannot be null.");
        else if (assetTypeId !== undefined)
            url_ += "AssetTypeId=" + encodeURIComponent("" + assetTypeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetSubType(<any>response_);
                } catch (e) {
                    return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetSubType(response: HttpResponseBase): Observable<AssetSubTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetSubTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetSubTypeDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetCategory(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetCategoryDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetCategory?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetCategory(<any>response_);
                } catch (e) {
                    return <Observable<AssetCategoryDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetCategoryDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetCategory(response: HttpResponseBase): Observable<AssetCategoryDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetCategoryDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetCategoryDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetMake(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetMakeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetMake?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetMake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetMake(<any>response_);
                } catch (e) {
                    return <Observable<AssetMakeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetMakeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetMake(response: HttpResponseBase): Observable<AssetMakeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetMakeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetMakeDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetModel(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetModelDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetModel?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetModel(<any>response_);
                } catch (e) {
                    return <Observable<AssetModelDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetModelDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetModel(response: HttpResponseBase): Observable<AssetModelDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetModelDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetModelDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetStatus(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetStatusDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetStatus?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetStatus(<any>response_);
                } catch (e) {
                    return <Observable<AssetStatusDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetStatusDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetStatus(response: HttpResponseBase): Observable<AssetStatusDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetStatusDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetStatusDTOIListApiResult>(<any>null);
    }

    /**
     * @param assetTypeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAssetSubTypeByAssetTypeId(assetTypeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<AssetSubTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetSubTypeByAssetTypeId?";
        if (assetTypeId === null)
            throw new Error("The parameter 'assetTypeId' cannot be null.");
        else if (assetTypeId !== undefined)
            url_ += "AssetTypeId=" + encodeURIComponent("" + assetTypeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetSubTypeByAssetTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetSubTypeByAssetTypeId(<any>response_);
                } catch (e) {
                    return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetSubTypeByAssetTypeId(response: HttpResponseBase): Observable<AssetSubTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetSubTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetSubTypeDTOIListApiResult>(<any>null);
    }

    /**
     * @param assetSubTypeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetbyAssetSubtypeId(assetSubTypeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetbyAssetSubtypeId?";
        if (assetSubTypeId === null)
            throw new Error("The parameter 'assetSubTypeId' cannot be null.");
        else if (assetSubTypeId !== undefined)
            url_ += "AssetSubTypeId=" + encodeURIComponent("" + assetSubTypeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetbyAssetSubtypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetbyAssetSubtypeId(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetbyAssetSubtypeId(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param assetmakeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetModelByAssetMakeId(assetmakeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetModelByAssetMakeId?";
        if (assetmakeId === null)
            throw new Error("The parameter 'assetmakeId' cannot be null.");
        else if (assetmakeId !== undefined)
            url_ += "AssetmakeId=" + encodeURIComponent("" + assetmakeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetModelByAssetMakeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetModelByAssetMakeId(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetModelByAssetMakeId(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getDepreciationProfile(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDeperciationProfileDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetDepreciationProfile?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepreciationProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepreciationProfile(<any>response_);
                } catch (e) {
                    return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepreciationProfile(response: HttpResponseBase): Observable<AssetDeperciationProfileDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDeperciationProfileDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDeperciationProfileDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getActiveassetlist(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDeperciationProfileDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetActiveassetlist?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveassetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveassetlist(<any>response_);
                } catch (e) {
                    return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveassetlist(response: HttpResponseBase): Observable<AssetDeperciationProfileDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDeperciationProfileDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDeperciationProfileDTOIListApiResult>(<any>null);
    }

    /**
     * @param employeeId (optional) 
     * @param assetId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetByAssigedEmployee(employeeId: number | undefined, assetId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetHistoryDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetByAssigedEmployee?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        if (assetId === null)
            throw new Error("The parameter 'assetId' cannot be null.");
        else if (assetId !== undefined)
            url_ += "AssetId=" + encodeURIComponent("" + assetId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetByAssigedEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetByAssigedEmployee(<any>response_);
                } catch (e) {
                    return <Observable<AssetHistoryDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetHistoryDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetByAssigedEmployee(response: HttpResponseBase): Observable<AssetHistoryDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetHistoryDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetHistoryDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateBenefitPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateBenefitPlan(body: BenefitPlanDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Benefit/AddUpdateBenefitPlan/Add-Update-BenefitPlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateBenefitPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateBenefitPlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateBenefitPlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteBenefitPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteBenefitPlan(body: DeleteDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Benefit/DeleteBenefitPlan/DeleteBenefitPlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBenefitPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBenefitPlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBenefitPlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetBenefitPlanByCriteriaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param iD (optional) 
     * @param catalog (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getBenefitPlanByCriteria(iD: number | undefined, catalog: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<BenefitPlanListApiResult> {
        let url_ = this.baseUrl + "/api/Benefit/GetBenefitPlanByCriteria/GetBenefitPlanByCriteria?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (catalog !== undefined && catalog !== null)
            url_ += "Catalog=" + encodeURIComponent("" + catalog) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBenefitPlanByCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBenefitPlanByCriteria(<any>response_);
                } catch (e) {
                    return <Observable<BenefitPlanListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BenefitPlanListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetBenefitPlanByCriteria(response: HttpResponseBase): Observable<BenefitPlanListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BenefitPlanListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BenefitPlanListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEmployeeCoverageBenefitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmployeeCoverageBenefit(body: EmployeeCoverageBenefitDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Benefit/AddUpdateEmployeeCoverageBenefit/Add-Update-Employee-Coverage-Benefit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmployeeCoverageBenefit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmployeeCoverageBenefit(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmployeeCoverageBenefit(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeCoverageBenefitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param iD (optional) 
     * @param coverageName (optional) 
     * @param coveragePlanId (optional) 
     * @param companyID (optional) 
     * @param employeeId (optional) 
     * @param subID (optional) 
     * @param eligibilityTypeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchEmployeeCoverageBenefit(iD: number | undefined, coverageName: string | null | undefined, coveragePlanId: number | undefined, companyID: number | undefined, employeeId: number | undefined, subID: number | undefined, eligibilityTypeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<EmployeeCoverageListApiResult> {
        let url_ = this.baseUrl + "/api/Benefit/FetchEmployeeCoverageBenefit/FetchEmployeeCoverageBenefit?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (coverageName !== undefined && coverageName !== null)
            url_ += "CoverageName=" + encodeURIComponent("" + coverageName) + "&";
        if (coveragePlanId === null)
            throw new Error("The parameter 'coveragePlanId' cannot be null.");
        else if (coveragePlanId !== undefined)
            url_ += "CoveragePlanId=" + encodeURIComponent("" + coveragePlanId) + "&";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        if (subID === null)
            throw new Error("The parameter 'subID' cannot be null.");
        else if (subID !== undefined)
            url_ += "SubID=" + encodeURIComponent("" + subID) + "&";
        if (eligibilityTypeId === null)
            throw new Error("The parameter 'eligibilityTypeId' cannot be null.");
        else if (eligibilityTypeId !== undefined)
            url_ += "EligibilityTypeId=" + encodeURIComponent("" + eligibilityTypeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEmployeeCoverageBenefit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEmployeeCoverageBenefit(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeCoverageListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeCoverageListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEmployeeCoverageBenefit(response: HttpResponseBase): Observable<EmployeeCoverageListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeCoverageListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeCoverageListApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteEmployeeCoverageBenefitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteEmployeeCoverageBenefit(body: DeleteDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Benefit/DeleteEmployeeCoverageBenefit/Delete-Employee-Coverage-Benefit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEmployeeCoverageBenefit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEmployeeCoverageBenefit(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEmployeeCoverageBenefit(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateCoverageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateCoverage(body: CoveragePlanDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Benefit/AddUpdateCoverage/Add-Update-Coverage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateCoverage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateCoverage(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateCoverage(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchCoveragePlansServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param modifiedDate (optional) 
     * @param coverageName (optional) 
     * @param comapnyId (optional) 
     * @return Success
     */
    fetchCoveragePlans(id: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, modifiedDate: Date | null | undefined, coverageName: string | null | undefined, comapnyId: number | undefined): Observable<CoveragePlanListApiResult> {
        let url_ = this.baseUrl + "/api/Benefit/FetchCoveragePlans/FetchCoveragePlans?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (modifiedDate !== undefined && modifiedDate !== null)
            url_ += "ModifiedDate=" + encodeURIComponent(modifiedDate ? "" + modifiedDate.toJSON() : "") + "&";
        if (coverageName !== undefined && coverageName !== null)
            url_ += "CoverageName=" + encodeURIComponent("" + coverageName) + "&";
        if (comapnyId === null)
            throw new Error("The parameter 'comapnyId' cannot be null.");
        else if (comapnyId !== undefined)
            url_ += "ComapnyId=" + encodeURIComponent("" + comapnyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchCoveragePlans(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchCoveragePlans(<any>response_);
                } catch (e) {
                    return <Observable<CoveragePlanListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CoveragePlanListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchCoveragePlans(response: HttpResponseBase): Observable<CoveragePlanListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoveragePlanListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoveragePlanListApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteCoveragePlansServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteCoveragePlan(body: DeleteDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Benefit/DeleteCoveragePlans/Delete-Coverage-Plan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCoveragePlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCoveragePlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCoveragePlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEligibilityTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateEligibilityType(body: EligibilityTypeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Benefit/AddUpdateEligibilityType/Add-Update-Eligibility-Type";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEligibilityType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEligibilityType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEligibilityType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetEligibilityTypeByCriteriaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param iD (optional) 
     * @param name (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getEligibilityTypeByCriteria(iD: number | undefined, name: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<EligibilityTypeListApiResult> {
        let url_ = this.baseUrl + "/api/Benefit/GetEligibilityTypeByCriteria/GetEligibilityTypeByCriteria?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEligibilityTypeByCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEligibilityTypeByCriteria(<any>response_);
                } catch (e) {
                    return <Observable<EligibilityTypeListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EligibilityTypeListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEligibilityTypeByCriteria(response: HttpResponseBase): Observable<EligibilityTypeListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EligibilityTypeListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EligibilityTypeListApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteEligibilityTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteEligibilityType(body: DeleteDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Benefit/DeleteEligibilityType/Delete-Eligibility-Type";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEligibilityType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEligibilityType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEligibilityType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateBudgetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for add/updating Budget for a particular period
     * @param body (optional) 
     * @return Success
     */
    addUpdateBudget(body: ManageBudgetDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Budget/AddUpdateBudget/Add-Update-Budget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateBudget(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateBudget(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllBudgetsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving All Budgets for further CRUD operation
     * @return Success
     */
    getAllBudgets(): Observable<BudgetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Budget/FetchAllBudgets/GetAllBudgets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBudgets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBudgets(<any>response_);
                } catch (e) {
                    return <Observable<BudgetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BudgetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBudgets(response: HttpResponseBase): Observable<BudgetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchBudgetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting Single Budget details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getBudget(id: number | undefined): Observable<BudgetDTOApiResult> {
        let url_ = this.baseUrl + "/api/Budget/FetchBudget/GetBudget?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBudget(<any>response_);
                } catch (e) {
                    return <Observable<BudgetDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BudgetDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetBudget(response: HttpResponseBase): Observable<BudgetDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetDTOApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteBudgetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API  for Deleting Budget
     * @param body (optional) 
     * @return Success
     */
    deleteBudget(body: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Budget/DeleteBudget/DeleteBudget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBudget(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBudget(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateBudgetItemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for add/updating BudgetItem and it's Allocations
     * @param body (optional) 
     * @return Success
     */
    addUpdateBudgetItem(body: ManageBudgetItemDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Budget/AddUpdateBudgetItem/Add-Update-BudgetItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateBudgetItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateBudgetItem(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateBudgetItem(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllBudgetItemsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving All BudgetItems for further CRUD operation
     * @param budgetId (optional) 
     * @return Success
     */
    getAllBudgetItems(budgetId: number | undefined): Observable<BudgetItemDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Budget/FetchAllBudgetItems/GetAllBudgetItems?";
        if (budgetId === null)
            throw new Error("The parameter 'budgetId' cannot be null.");
        else if (budgetId !== undefined)
            url_ += "budgetId=" + encodeURIComponent("" + budgetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBudgetItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBudgetItems(<any>response_);
                } catch (e) {
                    return <Observable<BudgetItemDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BudgetItemDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBudgetItems(response: HttpResponseBase): Observable<BudgetItemDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetItemDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetItemDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchBudgetItemsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting BudgetItems that can be use for dropdowns
     * @param budgetId (optional) 
     * @return Success
     */
    getBudgetItems(budgetId: number | undefined): Observable<DisbursementBudgetItemIListApiResult> {
        let url_ = this.baseUrl + "/api/Budget/FetchBudgetItems/GetBudgetItems?";
        if (budgetId === null)
            throw new Error("The parameter 'budgetId' cannot be null.");
        else if (budgetId !== undefined)
            url_ += "budgetId=" + encodeURIComponent("" + budgetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBudgetItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBudgetItems(<any>response_);
                } catch (e) {
                    return <Observable<DisbursementBudgetItemIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DisbursementBudgetItemIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetBudgetItems(response: HttpResponseBase): Observable<DisbursementBudgetItemIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DisbursementBudgetItemIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DisbursementBudgetItemIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchBudgetItemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting Single Budget details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getBudgetItem(id: number | undefined): Observable<BudgetItemDTOApiResult> {
        let url_ = this.baseUrl + "/api/Budget/FetchBudgetItem/GetBudgetItem?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBudgetItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBudgetItem(<any>response_);
                } catch (e) {
                    return <Observable<BudgetItemDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BudgetItemDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetBudgetItem(response: HttpResponseBase): Observable<BudgetItemDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetItemDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetItemDTOApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteBudgetItemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API  for Deleting BudgetItem
     * @param body (optional) 
     * @return Success
     */
    deleteBudgetItem(body: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Budget/DeleteBudgetItem/DeleteBudgetItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBudgetItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBudgetItem(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBudgetItem(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class BulkMasterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for downloading Sample Template for Bulk Upload
     * @param processId (optional) 
     * @return Success
     */
    downloadSampleTemplate(processId: number | undefined): Observable<File> {
        let url_ = this.baseUrl + "/api/BulkMaster/DownloadSampleTemplate?";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "processId=" + encodeURIComponent("" + processId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadSampleTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadSampleTemplate(<any>response_);
                } catch (e) {
                    return <Observable<File>><any>_observableThrow(e);
                }
            } else
                return <Observable<File>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadSampleTemplate(response: HttpResponseBase): Observable<File> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = File.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<File>(<any>null);
    }

    /**
     * API for Bulk uploading
     * @param processId (optional) 
     * @param bulkFile (optional) 
     * @return Success
     */
    bulkUpload(processId: number | undefined, bulkFile: FileParameter | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/BulkMaster/BulkUpload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (processId === null || processId === undefined)
            throw new Error("The parameter 'processId' cannot be null.");
        else
            content_.append("processId", processId.toString());
        if (bulkFile !== null && bulkFile !== undefined)
            content_.append("bulkFile", bulkFile.data, bulkFile.fileName ? bulkFile.fileName : "bulkFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkUploadid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkUploadid(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processBulkUploadid(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API for Processing Bulk upload (i.e. it does the final submission of the previous bulk upload)
    this will only process the record with Status "Ready" and ignore others
    by supplying "ProcessId and BulkUploadId that was return after uploading."
     * @param processId (optional) 
     * @param bulkUploadId (optional) 
     * @return Success
     */
    processBulkUpload(processId: number | undefined, bulkUploadId: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/BulkMaster/ProcessBulkUpload?";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "processId=" + encodeURIComponent("" + processId) + "&";
        if (bulkUploadId === null)
            throw new Error("The parameter 'bulkUploadId' cannot be null.");
        else if (bulkUploadId !== undefined)
            url_ += "bulkUploadId=" + encodeURIComponent("" + bulkUploadId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessBulkUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessBulkUpload(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processProcessBulkUpload(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEmployeetoNineBoxGridServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Employee to ninebox Grid
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmployeetoNineBoxGrid(body: NineGridBoxDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/AddUpdateEmployeetoNineBoxGrid/Add-Update-EmployeetoNineBoxGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmployeetoNineBoxGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmployeetoNineBoxGrid(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmployeetoNineBoxGrid(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEmployeetoNineBoxGridBoxbyAppersialScoreServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Employee to ninebox Grid
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmployeetoBoxBasedonAppersailScore(body: NineGridBoxDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/AddUpdateEmployeetoNineBoxGridBoxbyAppersialScore/Add-Update-EmployeetoBox-basedonAppersailScore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmployeetoBoxBasedonAppersailScore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmployeetoBoxBasedonAppersailScore(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmployeetoBoxBasedonAppersailScore(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class MoveEmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for Moving Employee
     * @param body (optional) 
     * @return Success
     */
    moveEmployee(body: ManageMoveEmployeeFilterDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/MoveEmployee/MoveEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveEmployee(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processMoveEmployee(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RemoveEmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for Remove Employee
     * @param body (optional) 
     * @return Success
     */
    removeEmployee(body: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/RemoveEmployee/RemoveEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveEmployee(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveEmployee(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetEmployeeebyGridBoxServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch  Employee by Grid Box.
    Note: all filter are optional
     * @param gridboxID (optional) 
     * @param departmentId (optional) 
     * @return Success
     */
    getEmployeebyGridBox(gridboxID: number | undefined, departmentId: number | undefined): Observable<NineGridBoxDTOListApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/GetEmployeeebyGridBox/GetEmployeebyGridBox?";
        if (gridboxID === null)
            throw new Error("The parameter 'gridboxID' cannot be null.");
        else if (gridboxID !== undefined)
            url_ += "gridboxID=" + encodeURIComponent("" + gridboxID) + "&";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeebyGridBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeebyGridBox(<any>response_);
                } catch (e) {
                    return <Observable<NineGridBoxDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<NineGridBoxDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeebyGridBox(response: HttpResponseBase): Observable<NineGridBoxDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NineGridBoxDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NineGridBoxDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetGridBoxCountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch by Grid Box counts.
    Note: all filter are optional
     * @return Success
     */
    getGridBoxCount(): Observable<GridBoxCountDTOListApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/GetGridBoxCount/GetGridBoxCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGridBoxCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGridBoxCount(<any>response_);
                } catch (e) {
                    return <Observable<GridBoxCountDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GridBoxCountDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGridBoxCount(response: HttpResponseBase): Observable<GridBoxCountDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GridBoxCountDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GridBoxCountDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEmployeetoTalentPoolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Employee  to Talent Pool
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmployeetoTalentPool(body: EmployeeTalentPoolDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/AddUpdateEmployeetoTalentPool/Add-Update-EmployeetoTalentPool";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmployeetoTalentPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmployeetoTalentPool(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmployeetoTalentPool(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateRequirmentstoTalentPoolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Requirments  to Talent Pool
     * @param talentPoolId (optional) 
     * @param requirements (optional) 
     * @return Success
     */
    addUpdateRequirmentstoTalentPool(talentPoolId: number | undefined, requirements: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/AddUpdateRequirmentstoTalentPool/Add-Update-RequirmentstoTalentPool?";
        if (talentPoolId === null)
            throw new Error("The parameter 'talentPoolId' cannot be null.");
        else if (talentPoolId !== undefined)
            url_ += "TalentPoolId=" + encodeURIComponent("" + talentPoolId) + "&";
        if (requirements !== undefined && requirements !== null)
            url_ += "Requirements=" + encodeURIComponent("" + requirements) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateRequirmentstoTalentPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateRequirmentstoTalentPool(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateRequirmentstoTalentPool(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CareerSuccessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating CareerSuccsions
     * @param body (optional) 
     * @return Success
     */
    careerSuccession(body: ManageCareerSuccessionDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/CareerSuccession/CareerSuccession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCareerSuccession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCareerSuccession(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCareerSuccession(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CareerPoolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for Creating  Talent Pool
     * @param body (optional) 
     * @return Success
     */
    createPool(body: AddTalentPoolDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/CareerPool/CreatePool";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePool(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePool(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteEmployeefromTalentPoolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for  Delete  Employee from Talent Pool
     * @param talentPoolId (optional) 
     * @param employeeId (optional) 
     * @return Success
     */
    deleteEmployeeFromPool(talentPoolId: number | undefined, employeeId: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/DeleteEmployeefromTalentPool/DeleteEmployeeFromPool?";
        if (talentPoolId === null)
            throw new Error("The parameter 'talentPoolId' cannot be null.");
        else if (talentPoolId !== undefined)
            url_ += "TalentPoolId=" + encodeURIComponent("" + talentPoolId) + "&";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEmployeeFromPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEmployeeFromPool(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEmployeeFromPool(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetTalentPoolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch TalentPools.
    Note: all filter are optional
     * @param user_id (optional) 
     * @param employee_id (optional) 
     * @param employee_number (optional) 
     * @param employee_contract_id (optional) 
     * @param companyProfile_Id (optional) 
     * @param companyProfile_UserId (optional) 
     * @param companyProfile_RCNo (optional) 
     * @param companyProfile_LogoName (optional) 
     * @param companyProfile_ShortText (optional) 
     * @param companyProfile_FirstName (optional) 
     * @param companyProfile_LastName (optional) 
     * @param companyProfile_Address (optional) 
     * @param companyProfile_DomainName (optional) 
     * @param companyProfile_AuditorEmail (optional) 
     * @param companyProfile_MaxEmployeeCount (optional) 
     * @param companyProfile_SubscriptionPlanId (optional) 
     * @param companyProfile_SubscriptionPlanName (optional) 
     * @param companyProfile_LastBillingDate (optional) 
     * @param companyProfile_LastPaymentDate (optional) 
     * @param companyProfile_LicenseUsage (optional) 
     * @param companyProfile_IsActiveByAdmin (optional) 
     * @param companyProfile_IsTrial (optional) 
     * @param companyProfile_FrequencyId (optional) 
     * @param companyProfile_TempRef (optional) 
     * @param companyProfile_ReferenceNumber (optional) 
     * @param grade_id (optional) 
     * @param confirmation_date (optional) 
     * @param serial_no (optional) 
     * @param first_name (optional) 
     * @param last_name (optional) 
     * @param full_name (optional) 
     * @param other_name (optional) 
     * @param department (optional) 
     * @param department_id (optional) 
     * @param email (optional) 
     * @param phone_number (optional) 
     * @param email_confirmed (optional) 
     * @param session_token (optional) 
     * @param jwt_token (optional) 
     * @param user_token (optional) 
     * @param company_id (optional) 
     * @param licenseUsuage (optional) 
     * @param licenseCount (optional) 
     * @param company_name (optional) 
     * @param sub_id (optional) 
     * @param isAdmin (optional) 
     * @param isSuperAdmin (optional) 
     * @param isTenantAdmin (optional) 
     * @param isActiveBySysOrAdmin (optional) 
     * @param lstPermissions (optional) 
     * @param message (optional) 
     * @param isSuccessful (optional) 
     * @param retId (optional) 
     * @param bulkUploadId (optional) 
     * @param bulkUploadHtmlData (optional) 
     * @param redirectUrl (optional) 
     * @param referenceNumber (optional) 
     * @param errors (optional) 
     * @return Success
     */
    fetchTalentPool(user_id: number | undefined, employee_id: number | undefined, employee_number: string | null | undefined, employee_contract_id: number | undefined, companyProfile_Id: number | undefined, companyProfile_UserId: number | undefined, companyProfile_Name: string, companyProfile_RCNo: string | null | undefined, companyProfile_LogoName: string | null | undefined, companyProfile_ShortText: string | null | undefined, companyProfile_Email: string, companyProfile_PhoneNumber: string, companyProfile_FirstName: string | null | undefined, companyProfile_LastName: string | null | undefined, companyProfile_Address: string | null | undefined, companyProfile_AdministratorEmail: string, companyProfile_DomainName: string | null | undefined, companyProfile_AuditorEmail: string | null | undefined, companyProfile_MaxEmployeeCount: number | undefined, companyProfile_SubscriptionPlanId: number | undefined, companyProfile_SubscriptionPlanName: string | null | undefined, companyProfile_LastBillingDate: Date | null | undefined, companyProfile_LastPaymentDate: Date | null | undefined, companyProfile_LicenseUsage: number | undefined, companyProfile_IsActiveByAdmin: boolean | undefined, companyProfile_IsTrial: boolean | undefined, companyProfile_Password: string, companyProfile_FrequencyId: number | undefined, companyProfile_TempRef: string | null | undefined, companyProfile_ReferenceNumber: string | null | undefined, grade_id: number | null | undefined, confirmation_date: Date | null | undefined, serial_no: string | null | undefined, first_name: string | null | undefined, last_name: string | null | undefined, full_name: string | null | undefined, other_name: string | null | undefined, department: string | null | undefined, department_id: number | undefined, email: string | null | undefined, phone_number: string | null | undefined, email_confirmed: boolean | undefined, session_token: string | null | undefined, jwt_token: string | null | undefined, user_token: string | null | undefined, company_id: number | undefined, licenseUsuage: number | undefined, licenseCount: number | undefined, company_name: string | null | undefined, sub_id: number | undefined, isAdmin: boolean | undefined, isSuperAdmin: boolean | undefined, isTenantAdmin: boolean | undefined, isActiveBySysOrAdmin: boolean | undefined, lstPermissions: string[] | null | undefined, message: string | null | undefined, isSuccessful: boolean | undefined, retId: number | undefined, bulkUploadId: number | undefined, bulkUploadHtmlData: string | null | undefined, redirectUrl: string | null | undefined, referenceNumber: string | null | undefined, errors: string[] | null | undefined): Observable<AddTalentPoolDTOListApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/GetTalentPool/FetchTalentPool?";
        if (user_id === null)
            throw new Error("The parameter 'user_id' cannot be null.");
        else if (user_id !== undefined)
            url_ += "user_id=" + encodeURIComponent("" + user_id) + "&";
        if (employee_id === null)
            throw new Error("The parameter 'employee_id' cannot be null.");
        else if (employee_id !== undefined)
            url_ += "employee_id=" + encodeURIComponent("" + employee_id) + "&";
        if (employee_number !== undefined && employee_number !== null)
            url_ += "employee_number=" + encodeURIComponent("" + employee_number) + "&";
        if (employee_contract_id === null)
            throw new Error("The parameter 'employee_contract_id' cannot be null.");
        else if (employee_contract_id !== undefined)
            url_ += "employee_contract_id=" + encodeURIComponent("" + employee_contract_id) + "&";
        if (companyProfile_Id === null)
            throw new Error("The parameter 'companyProfile_Id' cannot be null.");
        else if (companyProfile_Id !== undefined)
            url_ += "CompanyProfile.Id=" + encodeURIComponent("" + companyProfile_Id) + "&";
        if (companyProfile_UserId === null)
            throw new Error("The parameter 'companyProfile_UserId' cannot be null.");
        else if (companyProfile_UserId !== undefined)
            url_ += "CompanyProfile.UserId=" + encodeURIComponent("" + companyProfile_UserId) + "&";
        if (companyProfile_Name === undefined || companyProfile_Name === null)
            throw new Error("The parameter 'companyProfile_Name' must be defined and cannot be null.");
        else
            url_ += "CompanyProfile.Name=" + encodeURIComponent("" + companyProfile_Name) + "&";
        if (companyProfile_RCNo !== undefined && companyProfile_RCNo !== null)
            url_ += "CompanyProfile.RCNo=" + encodeURIComponent("" + companyProfile_RCNo) + "&";
        if (companyProfile_LogoName !== undefined && companyProfile_LogoName !== null)
            url_ += "CompanyProfile.LogoName=" + encodeURIComponent("" + companyProfile_LogoName) + "&";
        if (companyProfile_ShortText !== undefined && companyProfile_ShortText !== null)
            url_ += "CompanyProfile.ShortText=" + encodeURIComponent("" + companyProfile_ShortText) + "&";
        if (companyProfile_Email === undefined || companyProfile_Email === null)
            throw new Error("The parameter 'companyProfile_Email' must be defined and cannot be null.");
        else
            url_ += "CompanyProfile.Email=" + encodeURIComponent("" + companyProfile_Email) + "&";
        if (companyProfile_PhoneNumber === undefined || companyProfile_PhoneNumber === null)
            throw new Error("The parameter 'companyProfile_PhoneNumber' must be defined and cannot be null.");
        else
            url_ += "CompanyProfile.PhoneNumber=" + encodeURIComponent("" + companyProfile_PhoneNumber) + "&";
        if (companyProfile_FirstName !== undefined && companyProfile_FirstName !== null)
            url_ += "CompanyProfile.FirstName=" + encodeURIComponent("" + companyProfile_FirstName) + "&";
        if (companyProfile_LastName !== undefined && companyProfile_LastName !== null)
            url_ += "CompanyProfile.LastName=" + encodeURIComponent("" + companyProfile_LastName) + "&";
        if (companyProfile_Address !== undefined && companyProfile_Address !== null)
            url_ += "CompanyProfile.Address=" + encodeURIComponent("" + companyProfile_Address) + "&";
        if (companyProfile_AdministratorEmail === undefined || companyProfile_AdministratorEmail === null)
            throw new Error("The parameter 'companyProfile_AdministratorEmail' must be defined and cannot be null.");
        else
            url_ += "CompanyProfile.AdministratorEmail=" + encodeURIComponent("" + companyProfile_AdministratorEmail) + "&";
        if (companyProfile_DomainName !== undefined && companyProfile_DomainName !== null)
            url_ += "CompanyProfile.DomainName=" + encodeURIComponent("" + companyProfile_DomainName) + "&";
        if (companyProfile_AuditorEmail !== undefined && companyProfile_AuditorEmail !== null)
            url_ += "CompanyProfile.AuditorEmail=" + encodeURIComponent("" + companyProfile_AuditorEmail) + "&";
        if (companyProfile_MaxEmployeeCount === null)
            throw new Error("The parameter 'companyProfile_MaxEmployeeCount' cannot be null.");
        else if (companyProfile_MaxEmployeeCount !== undefined)
            url_ += "CompanyProfile.MaxEmployeeCount=" + encodeURIComponent("" + companyProfile_MaxEmployeeCount) + "&";
        if (companyProfile_SubscriptionPlanId === null)
            throw new Error("The parameter 'companyProfile_SubscriptionPlanId' cannot be null.");
        else if (companyProfile_SubscriptionPlanId !== undefined)
            url_ += "CompanyProfile.SubscriptionPlanId=" + encodeURIComponent("" + companyProfile_SubscriptionPlanId) + "&";
        if (companyProfile_SubscriptionPlanName !== undefined && companyProfile_SubscriptionPlanName !== null)
            url_ += "CompanyProfile.SubscriptionPlanName=" + encodeURIComponent("" + companyProfile_SubscriptionPlanName) + "&";
        if (companyProfile_LastBillingDate !== undefined && companyProfile_LastBillingDate !== null)
            url_ += "CompanyProfile.LastBillingDate=" + encodeURIComponent(companyProfile_LastBillingDate ? "" + companyProfile_LastBillingDate.toJSON() : "") + "&";
        if (companyProfile_LastPaymentDate !== undefined && companyProfile_LastPaymentDate !== null)
            url_ += "CompanyProfile.LastPaymentDate=" + encodeURIComponent(companyProfile_LastPaymentDate ? "" + companyProfile_LastPaymentDate.toJSON() : "") + "&";
        if (companyProfile_LicenseUsage === null)
            throw new Error("The parameter 'companyProfile_LicenseUsage' cannot be null.");
        else if (companyProfile_LicenseUsage !== undefined)
            url_ += "CompanyProfile.LicenseUsage=" + encodeURIComponent("" + companyProfile_LicenseUsage) + "&";
        if (companyProfile_IsActiveByAdmin === null)
            throw new Error("The parameter 'companyProfile_IsActiveByAdmin' cannot be null.");
        else if (companyProfile_IsActiveByAdmin !== undefined)
            url_ += "CompanyProfile.IsActiveByAdmin=" + encodeURIComponent("" + companyProfile_IsActiveByAdmin) + "&";
        if (companyProfile_IsTrial === null)
            throw new Error("The parameter 'companyProfile_IsTrial' cannot be null.");
        else if (companyProfile_IsTrial !== undefined)
            url_ += "CompanyProfile.IsTrial=" + encodeURIComponent("" + companyProfile_IsTrial) + "&";
        if (companyProfile_Password === undefined || companyProfile_Password === null)
            throw new Error("The parameter 'companyProfile_Password' must be defined and cannot be null.");
        else
            url_ += "CompanyProfile.Password=" + encodeURIComponent("" + companyProfile_Password) + "&";
        if (companyProfile_FrequencyId === null)
            throw new Error("The parameter 'companyProfile_FrequencyId' cannot be null.");
        else if (companyProfile_FrequencyId !== undefined)
            url_ += "CompanyProfile.FrequencyId=" + encodeURIComponent("" + companyProfile_FrequencyId) + "&";
        if (companyProfile_TempRef !== undefined && companyProfile_TempRef !== null)
            url_ += "CompanyProfile.TempRef=" + encodeURIComponent("" + companyProfile_TempRef) + "&";
        if (companyProfile_ReferenceNumber !== undefined && companyProfile_ReferenceNumber !== null)
            url_ += "CompanyProfile.ReferenceNumber=" + encodeURIComponent("" + companyProfile_ReferenceNumber) + "&";
        if (grade_id !== undefined && grade_id !== null)
            url_ += "grade_id=" + encodeURIComponent("" + grade_id) + "&";
        if (confirmation_date !== undefined && confirmation_date !== null)
            url_ += "confirmation_date=" + encodeURIComponent(confirmation_date ? "" + confirmation_date.toJSON() : "") + "&";
        if (serial_no !== undefined && serial_no !== null)
            url_ += "serial_no=" + encodeURIComponent("" + serial_no) + "&";
        if (first_name !== undefined && first_name !== null)
            url_ += "first_name=" + encodeURIComponent("" + first_name) + "&";
        if (last_name !== undefined && last_name !== null)
            url_ += "last_name=" + encodeURIComponent("" + last_name) + "&";
        if (full_name !== undefined && full_name !== null)
            url_ += "full_name=" + encodeURIComponent("" + full_name) + "&";
        if (other_name !== undefined && other_name !== null)
            url_ += "other_name=" + encodeURIComponent("" + other_name) + "&";
        if (department !== undefined && department !== null)
            url_ += "department=" + encodeURIComponent("" + department) + "&";
        if (department_id === null)
            throw new Error("The parameter 'department_id' cannot be null.");
        else if (department_id !== undefined)
            url_ += "department_id=" + encodeURIComponent("" + department_id) + "&";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (phone_number !== undefined && phone_number !== null)
            url_ += "phone_number=" + encodeURIComponent("" + phone_number) + "&";
        if (email_confirmed === null)
            throw new Error("The parameter 'email_confirmed' cannot be null.");
        else if (email_confirmed !== undefined)
            url_ += "email_confirmed=" + encodeURIComponent("" + email_confirmed) + "&";
        if (session_token !== undefined && session_token !== null)
            url_ += "session_token=" + encodeURIComponent("" + session_token) + "&";
        if (jwt_token !== undefined && jwt_token !== null)
            url_ += "jwt_token=" + encodeURIComponent("" + jwt_token) + "&";
        if (user_token !== undefined && user_token !== null)
            url_ += "user_token=" + encodeURIComponent("" + user_token) + "&";
        if (company_id === null)
            throw new Error("The parameter 'company_id' cannot be null.");
        else if (company_id !== undefined)
            url_ += "company_id=" + encodeURIComponent("" + company_id) + "&";
        if (licenseUsuage === null)
            throw new Error("The parameter 'licenseUsuage' cannot be null.");
        else if (licenseUsuage !== undefined)
            url_ += "LicenseUsuage=" + encodeURIComponent("" + licenseUsuage) + "&";
        if (licenseCount === null)
            throw new Error("The parameter 'licenseCount' cannot be null.");
        else if (licenseCount !== undefined)
            url_ += "LicenseCount=" + encodeURIComponent("" + licenseCount) + "&";
        if (company_name !== undefined && company_name !== null)
            url_ += "company_name=" + encodeURIComponent("" + company_name) + "&";
        if (sub_id === null)
            throw new Error("The parameter 'sub_id' cannot be null.");
        else if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&";
        if (isAdmin === null)
            throw new Error("The parameter 'isAdmin' cannot be null.");
        else if (isAdmin !== undefined)
            url_ += "IsAdmin=" + encodeURIComponent("" + isAdmin) + "&";
        if (isSuperAdmin === null)
            throw new Error("The parameter 'isSuperAdmin' cannot be null.");
        else if (isSuperAdmin !== undefined)
            url_ += "IsSuperAdmin=" + encodeURIComponent("" + isSuperAdmin) + "&";
        if (isTenantAdmin === null)
            throw new Error("The parameter 'isTenantAdmin' cannot be null.");
        else if (isTenantAdmin !== undefined)
            url_ += "IsTenantAdmin=" + encodeURIComponent("" + isTenantAdmin) + "&";
        if (isActiveBySysOrAdmin === null)
            throw new Error("The parameter 'isActiveBySysOrAdmin' cannot be null.");
        else if (isActiveBySysOrAdmin !== undefined)
            url_ += "IsActiveBySysOrAdmin=" + encodeURIComponent("" + isActiveBySysOrAdmin) + "&";
        if (lstPermissions !== undefined && lstPermissions !== null)
            lstPermissions && lstPermissions.forEach(item => { url_ += "lstPermissions=" + encodeURIComponent("" + item) + "&"; });
        if (message !== undefined && message !== null)
            url_ += "Message=" + encodeURIComponent("" + message) + "&";
        if (isSuccessful === null)
            throw new Error("The parameter 'isSuccessful' cannot be null.");
        else if (isSuccessful !== undefined)
            url_ += "IsSuccessful=" + encodeURIComponent("" + isSuccessful) + "&";
        if (retId === null)
            throw new Error("The parameter 'retId' cannot be null.");
        else if (retId !== undefined)
            url_ += "RetId=" + encodeURIComponent("" + retId) + "&";
        if (bulkUploadId === null)
            throw new Error("The parameter 'bulkUploadId' cannot be null.");
        else if (bulkUploadId !== undefined)
            url_ += "BulkUploadId=" + encodeURIComponent("" + bulkUploadId) + "&";
        if (bulkUploadHtmlData !== undefined && bulkUploadHtmlData !== null)
            url_ += "BulkUploadHtmlData=" + encodeURIComponent("" + bulkUploadHtmlData) + "&";
        if (redirectUrl !== undefined && redirectUrl !== null)
            url_ += "RedirectUrl=" + encodeURIComponent("" + redirectUrl) + "&";
        if (referenceNumber !== undefined && referenceNumber !== null)
            url_ += "ReferenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        if (errors !== undefined && errors !== null)
            errors && errors.forEach(item => { url_ += "Errors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchTalentPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchTalentPool(<any>response_);
                } catch (e) {
                    return <Observable<AddTalentPoolDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddTalentPoolDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchTalentPool(response: HttpResponseBase): Observable<AddTalentPoolDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddTalentPoolDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddTalentPoolDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchSuccessionPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting CareerrSuccssionPlan that can be use for dropdowns
     * @return Success
     */
    getCareerSuccessionPlan(): Observable<CareerSuccessionIListApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/FetchSuccessionPlan/Get-CareerSuccession-Plan";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCareerSuccessionPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCareerSuccessionPlan(<any>response_);
                } catch (e) {
                    return <Observable<CareerSuccessionIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CareerSuccessionIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCareerSuccessionPlan(response: HttpResponseBase): Observable<CareerSuccessionIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CareerSuccessionIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CareerSuccessionIListApiResult>(<any>null);
    }
}

@Injectable()
export class RemoveEmployeeFromSuccessorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for Remove Employee form Successor
     * @param successionId (optional) 
     * @param employee (optional) 
     * @return Success
     */
    removeEmployeeFromSuccessor(successionId: number | undefined, employee: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/RemoveEmployeeFromSuccessor/RemoveEmployeeFromSuccessor?";
        if (successionId === null)
            throw new Error("The parameter 'successionId' cannot be null.");
        else if (successionId !== undefined)
            url_ += "SuccessionId=" + encodeURIComponent("" + successionId) + "&";
        if (employee !== undefined && employee !== null)
            url_ += "Employee=" + encodeURIComponent("" + employee) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveEmployeeFromSuccessor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveEmployeeFromSuccessor(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveEmployeeFromSuccessor(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RemoveRequirmentfromTalentPoolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for Remove Requirment from TalentPool
     * @param requirementId (optional) 
     * @return Success
     */
    removeRequirementFromTalentPool(requirementId: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/CareerSuccession/RemoveRequirmentfromTalentPool/RemoveRequirementFromTalentPool?";
        if (requirementId === null)
            throw new Error("The parameter 'requirementId' cannot be null.");
        else if (requirementId !== undefined)
            url_ += "RequirementId=" + encodeURIComponent("" + requirementId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRequirementFromTalentPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRequirementFromTalentPool(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRequirementFromTalentPool(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateCertificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Certification
     * @param body (optional) 
     * @return Success
     */
    addUpdateCertification(body: ManageCertificationDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Certification/AddUpdateCertification/Add-Update-Certification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateCertification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateCertification(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateCertification(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllCertificationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch Certifications.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param professionalBodyId (optional) 
     * @return Success
     */
    getAllCertifications(pageSize: number | undefined, pageNumber: number | undefined, professionalBodyId: number | undefined): Observable<CertificationDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Certification/GetAllCertifications/GetAllCertifications?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (professionalBodyId === null)
            throw new Error("The parameter 'professionalBodyId' cannot be null.");
        else if (professionalBodyId !== undefined)
            url_ += "ProfessionalBodyId=" + encodeURIComponent("" + professionalBodyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCertifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCertifications(<any>response_);
                } catch (e) {
                    return <Observable<CertificationDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CertificationDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCertifications(response: HttpResponseBase): Observable<CertificationDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificationDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CertificationDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetCertificationByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to get Certification by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getCertification(id: number | undefined): Observable<CertificationDTOApiResult> {
        let url_ = this.baseUrl + "/api/Certification/GetCertificationById/GetCertification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCertification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCertification(<any>response_);
                } catch (e) {
                    return <Observable<CertificationDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CertificationDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCertification(response: HttpResponseBase): Observable<CertificationDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificationDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CertificationDTOApiResult>(<any>null);
    }
}

@Injectable()
export class CommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting Element Types that can be use for dropdowns
     * @return Success
     */
    getElementTypes(): Observable<ElementTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetElementTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetElementTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetElementTypes(<any>response_);
                } catch (e) {
                    return <Observable<ElementTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ElementTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetElementTypes(response: HttpResponseBase): Observable<ElementTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElementTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElementTypeDTOIListApiResult>(<any>null);
    }

    /**
     * API for getting Element Categories that can be use for dropdowns
     * @return Success
     */
    getElementCategories(): Observable<ElementCategoryDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetElementCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetElementCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetElementCategories(<any>response_);
                } catch (e) {
                    return <Observable<ElementCategoryDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ElementCategoryDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetElementCategories(response: HttpResponseBase): Observable<ElementCategoryDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElementCategoryDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElementCategoryDTOIListApiResult>(<any>null);
    }

    /**
     * API for getting Payment Institutions that can be use for dropdowns
     * @return Success
     */
    getPaymentInstitutions(): Observable<PaymentInstitutionIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetPaymentInstitutions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInstitutions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInstitutions(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInstitutionIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInstitutionIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInstitutions(response: HttpResponseBase): Observable<PaymentInstitutionIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInstitutionIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInstitutionIListApiResult>(<any>null);
    }

    /**
     * API for getting Payment Elements that can be use for dropdowns
     * @return Success
     */
    getPayElements(): Observable<ElementIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetPayElements";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayElements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayElements(<any>response_);
                } catch (e) {
                    return <Observable<ElementIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ElementIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayElements(response: HttpResponseBase): Observable<ElementIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ElementIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElementIListApiResult>(<any>null);
    }

    /**
     * API for getting Payroll Types that can be use for dropdowns
     * @return Success
     */
    getPayrollTypes(): Observable<PayrollTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetPayrollTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayrollTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayrollTypes(<any>response_);
                } catch (e) {
                    return <Observable<PayrollTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayrollTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayrollTypes(response: HttpResponseBase): Observable<PayrollTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayrollTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayrollTypeIListApiResult>(<any>null);
    }

    /**
     * API for getting Frequencies that can be use for dropdowns
     * @return Success
     */
    getFrequencies(): Observable<FrequencyRuleIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetFrequencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFrequencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFrequencies(<any>response_);
                } catch (e) {
                    return <Observable<FrequencyRuleIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<FrequencyRuleIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetFrequencies(response: HttpResponseBase): Observable<FrequencyRuleIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FrequencyRuleIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FrequencyRuleIListApiResult>(<any>null);
    }

    /**
     * API for getting Institutions that can be use for dropdowns
    for filtering
     * @return Success
     */
    getInstitutions(): Observable<InstitutionIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetInstitutions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInstitutions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstitutions(<any>response_);
                } catch (e) {
                    return <Observable<InstitutionIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InstitutionIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetInstitutions(response: HttpResponseBase): Observable<InstitutionIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InstitutionIListApiResult>(<any>null);
    }

    /**
     * API for getting Courses that can be use for dropdowns
    for filtering
     * @return Success
     */
    getCourses(): Observable<CourseIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetCourses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourses(<any>response_);
                } catch (e) {
                    return <Observable<CourseIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CourseIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCourses(response: HttpResponseBase): Observable<CourseIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseIListApiResult>(<any>null);
    }

    /**
     * API for getting Qualifications that can be use for dropdowns
    for filtering
     * @return Success
     */
    getQualifications(): Observable<QualificationIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetQualifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQualifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQualifications(<any>response_);
                } catch (e) {
                    return <Observable<QualificationIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<QualificationIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetQualifications(response: HttpResponseBase): Observable<QualificationIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QualificationIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QualificationIListApiResult>(<any>null);
    }

    /**
     * API for getting Payment Channels on the System that can be use for dropdowns
    for filtering
     * @return Success
     */
    getPaymentChannels(): Observable<ChannelIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetPaymentChannels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentChannels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentChannels(<any>response_);
                } catch (e) {
                    return <Observable<ChannelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChannelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentChannels(response: HttpResponseBase): Observable<ChannelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChannelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChannelIListApiResult>(<any>null);
    }

    /**
     * API for getting Skills that can be use for dropdowns
    for filtering
     * @return Success
     */
    getSkills(): Observable<SkillIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetSkills";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkills(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkills(<any>response_);
                } catch (e) {
                    return <Observable<SkillIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkills(response: HttpResponseBase): Observable<SkillIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkillIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillIListApiResult>(<any>null);
    }

    /**
     * Skill-Categories
    API for getting Sectors/Skill-Categories that can be use for dropdowns
    for filtering
     * @return Success
     */
    getSKillCategories(): Observable<SectorIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetSKillCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSKillCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSKillCategories(<any>response_);
                } catch (e) {
                    return <Observable<SectorIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SectorIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSKillCategories(response: HttpResponseBase): Observable<SectorIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SectorIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SectorIListApiResult>(<any>null);
    }

    /**
     * API for getting Professional Bodies that can be use for dropdowns
    for filtering
     * @return Success
     */
    getProfessionalBodies(): Observable<ProfessionalBodyIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetProfessionalBodies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfessionalBodies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfessionalBodies(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalBodyIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalBodyIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfessionalBodies(response: HttpResponseBase): Observable<ProfessionalBodyIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfessionalBodyIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalBodyIListApiResult>(<any>null);
    }

    /**
     * API for getting Certifications that can be use for dropdowns
    for filtering
     * @return Success
     */
    getCertifications(): Observable<CertificationIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetCertifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCertifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCertifications(<any>response_);
                } catch (e) {
                    return <Observable<CertificationIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CertificationIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCertifications(response: HttpResponseBase): Observable<CertificationIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificationIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CertificationIListApiResult>(<any>null);
    }

    /**
     * API for getting Tenant Beneficiaries that can be use for dropdowns
    and takes searchText (i.e. account-name, account-no, bank-name, bank-code)
    for filtering
     * @param searchText (optional) 
     * @return Success
     */
    getBeneficiaries(searchText: string | null | undefined): Observable<TenantBeneficiaryIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetBeneficiaries?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBeneficiaries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBeneficiaries(<any>response_);
                } catch (e) {
                    return <Observable<TenantBeneficiaryIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantBeneficiaryIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetBeneficiaries(response: HttpResponseBase): Observable<TenantBeneficiaryIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantBeneficiaryIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantBeneficiaryIListApiResult>(<any>null);
    }

    /**
     * API for getting Locations that can be use for dropdowns
     * @return Success
     */
    getLocations(): Observable<LocationIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetLocations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocations(<any>response_);
                } catch (e) {
                    return <Observable<LocationIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocations(response: HttpResponseBase): Observable<LocationIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationIListApiResult>(<any>null);
    }

    /**
     * API for getting Departments that can be use for dropdowns
     * @return Success
     */
    getDepartments(): Observable<DepartmentIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetDepartments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartments(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartments(response: HttpResponseBase): Observable<DepartmentIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentIListApiResult>(<any>null);
    }

    /**
     * API for getting JobRoles that can be use for dropdowns
     * @return Success
     */
    getJobRoles(): Observable<JobRoleIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetJobRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobRoles(<any>response_);
                } catch (e) {
                    return <Observable<JobRoleIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobRoleIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobRoles(response: HttpResponseBase): Observable<JobRoleIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobRoleIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobRoleIListApiResult>(<any>null);
    }

    /**
     * API for getting Events that can be use for dropdowns
     * @return Success
     */
    getEvents(): Observable<EventIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetEvents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEvents(<any>response_);
                } catch (e) {
                    return <Observable<EventIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EventIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEvents(response: HttpResponseBase): Observable<EventIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventIListApiResult>(<any>null);
    }

    /**
     * API for getting Positions that can be use for dropdowns
     * @return Success
     */
    getPositions(): Observable<PositionIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetPositions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPositions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPositions(<any>response_);
                } catch (e) {
                    return <Observable<PositionIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPositions(response: HttpResponseBase): Observable<PositionIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PositionIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionIListApiResult>(<any>null);
    }

    /**
     * API for getting All Parent Positions that can be use for dropdowns
     * @return Success
     */
    getParentPositions(): Observable<PositionIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetParentPositions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetParentPositions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetParentPositions(<any>response_);
                } catch (e) {
                    return <Observable<PositionIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetParentPositions(response: HttpResponseBase): Observable<PositionIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PositionIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionIListApiResult>(<any>null);
    }

    /**
     * API for getting SalaryScale that can be use for dropdowns
     * @return Success
     */
    getSalaryScale(): Observable<SalaryScaleIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetSalaryScale";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalaryScale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalaryScale(<any>response_);
                } catch (e) {
                    return <Observable<SalaryScaleIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SalaryScaleIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalaryScale(response: HttpResponseBase): Observable<SalaryScaleIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryScaleIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryScaleIListApiResult>(<any>null);
    }

    /**
     * API for getting Grade that can be use for dropdowns
     * @return Success
     */
    getGrades(): Observable<GradeIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetGrades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGrades(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGrades(<any>response_);
                } catch (e) {
                    return <Observable<GradeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGrades(response: HttpResponseBase): Observable<GradeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeIListApiResult>(<any>null);
    }

    /**
     * API for getting GradeSteps that can be use for dropdowns
     * @return Success
     */
    getGradeSteps(): Observable<GradeStepIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetGradeSteps";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeSteps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeSteps(<any>response_);
                } catch (e) {
                    return <Observable<GradeStepIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeStepIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGradeSteps(response: HttpResponseBase): Observable<GradeStepIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeStepIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeStepIListApiResult>(<any>null);
    }

    /**
     * API for getting GradeLevelBenefit that can be use for dropdowns
     * @return Success
     */
    getGradeLevelBenefit(): Observable<GradeLevelBenefitIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetGradeLevelBenefit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeLevelBenefit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeLevelBenefit(<any>response_);
                } catch (e) {
                    return <Observable<GradeLevelBenefitIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeLevelBenefitIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGradeLevelBenefit(response: HttpResponseBase): Observable<GradeLevelBenefitIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeLevelBenefitIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeLevelBenefitIListApiResult>(<any>null);
    }

    /**
     * API for getting RequestTypes that can be use for dropdowns
     * @return Success
     */
    getRequestTypes(): Observable<RequestTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetRequestTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestTypes(<any>response_);
                } catch (e) {
                    return <Observable<RequestTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestTypes(response: HttpResponseBase): Observable<RequestTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestTypeIListApiResult>(<any>null);
    }

    /**
     * API for getting Positions that can be use for dropdowns
     * @return Success
     */
    getPosition(): Observable<PositionIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetPosition";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosition(<any>response_);
                } catch (e) {
                    return <Observable<PositionIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPosition(response: HttpResponseBase): Observable<PositionIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PositionIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionIListApiResult>(<any>null);
    }

    /**
     * API for getting Request that can be use for dropdowns
     * @return Success
     */
    getRequests(): Observable<RequestIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetRequests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequests(<any>response_);
                } catch (e) {
                    return <Observable<RequestIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequests(response: HttpResponseBase): Observable<RequestIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestIListApiResult>(<any>null);
    }

    /**
     * API for getting Retirement that can be use for dropdowns
     * @return Success
     */
    getRetiree(): Observable<RetirementIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetRetiree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetiree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetiree(<any>response_);
                } catch (e) {
                    return <Observable<RetirementIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirementIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetiree(response: HttpResponseBase): Observable<RetirementIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementIListApiResult>(<any>null);
    }

    /**
     * @return Success
     */
    getRetirmentType(): Observable<RetirementTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetRetirmentType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetirmentType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetirmentType(<any>response_);
                } catch (e) {
                    return <Observable<RetirementTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirementTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetirmentType(response: HttpResponseBase): Observable<RetirementTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementTypeIListApiResult>(<any>null);
    }

    /**
     * API for getting Positions that can be use for dropdowns
     * @return Success
     */
    getCompetency(): Observable<CompetencyIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetCompetency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompetency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompetency(<any>response_);
                } catch (e) {
                    return <Observable<CompetencyIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompetencyIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompetency(response: HttpResponseBase): Observable<CompetencyIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompetencyIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompetencyIListApiResult>(<any>null);
    }
}

@Injectable()
export class CommunicationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch Email Settings.
    Note: all filter are optional
     * @return Success
     */
    getAllEmailSettings(): Observable<EmailSettingListApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetAllEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmailSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmailSettings(<any>response_);
                } catch (e) {
                    return <Observable<EmailSettingListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailSettingListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEmailSettings(response: HttpResponseBase): Observable<EmailSettingListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailSettingListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailSettingListApiResult>(<any>null);
    }

    /**
     * API to get EmailSetting by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getEmailSetting(id: number | undefined): Observable<EmailSettingApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetEmailSetting?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailSetting(<any>response_);
                } catch (e) {
                    return <Observable<EmailSettingApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailSettingApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailSetting(response: HttpResponseBase): Observable<EmailSettingApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailSettingApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailSettingApiResult>(<any>null);
    }

    /**
     * API for adding/updating EmailSettings
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmailSetting(body: EmailSetting | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Communication/Add-Update-EmailSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmailSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmailSetting(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmailSetting(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch TemplateTypes (Promotion, Account Creation etc.) for Dropdowns
    while adding Email Template
     * @return Success
     */
    getAllTemplateTypes(): Observable<IDTextViewModelListApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetAllTemplateTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTemplateTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTemplateTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTemplateTypes(response: HttpResponseBase): Observable<IDTextViewModelListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelListApiResult>(<any>null);
    }

    /**
     * API for adding/updating EmailTemplate
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmailTemplate(body: ManageMailTemplateDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Communication/Add-Update-EmailTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmailTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmailTemplate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmailTemplate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Email Templates.
    Note: all filter are optional
     * @return Success
     */
    getAllEmailTemplates(): Observable<MailTemplateDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetAllEmailTemplates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmailTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmailTemplates(<any>response_);
                } catch (e) {
                    return <Observable<MailTemplateDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MailTemplateDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEmailTemplates(response: HttpResponseBase): Observable<MailTemplateDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailTemplateDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MailTemplateDTOListApiResult>(<any>null);
    }

    /**
     * API to get EmailTemplate by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getEmailTemplate(id: number | undefined): Observable<MailTemplateDTOApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetEmailTemplate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailTemplate(<any>response_);
                } catch (e) {
                    return <Observable<MailTemplateDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MailTemplateDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailTemplate(response: HttpResponseBase): Observable<MailTemplateDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MailTemplateDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MailTemplateDTOApiResult>(<any>null);
    }

    /**
     * API for retrieving all Email Logs by email log filtering parameter
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param emailTo (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getEmailLogs(startDate: Date | null | undefined, endDate: Date | null | undefined, emailTo: string | null | undefined, pageSize: number | undefined): Observable<EmailLogDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetEmailLogs?";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (emailTo !== undefined && emailTo !== null)
            url_ += "EmailTo=" + encodeURIComponent("" + emailTo) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailLogs(<any>response_);
                } catch (e) {
                    return <Observable<EmailLogDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailLogDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailLogs(response: HttpResponseBase): Observable<EmailLogDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailLogDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailLogDTOIListApiResult>(<any>null);
    }

    /**
     * API for getting Single EmailLog Details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getEmailLogById(id: number | undefined): Observable<EmailLogDTOApiResult> {
        let url_ = this.baseUrl + "/api/Communication/GetEmailLogById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailLogById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailLogById(<any>response_);
                } catch (e) {
                    return <Observable<EmailLogDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailLogDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailLogById(response: HttpResponseBase): Observable<EmailLogDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailLogDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailLogDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateCompensationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateCompensation(body: CompensationDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Compensation/AddUpdateCompensation/Add-Update-Compensation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateCompensation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateCompensation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateCompensation(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchCompensationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param iD (optional) 
     * @param compensationName (optional) 
     * @param employeeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchCompensation(iD: number | undefined, compensationName: string | null | undefined, employeeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<DependantListApiResult> {
        let url_ = this.baseUrl + "/api/Compensation/FetchCompensation/FetchCompensation?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (compensationName !== undefined && compensationName !== null)
            url_ += "CompensationName=" + encodeURIComponent("" + compensationName) + "&";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchCompensation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchCompensation(<any>response_);
                } catch (e) {
                    return <Observable<DependantListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DependantListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchCompensation(response: HttpResponseBase): Observable<DependantListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DependantListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DependantListApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteCompensationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteCompensation(body: DeleteDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Compensation/DeleteCompensation/Delete-Compensation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCompensation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCompensation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCompensation(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEmployeeCompensationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmployeeCompensation(body: EmployeeCompensationDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Compensation/AddUpdateEmployeeCompensation/Add-Update-Employee-Compensation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmployeeCompensation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmployeeCompensation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmployeeCompensation(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeCompensationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param iD (optional) 
     * @param compensationId (optional) 
     * @param employeeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchEmployeeCompensation(iD: number | undefined, compensationId: number | undefined, employeeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<DependantListApiResult> {
        let url_ = this.baseUrl + "/api/Compensation/FetchEmployeeCompensation/Fetch-Employee-Compensation?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (compensationId === null)
            throw new Error("The parameter 'compensationId' cannot be null.");
        else if (compensationId !== undefined)
            url_ += "CompensationId=" + encodeURIComponent("" + compensationId) + "&";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEmployeeCompensation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEmployeeCompensation(<any>response_);
                } catch (e) {
                    return <Observable<DependantListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DependantListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEmployeeCompensation(response: HttpResponseBase): Observable<DependantListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DependantListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DependantListApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteEmployeeCompensationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteEmployeeCompensation(body: DeleteDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Compensation/DeleteEmployeeCompensation/Delete-Employee-Compensation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEmployeeCompensation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEmployeeCompensation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEmployeeCompensation(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CompetencyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Competency
     * @param body (optional) 
     * @return Success
     */
    addUpdateCompetency(body: ManageCompetencyDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Competency/Add-Update-Competency";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateCompetency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateCompetency(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateCompetency(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API for  Deleting Competency
     * @param iD (optional) 
     * @return Success
     */
    deleteCompetency(iD: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Competency/Delete-Competency?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCompetency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCompetency(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCompetency(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param employeeId (optional) 
     * @param competencyId (optional) 
     * @return Success
     */
    compareCompetency(employeeId: number | undefined, competencyId: number | undefined): Observable<VmListComparismApiResult> {
        let url_ = this.baseUrl + "/api/Competency/Compare-Competency?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        if (competencyId === null)
            throw new Error("The parameter 'competencyId' cannot be null.");
        else if (competencyId !== undefined)
            url_ += "CompetencyId=" + encodeURIComponent("" + competencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompareCompetency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompareCompetency(<any>response_);
                } catch (e) {
                    return <Observable<VmListComparismApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VmListComparismApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCompareCompetency(response: HttpResponseBase): Observable<VmListComparismApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VmListComparismApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VmListComparismApiResult>(<any>null);
    }
}

@Injectable()
export class SaveConfirmationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveConfirmation(body: VwConfirmationDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Confirmation/SaveConfirmation/SaveConfirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveConfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveConfirmation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSaveConfirmation(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetConfirmationsByDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param log_status (optional) 
     * @param _pagenumber (optional) 
     * @param _PageSize (optional) 
     * @return Success
     */
    getConfirmationsByDetails(startDate: Date | null | undefined, endDate: Date | null | undefined, log_status: number | undefined, _pagenumber: number | undefined, _PageSize: number | undefined): Observable<VwConfirmationDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Confirmation/GetConfirmationsByDetails/GetConfirmationsByDetails?";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (log_status === null)
            throw new Error("The parameter 'log_status' cannot be null.");
        else if (log_status !== undefined)
            url_ += "log_status=" + encodeURIComponent("" + log_status) + "&";
        if (_pagenumber === null)
            throw new Error("The parameter '_pagenumber' cannot be null.");
        else if (_pagenumber !== undefined)
            url_ += "_pagenumber=" + encodeURIComponent("" + _pagenumber) + "&";
        if (_PageSize === null)
            throw new Error("The parameter '_PageSize' cannot be null.");
        else if (_PageSize !== undefined)
            url_ += "_PageSize=" + encodeURIComponent("" + _PageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfirmationsByDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfirmationsByDetails(<any>response_);
                } catch (e) {
                    return <Observable<VwConfirmationDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwConfirmationDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfirmationsByDetails(response: HttpResponseBase): Observable<VwConfirmationDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwConfirmationDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwConfirmationDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class CourseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Course
     * @param body (optional) 
     * @return Success
     */
    addUpdateCourse(body: Course | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Course/Add-Update-Course";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateCourse(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateCourse(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Courses.
    Note: all filter are optional
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllCourses(pageNumber: number | undefined, pageSize: number | undefined): Observable<CourseListApiResult> {
        let url_ = this.baseUrl + "/api/Course/GetAllCourses?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCourses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCourses(<any>response_);
                } catch (e) {
                    return <Observable<CourseListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CourseListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCourses(response: HttpResponseBase): Observable<CourseListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseListApiResult>(<any>null);
    }

    /**
     * API to get Course by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getCourse(id: number | undefined): Observable<CourseApiResult> {
        let url_ = this.baseUrl + "/api/Course/GetCourse?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourse(<any>response_);
                } catch (e) {
                    return <Observable<CourseApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CourseApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCourse(response: HttpResponseBase): Observable<CourseApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseApiResult>(<any>null);
    }
}

@Injectable()
export class FetchDashboardDataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching admin dashboard
     * @return Success
     */
    fetchDashboardData(): Observable<DashboardDTOApiResult> {
        let url_ = this.baseUrl + "/api/Dashboard/FetchDashboardData/FetchDashboardData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<DashboardDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchDashboardData(response: HttpResponseBase): Observable<DashboardDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardDTOApiResult>(<any>null);
    }
}

@Injectable()
export class DataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting Loan Eligible Status i.e.
    {'ALL_EMPLOYEES=0, FULL-TIME_EMPLOYEES=1, PART-TIME_EMPLOYEES=2' }
     * @return Success
     */
    loanEligibleStatus(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/LoanEligibleStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoanEligibleStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoanEligibleStatus(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processLoanEligibleStatus(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Interest Types i.e.
    {'NONE=0, FIXED RATE=1, REDUCING BALANCE=2' }
     * @return Success
     */
    interestTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/InterestTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInterestTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInterestTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processInterestTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Document Entity Types i.e.
    {'TRAINING, CONFIRMATION, OTHERS' }
     * @return Success
     */
    docEntityTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/DocEntityTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocEntityTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocEntityTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDocEntityTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Qualification Categories i.e.
    {'O_Level, Diploma, Degree, Masters, PHD, Professor' }
     * @return Success
     */
    qualificationCategories(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/QualificationCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQualificationCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQualificationCategories(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processQualificationCategories(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Bulk Upload Process/Types i.e.
    {'Profile': 1, 'Contract': 2, 'Qualification': 3 }
     * @return Success
     */
    employeeProfileOperation(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/EmployeeProfileOperation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeProfileOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeProfileOperation(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeProfileOperation(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Bank Account Types for dropdowns
     * @return Success
     */
    getAccountTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetAccountTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Bulk Upload Process/Types i.e.
    {'Employee Bank Upload': 2, 'Employee Records Upload': 10}
     * @return Success
     */
    getBulkUploadProcesses(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetBulkUploadProcesses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBulkUploadProcesses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBulkUploadProcesses(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetBulkUploadProcesses(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Pay Types while setting up Pay Element under Payroll for dropdowns
     * @return Success
     */
    getPayTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetPayTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Document Types while uploading document on the system for dropdowns
     * @return Success
     */
    getDocumentTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetDocumentTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Disbursement Categories enumerable that can be use for dropdowns, option button
     * @return Success
     */
    getDisbursementCategories(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetDisbursementCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDisbursementCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDisbursementCategories(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDisbursementCategories(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of different Generics/Common Dropdowns on the System by their Constant Name
    Some of the Constant names for the Dropdowns are;
    1: employment_status
    2: department
    3: bank
    4: marital_status
    8: religion
    10: title
    12: gender
    14: pfa
    16: address_type
    27: Sectors
     * @param dropDownName (optional) 
     * @return Success
     */
    getDropDownValues(dropDownName: string | null | undefined): Observable<DropdownValueIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetDropDownValues?";
        if (dropDownName !== undefined && dropDownName !== null)
            url_ += "dropDownName=" + encodeURIComponent("" + dropDownName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDropDownValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDropDownValues(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDropDownValues(response: HttpResponseBase): Observable<DropdownValueIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of different Generics/Common Dropdowns on the System by their Constant Value
    Some of the Constant names for the Dropdowns are;
    employment_status: 1
    department: 2
    bank: 3
    marital_status: 4
    religion: 8
    title: 10
    gender: 12
    pension fund administrator: 14
    address_type: 16 
    sectors: 27
     * @param dropDownId (optional) 
     * @return Success
     */
    getDropDownValuesById(dropDownId: number | undefined): Observable<DropdownValueIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetDropDownValuesById?";
        if (dropDownId === null)
            throw new Error("The parameter 'dropDownId' cannot be null.");
        else if (dropDownId !== undefined)
            url_ += "dropDownId=" + encodeURIComponent("" + dropDownId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDropDownValuesById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDropDownValuesById(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDropDownValuesById(response: HttpResponseBase): Observable<DropdownValueIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueIListApiResult>(<any>null);
    }

    /**
     * API for getting Tenant Status enumerable that can be use for filtering parameter
     * @return Success
     */
    getTenantStatus(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetTenantStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantStatus(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantStatus(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of all Countries on the System
     * @return Success
     */
    getCountries(): Observable<CountryIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<CountryIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<CountryIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of all State by CountryId
     * @param countryId (optional) 
     * @return Success
     */
    getStateByCountryId(countryId: number | undefined): Observable<StateIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetStateByCountryId?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStateByCountryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStateByCountryId(<any>response_);
                } catch (e) {
                    return <Observable<StateIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StateIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetStateByCountryId(response: HttpResponseBase): Observable<StateIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StateIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StateIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of all States on the System
     * @return Success
     */
    getStates(): Observable<StateIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetStates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStates(<any>response_);
                } catch (e) {
                    return <Observable<StateIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StateIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetStates(response: HttpResponseBase): Observable<StateIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StateIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StateIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of all Local Govts on the System
     * @return Success
     */
    getLGAs(): Observable<LGAIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetLGAs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLGAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLGAs(<any>response_);
                } catch (e) {
                    return <Observable<LGAIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LGAIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLGAs(response: HttpResponseBase): Observable<LGAIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LGAIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LGAIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of all Local Govts by State
     * @param stateId (optional) 
     * @return Success
     */
    getLGAsByState(stateId: number | undefined): Observable<LGAIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetLGAsByState?";
        if (stateId === null)
            throw new Error("The parameter 'stateId' cannot be null.");
        else if (stateId !== undefined)
            url_ += "stateId=" + encodeURIComponent("" + stateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLGAsByState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLGAsByState(<any>response_);
                } catch (e) {
                    return <Observable<LGAIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LGAIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLGAsByState(response: HttpResponseBase): Observable<LGAIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LGAIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LGAIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Unit of Measurement enumerable that can be use for dropdown values
     * @return Success
     */
    getUnitOfMeasurements(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetUnitOfMeasurements";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitOfMeasurements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitOfMeasurements(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitOfMeasurements(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Rating Types enumerable that can be use for dropdown values
     * @return Success
     */
    getRatingTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetRatingTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRatingTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRatingTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRatingTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Performance Review Purposes enumerable (Confirmation, Promotion, etc)
    that can be use for dropdown values
     * @return Success
     */
    getReviewPurposes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetReviewPurposes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReviewPurposes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReviewPurposes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetReviewPurposes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Organization Strategies enumerable(Financial, Customer, etc)
    that can be use for dropdown values
     * @return Success
     */
    getStrategyCategories(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetStrategyCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStrategyCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStrategyCategories(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetStrategyCategories(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Appraisal Types enumerable that can be use for dropdown values
     * @return Success
     */
    getAppraisalTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetAppraisalTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppraisalTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppraisalTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppraisalTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of an enumerable Employee Contract Status that can be use for dropdown values in filter
     * @return Success
     */
    getEmployeeContractStatus(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetEmployeeContractStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeContractStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeContractStatus(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeContractStatus(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Requests Types enumerable that can be use for dropdown values
     * @return Success
     */
    getRequestTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetRequestTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Activity Types   for Manpower enumerable that can be use for dropdown values
     * @return Success
     */
    getActivityTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetActivityTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * Api for getting list of EventType  for Event service that can be used as dropdowns
     * @return Success
     */
    getEventType(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetEventType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEventType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEventType(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEventType(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * Api for getting list of RequirmentCategory for TalentManagementService that can be used as dropdowns
     * @return Success
     */
    getRequirmentCategory(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetRequirmentCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequirmentCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequirmentCategory(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequirmentCategory(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * Api for getting list of RequirmentType for TalentManagementService that can be used as dropdowns
     * @return Success
     */
    getRequirmentType(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetRequirmentType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequirmentType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequirmentType(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequirmentType(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateDepartmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Department
     * @param body (optional) 
     * @return Success
     */
    addUpdateDepartment(body: ManageDepartmentDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Department/AddUpdateDepartment/Add-Update-Department";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateDepartment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateDepartment(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllDepartmentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch Departments.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllDepartments(pageSize: number | undefined, pageNumber: number | undefined): Observable<DepartmentDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Department/GetAllDepartments/GetAllDepartments?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDepartments(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDepartments(response: HttpResponseBase): Observable<DepartmentDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetDepartmentByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to get Department by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getDepartment(id: number | undefined): Observable<DepartmentDTOApiResult> {
        let url_ = this.baseUrl + "/api/Department/GetDepartmentById/GetDepartment?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartment(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartment(response: HttpResponseBase): Observable<DepartmentDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateDependantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateDependant(body: DependantDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Dependant/AddUpdateDependant/Add-Update-Dependant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateDependant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateDependant(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateDependant(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteDependantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteDependant(body: DeleteDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Dependant/DeleteDependant/DeleteDependant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDependant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDependant(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDependant(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetDependantByCriteriaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param iD (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param dependantType (optional) 
     * @param gender (optional) 
     * @param nIN (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchDependants(iD: number | undefined, firstName: string | null | undefined, lastName: string | null | undefined, dependantType: string | null | undefined, gender: string | null | undefined, nIN: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<DependantListApiResult> {
        let url_ = this.baseUrl + "/api/Dependant/GetDependantByCriteria/FetchDependants?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (firstName !== undefined && firstName !== null)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName !== undefined && lastName !== null)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (dependantType !== undefined && dependantType !== null)
            url_ += "DependantType=" + encodeURIComponent("" + dependantType) + "&";
        if (gender !== undefined && gender !== null)
            url_ += "Gender=" + encodeURIComponent("" + gender) + "&";
        if (nIN !== undefined && nIN !== null)
            url_ += "NIN=" + encodeURIComponent("" + nIN) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchDependants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchDependants(<any>response_);
                } catch (e) {
                    return <Observable<DependantListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DependantListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchDependants(response: HttpResponseBase): Observable<DependantListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DependantListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DependantListApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllDependantByCompanyIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param employeeId (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllDependantByCompanyId(employeeId: number | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<DependantResultDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Dependant/GetAllDependantByCompanyId/GetAllDependantByCompanyId?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDependantByCompanyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDependantByCompanyId(<any>response_);
                } catch (e) {
                    return <Observable<DependantResultDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DependantResultDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDependantByCompanyId(response: HttpResponseBase): Observable<DependantResultDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DependantResultDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DependantResultDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllDependantByEmployeeIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param employeeId (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllDependantByEmployeeId(employeeId: number | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<DependantResultDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Dependant/GetAllDependantByEmployeeId/GetAllDependantByEmployeeId?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDependantByEmployeeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDependantByEmployeeId(<any>response_);
                } catch (e) {
                    return <Observable<DependantResultDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DependantResultDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDependantByEmployeeId(response: HttpResponseBase): Observable<DependantResultDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DependantResultDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DependantResultDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateDeploymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateDeployment(body: DeploymentRegistrationPayLoad | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Deployment/AddUpdateDeployment/Add-Update-Deployment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateDeployment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateDeployment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateDeployment(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchDeploymentByReferenceNoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param referenceNo (optional) 
     * @return Success
     */
    fetchDeploymentByReferenceNo(referenceNo: string | null | undefined): Observable<DeploymentLogIListApiResult> {
        let url_ = this.baseUrl + "/api/Deployment/FetchDeploymentByReferenceNo/FetchDeploymentByReferenceNo?";
        if (referenceNo !== undefined && referenceNo !== null)
            url_ += "ReferenceNo=" + encodeURIComponent("" + referenceNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchDeploymentByReferenceNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchDeploymentByReferenceNo(<any>response_);
                } catch (e) {
                    return <Observable<DeploymentLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeploymentLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchDeploymentByReferenceNo(response: HttpResponseBase): Observable<DeploymentLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeploymentLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeploymentLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchDeploymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param companyID (optional) 
     * @param subID (optional) 
     * @param employeeContractid (optional) 
     * @param name (optional) 
     * @param iD (optional) 
     * @param strStartDate (optional) 
     * @param strEndDate (optional) 
     * @param referenceId (optional) 
     * @param code (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchDeployment(companyID: number | undefined, subID: number | undefined, employeeContractid: number | undefined, name: string | null | undefined, iD: number | undefined, strStartDate: string | null | undefined, strEndDate: string | null | undefined, referenceId: string | null | undefined, code: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<DeploymentLogDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Deployment/FetchDeployment/FetchDeployment?";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        if (subID === null)
            throw new Error("The parameter 'subID' cannot be null.");
        else if (subID !== undefined)
            url_ += "SubID=" + encodeURIComponent("" + subID) + "&";
        if (employeeContractid === null)
            throw new Error("The parameter 'employeeContractid' cannot be null.");
        else if (employeeContractid !== undefined)
            url_ += "employeeContractid=" + encodeURIComponent("" + employeeContractid) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (strStartDate !== undefined && strStartDate !== null)
            url_ += "strStartDate=" + encodeURIComponent("" + strStartDate) + "&";
        if (strEndDate !== undefined && strEndDate !== null)
            url_ += "strEndDate=" + encodeURIComponent("" + strEndDate) + "&";
        if (referenceId !== undefined && referenceId !== null)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchDeployment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchDeployment(<any>response_);
                } catch (e) {
                    return <Observable<DeploymentLogDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeploymentLogDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchDeployment(response: HttpResponseBase): Observable<DeploymentLogDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeploymentLogDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeploymentLogDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class EmployeeDeploymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @return Success
     */
    employeeDeployment(): Observable<CreateDeploymentViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Deployment/EmployeeDeployment/EmployeeDeployment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeDeployment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeDeployment(<any>response_);
                } catch (e) {
                    return <Observable<CreateDeploymentViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateDeploymentViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeDeployment(response: HttpResponseBase): Observable<CreateDeploymentViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateDeploymentViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateDeploymentViewModelIListApiResult>(<any>null);
    }
}

@Injectable()
export class TenantDisbursementChannelsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch Tenant Disbursement Channels.
     * @return Success
     */
    getDisbursementChannels(): Observable<DisburseChannelDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Disbursement/TenantDisbursementChannels/GetDisbursementChannels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDisbursementChannels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDisbursementChannels(<any>response_);
                } catch (e) {
                    return <Observable<DisburseChannelDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DisburseChannelDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDisbursementChannels(response: HttpResponseBase): Observable<DisburseChannelDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DisburseChannelDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DisburseChannelDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class SingleDisbursementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for posting/updating Single Disbursement
     * @param body (optional) 
     * @return Success
     */
    postSingleDisbursement(body: SingleDisbursementPostDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Disbursement/SingleDisbursement/PostSingleDisbursement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostSingleDisbursement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostSingleDisbursement(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostSingleDisbursement(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CreateEmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding a single Employee profile
     * @param body (optional) 
     * @return Success
     */
    addEmployee(body: ManageEmployeeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Employee/CreateEmployee/AddEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEmployee(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddEmployee(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class UploadProfileImageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for uploading Employee profile picture
     * @param base64Image (optional) 
     * @param employeeId (optional) 
     * @return Success
     */
    uploadProfileImage(base64Image: string | null | undefined, employeeId: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Employee/UploadProfileImage/UploadProfileImage?";
        if (base64Image !== undefined && base64Image !== null)
            url_ += "base64Image=" + encodeURIComponent("" + base64Image) + "&";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadProfileImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadProfileImage(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUploadProfileImage(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeesDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving all Employees by Employee number (i.e. for specific Employee) or
    empty string (i.e. for all Employee
    with their few details for further CRUD operation
     * @param searchText (optional) 
     * @param contractStatus (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getEmployeesDetails(searchText: string | null | undefined, contractStatus: number | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<DropdownValueDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeesDetails/GetEmployeesDetails?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (contractStatus === null)
            throw new Error("The parameter 'contractStatus' cannot be null.");
        else if (contractStatus !== undefined)
            url_ += "ContractStatus=" + encodeURIComponent("" + contractStatus) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesDetails(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeesDetails(response: HttpResponseBase): Observable<DropdownValueDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeesByName_IdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving all Employees with details (includes; Fullname, Id, EmpNo)
    that matches the supplied name/employee Id 
    which can be use in various part of the system for Dropdown selection for;
    Supervisor-List, Appraisal-Reviewer-List etc
     * @param nameId (optional) 
     * @return Success
     */
    getEmployeesByNameId(nameId: string | null | undefined): Observable<DropdownValueDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeesByName_Id/GetEmployeesByName-Id?";
        if (nameId !== undefined && nameId !== null)
            url_ += "nameId=" + encodeURIComponent("" + nameId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesByNameId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesByNameId(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeesByNameId(response: HttpResponseBase): Observable<DropdownValueDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving single Employee's record
     * @param employeeId (optional) 
     * @return Success
     */
    getEmployeeById(employeeId: number | undefined): Observable<EmployeeDTOApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeeById/GetEmployeeById?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeById(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeById(response: HttpResponseBase): Observable<EmployeeDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDTOApiResult>(<any>null);
    }
}

@Injectable()
export class SearchEmployeesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for Master Employees Search
     * @param pageSize (optional) 
     * @param companyId (optional) 
     * @param searchText (optional) 
     * @param peopleGroupId (optional) 
     * @param departmentId (optional) 
     * @param jobRoleId (optional) 
     * @param locationId (optional) 
     * @param salaryscaleId (optional) 
     * @param gradeId (optional) 
     * @param gradestepId (optional) 
     * @return Success
     */
    searchEmployees(pageSize: number | undefined, companyId: number | undefined, searchText: string | null | undefined, peopleGroupId: number | undefined, departmentId: number | undefined, jobRoleId: number | undefined, locationId: number | undefined, salaryscaleId: number | undefined, gradeId: number | undefined, gradestepId: number | undefined): Observable<EmployeeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Employee/SearchEmployees/SearchEmployees?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (peopleGroupId === null)
            throw new Error("The parameter 'peopleGroupId' cannot be null.");
        else if (peopleGroupId !== undefined)
            url_ += "peopleGroupId=" + encodeURIComponent("" + peopleGroupId) + "&";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (jobRoleId === null)
            throw new Error("The parameter 'jobRoleId' cannot be null.");
        else if (jobRoleId !== undefined)
            url_ += "jobRoleId=" + encodeURIComponent("" + jobRoleId) + "&";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (salaryscaleId === null)
            throw new Error("The parameter 'salaryscaleId' cannot be null.");
        else if (salaryscaleId !== undefined)
            url_ += "salaryscaleId=" + encodeURIComponent("" + salaryscaleId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (gradestepId === null)
            throw new Error("The parameter 'gradestepId' cannot be null.");
        else if (gradestepId !== undefined)
            url_ += "gradestepId=" + encodeURIComponent("" + gradestepId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchEmployees(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearchEmployees(response: HttpResponseBase): Observable<EmployeeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllEmployeesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving All Tenant's registered Employees
     * @param searchText (optional) 
     * @param contractStatus (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllEmployees(searchText: string | null | undefined, contractStatus: number | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<EmployeeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchAllEmployees/GetAllEmployees?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (contractStatus === null)
            throw new Error("The parameter 'contractStatus' cannot be null.");
        else if (contractStatus !== undefined)
            url_ += "ContractStatus=" + encodeURIComponent("" + contractStatus) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmployees(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEmployees(response: HttpResponseBase): Observable<EmployeeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeContractByEmployeeIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving Employee's Contract profile by Employee Id
     * @param employeeId (optional) 
     * @return Success
     */
    fetchEmployeeContractByEmployeeId(employeeId: number | undefined): Observable<EmployeeContractAssignmentDTOApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeeContractByEmployeeId/FetchEmployeeContractByEmployeeId?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEmployeeContractByEmployeeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEmployeeContractByEmployeeId(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeContractAssignmentDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeContractAssignmentDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEmployeeContractByEmployeeId(response: HttpResponseBase): Observable<EmployeeContractAssignmentDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeContractAssignmentDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeContractAssignmentDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Event
     * @param body (optional) 
     * @return Success
     */
    addUpdateEvent(body: ManageEventDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Events/AddUpdateEvents/Add-Update-Event";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEvent(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEvent(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch Events.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllEvents(pageSize: number | undefined, pageNumber: number | undefined): Observable<EventDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Events/GetAllEvents/GetAllEvents?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEvents(<any>response_);
                } catch (e) {
                    return <Observable<EventDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EventDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEvents(response: HttpResponseBase): Observable<EventDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetEventsByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to get jobroles by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getEventsById(id: number | undefined): Observable<EventDTOApiResult> {
        let url_ = this.baseUrl + "/api/Events/GetEventsById/GetEventsById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEventsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEventsById(<any>response_);
                } catch (e) {
                    return <Observable<EventDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EventDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEventsById(response: HttpResponseBase): Observable<EventDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventDTOApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to delete JobRole
     * @param id (optional) 
     * @return Success
     */
    deleteEvents(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Events/DeleteEvents/DeleteEvents?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEvents(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEvents(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateExpenseGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateExpenseGroup(body: ExpenseGroupDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseGroup/AddUpdateExpenseGroup/AddUpdateExpenseGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateExpenseGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateExpenseGroup(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateExpenseGroup(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseGroup(encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseGroup/ToggleExpenseGroup/ToggleExpenseGroup?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseGroup(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseGroup(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseGroupsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param companyID (optional) 
     * @param subID (optional) 
     * @param name (optional) 
     * @param iD (optional) 
     * @param referenceId (optional) 
     * @param code (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getExpenseGroups(companyID: number | undefined, subID: number | undefined, name: string | null | undefined, iD: number | undefined, referenceId: string | null | undefined, code: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseGroupIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseGroup/GetExpenseGroups/GetExpenseGroups?";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        if (subID === null)
            throw new Error("The parameter 'subID' cannot be null.");
        else if (subID !== undefined)
            url_ += "SubID=" + encodeURIComponent("" + subID) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (referenceId !== undefined && referenceId !== null)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseGroups(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseGroupIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseGroupIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseGroups(response: HttpResponseBase): Observable<ExpenseGroupIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseGroupIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseGroupIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateExpenseProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateExpenseProject(body: ExpenseProjectDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseProject/AddUpdateExpenseProject/AddUpdateExpenseProject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateExpenseProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateExpenseProject(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateExpenseProject(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseProject(encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseProject/ToggleExpenseProject/ToggleExpenseProject?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseProject(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseProject(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param iD (optional) 
     * @param name (optional) 
     * @param description (optional) 
     * @param ban (optional) 
     * @param referenceId (optional) 
     * @param code (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getExpenseProject(iD: number | undefined, name: string | null | undefined, description: string | null | undefined, ban: boolean | undefined, referenceId: string | null | undefined, code: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseProjectIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseProject/GetExpenseProject/GetExpenseProject?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (ban === null)
            throw new Error("The parameter 'ban' cannot be null.");
        else if (ban !== undefined)
            url_ += "Ban=" + encodeURIComponent("" + ban) + "&";
        if (referenceId !== undefined && referenceId !== null)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseProject(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseProjectIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseProjectIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseProject(response: HttpResponseBase): Observable<ExpenseProjectIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseProjectIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseProjectIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateProjectActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateProjectActivity(body: ExpenseProjectActivityDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseProjectActivity/AddUpdateProjectActivity/Add-Update-ProjectActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateProjectActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateProjectActivity(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateProjectActivity(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleProjectActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    toggleLoanType(body: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseProjectActivity/ToggleProjectActivity/Toggle-Loan-Type";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleLoanType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleLoanType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleLoanType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetProjectActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param companyID (optional) 
     * @param subID (optional) 
     * @param name (optional) 
     * @param iD (optional) 
     * @param referenceId (optional) 
     * @param code (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getProjectActivity(companyID: number | undefined, subID: number | undefined, name: string | null | undefined, iD: number | undefined, referenceId: string | null | undefined, code: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseProjectActivityIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseProjectActivity/GetProjectActivity/GetProjectActivity?";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        if (subID === null)
            throw new Error("The parameter 'subID' cannot be null.");
        else if (subID !== undefined)
            url_ += "SubID=" + encodeURIComponent("" + subID) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (referenceId !== undefined && referenceId !== null)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectActivity(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseProjectActivityIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseProjectActivityIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectActivity(response: HttpResponseBase): Observable<ExpenseProjectActivityIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseProjectActivityIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseProjectActivityIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateExpenseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateExpense(body: ExpenseDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseRequest/AddUpdateExpense/AddUpdateExpense";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateExpense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateExpense(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateExpense(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseRequest(encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseRequest/ToggleExpenseRequest/ToggleExpenseRequest?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchExpensesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param companyID (optional) 
     * @param subID (optional) 
     * @param iD (optional) 
     * @param userid (optional) 
     * @param companyid (optional) 
     * @param searchText (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchType (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchExpenses(companyID: number | undefined, subID: number | undefined, iD: number | undefined, userid: number | undefined, companyid: number | undefined, searchText: string | null | undefined, startDate: string | null | undefined, endDate: string | null | undefined, searchType: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseRequest/FetchExpenses/FetchExpenses?";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        if (subID === null)
            throw new Error("The parameter 'subID' cannot be null.");
        else if (subID !== undefined)
            url_ += "SubID=" + encodeURIComponent("" + subID) + "&";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        if (companyid === null)
            throw new Error("The parameter 'companyid' cannot be null.");
        else if (companyid !== undefined)
            url_ += "companyid=" + encodeURIComponent("" + companyid) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "startDate=" + encodeURIComponent("" + startDate) + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "endDate=" + encodeURIComponent("" + endDate) + "&";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchExpenses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchExpenses(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchExpenses(response: HttpResponseBase): Observable<ExpenseDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchExpensesDetailedServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param projid (optional) 
     * @param expensegrpid (optional) 
     * @param expensetypeid (optional) 
     * @param locationid (optional) 
     * @param deptid (optional) 
     * @param userid (optional) 
     * @param companyid (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchType (optional) 
     * @param page (optional) 
     * @param searchText (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchExpensesDetailed(projid: number | undefined, expensegrpid: number | undefined, expensetypeid: number | undefined, locationid: number | undefined, deptid: number | undefined, userid: number | undefined, companyid: number | undefined, startDate: Date | undefined, endDate: Date | undefined, searchType: number | undefined, page: number | undefined, searchText: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseRequest/FetchExpensesDetailed/FetchExpensesDetailed?";
        if (projid === null)
            throw new Error("The parameter 'projid' cannot be null.");
        else if (projid !== undefined)
            url_ += "projid=" + encodeURIComponent("" + projid) + "&";
        if (expensegrpid === null)
            throw new Error("The parameter 'expensegrpid' cannot be null.");
        else if (expensegrpid !== undefined)
            url_ += "expensegrpid=" + encodeURIComponent("" + expensegrpid) + "&";
        if (expensetypeid === null)
            throw new Error("The parameter 'expensetypeid' cannot be null.");
        else if (expensetypeid !== undefined)
            url_ += "expensetypeid=" + encodeURIComponent("" + expensetypeid) + "&";
        if (locationid === null)
            throw new Error("The parameter 'locationid' cannot be null.");
        else if (locationid !== undefined)
            url_ += "locationid=" + encodeURIComponent("" + locationid) + "&";
        if (deptid === null)
            throw new Error("The parameter 'deptid' cannot be null.");
        else if (deptid !== undefined)
            url_ += "deptid=" + encodeURIComponent("" + deptid) + "&";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        if (companyid === null)
            throw new Error("The parameter 'companyid' cannot be null.");
        else if (companyid !== undefined)
            url_ += "companyid=" + encodeURIComponent("" + companyid) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchExpensesDetailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchExpensesDetailed(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchExpensesDetailed(response: HttpResponseBase): Observable<ExpenseDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateLoanTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateExpenseType(body: ExpenseTypeDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/AddUpdateLoanType/AddUpdateExpenseType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateExpenseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateExpenseType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateExpenseType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateLoanRequest(body: NewLoanRequestDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/AddUpdateLoanType/Add-Update-Loan-Request";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateLoanRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateLoanRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateLoanRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateLoanType(body: ManageLoanTypeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/AddUpdateLoanType/Add-Update-LoanType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateLoanType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateLoanType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateLoanType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseType(encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/ToggleExpenseType/ToggleExpenseType?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param iD (optional) 
     * @param ledgerNo (optional) 
     * @param name (optional) 
     * @param description (optional) 
     * @param referenceId (optional) 
     * @param code (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getExpenseTypes(iD: number | undefined, ledgerNo: string | null | undefined, name: string | null | undefined, description: string | null | undefined, referenceId: string | null | undefined, code: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/GetExpenseTypes/GetExpenseTypes?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (ledgerNo !== undefined && ledgerNo !== null)
            url_ += "LedgerNo=" + encodeURIComponent("" + ledgerNo) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (referenceId !== undefined && referenceId !== null)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseTypes(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseTypes(response: HttpResponseBase): Observable<ExpenseTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddExpenseSubTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addExpenseSubType(body: ExpenseSubType | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/AddExpenseSubType/AddExpenseSubType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddExpenseSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddExpenseSubType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddExpenseSubType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseSubTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param typeId (optional) 
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseSubType(typeId: string | null | undefined, encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/ToggleExpenseSubType/ToggleExpenseSubType?";
        if (typeId !== undefined && typeId !== null)
            url_ += "TypeId=" + encodeURIComponent("" + typeId) + "&";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseSubType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseSubType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseTypeNameServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    getExpenseTypeName(encryptedId: string | null | undefined): Observable<ExpenseTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/GetExpenseTypeName/GetExpenseTypeName?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseTypeName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseTypeName(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseTypeName(response: HttpResponseBase): Observable<ExpenseTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseSubTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param iD (optional) 
     * @param ledgerNo (optional) 
     * @param name (optional) 
     * @param description (optional) 
     * @param referenceId (optional) 
     * @param code (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getExpenseSubTypes(iD: number | undefined, ledgerNo: string | null | undefined, name: string | null | undefined, description: string | null | undefined, referenceId: string | null | undefined, code: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/GetExpenseSubTypes/GetExpenseSubTypes?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (ledgerNo !== undefined && ledgerNo !== null)
            url_ += "LedgerNo=" + encodeURIComponent("" + ledgerNo) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (referenceId !== undefined && referenceId !== null)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseSubTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseSubTypes(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseSubTypes(response: HttpResponseBase): Observable<ExpenseTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class FileStorageManagerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to upload documents for Employee on the system.
     * @param id (optional) 
     * @param employee_id (optional) 
     * @param employeeNo (optional) 
     * @param name (optional) 
     * @param directory (optional) 
     * @param lastModifiedDate (optional) 
     * @param docUrl (optional) 
     * @param file (optional) 
     * @param docType (optional) 
     * @param comment (optional) 
     * @return Success
     */
    uploadDocuments(id: number | undefined, employee_id: number | undefined, employeeNo: string | undefined, name: string | undefined, directory: string | null | undefined, lastModifiedDate: Date | undefined, docUrl: string | null | undefined, file: FileParameter | null | undefined, docType: string | undefined, comment: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/FileStorageManager/UploadDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("id", id.toString());
        if (employee_id === null || employee_id === undefined)
            throw new Error("The parameter 'employee_id' cannot be null.");
        else
            content_.append("employee_id", employee_id.toString());
        if (employeeNo === null || employeeNo === undefined)
            throw new Error("The parameter 'employeeNo' cannot be null.");
        else
            content_.append("EmployeeNo", employeeNo.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (directory !== null && directory !== undefined)
            content_.append("Directory", directory.toString());
        if (lastModifiedDate === null || lastModifiedDate === undefined)
            throw new Error("The parameter 'lastModifiedDate' cannot be null.");
        else
            content_.append("LastModifiedDate", lastModifiedDate.toJSON());
        if (docUrl !== null && docUrl !== undefined)
            content_.append("DocUrl", docUrl.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (docType === null || docType === undefined)
            throw new Error("The parameter 'docType' cannot be null.");
        else
            content_.append("docType", docType.toString());
        if (comment !== null && comment !== undefined)
            content_.append("comment", comment.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadDocuments(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUploadDocuments(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param employeeNumber (optional) 
     * @param docType (optional) 
     * @return Success
     */
    fetchEmployeeDocuments(employeeNumber: string | null | undefined, docType: string | null | undefined): Observable<AzureDocsListApiResult> {
        let url_ = this.baseUrl + "/api/FileStorageManager/FetchEmployeeDocuments?";
        if (employeeNumber !== undefined && employeeNumber !== null)
            url_ += "employeeNumber=" + encodeURIComponent("" + employeeNumber) + "&";
        if (docType !== undefined && docType !== null)
            url_ += "docType=" + encodeURIComponent("" + docType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEmployeeDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEmployeeDocuments(<any>response_);
                } catch (e) {
                    return <Observable<AzureDocsListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AzureDocsListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEmployeeDocuments(response: HttpResponseBase): Observable<AzureDocsListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AzureDocsListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AzureDocsListApiResult>(<any>null);
    }

    /**
     * API for downloading Document in form of Base64string by passing the filename
     * @param filename (optional) 
     * @return Success
     */
    downloadMiscDocument(filename: string | null | undefined): Observable<StringApiResult> {
        let url_ = this.baseUrl + "/api/FileStorageManager/DownloadMiscDocument?";
        if (filename !== undefined && filename !== null)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadMiscDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadMiscDocument(<any>response_);
                } catch (e) {
                    return <Observable<StringApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadMiscDocument(response: HttpResponseBase): Observable<StringApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringApiResult>(<any>null);
    }
}

@Injectable()
export class GradeLevelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating GradeLevel
     * @param body (optional) 
     * @return Success
     */
    addUpdateGradeLevel(body: GradeLevelCreatePayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevel/Add-Update-GradeLevel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateGradeLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateGradeLevel(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateGradeLevel(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API  for Deleting GradeLevel
     * @param body (optional) 
     * @return Success
     */
    delete_GradeLevel(body: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevel/Delete GradeLevel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete_GradeLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete_GradeLevel(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDelete_GradeLevel(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch GradeLevel.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param promotion_min_years (optional) 
     * @param promotion_min_in_days (optional) 
     * @return Success
     */
    getAllGradeLevel(pageSize: number | undefined, pageNumber: number | undefined, promotion_min_years: number | null | undefined, promotion_min_in_days: number | null | undefined): Observable<GradeLevelDTOListApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevel/GetAllGradeLevel?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (promotion_min_years !== undefined && promotion_min_years !== null)
            url_ += "promotion_min_years=" + encodeURIComponent("" + promotion_min_years) + "&";
        if (promotion_min_in_days !== undefined && promotion_min_in_days !== null)
            url_ += "promotion_min_in_days=" + encodeURIComponent("" + promotion_min_in_days) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGradeLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGradeLevel(<any>response_);
                } catch (e) {
                    return <Observable<GradeLevelDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeLevelDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGradeLevel(response: HttpResponseBase): Observable<GradeLevelDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeLevelDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeLevelDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GradeLevelBenefitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating GradeLevelBenefit
     * @param body (optional) 
     * @return Success
     */
    addUpdateGradeLevelBenefit(body: ManageGradeLevelBenefitDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevelBenefit/Add-Update-GradeLevelBenefit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateGradeLevelBenefit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateGradeLevelBenefit(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateGradeLevelBenefit(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API  for Deleting GradeLevelBenefit
     * @param id (optional) 
     * @return Success
     */
    deleteGradeLevelBenefit(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevelBenefit/DeleteGradeLevelBenefit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGradeLevelBenefit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGradeLevelBenefit(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteGradeLevelBenefit(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to get GradeLevelBenefit by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getGradeLevelBenefitById(id: number | undefined): Observable<GradeLevelBenefitDTOApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevelBenefit/GetGradeLevelBenefitById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeLevelBenefitById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeLevelBenefitById(<any>response_);
                } catch (e) {
                    return <Observable<GradeLevelBenefitDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeLevelBenefitDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGradeLevelBenefitById(response: HttpResponseBase): Observable<GradeLevelBenefitDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeLevelBenefitDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeLevelBenefitDTOApiResult>(<any>null);
    }

    /**
     * API to Fetch GradeLevelBenefit.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllGradeLevelBenefit(pageSize: number | undefined, pageNumber: number | undefined): Observable<GradeLevelBenefitDTOListApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevelBenefit/GetAllGradeLevelBenefit?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGradeLevelBenefit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGradeLevelBenefit(<any>response_);
                } catch (e) {
                    return <Observable<GradeLevelBenefitDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeLevelBenefitDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGradeLevelBenefit(response: HttpResponseBase): Observable<GradeLevelBenefitDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeLevelBenefitDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeLevelBenefitDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GradeLevelStepServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating GradeLevelStep
     * @param body (optional) 
     * @return Success
     */
    addUpdateGradeLevelStep(body: GradestepCreatePayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevelStep/Add-Update-GradeLevelStep";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateGradeLevelStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateGradeLevelStep(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateGradeLevelStep(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Grade Level Steps.
    Note: all filter are optional
     * @param gradeName (optional) 
     * @param stepName (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param companyID (optional) 
     * @return Success
     */
    getAllGradeLevelSteps(gradeName: boolean | undefined, stepName: boolean | undefined, pageSize: number | undefined, pageNumber: number | undefined, companyID: number | undefined): Observable<GradestepDTOListApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevelStep/GetAllGradeLevelSteps?";
        if (gradeName === null)
            throw new Error("The parameter 'gradeName' cannot be null.");
        else if (gradeName !== undefined)
            url_ += "GradeName=" + encodeURIComponent("" + gradeName) + "&";
        if (stepName === null)
            throw new Error("The parameter 'stepName' cannot be null.");
        else if (stepName !== undefined)
            url_ += "stepName=" + encodeURIComponent("" + stepName) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGradeLevelSteps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGradeLevelSteps(<any>response_);
                } catch (e) {
                    return <Observable<GradestepDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradestepDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGradeLevelSteps(response: HttpResponseBase): Observable<GradestepDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradestepDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradestepDTOListApiResult>(<any>null);
    }

    /**
     * API to get GradeLevelStep by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getGradeLevelStepById(id: number | undefined): Observable<GradestepDTOApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevelStep/GetGradeLevelStepById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGradeLevelStepById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGradeLevelStepById(<any>response_);
                } catch (e) {
                    return <Observable<GradestepDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradestepDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGradeLevelStepById(response: HttpResponseBase): Observable<GradestepDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradestepDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradestepDTOApiResult>(<any>null);
    }

    /**
     * API  for Deleting GradeLevel Step
     * @param body (optional) 
     * @return Success
     */
    delete_GradeLevel_Step(body: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/GradeLevelStep/Delete GradeLevel Step";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete_GradeLevel_Step(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete_GradeLevel_Step(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDelete_GradeLevel_Step(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class InstitutionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Institution
     * @param body (optional) 
     * @return Success
     */
    addUpdateInstitution(body: Institution | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Institution/Add-Update-Institution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateInstitution(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateInstitution(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Institutions.
    Note: all filter are optional
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllInstitutions(pageNumber: number | undefined, pageSize: number | undefined): Observable<InstitutionListApiResult> {
        let url_ = this.baseUrl + "/api/Institution/GetAllInstitutions?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInstitutions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInstitutions(<any>response_);
                } catch (e) {
                    return <Observable<InstitutionListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InstitutionListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllInstitutions(response: HttpResponseBase): Observable<InstitutionListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InstitutionListApiResult>(<any>null);
    }

    /**
     * API to get Institution by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getInstitution(id: number | undefined): Observable<InstitutionApiResult> {
        let url_ = this.baseUrl + "/api/Institution/GetInstitution?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstitution(<any>response_);
                } catch (e) {
                    return <Observable<InstitutionApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InstitutionApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetInstitution(response: HttpResponseBase): Observable<InstitutionApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InstitutionApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateInterestRateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateIntrestRate(body: InterestRateDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/InterestRate/AddUpdateInterestRate/Add-Update-IntrestRate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateIntrestRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateIntrestRate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateIntrestRate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleInterestRateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    toggleInterestRate(body: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/InterestRate/ToggleInterestRate/Toggle-Interest-Rate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleInterestRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleInterestRate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleInterestRate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetInterestRateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @return Success
     */
    getInterestRate(): Observable<InterestRateIListApiResult> {
        let url_ = this.baseUrl + "/api/InterestRate/GetInterestRate/GetInterestRate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInterestRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInterestRate(<any>response_);
                } catch (e) {
                    return <Observable<InterestRateIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InterestRateIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetInterestRate(response: HttpResponseBase): Observable<InterestRateIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InterestRateIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InterestRateIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateJobRolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating JobRole
     * @param body (optional) 
     * @return Success
     */
    addUpdateJobRoles(body: ManageJobRoleDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/JobRoles/AddUpdateJobRoles/Add-Update-JobRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateJobRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateJobRoles(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateJobRoles(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllJobRolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch JobRoles.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllJobRoles(pageSize: number | undefined, pageNumber: number | undefined): Observable<JobRolesDTOListApiResult> {
        let url_ = this.baseUrl + "/api/JobRoles/GetAllJobRoles/GetAllJobRoles?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllJobRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllJobRoles(<any>response_);
                } catch (e) {
                    return <Observable<JobRolesDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobRolesDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllJobRoles(response: HttpResponseBase): Observable<JobRolesDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobRolesDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobRolesDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetJobRoleByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to get jobroles by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getJobRolesById(id: number | undefined): Observable<JobRolesDTOApiResult> {
        let url_ = this.baseUrl + "/api/JobRoles/GetJobRoleById/GetJobRolesById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobRolesById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobRolesById(<any>response_);
                } catch (e) {
                    return <Observable<JobRolesDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobRolesDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobRolesById(response: HttpResponseBase): Observable<JobRolesDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobRolesDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobRolesDTOApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteJobRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to delete Jobrole
     * @param id (optional) 
     * @return Success
     */
    deleteJobRole(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/JobRoles/DeleteJobRole/DeleteJobRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteJobRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteJobRole(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteJobRole(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchKeyResultAreasServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving all Key Result Areas with filters as follows 
    'Status: for Active/InActive' Key Result Area
    'RatingType: for Open-ended/Close-ended' Key Result Area
     * @param status (optional) 
     * @param ratingType (optional) 
     * @param strategyCategoryId (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getKeyResultAreas(status: number | undefined, ratingType: number | undefined, strategyCategoryId: number | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<SectionDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/KeyResultArea/FetchKeyResultAreas/GetKeyResultAreas?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (ratingType === null)
            throw new Error("The parameter 'ratingType' cannot be null.");
        else if (ratingType !== undefined)
            url_ += "RatingType=" + encodeURIComponent("" + ratingType) + "&";
        if (strategyCategoryId === null)
            throw new Error("The parameter 'strategyCategoryId' cannot be null.");
        else if (strategyCategoryId !== undefined)
            url_ += "StrategyCategoryId=" + encodeURIComponent("" + strategyCategoryId) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyResultAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyResultAreas(<any>response_);
                } catch (e) {
                    return <Observable<SectionDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SectionDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeyResultAreas(response: HttpResponseBase): Observable<SectionDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SectionDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SectionDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchKRAsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving all Key Result Areas without filters that can be using for dropdowns
     * @return Success
     */
    getKRAs(): Observable<KPISectionIListApiResult> {
        let url_ = this.baseUrl + "/api/KeyResultArea/FetchKRAs/GetKRAs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKRAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKRAs(<any>response_);
                } catch (e) {
                    return <Observable<KPISectionIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KPISectionIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetKRAs(response: HttpResponseBase): Observable<KPISectionIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KPISectionIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KPISectionIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchKeyResultAreaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting Single Key Result Area Details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getKeyResultArea(id: number | undefined): Observable<SectionDTOApiResult> {
        let url_ = this.baseUrl + "/api/KeyResultArea/FetchKeyResultArea/GetKeyResultArea?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyResultArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyResultArea(<any>response_);
                } catch (e) {
                    return <Observable<SectionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SectionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeyResultArea(response: HttpResponseBase): Observable<SectionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SectionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SectionDTOApiResult>(<any>null);
    }
}

@Injectable()
export class CreateKeyResultAreaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for add/updating Key Result Areas 
    Toggle (i.e. While Updating use the property 'IsActive'
    as Radio-toggle button and pass true/false. When creating new Key Result Areas 'IsActive is by default)
     * @param body (optional) 
     * @return Success
     */
    createKeyResultArea(body: ManageSectionDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/KeyResultArea/CreateKeyResultArea/CreateKeyResultArea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateKeyResultArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateKeyResultArea(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateKeyResultArea(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AssignKRAServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for add/updating Key Result Areas 
    Toggle (i.e. While Updating use the property 'IsActive'
    as Radio-toggle button and pass true/false. When creating new Key Result Areas 'IsActive is by default)
     * @param body (optional) 
     * @return Success
     */
    assignKRA(body: AssignKraDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/KeyResultArea/AssignKRA/AssignKRA";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignKRA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignKRA(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssignKRA(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateKPIServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for add/updating Key Performance Index (KPI) by Admin/Line Managers
     * @param body (optional) 
     * @return Success
     */
    addUpdateKPI(body: ManageKpiDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/KPI/AddUpdateKPI/Add-Update-KPI";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateKPI(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateKPI(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEmployeeKPIServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for add/updating Employee's Key Performance Index (KPI)
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmployeeKPI(body: ManageKpiDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/KPI/AddUpdateEmployeeKPI/Add-Update-EmployeeKPI";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmployeeKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmployeeKPI(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmployeeKPI(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchKPIsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving All Key Performance Index (KPIs) attach to a KRA
     * @param key_area_id (optional) 
     * @return Success
     */
    getKPIs(key_area_id: number | undefined): Observable<KpiDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/KPI/FetchKPIs/GetKPIs?";
        if (key_area_id === null)
            throw new Error("The parameter 'key_area_id' cannot be null.");
        else if (key_area_id !== undefined)
            url_ += "key_area_id=" + encodeURIComponent("" + key_area_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKPIs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKPIs(<any>response_);
                } catch (e) {
                    return <Observable<KpiDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KpiDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetKPIs(response: HttpResponseBase): Observable<KpiDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KpiDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KpiDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchKPIServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting Single Key Performance Index (KPI) Details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getKPI(id: number | undefined): Observable<KpiDTOApiResult> {
        let url_ = this.baseUrl + "/api/KPI/FetchKPI/GetKPI?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKPI(<any>response_);
                } catch (e) {
                    return <Observable<KpiDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KpiDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetKPI(response: HttpResponseBase): Observable<KpiDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KpiDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KpiDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeKPIsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving Employee's Key Performance Index (KPI)
     * @param key_area_id (optional) 
     * @return Success
     */
    getEmployeeKPIs(key_area_id: number | undefined): Observable<KpiDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/KPI/FetchEmployeeKPIs/GetEmployeeKPIs?";
        if (key_area_id === null)
            throw new Error("The parameter 'key_area_id' cannot be null.");
        else if (key_area_id !== undefined)
            url_ += "key_area_id=" + encodeURIComponent("" + key_area_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeKPIs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeKPIs(<any>response_);
                } catch (e) {
                    return <Observable<KpiDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KpiDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeKPIs(response: HttpResponseBase): Observable<KpiDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KpiDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KpiDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class LeaveEntitlementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to fetch all the leave entitlements. no param for now
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getLeaveEntitlements(pageNumber: number | undefined, pageSize: number | undefined): Observable<LeaveEntitlementResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/GetLeaveEntitlements?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveEntitlements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveEntitlements(<any>response_);
                } catch (e) {
                    return <Observable<LeaveEntitlementResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveEntitlementResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveEntitlements(response: HttpResponseBase): Observable<LeaveEntitlementResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveEntitlementResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveEntitlementResourceListApiResult>(<any>null);
    }

    /**
     * this method is get leave entitlement by Id. Id is required
     * @param id (optional) 
     * @return Success
     */
    getLeaveEntitlement(id: number | undefined): Observable<LeaveEntitlementResourceApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/GetLeaveEntitlement?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveEntitlement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveEntitlement(<any>response_);
                } catch (e) {
                    return <Observable<LeaveEntitlementResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveEntitlementResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveEntitlement(response: HttpResponseBase): Observable<LeaveEntitlementResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveEntitlementResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveEntitlementResourceApiResult>(<any>null);
    }

    /**
     * this method is used to used to create and edit leave entitlement. Note all fields are required.
     * @param body (optional) 
     * @return Success
     */
    addLeaveEntitlement(body: LeaveEntitlementPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/AddLeaveEntitlement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddLeaveEntitlement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddLeaveEntitlement(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddLeaveEntitlement(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave entitlement
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveEntitlement(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/DeleteLeaveEntitlement?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveEntitlement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveEntitlement(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveEntitlement(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to fetch all grades for a particular company. it uses authenticated user comapyid
     * @return Success
     */
    getGrades(): Observable<GradeListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/GetGrades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGrades(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGrades(<any>response_);
                } catch (e) {
                    return <Observable<GradeListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGrades(response: HttpResponseBase): Observable<GradeListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateHolidayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for add/updating Leave Holiday Date
     * @param body (optional) 
     * @return Success
     */
    addUpdateHoliday(body: ManageLeaveHolidayDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/AddUpdateHoliday/Add-Update-Holiday";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateHoliday(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateHoliday(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateHoliday(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class HolidayDatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to fetch all or by Id. no param for now
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getHolidayDates(pageNumber: number | undefined, pageSize: number | undefined): Observable<LeaveHolidayDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/HolidayDates/GetHolidayDates?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHolidayDates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHolidayDates(<any>response_);
                } catch (e) {
                    return <Observable<LeaveHolidayDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveHolidayDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetHolidayDates(response: HttpResponseBase): Observable<LeaveHolidayDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveHolidayDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveHolidayDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is get leave holiday date by Id. Id is required
     * @param id (optional) 
     * @return Success
     */
    getHolidayById(id: number | undefined): Observable<LeaveHolidayDTOApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/GetById/GetHolidayById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHolidayById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHolidayById(<any>response_);
                } catch (e) {
                    return <Observable<LeaveHolidayDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveHolidayDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetHolidayById(response: HttpResponseBase): Observable<LeaveHolidayDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveHolidayDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveHolidayDTOApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to delete leave holiday date
     * @param id (optional) 
     * @return Success
     */
    deleteHolidayDate(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/Delete/DeleteHolidayDate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteHolidayDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHolidayDate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteHolidayDate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave plan
     * @param id (optional) 
     * @return Success
     */
    deleteLeavePlan(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/Delete/DeleteLeavePlan?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeavePlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeavePlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeavePlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete. leave request Id is required
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveRequest(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/Delete/DeleteLeaveRequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave year
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveYear(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/Delete/DeleteLeaveYear?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveYear(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveYear(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CreateLeavePlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to create  leave plan. Note all fields are required
     * @param body (optional) 
     * @return Success
     */
    createLeavePlan(body: LeavePlanDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/CreateLeavePlan/CreateLeavePlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLeavePlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLeavePlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLeavePlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchLeavePlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used fetch leave plans. all filter are optional
     * @param isApproved (optional) 
     * @param leaveYearId (optional) 
     * @param leaveTypeId (optional) 
     * @param empno (optional) 
     * @param strStartDate (optional) 
     * @param strEndDate (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchLeavePlans(isApproved: number | null | undefined, leaveYearId: number | null | undefined, leaveTypeId: number | null | undefined, empno: string | null | undefined, strStartDate: Date | null | undefined, strEndDate: Date | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<LeavePlanResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/FetchLeavePlan/FetchLeavePlans?";
        if (isApproved !== undefined && isApproved !== null)
            url_ += "IsApproved=" + encodeURIComponent("" + isApproved) + "&";
        if (leaveYearId !== undefined && leaveYearId !== null)
            url_ += "LeaveYearId=" + encodeURIComponent("" + leaveYearId) + "&";
        if (leaveTypeId !== undefined && leaveTypeId !== null)
            url_ += "LeaveTypeId=" + encodeURIComponent("" + leaveTypeId) + "&";
        if (empno !== undefined && empno !== null)
            url_ += "Empno=" + encodeURIComponent("" + empno) + "&";
        if (strStartDate !== undefined && strStartDate !== null)
            url_ += "StrStartDate=" + encodeURIComponent(strStartDate ? "" + strStartDate.toJSON() : "") + "&";
        if (strEndDate !== undefined && strEndDate !== null)
            url_ += "StrEndDate=" + encodeURIComponent(strEndDate ? "" + strEndDate.toJSON() : "") + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchLeavePlans(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchLeavePlans(<any>response_);
                } catch (e) {
                    return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchLeavePlans(response: HttpResponseBase): Observable<LeavePlanResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeavePlanResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeavePlanResourceListApiResult>(<any>null);
    }
}

@Injectable()
export class LeavePlanEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used fetch events using calender type.calender type include: LeavePlan, ActiveLeaveRequests
     * @param calenderType (optional) 
     * @return Success
     */
    getLeavePlanEvents(calenderType: string | null | undefined): Observable<LeavePlanResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/LeavePlanEvents/GetLeavePlanEvents?";
        if (calenderType !== undefined && calenderType !== null)
            url_ += "calenderType=" + encodeURIComponent("" + calenderType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeavePlanEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeavePlanEvents(<any>response_);
                } catch (e) {
                    return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeavePlanEvents(response: HttpResponseBase): Observable<LeavePlanResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeavePlanResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeavePlanResourceListApiResult>(<any>null);
    }
}

@Injectable()
export class ApproveOrRejectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to approve or reject leave plan. Note all fields are requiered except companyId
    it uses Enum Leave Plan status : Approved = 1, Reject = 2, Pending =3
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectLeavePlan(body: ApproveOrRejectPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/ApproveOrReject/ApproveOrRejectLeavePlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectLeavePlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectLeavePlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectLeavePlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class PostReviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to review leave plan. Note all fields are requiered except companyId
    it uses Enum Leave Plan status : Approved = 1, Reject = 2, Pending =3
     * @param body (optional) 
     * @return Success
     */
    postReview(body: ApproveOrRejectPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/PostReview/postReview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostReview(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostReview(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CreateLeaveByAdminServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to create and edit leave by admin.
     * @param body (optional) 
     * @return Success
     */
    createLeaveByAdmin(body: ManageLeaveRequestDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/CreateLeaveByAdmin/CreateLeaveByAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLeaveByAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLeaveByAdmin(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLeaveByAdmin(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to get leave report.
    all filter is optional
     * @param leaveTypeId (optional) 
     * @param leaveYearId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param employeeName (optional) 
     * @param noOfDays (optional) 
     * @param remainingDays (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getLeaveReports(leaveTypeId: number | undefined, leaveYearId: number | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, employeeName: string | null | undefined, noOfDays: number | undefined, remainingDays: number | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<LeaveReportListDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/GetLeaveRequest/GetLeaveReports?";
        if (leaveTypeId === null)
            throw new Error("The parameter 'leaveTypeId' cannot be null.");
        else if (leaveTypeId !== undefined)
            url_ += "LeaveTypeId=" + encodeURIComponent("" + leaveTypeId) + "&";
        if (leaveYearId === null)
            throw new Error("The parameter 'leaveYearId' cannot be null.");
        else if (leaveYearId !== undefined)
            url_ += "LeaveYearId=" + encodeURIComponent("" + leaveYearId) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (employeeName !== undefined && employeeName !== null)
            url_ += "EmployeeName=" + encodeURIComponent("" + employeeName) + "&";
        if (noOfDays === null)
            throw new Error("The parameter 'noOfDays' cannot be null.");
        else if (noOfDays !== undefined)
            url_ += "NoOfDays=" + encodeURIComponent("" + noOfDays) + "&";
        if (remainingDays === null)
            throw new Error("The parameter 'remainingDays' cannot be null.");
        else if (remainingDays !== undefined)
            url_ += "RemainingDays=" + encodeURIComponent("" + remainingDays) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveReports(<any>response_);
                } catch (e) {
                    return <Observable<LeaveReportListDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveReportListDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveReports(response: HttpResponseBase): Observable<LeaveReportListDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveReportListDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveReportListDTOListApiResult>(<any>null);
    }

    /**
     * this method is used to get leave by Id.
    Id is required
     * @param id (optional) 
     * @return Success
     */
    getLeaveRequestById(id: number | undefined): Observable<LeaveRequestApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/GetLeaveRequest/GetLeaveRequestById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveRequestById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveRequestById(<any>response_);
                } catch (e) {
                    return <Observable<LeaveRequestApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveRequestApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveRequestById(response: HttpResponseBase): Observable<LeaveRequestApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveRequestApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveRequestApiResult>(<any>null);
    }
}

@Injectable()
export class CancelLeaveRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to cancel leave request by initiator. leave request Id is required
     * @param id (optional) 
     * @return Success
     */
    cancelLeaveRequest(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/CancelLeaveRequest/CancelLeaveRequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelLeaveRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelLeaveRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCancelLeaveRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * fetch LeaveTypes.
    Note: all filter are optional
     * @param isAnnualLeave (optional) 
     * @param maxDays (optional) 
     * @param isGradeDependent (optional) 
     * @param minDays (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getLeaveTypes(isAnnualLeave: boolean | undefined, maxDays: number | null | undefined, isGradeDependent: boolean | undefined, minDays: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<LeaveTypeDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/GetLeaveTypes/GetLeaveTypes?";
        if (isAnnualLeave === null)
            throw new Error("The parameter 'isAnnualLeave' cannot be null.");
        else if (isAnnualLeave !== undefined)
            url_ += "IsAnnualLeave=" + encodeURIComponent("" + isAnnualLeave) + "&";
        if (maxDays !== undefined && maxDays !== null)
            url_ += "MaxDays=" + encodeURIComponent("" + maxDays) + "&";
        if (isGradeDependent === null)
            throw new Error("The parameter 'isGradeDependent' cannot be null.");
        else if (isGradeDependent !== undefined)
            url_ += "IsGradeDependent=" + encodeURIComponent("" + isGradeDependent) + "&";
        if (minDays !== undefined && minDays !== null)
            url_ += "MinDays=" + encodeURIComponent("" + minDays) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveTypes(<any>response_);
                } catch (e) {
                    return <Observable<LeaveTypeDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveTypeDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveTypes(response: HttpResponseBase): Observable<LeaveTypeDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveTypeDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveTypeDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteLeaveTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to delete leave type
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveType(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/DeleteLeaveType/DeleteLeaveType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * This method is used to get leave type by id
     * @param id (optional) 
     * @return Success
     */
    getLeaveType(id: number | undefined): Observable<LeaveTypeDTOApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/GetLeaveType/GetLeaveType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveType(<any>response_);
                } catch (e) {
                    return <Observable<LeaveTypeDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveTypeDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveType(response: HttpResponseBase): Observable<LeaveTypeDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveTypeDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveTypeDTOApiResult>(<any>null);
    }
}

@Injectable()
export class LeaveWorkFlowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to fetch all the leave workflow. no param for now
     * @return Success
     */
    get(): Observable<LeaveWorkFlowResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LeaveWorkFlowResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveWorkFlowResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LeaveWorkFlowResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveWorkFlowResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveWorkFlowResourceListApiResult>(<any>null);
    }

    /**
     * this method is get leave workflow by Id. Id is required
     * @param id (optional) 
     * @return Success
     */
    getLeaveWorkFlowById(id: number | undefined): Observable<LeaveWorkFlowResourceApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/GetLeaveWorkFlowById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveWorkFlowById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveWorkFlowById(<any>response_);
                } catch (e) {
                    return <Observable<LeaveWorkFlowResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveWorkFlowResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveWorkFlowById(response: HttpResponseBase): Observable<LeaveWorkFlowResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveWorkFlowResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveWorkFlowResourceApiResult>(<any>null);
    }

    /**
     * this method is used to used to create and edit leave workflow. Note all fields are requiered.
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateWorkflow(body: LeaveworkFlowPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/AddOrUpdateWorkflow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateWorkflow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateWorkflow(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateWorkflow(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave workflow
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveWorkFlow(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/DeleteLeaveWorkFlow?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveWorkFlow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveWorkFlow(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveWorkFlow(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveYearsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * Gets leave years
     * @param yearStartDate (optional) 
     * @param yearName (optional) 
     * @param yearEndDate (optional) 
     * @param companyID (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getLeaveYears(yearStartDate: Date | null | undefined, yearName: string | null | undefined, yearEndDate: Date | null | undefined, companyID: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<LeaveYearDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/GetLeaveYears/GetLeaveYears?";
        if (yearStartDate !== undefined && yearStartDate !== null)
            url_ += "YearStartDate=" + encodeURIComponent(yearStartDate ? "" + yearStartDate.toJSON() : "") + "&";
        if (yearName !== undefined && yearName !== null)
            url_ += "YearName=" + encodeURIComponent("" + yearName) + "&";
        if (yearEndDate !== undefined && yearEndDate !== null)
            url_ += "YearEndDate=" + encodeURIComponent(yearEndDate ? "" + yearEndDate.toJSON() : "") + "&";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveYears(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveYears(<any>response_);
                } catch (e) {
                    return <Observable<LeaveYearDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveYearDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveYears(response: HttpResponseBase): Observable<LeaveYearDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveYearDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveYearDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class CreateLeaveYearServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to create and edit leave year. Note: all fields are required
     * @param body (optional) 
     * @return Success
     */
    createLeaveYear(body: LeaveYearCreatePayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/CreateLeaveYear/CreateLeaveYear";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLeaveYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLeaveYear(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLeaveYear(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveYearServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to delete leave year
     * @param id (optional) 
     * @return Success
     */
    getLeaveYear(id: number | undefined): Observable<LeaveYearDTOApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/GetLeaveYear/GetLeaveYear?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveYear(<any>response_);
                } catch (e) {
                    return <Observable<LeaveYearDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveYearDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveYear(response: HttpResponseBase): Observable<LeaveYearDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveYearDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveYearDTOApiResult>(<any>null);
    }
}

@Injectable()
export class PostFullRepaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postFullRepayment(body: PostLoanDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/PostFullRepayment/Post-Full-Repayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostFullRepayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostFullRepayment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostFullRepayment(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class SimulatePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param principal (optional) 
     * @param interestType (optional) 
     * @param tenor (optional) 
     * @param interestRate (optional) 
     * @param effectiveDate (optional) 
     * @return Success
     */
    simulatePayment(principal: number | undefined, interestType: number | undefined, tenor: number | undefined, interestRate: number | undefined, effectiveDate: string | null | undefined): Observable<LoanRepaymentLogIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/SimulatePayment/SimulatePayment?";
        if (principal === null)
            throw new Error("The parameter 'principal' cannot be null.");
        else if (principal !== undefined)
            url_ += "principal=" + encodeURIComponent("" + principal) + "&";
        if (interestType === null)
            throw new Error("The parameter 'interestType' cannot be null.");
        else if (interestType !== undefined)
            url_ += "interestType=" + encodeURIComponent("" + interestType) + "&";
        if (tenor === null)
            throw new Error("The parameter 'tenor' cannot be null.");
        else if (tenor !== undefined)
            url_ += "tenor=" + encodeURIComponent("" + tenor) + "&";
        if (interestRate === null)
            throw new Error("The parameter 'interestRate' cannot be null.");
        else if (interestRate !== undefined)
            url_ += "interestRate=" + encodeURIComponent("" + interestRate) + "&";
        if (effectiveDate !== undefined && effectiveDate !== null)
            url_ += "effectiveDate=" + encodeURIComponent("" + effectiveDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimulatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimulatePayment(<any>response_);
                } catch (e) {
                    return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSimulatePayment(response: HttpResponseBase): Observable<LoanRepaymentLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRepaymentLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRepaymentLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanRequestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param searchType (optional) 
     * @param page (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getLoanRequests(searchType: number | undefined, page: number | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<LoanRequestDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/GetLoanRequests/GetLoanRequests?";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanRequests(<any>response_);
                } catch (e) {
                    return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanRequests(response: HttpResponseBase): Observable<LoanRequestDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRequestDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRequestDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanSummaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param loanId (optional) 
     * @return Success
     */
    getLoanSummary(loanId: number | undefined): Observable<IdNameObjIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/GetLoanSummary/GetLoanSummary?";
        if (loanId === null)
            throw new Error("The parameter 'loanId' cannot be null.");
        else if (loanId !== undefined)
            url_ += "LoanId=" + encodeURIComponent("" + loanId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanSummary(<any>response_);
                } catch (e) {
                    return <Observable<IdNameObjIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameObjIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanSummary(response: HttpResponseBase): Observable<IdNameObjIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdNameObjIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameObjIListApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateLoanRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLoanRequest(body: UpdateLoadRequestDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/UpdateLoanRequest/UpdateLoanRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLoanRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLoanRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLoanRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class LoadRepaymentScheduleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param loanId (optional) 
     * @param recompute (optional) 
     * @return Success
     */
    loadRepaymentSchedule(loanId: number | undefined, recompute: number | undefined): Observable<LoanRepaymentLogIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/LoadRepaymentSchedule/LoadRepaymentSchedule?";
        if (loanId === null)
            throw new Error("The parameter 'loanId' cannot be null.");
        else if (loanId !== undefined)
            url_ += "loanId=" + encodeURIComponent("" + loanId) + "&";
        if (recompute === null)
            throw new Error("The parameter 'recompute' cannot be null.");
        else if (recompute !== undefined)
            url_ += "recompute=" + encodeURIComponent("" + recompute) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadRepaymentSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadRepaymentSchedule(<any>response_);
                } catch (e) {
                    return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processLoadRepaymentSchedule(response: HttpResponseBase): Observable<LoanRepaymentLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRepaymentLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRepaymentLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchLoanRequestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param searchType (optional) 
     * @param page (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchLoanRequests(searchType: number | undefined, page: number | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<LoanRequestDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/FetchLoanRequests/FetchLoanRequests?";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchLoanRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchLoanRequests(<any>response_);
                } catch (e) {
                    return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchLoanRequests(response: HttpResponseBase): Observable<LoanRequestDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRequestDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRequestDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param companyId (optional) 
     * @param loanreqId (optional) 
     * @param userid (optional) 
     * @return Success
     */
    getLoanRequest(companyId: number | undefined, loanreqId: number | undefined, userid: number | undefined): Observable<LoanRequestApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/GetLoanRequest/GetLoanRequest?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (loanreqId === null)
            throw new Error("The parameter 'loanreqId' cannot be null.");
        else if (loanreqId !== undefined)
            url_ += "loanreqId=" + encodeURIComponent("" + loanreqId) + "&";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanRequest(<any>response_);
                } catch (e) {
                    return <Observable<LoanRequestApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRequestApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanRequest(response: HttpResponseBase): Observable<LoanRequestApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRequestApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRequestApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanTypesByCriteriaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving All Loan Types for further CRUD operation
     * @param iD (optional) 
     * @param code (optional) 
     * @param ledgerNo (optional) 
     * @param name (optional) 
     * @param minTenor (optional) 
     * @param maxTenor (optional) 
     * @param minAmount (optional) 
     * @param maxAmount (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getLoanTypesByCriteria(iD: number | undefined, code: string | null | undefined, ledgerNo: string | null | undefined, name: string | null | undefined, minTenor: number | undefined, maxTenor: number | undefined, minAmount: number | undefined, maxAmount: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<LoanTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/GetLoanTypesByCriteria/GetLoanTypesByCriteria?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (ledgerNo !== undefined && ledgerNo !== null)
            url_ += "LedgerNo=" + encodeURIComponent("" + ledgerNo) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (minTenor === null)
            throw new Error("The parameter 'minTenor' cannot be null.");
        else if (minTenor !== undefined)
            url_ += "MinTenor=" + encodeURIComponent("" + minTenor) + "&";
        if (maxTenor === null)
            throw new Error("The parameter 'maxTenor' cannot be null.");
        else if (maxTenor !== undefined)
            url_ += "MaxTenor=" + encodeURIComponent("" + maxTenor) + "&";
        if (minAmount === null)
            throw new Error("The parameter 'minAmount' cannot be null.");
        else if (minAmount !== undefined)
            url_ += "MinAmount=" + encodeURIComponent("" + minAmount) + "&";
        if (maxAmount === null)
            throw new Error("The parameter 'maxAmount' cannot be null.");
        else if (maxAmount !== undefined)
            url_ += "MaxAmount=" + encodeURIComponent("" + maxAmount) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanTypesByCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanTypesByCriteria(<any>response_);
                } catch (e) {
                    return <Observable<LoanTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanTypesByCriteria(response: HttpResponseBase): Observable<LoanTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanTypeDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting LoanTypes that can be use for dropdowns
     * @return Success
     */
    getLoanTypes(): Observable<LoanTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/GetLoanTypes/GetLoanTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanTypes(<any>response_);
                } catch (e) {
                    return <Observable<LoanTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanTypes(response: HttpResponseBase): Observable<LoanTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchLoanTypeByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    fetchLoanTypeById(id: number | undefined): Observable<LoanTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/FetchLoanTypeById/FetchLoanTypeById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchLoanTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchLoanTypeById(<any>response_);
                } catch (e) {
                    return <Observable<LoanTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchLoanTypeById(response: HttpResponseBase): Observable<LoanTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanTypeDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleLoanTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    toggleLoanType(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/ToggleLoanType/Toggle-Loan-Type?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleLoanType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleLoanType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleLoanType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateLocationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Location
     * @param body (optional) 
     * @return Success
     */
    addUpdateLocation(body: ManageLocationDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Location/AddUpdateLocation/Add-Update-Location";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateLocation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateLocation(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllLocationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch Locations.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param lga_id (optional) 
     * @param state_id (optional) 
     * @return Success
     */
    getAllLocations(pageSize: number | undefined, pageNumber: number | undefined, lga_id: number | undefined, state_id: number | undefined): Observable<LocationDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Location/GetAllLocations/GetAllLocations?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (lga_id === null)
            throw new Error("The parameter 'lga_id' cannot be null.");
        else if (lga_id !== undefined)
            url_ += "lga_id=" + encodeURIComponent("" + lga_id) + "&";
        if (state_id === null)
            throw new Error("The parameter 'state_id' cannot be null.");
        else if (state_id !== undefined)
            url_ += "state_id=" + encodeURIComponent("" + state_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLocations(<any>response_);
                } catch (e) {
                    return <Observable<LocationDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLocations(response: HttpResponseBase): Observable<LocationDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLocationByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to get Location by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getLocation(id: number | undefined): Observable<LocationDTOApiResult> {
        let url_ = this.baseUrl + "/api/Location/GetLocationById/GetLocation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocation(<any>response_);
                } catch (e) {
                    return <Observable<LocationDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocation(response: HttpResponseBase): Observable<LocationDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationDTOApiResult>(<any>null);
    }
}

@Injectable()
export class ManpowerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating DepartmentActivity
     * @param body (optional) 
     * @return Success
     */
    addUpdateDepartmentActivity(body: DepartmentActivityDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Manpower/Add-Update-DepartmentActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateDepartmentActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateDepartmentActivity(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateDepartmentActivity(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Requirments Details.
    Note: all filter are optional
     * @param reqId (optional) 
     * @return Success
     */
    getRequirmentsDetails(reqId: number | undefined): Observable<DepartmentManPowerActivityDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Manpower/Get-Requirments-Details?";
        if (reqId === null)
            throw new Error("The parameter 'reqId' cannot be null.");
        else if (reqId !== undefined)
            url_ += "reqId=" + encodeURIComponent("" + reqId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequirmentsDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequirmentsDetails(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentManPowerActivityDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentManPowerActivityDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequirmentsDetails(response: HttpResponseBase): Observable<DepartmentManPowerActivityDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentManPowerActivityDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentManPowerActivityDTOListApiResult>(<any>null);
    }

    /**
     * API to Fetch baseYear.
    Note: all filter are optional
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchBaseYear(pageNumber: number | undefined, pageSize: number | undefined): Observable<BaseYearDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Manpower/Fetch-Base-Year?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchBaseYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchBaseYear(<any>response_);
                } catch (e) {
                    return <Observable<BaseYearDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BaseYearDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchBaseYear(response: HttpResponseBase): Observable<BaseYearDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseYearDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BaseYearDTOListApiResult>(<any>null);
    }

    /**
     * API to Fetch Departments Activity.
    Note: all filter are optional
     * @param taskProject (optional) 
     * @param taskType (optional) 
     * @param year (optional) 
     * @param status (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getDepartmentActivity(taskProject: string | null | undefined, taskType: number | null | undefined, year: number | null | undefined, status: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<DepartmentActivityDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Manpower/Get-Department-Activity?";
        if (taskProject !== undefined && taskProject !== null)
            url_ += "taskProject=" + encodeURIComponent("" + taskProject) + "&";
        if (taskType !== undefined && taskType !== null)
            url_ += "taskType=" + encodeURIComponent("" + taskType) + "&";
        if (year !== undefined && year !== null)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentActivity(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentActivityDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentActivityDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartmentActivity(response: HttpResponseBase): Observable<DepartmentActivityDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentActivityDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentActivityDTOListApiResult>(<any>null);
    }

    /**
     * API to Fetch ProjectionActivities.
    Note: all filter are optional
     * @param actitvityTypeId (optional) 
     * @param deptId (optional) 
     * @param status (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchProjectionActivities(actitvityTypeId: number | null | undefined, deptId: number | undefined, status: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<DepartmentManPowerActivityDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Manpower/Fetch-Projection-Activities?";
        if (actitvityTypeId !== undefined && actitvityTypeId !== null)
            url_ += "actitvityTypeId=" + encodeURIComponent("" + actitvityTypeId) + "&";
        if (deptId === null)
            throw new Error("The parameter 'deptId' cannot be null.");
        else if (deptId !== undefined)
            url_ += "deptId=" + encodeURIComponent("" + deptId) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchProjectionActivities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchProjectionActivities(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentManPowerActivityDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentManPowerActivityDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchProjectionActivities(response: HttpResponseBase): Observable<DepartmentManPowerActivityDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentManPowerActivityDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentManPowerActivityDTOIListApiResult>(<any>null);
    }

    /**
     * API to Fetch Projection Task Project .
    Note: all filter are optional
     * @param tasktype (optional) 
     * @param activityYear (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchProjectionTaskProject(tasktype: number | undefined, activityYear: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<DepartmentActivityDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Manpower/Fetch-Projection-Task-Project?";
        if (tasktype === null)
            throw new Error("The parameter 'tasktype' cannot be null.");
        else if (tasktype !== undefined)
            url_ += "tasktype=" + encodeURIComponent("" + tasktype) + "&";
        if (activityYear === null)
            throw new Error("The parameter 'activityYear' cannot be null.");
        else if (activityYear !== undefined)
            url_ += "activityYear=" + encodeURIComponent("" + activityYear) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchProjectionTaskProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchProjectionTaskProject(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentActivityDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentActivityDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchProjectionTaskProject(response: HttpResponseBase): Observable<DepartmentActivityDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentActivityDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentActivityDTOIListApiResult>(<any>null);
    }

    /**
     * API for submitting Requirment Review
     * @param activitymodel (optional) 
     * @return Success
     */
    submitRequirmentReview(activitymodel: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Manpower/Submit-Requirment-Review?";
        if (activitymodel !== undefined && activitymodel !== null)
            url_ += "activitymodel=" + encodeURIComponent("" + activitymodel) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitRequirmentReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitRequirmentReview(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitRequirmentReview(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to fetch Projection Activity
    Note: all filter are optional
     * @param activityTypeId (optional) 
     * @param deptId (optional) 
     * @param status (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchProjectionActivity(activityTypeId: number | undefined, deptId: number | undefined, status: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<DepartmentActivityDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Manpower/Fetch-Projection-Activity?";
        if (activityTypeId === null)
            throw new Error("The parameter 'activityTypeId' cannot be null.");
        else if (activityTypeId !== undefined)
            url_ += "activityTypeId=" + encodeURIComponent("" + activityTypeId) + "&";
        if (deptId === null)
            throw new Error("The parameter 'deptId' cannot be null.");
        else if (deptId !== undefined)
            url_ += "deptId=" + encodeURIComponent("" + deptId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchProjectionActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchProjectionActivity(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentActivityDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentActivityDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchProjectionActivity(response: HttpResponseBase): Observable<DepartmentActivityDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentActivityDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentActivityDTOIListApiResult>(<any>null);
    }

    /**
     * API to fetch Projection Requirment
    Note: all filter are optional
     * @param baseYear (optional) 
     * @param year (optional) 
     * @param activityName (optional) 
     * @param jobCategory (optional) 
     * @param deptId (optional) 
     * @param status (optional) 
     * @param tastType (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchProjectionRequirment(baseYear: number | undefined, year: number | undefined, activityName: string | null | undefined, jobCategory: string | null | undefined, deptId: number | null | undefined, status: number | null | undefined, tastType: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<DepartmentManPowerActivityDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Manpower/Fetch-Projection-Requirment?";
        if (baseYear === null)
            throw new Error("The parameter 'baseYear' cannot be null.");
        else if (baseYear !== undefined)
            url_ += "BaseYear=" + encodeURIComponent("" + baseYear) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&";
        if (activityName !== undefined && activityName !== null)
            url_ += "ActivityName=" + encodeURIComponent("" + activityName) + "&";
        if (jobCategory !== undefined && jobCategory !== null)
            url_ += "JobCategory=" + encodeURIComponent("" + jobCategory) + "&";
        if (deptId !== undefined && deptId !== null)
            url_ += "deptId=" + encodeURIComponent("" + deptId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (tastType !== undefined && tastType !== null)
            url_ += "tastType=" + encodeURIComponent("" + tastType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchProjectionRequirment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchProjectionRequirment(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentManPowerActivityDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentManPowerActivityDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchProjectionRequirment(response: HttpResponseBase): Observable<DepartmentManPowerActivityDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentManPowerActivityDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentManPowerActivityDTOIListApiResult>(<any>null);
    }

    /**
     * API to add requirment to plan
     * @param body (optional) 
     * @return Success
     */
    addRequirementToPlan(body: DepartmentManPowerActivityDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Manpower/Add-Requirement-ToPlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRequirementToPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRequirementToPlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddRequirementToPlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param requirementId (optional) 
     * @return Success
     */
    removeRequirementToPlan(requirementId: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Manpower/Remove-Requirement-ToPlan?";
        if (requirementId === null)
            throw new Error("The parameter 'requirementId' cannot be null.");
        else if (requirementId !== undefined)
            url_ += "requirementId=" + encodeURIComponent("" + requirementId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRequirementToPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRequirementToPlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRequirementToPlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Download AssetReport
    Note: all filter are optional
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    fetchAssetReport(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Manpower/Fetch-Asset-Report?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAssetReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAssetReport(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAssetReport(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpateOfferLetterTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateOfferletterTemplate(body: OfferLetterTemplateDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/OfferLetter/AddUpateOfferLetterTemplate/Add-Update-OfferletterTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateOfferletterTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateOfferletterTemplate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateOfferletterTemplate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleOfferLetterTempleteServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    toggleOfferLetterTemplate(body: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/OfferLetter/ToggleOfferLetterTemplete/Toggle-Offer-Letter-Template";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleOfferLetterTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleOfferLetterTemplate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleOfferLetterTemplate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchOfferLetterTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param iD (optional) 
     * @param signatoryName (optional) 
     * @param offerTitle (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchOfferLetterTemplate(iD: number | undefined, signatoryName: string | null | undefined, offerTitle: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<LoanTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/OfferLetter/FetchOfferLetterTemplate/FetchOfferLetterTemplate?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (signatoryName !== undefined && signatoryName !== null)
            url_ += "SignatoryName=" + encodeURIComponent("" + signatoryName) + "&";
        if (offerTitle !== undefined && offerTitle !== null)
            url_ += "OfferTitle=" + encodeURIComponent("" + offerTitle) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchOfferLetterTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchOfferLetterTemplate(<any>response_);
                } catch (e) {
                    return <Observable<LoanTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchOfferLetterTemplate(response: HttpResponseBase): Observable<LoanTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class PrepareOfferLetterEmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param onboardingId (optional) 
     * @return Success
     */
    applicantJobOfferEmail(onboardingId: number | undefined): Observable<PrepareOfferLetterDTOApiResult> {
        let url_ = this.baseUrl + "/api/OfferLetter/PrepareOfferLetterEmail/Applicant-Job-Offer-Email?";
        if (onboardingId === null)
            throw new Error("The parameter 'onboardingId' cannot be null.");
        else if (onboardingId !== undefined)
            url_ += "OnboardingId=" + encodeURIComponent("" + onboardingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplicantJobOfferEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplicantJobOfferEmail(<any>response_);
                } catch (e) {
                    return <Observable<PrepareOfferLetterDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrepareOfferLetterDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processApplicantJobOfferEmail(response: HttpResponseBase): Observable<PrepareOfferLetterDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepareOfferLetterDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepareOfferLetterDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchOnboardingPersonnalDataByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param companyId (optional) 
     * @param subId (optional) 
     * @return Success
     */
    fetchOnboardingPersonnalDataById(id: number | undefined, companyId: number | undefined, subId: number | undefined): Observable<OnboardingPersonalInfoApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/FetchOnboardingPersonnalDataById/FetchOnboardingPersonnalDataById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "SubId=" + encodeURIComponent("" + subId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchOnboardingPersonnalDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchOnboardingPersonnalDataById(<any>response_);
                } catch (e) {
                    return <Observable<OnboardingPersonalInfoApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OnboardingPersonalInfoApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchOnboardingPersonnalDataById(response: HttpResponseBase): Observable<OnboardingPersonalInfoApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingPersonalInfoApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OnboardingPersonalInfoApiResult>(<any>null);
    }
}

@Injectable()
export class FetchOnboardingDocummentDataByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param onboardingId (optional) 
     * @param companyId (optional) 
     * @param subId (optional) 
     * @return Success
     */
    fetchOnboardingDocummentDataById(id: number | undefined, onboardingId: number | undefined, companyId: number | undefined, subId: number | undefined): Observable<OnboardingDocumentInfoApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/FetchOnboardingDocummentDataById/FetchOnboardingDocummentDataById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (onboardingId === null)
            throw new Error("The parameter 'onboardingId' cannot be null.");
        else if (onboardingId !== undefined)
            url_ += "OnboardingId=" + encodeURIComponent("" + onboardingId) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "SubId=" + encodeURIComponent("" + subId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchOnboardingDocummentDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchOnboardingDocummentDataById(<any>response_);
                } catch (e) {
                    return <Observable<OnboardingDocumentInfoApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OnboardingDocumentInfoApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchOnboardingDocummentDataById(response: HttpResponseBase): Observable<OnboardingDocumentInfoApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingDocumentInfoApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OnboardingDocumentInfoApiResult>(<any>null);
    }
}

@Injectable()
export class FetchOnboardingMedicalDisclosureDataByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param onboardingId (optional) 
     * @param companyId (optional) 
     * @param subId (optional) 
     * @return Success
     */
    fetchOnboardingMedicalDisclosureDataById(id: number | undefined, onboardingId: number | undefined, companyId: number | undefined, subId: number | undefined): Observable<OnboardingMedicalDisclosureInfoApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/FetchOnboardingMedicalDisclosureDataById/FetchOnboardingMedicalDisclosureDataById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (onboardingId === null)
            throw new Error("The parameter 'onboardingId' cannot be null.");
        else if (onboardingId !== undefined)
            url_ += "OnboardingId=" + encodeURIComponent("" + onboardingId) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "SubId=" + encodeURIComponent("" + subId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchOnboardingMedicalDisclosureDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchOnboardingMedicalDisclosureDataById(<any>response_);
                } catch (e) {
                    return <Observable<OnboardingMedicalDisclosureInfoApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OnboardingMedicalDisclosureInfoApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchOnboardingMedicalDisclosureDataById(response: HttpResponseBase): Observable<OnboardingMedicalDisclosureInfoApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingMedicalDisclosureInfoApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OnboardingMedicalDisclosureInfoApiResult>(<any>null);
    }
}

@Injectable()
export class FetchOnboardingPaymentDataByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param onboardingId (optional) 
     * @param companyId (optional) 
     * @param subId (optional) 
     * @return Success
     */
    fetchOnboardingPaymentDataById(id: number | undefined, onboardingId: number | undefined, companyId: number | undefined, subId: number | undefined): Observable<OnboardingMedicalDisclosureInfoApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/FetchOnboardingPaymentDataById/FetchOnboardingPaymentDataById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (onboardingId === null)
            throw new Error("The parameter 'onboardingId' cannot be null.");
        else if (onboardingId !== undefined)
            url_ += "OnboardingId=" + encodeURIComponent("" + onboardingId) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "SubId=" + encodeURIComponent("" + subId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchOnboardingPaymentDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchOnboardingPaymentDataById(<any>response_);
                } catch (e) {
                    return <Observable<OnboardingMedicalDisclosureInfoApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OnboardingMedicalDisclosureInfoApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchOnboardingPaymentDataById(response: HttpResponseBase): Observable<OnboardingMedicalDisclosureInfoApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingMedicalDisclosureInfoApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OnboardingMedicalDisclosureInfoApiResult>(<any>null);
    }
}

@Injectable()
export class FetchOnboardingTaxDataByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @param onboardingId (optional) 
     * @param companyId (optional) 
     * @param subId (optional) 
     * @return Success
     */
    fetchOnboardingTaxDataById(id: number | undefined, onboardingId: number | undefined, companyId: number | undefined, subId: number | undefined): Observable<OnboardingTaxInfoApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/FetchOnboardingTaxDataById/FetchOnboardingTaxDataById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (onboardingId === null)
            throw new Error("The parameter 'onboardingId' cannot be null.");
        else if (onboardingId !== undefined)
            url_ += "OnboardingId=" + encodeURIComponent("" + onboardingId) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "SubId=" + encodeURIComponent("" + subId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchOnboardingTaxDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchOnboardingTaxDataById(<any>response_);
                } catch (e) {
                    return <Observable<OnboardingTaxInfoApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OnboardingTaxInfoApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchOnboardingTaxDataById(response: HttpResponseBase): Observable<OnboardingTaxInfoApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnboardingTaxInfoApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OnboardingTaxInfoApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeOnboardingDataDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param onboardingId (optional) 
     * @param companyId (optional) 
     * @return Success
     */
    fetchEmployeeOnboardingDataDetails(onboardingId: number | undefined, companyId: number | undefined): Observable<EmployeeOnboardingPersonalDataListApiResult> {
        let url_ = this.baseUrl + "/api/Onboarding/FetchEmployeeOnboardingDataDetails/FetchEmployeeOnboardingDataDetails?";
        if (onboardingId === null)
            throw new Error("The parameter 'onboardingId' cannot be null.");
        else if (onboardingId !== undefined)
            url_ += "OnboardingId=" + encodeURIComponent("" + onboardingId) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEmployeeOnboardingDataDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEmployeeOnboardingDataDetails(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeOnboardingPersonalDataListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeOnboardingPersonalDataListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEmployeeOnboardingDataDetails(response: HttpResponseBase): Observable<EmployeeOnboardingPersonalDataListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeOnboardingPersonalDataListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeOnboardingPersonalDataListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdatePayElementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Pay Element
     * @param body (optional) 
     * @return Success
     */
    addUpdatePayElement(body: ManagePayElementDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/PayElement/AddUpdatePayElement/Add-Update-PayElement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdatePayElement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdatePayElement(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdatePayElement(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllPayElementsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch Payment Elements.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param payTypeId (optional) 
     * @param paymentInstitutionId (optional) 
     * @param elementTypeId (optional) 
     * @param elementCategoryId (optional) 
     * @return Success
     */
    getAllPayElements(pageSize: number | undefined, pageNumber: number | undefined, payTypeId: number | undefined, paymentInstitutionId: number | undefined, elementTypeId: number | undefined, elementCategoryId: number | undefined): Observable<PayElementDTOListApiResult> {
        let url_ = this.baseUrl + "/api/PayElement/GetAllPayElements/GetAllPayElements?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (payTypeId === null)
            throw new Error("The parameter 'payTypeId' cannot be null.");
        else if (payTypeId !== undefined)
            url_ += "PayTypeId=" + encodeURIComponent("" + payTypeId) + "&";
        if (paymentInstitutionId === null)
            throw new Error("The parameter 'paymentInstitutionId' cannot be null.");
        else if (paymentInstitutionId !== undefined)
            url_ += "PaymentInstitutionId=" + encodeURIComponent("" + paymentInstitutionId) + "&";
        if (elementTypeId === null)
            throw new Error("The parameter 'elementTypeId' cannot be null.");
        else if (elementTypeId !== undefined)
            url_ += "ElementTypeId=" + encodeURIComponent("" + elementTypeId) + "&";
        if (elementCategoryId === null)
            throw new Error("The parameter 'elementCategoryId' cannot be null.");
        else if (elementCategoryId !== undefined)
            url_ += "ElementCategoryId=" + encodeURIComponent("" + elementCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPayElements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPayElements(<any>response_);
                } catch (e) {
                    return <Observable<PayElementDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayElementDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPayElements(response: HttpResponseBase): Observable<PayElementDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayElementDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayElementDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetPayElementByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to get Payment Element by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getPayElement(id: number | undefined): Observable<PayElementDTOApiResult> {
        let url_ = this.baseUrl + "/api/PayElement/GetPayElementById/GetPayElement?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayElement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayElement(<any>response_);
                } catch (e) {
                    return <Observable<PayElementDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayElementDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayElement(response: HttpResponseBase): Observable<PayElementDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayElementDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayElementDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdatePaymentInstitutionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Payment Institution
     * @param body (optional) 
     * @return Success
     */
    addUpdatePaymentInstitution(body: ManagePayInstitutionDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/PaymentInstitution/AddUpdatePaymentInstitution/Add-Update-PaymentInstitution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdatePaymentInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdatePaymentInstitution(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdatePaymentInstitution(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllPaymentInstitutionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch Payment Institutions.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param categoryId (optional) 
     * @return Success
     */
    getAllPaymentInstitutions(pageSize: number | undefined, pageNumber: number | undefined, categoryId: number | undefined): Observable<PayInstitutionDTOListApiResult> {
        let url_ = this.baseUrl + "/api/PaymentInstitution/GetAllPaymentInstitutions/GetAllPaymentInstitutions?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPaymentInstitutions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPaymentInstitutions(<any>response_);
                } catch (e) {
                    return <Observable<PayInstitutionDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayInstitutionDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPaymentInstitutions(response: HttpResponseBase): Observable<PayInstitutionDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayInstitutionDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayInstitutionDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetPaymentInstitutionByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to get Payment Institution by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getPaymentInstitution(id: number | undefined): Observable<PayInstitutionDTOApiResult> {
        let url_ = this.baseUrl + "/api/PaymentInstitution/GetPaymentInstitutionById/GetPaymentInstitution?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInstitution(<any>response_);
                } catch (e) {
                    return <Observable<PayInstitutionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayInstitutionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInstitution(response: HttpResponseBase): Observable<PayInstitutionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayInstitutionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayInstitutionDTOApiResult>(<any>null);
    }
}

@Injectable()
export class GetPayslipAnalysisServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching payslip analysis
     * @param payrollRunId (optional) 
     * @return Success
     */
    getPayslipAnalysis(payrollRunId: number | undefined): Observable<RptPayslipAnalyzerListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollReport/GetPayslipAnalysis/GetPayslipAnalysis?";
        if (payrollRunId === null)
            throw new Error("The parameter 'payrollRunId' cannot be null.");
        else if (payrollRunId !== undefined)
            url_ += "payrollRunId=" + encodeURIComponent("" + payrollRunId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayslipAnalysis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayslipAnalysis(<any>response_);
                } catch (e) {
                    return <Observable<RptPayslipAnalyzerListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RptPayslipAnalyzerListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayslipAnalysis(response: HttpResponseBase): Observable<RptPayslipAnalyzerListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RptPayslipAnalyzerListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RptPayslipAnalyzerListApiResult>(<any>null);
    }
}

@Injectable()
export class GetPayrollAnalysisServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching payroll analysis
     * @param payrollRunId (optional) 
     * @param payrollTypeId (optional) 
     * @return Success
     */
    getPayrollAnalysis(payrollRunId: number | undefined, payrollTypeId: number | undefined): Observable<RptPayrollRunAnalysisListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollReport/GetPayrollAnalysis/GetPayrollAnalysis?";
        if (payrollRunId === null)
            throw new Error("The parameter 'payrollRunId' cannot be null.");
        else if (payrollRunId !== undefined)
            url_ += "payrollRunId=" + encodeURIComponent("" + payrollRunId) + "&";
        if (payrollTypeId === null)
            throw new Error("The parameter 'payrollTypeId' cannot be null.");
        else if (payrollTypeId !== undefined)
            url_ += "payrollTypeId=" + encodeURIComponent("" + payrollTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayrollAnalysis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayrollAnalysis(<any>response_);
                } catch (e) {
                    return <Observable<RptPayrollRunAnalysisListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RptPayrollRunAnalysisListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayrollAnalysis(response: HttpResponseBase): Observable<RptPayrollRunAnalysisListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RptPayrollRunAnalysisListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RptPayrollRunAnalysisListApiResult>(<any>null);
    }
}

@Injectable()
export class GetBankScheduleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching the bank schedule
     * @param payrollRunId (optional) 
     * @return Success
     */
    getBankSchedule(payrollRunId: number | undefined): Observable<RptBankScheduleListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollReport/GetBankSchedule/GetBankSchedule?";
        if (payrollRunId === null)
            throw new Error("The parameter 'payrollRunId' cannot be null.");
        else if (payrollRunId !== undefined)
            url_ += "payrollRunId=" + encodeURIComponent("" + payrollRunId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankSchedule(<any>response_);
                } catch (e) {
                    return <Observable<RptBankScheduleListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RptBankScheduleListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankSchedule(response: HttpResponseBase): Observable<RptBankScheduleListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RptBankScheduleListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RptBankScheduleListApiResult>(<any>null);
    }
}

@Injectable()
export class GetEarningsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching the payroll earnings
     * @param payrollRunId (optional) 
     * @return Success
     */
    getEarnings(payrollRunId: number | undefined): Observable<RptEarningsListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollReport/GetEarnings/GetEarnings?";
        if (payrollRunId === null)
            throw new Error("The parameter 'payrollRunId' cannot be null.");
        else if (payrollRunId !== undefined)
            url_ += "payrollRunId=" + encodeURIComponent("" + payrollRunId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEarnings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEarnings(<any>response_);
                } catch (e) {
                    return <Observable<RptEarningsListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RptEarningsListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEarnings(response: HttpResponseBase): Observable<RptEarningsListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RptEarningsListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RptEarningsListApiResult>(<any>null);
    }
}

@Injectable()
export class GetDeductionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching the payroll deductions
     * @param payrollRunId (optional) 
     * @return Success
     */
    getDeductions(payrollRunId: number | undefined): Observable<RptDeductionsListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollReport/GetDeductions/GetDeductions?";
        if (payrollRunId === null)
            throw new Error("The parameter 'payrollRunId' cannot be null.");
        else if (payrollRunId !== undefined)
            url_ += "payrollRunId=" + encodeURIComponent("" + payrollRunId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeductions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeductions(<any>response_);
                } catch (e) {
                    return <Observable<RptDeductionsListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RptDeductionsListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeductions(response: HttpResponseBase): Observable<RptDeductionsListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RptDeductionsListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RptDeductionsListApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllElementsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching the all the payroll elements
     * @param payrollRunId (optional) 
     * @return Success
     */
    getAllElements(payrollRunId: number | undefined): Observable<RptAllElementSheetListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollReport/GetAllElements/GetAllElements?";
        if (payrollRunId === null)
            throw new Error("The parameter 'payrollRunId' cannot be null.");
        else if (payrollRunId !== undefined)
            url_ += "payrollRunId=" + encodeURIComponent("" + payrollRunId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllElements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllElements(<any>response_);
                } catch (e) {
                    return <Observable<RptAllElementSheetListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RptAllElementSheetListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllElements(response: HttpResponseBase): Observable<RptAllElementSheetListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RptAllElementSheetListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RptAllElementSheetListApiResult>(<any>null);
    }
}

@Injectable()
export class GetDeductionSummaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching the all the payroll deduction elements
     * @param payrollRunId (optional) 
     * @return Success
     */
    getDeductionSummary(payrollRunId: number | undefined): Observable<RptDeductionSummaryListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollReport/GetDeductionSummary/GetDeductionSummary?";
        if (payrollRunId === null)
            throw new Error("The parameter 'payrollRunId' cannot be null.");
        else if (payrollRunId !== undefined)
            url_ += "payrollRunId=" + encodeURIComponent("" + payrollRunId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeductionSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeductionSummary(<any>response_);
                } catch (e) {
                    return <Observable<RptDeductionSummaryListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RptDeductionSummaryListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeductionSummary(response: HttpResponseBase): Observable<RptDeductionSummaryListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RptDeductionSummaryListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RptDeductionSummaryListApiResult>(<any>null);
    }
}

@Injectable()
export class GetPaymentSummaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching the all the payroll earning elements
     * @param payrollRunId (optional) 
     * @return Success
     */
    getPaymentSummary(payrollRunId: number | undefined): Observable<RptPaymentSummaryListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollReport/GetPaymentSummary/GetPaymentSummary?";
        if (payrollRunId === null)
            throw new Error("The parameter 'payrollRunId' cannot be null.");
        else if (payrollRunId !== undefined)
            url_ += "payrollRunId=" + encodeURIComponent("" + payrollRunId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentSummary(<any>response_);
                } catch (e) {
                    return <Observable<RptPaymentSummaryListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RptPaymentSummaryListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentSummary(response: HttpResponseBase): Observable<RptPaymentSummaryListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RptPaymentSummaryListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RptPaymentSummaryListApiResult>(<any>null);
    }
}

@Injectable()
export class GetTaxDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching the all the payroll tax elements details
     * @param payrollRunId (optional) 
     * @return Success
     */
    getTaxDetail(payrollRunId: number | undefined): Observable<RptTaxDetailListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollReport/GetTaxDetail/GetTaxDetail?";
        if (payrollRunId === null)
            throw new Error("The parameter 'payrollRunId' cannot be null.");
        else if (payrollRunId !== undefined)
            url_ += "payrollRunId=" + encodeURIComponent("" + payrollRunId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaxDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxDetail(<any>response_);
                } catch (e) {
                    return <Observable<RptTaxDetailListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RptTaxDetailListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaxDetail(response: HttpResponseBase): Observable<RptTaxDetailListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RptTaxDetailListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RptTaxDetailListApiResult>(<any>null);
    }
}

@Injectable()
export class GetTaxSummaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching the all the payroll tax elements summary
     * @param payrollRunId (optional) 
     * @return Success
     */
    getTaxSummary(payrollRunId: number | undefined): Observable<RptTaxSummaryListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollReport/GetTaxSummary/GetTaxSummary?";
        if (payrollRunId === null)
            throw new Error("The parameter 'payrollRunId' cannot be null.");
        else if (payrollRunId !== undefined)
            url_ += "payrollRunId=" + encodeURIComponent("" + payrollRunId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaxSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxSummary(<any>response_);
                } catch (e) {
                    return <Observable<RptTaxSummaryListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RptTaxSummaryListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaxSummary(response: HttpResponseBase): Observable<RptTaxSummaryListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RptTaxSummaryListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RptTaxSummaryListApiResult>(<any>null);
    }
}

@Injectable()
export class GetPensionDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching the all the payroll pension elements details
     * @param payrollRunId (optional) 
     * @return Success
     */
    getPensionDetail(payrollRunId: number | undefined): Observable<RptPensionDetailListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollReport/GetPensionDetail/GetPensionDetail?";
        if (payrollRunId === null)
            throw new Error("The parameter 'payrollRunId' cannot be null.");
        else if (payrollRunId !== undefined)
            url_ += "payrollRunId=" + encodeURIComponent("" + payrollRunId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPensionDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPensionDetail(<any>response_);
                } catch (e) {
                    return <Observable<RptPensionDetailListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RptPensionDetailListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPensionDetail(response: HttpResponseBase): Observable<RptPensionDetailListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RptPensionDetailListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RptPensionDetailListApiResult>(<any>null);
    }
}

@Injectable()
export class GetPensionSummaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching the all the payroll pension elements summary
     * @param payrollRunId (optional) 
     * @return Success
     */
    getPensionSummary(payrollRunId: number | undefined): Observable<RptPensionSummaryListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollReport/GetPensionSummary/GetPensionSummary?";
        if (payrollRunId === null)
            throw new Error("The parameter 'payrollRunId' cannot be null.");
        else if (payrollRunId !== undefined)
            url_ += "payrollRunId=" + encodeURIComponent("" + payrollRunId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPensionSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPensionSummary(<any>response_);
                } catch (e) {
                    return <Observable<RptPensionSummaryListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RptPensionSummaryListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPensionSummary(response: HttpResponseBase): Observable<RptPensionSummaryListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RptPensionSummaryListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RptPensionSummaryListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchPayrollServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching payroll runs
     * @param payrollRunId (optional) 
     * @return Success
     */
    fetchPayroll(payrollRunId: number | undefined): Observable<PayrollRunListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollRun/FetchPayroll/FetchPayroll?";
        if (payrollRunId === null)
            throw new Error("The parameter 'payrollRunId' cannot be null.");
        else if (payrollRunId !== undefined)
            url_ += "payrollRunId=" + encodeURIComponent("" + payrollRunId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchPayroll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchPayroll(<any>response_);
                } catch (e) {
                    return <Observable<PayrollRunListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayrollRunListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchPayroll(response: HttpResponseBase): Observable<PayrollRunListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayrollRunListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayrollRunListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchPayslipsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching the payslips
     * @param payrollRunId (optional) 
     * @param payslipId (optional) 
     * @return Success
     */
    fetchPayslips(payrollRunId: number | undefined, payslipId: number | undefined): Observable<PayslipListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollRun/FetchPayslips/FetchPayslips?";
        if (payrollRunId === null)
            throw new Error("The parameter 'payrollRunId' cannot be null.");
        else if (payrollRunId !== undefined)
            url_ += "payrollRunId=" + encodeURIComponent("" + payrollRunId) + "&";
        if (payslipId === null)
            throw new Error("The parameter 'payslipId' cannot be null.");
        else if (payslipId !== undefined)
            url_ += "payslipId=" + encodeURIComponent("" + payslipId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchPayslips(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchPayslips(<any>response_);
                } catch (e) {
                    return <Observable<PayslipListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayslipListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchPayslips(response: HttpResponseBase): Observable<PayslipListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayslipListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayslipListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchPayslipItemsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for fetching the payslips items
     * @param payslipId (optional) 
     * @return Success
     */
    fetchPayslipItems(payslipId: number | undefined): Observable<PayslipItemListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollRun/FetchPayslipItems/FetchPayslipItems?";
        if (payslipId === null)
            throw new Error("The parameter 'payslipId' cannot be null.");
        else if (payslipId !== undefined)
            url_ += "payslipId=" + encodeURIComponent("" + payslipId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchPayslipItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchPayslipItems(<any>response_);
                } catch (e) {
                    return <Observable<PayslipItemListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayslipItemListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchPayslipItems(response: HttpResponseBase): Observable<PayslipItemListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayslipItemListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayslipItemListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdatePayScaleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Payroll Type (Pay Scale)
     * @param body (optional) 
     * @return Success
     */
    addUpdatePayScale(body: ManagePayrollTypeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/PayrollType/AddUpdatePayScale/Add-Update-PayScale";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdatePayScale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdatePayScale(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdatePayScale(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllPayrollTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch Payroll Types.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param frequencyRuleId (optional) 
     * @return Success
     */
    getAllPayrollTypes(pageSize: number | undefined, pageNumber: number | undefined, frequencyRuleId: number | undefined): Observable<PayrollTypeDTOListApiResult> {
        let url_ = this.baseUrl + "/api/PayrollType/GetAllPayrollTypes/GetAllPayrollTypes?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (frequencyRuleId === null)
            throw new Error("The parameter 'frequencyRuleId' cannot be null.");
        else if (frequencyRuleId !== undefined)
            url_ += "FrequencyRuleId=" + encodeURIComponent("" + frequencyRuleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPayrollTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPayrollTypes(<any>response_);
                } catch (e) {
                    return <Observable<PayrollTypeDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayrollTypeDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPayrollTypes(response: HttpResponseBase): Observable<PayrollTypeDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayrollTypeDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayrollTypeDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetPayrollTypeByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to get Payroll Type by id and can be used for update, details and also
    includes; No. of Employees and Employee list that are attached to this PayScale etc
     * @param id (optional) 
     * @return Success
     */
    getPayrollType(id: number | undefined): Observable<PayrollTypeDTOApiResult> {
        let url_ = this.baseUrl + "/api/PayrollType/GetPayrollTypeById/GetPayrollType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayrollType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayrollType(<any>response_);
                } catch (e) {
                    return <Observable<PayrollTypeDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayrollTypeDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayrollType(response: HttpResponseBase): Observable<PayrollTypeDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayrollTypeDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayrollTypeDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchPerformanceCyclesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving all Performance Cycles with filters as follows 
    'Status: for Active, Pending_Approval, Approved, Ongoing, Closed
    'RatingType: for Open-ended/Close-ended'
     * @param status (optional) 
     * @param departmentId (optional) 
     * @param locationId (optional) 
     * @param unitId (optional) 
     * @param ratingType (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getPerformanceCycles(status: number | undefined, departmentId: number | undefined, locationId: number | undefined, unitId: number | undefined, ratingType: number | undefined, pageSize: number | undefined): Observable<CycleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/PerformanceCycle/FetchPerformanceCycles/GetPerformanceCycles?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "LocationId=" + encodeURIComponent("" + locationId) + "&";
        if (unitId === null)
            throw new Error("The parameter 'unitId' cannot be null.");
        else if (unitId !== undefined)
            url_ += "UnitId=" + encodeURIComponent("" + unitId) + "&";
        if (ratingType === null)
            throw new Error("The parameter 'ratingType' cannot be null.");
        else if (ratingType !== undefined)
            url_ += "RatingType=" + encodeURIComponent("" + ratingType) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformanceCycles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformanceCycles(<any>response_);
                } catch (e) {
                    return <Observable<CycleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CycleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformanceCycles(response: HttpResponseBase): Observable<CycleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CycleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CycleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchPerformanceCycleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting Single Performance Cycle Details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getPerformanceCycle(id: number | undefined): Observable<CycleDTOApiResult> {
        let url_ = this.baseUrl + "/api/PerformanceCycle/FetchPerformanceCycle/GetPerformanceCycle?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformanceCycle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformanceCycle(<any>response_);
                } catch (e) {
                    return <Observable<CycleDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CycleDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformanceCycle(response: HttpResponseBase): Observable<CycleDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CycleDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CycleDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdatePerformanceCycleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for add/updating Performance Cycle
    Toggle (i.e. While Updating use the property 'IsActive'
    as Radio-toggle button and pass true/false. When creating new Performance Cycle 'IsActive is by default)
     * @param body (optional) 
     * @return Success
     */
    addUpdatePerformanceCycle(body: ManageCycleDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/PerformanceCycle/AddUpdatePerformanceCycle/Add-Update-PerformanceCycle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdatePerformanceCycle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdatePerformanceCycle(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdatePerformanceCycle(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdatePositionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Position
     * @param body (optional) 
     * @return Success
     */
    addUpdatePosition(body: ManagePositionDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Position/AddUpdatePosition/Add-Update-Position";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdatePosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdatePosition(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdatePosition(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllPositionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch Positions.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param parentPositionId (optional) 
     * @param nextPositionId (optional) 
     * @param basicSalary (optional) 
     * @return Success
     */
    getAllPositions(pageSize: number | undefined, pageNumber: number | undefined, parentPositionId: number | undefined, nextPositionId: number | undefined, basicSalary: number | undefined): Observable<PositionDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Position/GetAllPositions/GetAllPositions?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (parentPositionId === null)
            throw new Error("The parameter 'parentPositionId' cannot be null.");
        else if (parentPositionId !== undefined)
            url_ += "ParentPositionId=" + encodeURIComponent("" + parentPositionId) + "&";
        if (nextPositionId === null)
            throw new Error("The parameter 'nextPositionId' cannot be null.");
        else if (nextPositionId !== undefined)
            url_ += "NextPositionId=" + encodeURIComponent("" + nextPositionId) + "&";
        if (basicSalary === null)
            throw new Error("The parameter 'basicSalary' cannot be null.");
        else if (basicSalary !== undefined)
            url_ += "BasicSalary=" + encodeURIComponent("" + basicSalary) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPositions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPositions(<any>response_);
                } catch (e) {
                    return <Observable<PositionDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPositions(response: HttpResponseBase): Observable<PositionDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PositionDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetPositionByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to get Position by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getPosition(id: number | undefined): Observable<PositionDTOApiResult> {
        let url_ = this.baseUrl + "/api/Position/GetPositionById/GetPosition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosition(<any>response_);
                } catch (e) {
                    return <Observable<PositionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPosition(response: HttpResponseBase): Observable<PositionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PositionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateProfessionalBodyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Professional Body
     * @param body (optional) 
     * @return Success
     */
    addUpdateProfessionalBody(body: ManageProfessionalBodyDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ProfessionalBody/AddUpdateProfessionalBody/Add-Update-ProfessionalBody";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateProfessionalBody(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateProfessionalBody(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateProfessionalBody(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllProfessionalBodiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch Professional Bodies.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param sectorId (optional) 
     * @return Success
     */
    getAllProfessionalBodies(pageSize: number | undefined, pageNumber: number | undefined, sectorId: number | undefined): Observable<ProfessionalBodyDTOListApiResult> {
        let url_ = this.baseUrl + "/api/ProfessionalBody/GetAllProfessionalBodies/GetAllProfessionalBodies?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (sectorId === null)
            throw new Error("The parameter 'sectorId' cannot be null.");
        else if (sectorId !== undefined)
            url_ += "SectorId=" + encodeURIComponent("" + sectorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProfessionalBodies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProfessionalBodies(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalBodyDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalBodyDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProfessionalBodies(response: HttpResponseBase): Observable<ProfessionalBodyDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfessionalBodyDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalBodyDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetProfessionalBodyByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to get Professional Body by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getProfessionalBody(id: number | undefined): Observable<ProfessionalBodyDTOApiResult> {
        let url_ = this.baseUrl + "/api/ProfessionalBody/GetProfessionalBodyById/GetProfessionalBody?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfessionalBody(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfessionalBody(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalBodyDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalBodyDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfessionalBody(response: HttpResponseBase): Observable<ProfessionalBodyDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfessionalBodyDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalBodyDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEligibleBucketServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateEligibleBucket(body: PromotionEligibilityViewModel | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Promotion/AddUpdateEligibleBucket/AddUpdateEligibleBucket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEligibleBucket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEligibleBucket(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEligibleBucket(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetEligibilityEmployeeListsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param eligibilityId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getEligibilityEmployeeLists(eligibilityId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PromotionLogIListApiResult> {
        let url_ = this.baseUrl + "/api/Promotion/GetEligibilityEmployeeLists/GetEligibilityEmployeeLists?";
        if (eligibilityId === null)
            throw new Error("The parameter 'eligibilityId' cannot be null.");
        else if (eligibilityId !== undefined)
            url_ += "EligibilityId=" + encodeURIComponent("" + eligibilityId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEligibilityEmployeeLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEligibilityEmployeeLists(<any>response_);
                } catch (e) {
                    return <Observable<PromotionLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PromotionLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEligibilityEmployeeLists(response: HttpResponseBase): Observable<PromotionLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromotionLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PromotionLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetPromotionEligibilityListsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param _PageSize (optional) 
     * @param _PageNumber (optional) 
     * @param eligibilityId (optional) 
     * @param is_closed (optional) 
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    getPromotionEligibilityLists(_PageSize: number | undefined, _PageNumber: number | undefined, eligibilityId: number | null | undefined, is_closed: number | undefined, start: Date | null | undefined, end: Date | null | undefined): Observable<PromotionEligibilityViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Promotion/GetPromotionEligibilityLists/GetPromotionEligibilityLists?";
        if (_PageSize === null)
            throw new Error("The parameter '_PageSize' cannot be null.");
        else if (_PageSize !== undefined)
            url_ += "_PageSize=" + encodeURIComponent("" + _PageSize) + "&";
        if (_PageNumber === null)
            throw new Error("The parameter '_PageNumber' cannot be null.");
        else if (_PageNumber !== undefined)
            url_ += "_PageNumber=" + encodeURIComponent("" + _PageNumber) + "&";
        if (eligibilityId !== undefined && eligibilityId !== null)
            url_ += "EligibilityId=" + encodeURIComponent("" + eligibilityId) + "&";
        if (is_closed === null)
            throw new Error("The parameter 'is_closed' cannot be null.");
        else if (is_closed !== undefined)
            url_ += "is_closed=" + encodeURIComponent("" + is_closed) + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&";
        if (end !== undefined && end !== null)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPromotionEligibilityLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPromotionEligibilityLists(<any>response_);
                } catch (e) {
                    return <Observable<PromotionEligibilityViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PromotionEligibilityViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPromotionEligibilityLists(response: HttpResponseBase): Observable<PromotionEligibilityViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromotionEligibilityViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PromotionEligibilityViewModelIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetPromotionListsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param eligibilityId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getPromotionLists(eligibilityId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<Sp_FetchEligibleEmployeesIListApiResult> {
        let url_ = this.baseUrl + "/api/Promotion/GetPromotionLists/GetPromotionLists?";
        if (eligibilityId === null)
            throw new Error("The parameter 'eligibilityId' cannot be null.");
        else if (eligibilityId !== undefined)
            url_ += "EligibilityId=" + encodeURIComponent("" + eligibilityId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPromotionLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPromotionLists(<any>response_);
                } catch (e) {
                    return <Observable<Sp_FetchEligibleEmployeesIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<Sp_FetchEligibleEmployeesIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPromotionLists(response: HttpResponseBase): Observable<Sp_FetchEligibleEmployeesIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sp_FetchEligibleEmployeesIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sp_FetchEligibleEmployeesIListApiResult>(<any>null);
    }
}

@Injectable()
export class QualificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Qualification
     * @param body (optional) 
     * @return Success
     */
    addUpdateQualification(body: ManageQualificationDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Qualification/Add-Update-Qualification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateQualification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateQualification(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateQualification(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Qualifications.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param categoryId (optional) 
     * @return Success
     */
    getAllQualifications(pageSize: number | undefined, pageNumber: number | undefined, categoryId: number | undefined): Observable<QualificationDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Qualification/GetAllQualifications?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllQualifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllQualifications(<any>response_);
                } catch (e) {
                    return <Observable<QualificationDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<QualificationDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllQualifications(response: HttpResponseBase): Observable<QualificationDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QualificationDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QualificationDTOListApiResult>(<any>null);
    }

    /**
     * API to get Qualification by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getQualification(id: number | undefined): Observable<QualificationDTOApiResult> {
        let url_ = this.baseUrl + "/api/Qualification/GetQualification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQualification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQualification(<any>response_);
                } catch (e) {
                    return <Observable<QualificationDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<QualificationDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetQualification(response: HttpResponseBase): Observable<QualificationDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QualificationDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QualificationDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRatingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving all Ratings
     * @return Success
     */
    getRatings(): Observable<RatingDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Rating/FetchRatings/GetRatings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRatings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRatings(<any>response_);
                } catch (e) {
                    return <Observable<RatingDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RatingDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRatings(response: HttpResponseBase): Observable<RatingDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RatingDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RatingDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateRatingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for add/updating Rating
     * @param payloads (optional) 
     * @return Success
     */
    addUpdateRating(payloads: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Rating/AddUpdateRating/Add-Update-Rating?";
        if (payloads !== undefined && payloads !== null)
            url_ += "payloads=" + encodeURIComponent("" + payloads) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateRating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateRating(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateRating(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteRatingRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for deleting Rating
     * @param id (optional) 
     * @return Success
     */
    deleteRating(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Rating/DeleteRatingRecord/DeleteRating?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRating(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRating(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RecruitmentJobServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Job
     * @param body (optional) 
     * @return Success
     */
    addUpdateJob(body: ManageJobDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentJob/Add-Update-Job";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateJob(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateJob(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch All Jobs.
    Note: all filter are optional
     * @param body (optional) 
     * @return Success
     */
    getAllJobs(body: JobFilterDTO | undefined): Observable<JobDTOListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentJob/GetAllJobs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllJobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllJobs(<any>response_);
                } catch (e) {
                    return <Observable<JobDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllJobs(response: HttpResponseBase): Observable<JobDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDTOListApiResult>(<any>null);
    }

    /**
     * API for getting Jobs that can be use for dropdowns
     * @return Success
     */
    getJobs(): Observable<JobIListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentJob/GetJobs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobs(<any>response_);
                } catch (e) {
                    return <Observable<JobIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobs(response: HttpResponseBase): Observable<JobIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobIListApiResult>(<any>null);
    }

    /**
     * API to get Job details by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getJob(id: number | undefined): Observable<JobDTOApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentJob/GetJob?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJob(<any>response_);
                } catch (e) {
                    return <Observable<JobDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetJob(response: HttpResponseBase): Observable<JobDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDTOApiResult>(<any>null);
    }

    /**
     * API  for Deleting Job
     * @param id (optional) 
     * @return Success
     */
    deleteJob(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentJob/DeleteJob?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteJob(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteJob(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RecruitmentJobApplicationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param skills (optional) 
     * @param email (optional) 
     * @param mobile (optional) 
     * @param jobId (optional) 
     * @param applicantCode (optional) 
     * @param jobApplicantId (optional) 
     * @param dateApplied (optional) 
     * @param alertSent (optional) 
     * @param coverLetter (optional) 
     * @param jobLocation (optional) 
     * @param iD (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchJobApplications(skills: string | null | undefined, email: string | null | undefined, mobile: string | null | undefined, jobId: number | undefined, applicantCode: string | null | undefined, jobApplicantId: number | undefined, dateApplied: Date | undefined, alertSent: boolean | undefined, coverLetter: string | null | undefined, jobLocation: number | undefined, iD: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<JobApplicationSearchIListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentJobApplication/FetchJobApplications?";
        if (skills !== undefined && skills !== null)
            url_ += "Skills=" + encodeURIComponent("" + skills) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (mobile !== undefined && mobile !== null)
            url_ += "Mobile=" + encodeURIComponent("" + mobile) + "&";
        if (jobId === null)
            throw new Error("The parameter 'jobId' cannot be null.");
        else if (jobId !== undefined)
            url_ += "JobId=" + encodeURIComponent("" + jobId) + "&";
        if (applicantCode !== undefined && applicantCode !== null)
            url_ += "ApplicantCode=" + encodeURIComponent("" + applicantCode) + "&";
        if (jobApplicantId === null)
            throw new Error("The parameter 'jobApplicantId' cannot be null.");
        else if (jobApplicantId !== undefined)
            url_ += "JobApplicantId=" + encodeURIComponent("" + jobApplicantId) + "&";
        if (dateApplied === null)
            throw new Error("The parameter 'dateApplied' cannot be null.");
        else if (dateApplied !== undefined)
            url_ += "DateApplied=" + encodeURIComponent(dateApplied ? "" + dateApplied.toJSON() : "") + "&";
        if (alertSent === null)
            throw new Error("The parameter 'alertSent' cannot be null.");
        else if (alertSent !== undefined)
            url_ += "AlertSent=" + encodeURIComponent("" + alertSent) + "&";
        if (coverLetter !== undefined && coverLetter !== null)
            url_ += "CoverLetter=" + encodeURIComponent("" + coverLetter) + "&";
        if (jobLocation === null)
            throw new Error("The parameter 'jobLocation' cannot be null.");
        else if (jobLocation !== undefined)
            url_ += "JobLocation=" + encodeURIComponent("" + jobLocation) + "&";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchJobApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchJobApplications(<any>response_);
                } catch (e) {
                    return <Observable<JobApplicationSearchIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobApplicationSearchIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchJobApplications(response: HttpResponseBase): Observable<JobApplicationSearchIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobApplicationSearchIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobApplicationSearchIListApiResult>(<any>null);
    }

    /**
     * @param jobApplicantId (optional) 
     * @return Success
     */
    fetchJobInterviewerListByApplicationId(jobApplicantId: number | undefined): Observable<JobScheduleInterviewIListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentJobApplication/FetchJobInterviewerListByApplicationId?";
        if (jobApplicantId === null)
            throw new Error("The parameter 'jobApplicantId' cannot be null.");
        else if (jobApplicantId !== undefined)
            url_ += "JobApplicantId=" + encodeURIComponent("" + jobApplicantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchJobInterviewerListByApplicationId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchJobInterviewerListByApplicationId(<any>response_);
                } catch (e) {
                    return <Observable<JobScheduleInterviewIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobScheduleInterviewIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchJobInterviewerListByApplicationId(response: HttpResponseBase): Observable<JobScheduleInterviewIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobScheduleInterviewIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobScheduleInterviewIListApiResult>(<any>null);
    }

    /**
     * @param jobApplicantId (optional) 
     * @return Success
     */
    viewJobApplicationProfileById(jobApplicantId: number | undefined): Observable<JobApplicationIListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentJobApplication/ViewJobApplicationProfileById?";
        if (jobApplicantId === null)
            throw new Error("The parameter 'jobApplicantId' cannot be null.");
        else if (jobApplicantId !== undefined)
            url_ += "JobApplicantId=" + encodeURIComponent("" + jobApplicantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewJobApplicationProfileById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewJobApplicationProfileById(<any>response_);
                } catch (e) {
                    return <Observable<JobApplicationIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobApplicationIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processViewJobApplicationProfileById(response: HttpResponseBase): Observable<JobApplicationIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobApplicationIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobApplicationIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateJobApplication(body: JobApplicantDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentJobApplication/AddUpdateJobApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateJobApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateJobApplication(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateJobApplication(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateScheduleJobInterviews(body: JobApplicantScheduleInterview | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentJobApplication/AddUpdateScheduleJobInterviews";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateScheduleJobInterviews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateScheduleJobInterviews(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateScheduleJobInterviews(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RecruitmentQuizServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting Quiz Types i.e.
    {Interest, Personality, and  Aptitude Tests}
     * @return Success
     */
    getQuizTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentQuiz/GetQuizTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuizTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuizTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuizTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Question Types i.e.
    {'Multiple Choice, True/False, Multiple Answers, Fill-in-the-Blank'}
     * @return Success
     */
    getQuestionTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentQuiz/GetQuestionTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for adding/updating Quiz
     * @param body (optional) 
     * @return Success
     */
    addUpdateQuiz(body: ManageQuizDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentQuiz/Add-Update-Quiz";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateQuiz(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateQuiz(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateQuiz(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Quizzes.
     * @return Success
     */
    getAllQuizzes(): Observable<QuizDTOListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentQuiz/GetAllQuizzes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllQuizzes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllQuizzes(<any>response_);
                } catch (e) {
                    return <Observable<QuizDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuizDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllQuizzes(response: HttpResponseBase): Observable<QuizDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuizDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuizDTOListApiResult>(<any>null);
    }

    /**
     * API to get Quiz by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getQuiz(id: number | undefined): Observable<QuizDTOApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentQuiz/GetQuiz?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuiz(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuiz(<any>response_);
                } catch (e) {
                    return <Observable<QuizDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuizDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuiz(response: HttpResponseBase): Observable<QuizDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuizDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuizDTOApiResult>(<any>null);
    }
}

@Injectable()
export class RecruitmentSettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting Job Availability Types i.e.
    {'Physical, Remote, Flexible'}
     * @return Success
     */
    getJobAvailabilities(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/GetJobAvailabilities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobAvailabilities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobAvailabilities(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobAvailabilities(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting Job Employment Types i.e.
    {'Full-time, Contract'}
     * @return Success
     */
    getEmploymentTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/GetEmploymentTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmploymentTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmploymentTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmploymentTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for adding/updating HireStage
     * @param body (optional) 
     * @return Success
     */
    addUpdateHireStage(body: ManageHireStageDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/Add-Update-HireStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateHireStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateHireStage(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateHireStage(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch HireStages.
    Note: all filter are optional
     * @return Success
     */
    getAllHireStages(): Observable<HireStageDTOListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/GetAllHireStages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHireStages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHireStages(<any>response_);
                } catch (e) {
                    return <Observable<HireStageDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<HireStageDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHireStages(response: HttpResponseBase): Observable<HireStageDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HireStageDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HireStageDTOListApiResult>(<any>null);
    }

    /**
     * API for getting HireStages that can be use for dropdowns
     * @return Success
     */
    getHireStages(): Observable<HireStageIListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/GetHireStages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHireStages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHireStages(<any>response_);
                } catch (e) {
                    return <Observable<HireStageIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<HireStageIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetHireStages(response: HttpResponseBase): Observable<HireStageIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HireStageIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HireStageIListApiResult>(<any>null);
    }

    /**
     * API to get HireStage by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getHireStage(id: number | undefined): Observable<HireStageDTOApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/GetHireStage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHireStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHireStage(<any>response_);
                } catch (e) {
                    return <Observable<HireStageDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<HireStageDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetHireStage(response: HttpResponseBase): Observable<HireStageDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HireStageDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HireStageDTOApiResult>(<any>null);
    }

    /**
     * API for adding/updating SubHireStage
     * @param body (optional) 
     * @return Success
     */
    addUpdateSubHireStage(body: ManageSubHireStageDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/Add-Update-SubHireStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateSubHireStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateSubHireStage(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateSubHireStage(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Sub HireStages.
    Note: all filter are optional
     * @return Success
     */
    getAllSubHireStages(): Observable<SubHireStageDTOListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/GetAllSubHireStages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubHireStages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubHireStages(<any>response_);
                } catch (e) {
                    return <Observable<SubHireStageDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubHireStageDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSubHireStages(response: HttpResponseBase): Observable<SubHireStageDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubHireStageDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubHireStageDTOListApiResult>(<any>null);
    }

    /**
     * API to Fetch Sub HireStages by HireStage Id.
    Like Interview and sub-stages under it
     * @param hireStageId (optional) 
     * @return Success
     */
    getSubHireStageByStageId(hireStageId: number | undefined): Observable<SubHireStageDTOListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/GetSubHireStageByStageId?";
        if (hireStageId === null)
            throw new Error("The parameter 'hireStageId' cannot be null.");
        else if (hireStageId !== undefined)
            url_ += "hireStageId=" + encodeURIComponent("" + hireStageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubHireStageByStageId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubHireStageByStageId(<any>response_);
                } catch (e) {
                    return <Observable<SubHireStageDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubHireStageDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubHireStageByStageId(response: HttpResponseBase): Observable<SubHireStageDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubHireStageDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubHireStageDTOListApiResult>(<any>null);
    }

    /**
     * API for getting Sub HireStages that can be use for dropdowns
     * @return Success
     */
    getSubHireStages(): Observable<SubHireStageIListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/GetSubHireStages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubHireStages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubHireStages(<any>response_);
                } catch (e) {
                    return <Observable<SubHireStageIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubHireStageIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubHireStages(response: HttpResponseBase): Observable<SubHireStageIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubHireStageIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubHireStageIListApiResult>(<any>null);
    }

    /**
     * API to get Sub HireStage by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getSubHireStage(id: number | undefined): Observable<SubHireStageDTOApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/GetSubHireStage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubHireStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubHireStage(<any>response_);
                } catch (e) {
                    return <Observable<SubHireStageDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubHireStageDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubHireStage(response: HttpResponseBase): Observable<SubHireStageDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubHireStageDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubHireStageDTOApiResult>(<any>null);
    }

    /**
     * API for adding/updating ScoreCard
     * @param body (optional) 
     * @return Success
     */
    addUpdateScoreCard(body: ManageRecruitmentScoreCardDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/Add-Update-ScoreCard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateScoreCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateScoreCard(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateScoreCard(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch ScoreCards.
    Note: all filter are optional
     * @return Success
     */
    getAllRecruitmentScoreCards(): Observable<RecruitmentScoreCardDTOListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/GetAllRecruitmentScoreCards";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRecruitmentScoreCards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRecruitmentScoreCards(<any>response_);
                } catch (e) {
                    return <Observable<RecruitmentScoreCardDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecruitmentScoreCardDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRecruitmentScoreCards(response: HttpResponseBase): Observable<RecruitmentScoreCardDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecruitmentScoreCardDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecruitmentScoreCardDTOListApiResult>(<any>null);
    }

    /**
     * API for getting ScoreCards that can be use for dropdowns
     * @return Success
     */
    getRecruitmentScoreCards(): Observable<RecruitmentScoreCardIListApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/GetRecruitmentScoreCards";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecruitmentScoreCards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecruitmentScoreCards(<any>response_);
                } catch (e) {
                    return <Observable<RecruitmentScoreCardIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecruitmentScoreCardIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecruitmentScoreCards(response: HttpResponseBase): Observable<RecruitmentScoreCardIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecruitmentScoreCardIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecruitmentScoreCardIListApiResult>(<any>null);
    }

    /**
     * API to get ScoreCard by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getRecruitmentScoreCard(id: number | undefined): Observable<RecruitmentScoreCardDTOApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/GetRecruitmentScoreCard?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecruitmentScoreCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecruitmentScoreCard(<any>response_);
                } catch (e) {
                    return <Observable<RecruitmentScoreCardDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecruitmentScoreCardDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecruitmentScoreCard(response: HttpResponseBase): Observable<RecruitmentScoreCardDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecruitmentScoreCardDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecruitmentScoreCardDTOApiResult>(<any>null);
    }

    /**
     * API  for Removing ScoreCard Question by ScoreCardId and QuestionId
     * @param scoreCardId (optional) 
     * @param questionId (optional) 
     * @return Success
     */
    removeScoreCardQuestion(scoreCardId: number | undefined, questionId: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RecruitmentSetting/RemoveScoreCardQuestion?";
        if (scoreCardId === null)
            throw new Error("The parameter 'scoreCardId' cannot be null.");
        else if (scoreCardId !== undefined)
            url_ += "scoreCardId=" + encodeURIComponent("" + scoreCardId) + "&";
        if (questionId === null)
            throw new Error("The parameter 'questionId' cannot be null.");
        else if (questionId !== undefined)
            url_ += "questionId=" + encodeURIComponent("" + questionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveScoreCardQuestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveScoreCardQuestion(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveScoreCardQuestion(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Request
     * @param body (optional) 
     * @return Success
     */
    addUpdateRequest(body: ManageRequestDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RequestandComplaint/AddUpdateRequest/Add-Update-Request";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch Requests.
    Note: all filter are optional
     * @param departmentId (optional) 
     * @param requestStatusId (optional) 
     * @param log_status (optional) 
     * @param requestTypeId (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllRequest(departmentId: number | undefined, requestStatusId: number | undefined, log_status: number | undefined, requestTypeId: number | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<RequestDTOListApiResult> {
        let url_ = this.baseUrl + "/api/RequestandComplaint/GetAllRequest/GetAllRequest?";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (requestStatusId === null)
            throw new Error("The parameter 'requestStatusId' cannot be null.");
        else if (requestStatusId !== undefined)
            url_ += "RequestStatusId=" + encodeURIComponent("" + requestStatusId) + "&";
        if (log_status === null)
            throw new Error("The parameter 'log_status' cannot be null.");
        else if (log_status !== undefined)
            url_ += "log_status=" + encodeURIComponent("" + log_status) + "&";
        if (requestTypeId === null)
            throw new Error("The parameter 'requestTypeId' cannot be null.");
        else if (requestTypeId !== undefined)
            url_ += "RequestTypeId=" + encodeURIComponent("" + requestTypeId) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRequest(<any>response_);
                } catch (e) {
                    return <Observable<RequestDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRequest(response: HttpResponseBase): Observable<RequestDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetRequestByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to get Department by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getRequestById(id: number | undefined): Observable<RequestDTOApiResult> {
        let url_ = this.baseUrl + "/api/RequestandComplaint/GetRequestById/GetRequestById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestById(<any>response_);
                } catch (e) {
                    return <Observable<RequestDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestById(response: HttpResponseBase): Observable<RequestDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestDTOApiResult>(<any>null);
    }
}

@Injectable()
export class CreateUpdateRequestTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating RequestType
     * @param body (optional) 
     * @return Success
     */
    createUpdateRequestType(body: ManageRequestTypeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RequestType/CreateUpdateRequestType/CreateUpdateRequestType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUpdateRequestType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUpdateRequestType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUpdateRequestType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllRequestTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch RequestType.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllRequestType(pageSize: number | undefined, pageNumber: number | undefined): Observable<RequestTypeDTOListApiResult> {
        let url_ = this.baseUrl + "/api/RequestType/GetAllRequestType/GetAllRequestType?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRequestType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRequestType(<any>response_);
                } catch (e) {
                    return <Observable<RequestTypeDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestTypeDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRequestType(response: HttpResponseBase): Observable<RequestTypeDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestTypeDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestTypeDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetRequestTypeByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to get RequestType by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getRequestTypeById(id: number | undefined): Observable<RequestTypeDTOApiResult> {
        let url_ = this.baseUrl + "/api/RequestType/GetRequestTypeById/GetRequestTypeById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestTypeById(<any>response_);
                } catch (e) {
                    return <Observable<RequestTypeDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestTypeDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestTypeById(response: HttpResponseBase): Observable<RequestTypeDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestTypeDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestTypeDTOApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteRequestTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRequestType(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RequestType/DeleteRequestType/Delete-RequestType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRequestType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRequestType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRequestType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RetirementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Post Retirement
     * @param adminMode (optional) 
     * @param saveNsubmit (optional) 
     * @param body (optional) 
     * @return Success
     */
    postRetireee(adminMode: number | undefined, saveNsubmit: number | undefined, body: ManageRetirementDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/PostRetireee?";
        if (adminMode === null)
            throw new Error("The parameter 'adminMode' cannot be null.");
        else if (adminMode !== undefined)
            url_ += "adminMode=" + encodeURIComponent("" + adminMode) + "&";
        if (saveNsubmit === null)
            throw new Error("The parameter 'saveNsubmit' cannot be null.");
        else if (saveNsubmit !== undefined)
            url_ += "saveNsubmit=" + encodeURIComponent("" + saveNsubmit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostRetireee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostRetireee(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostRetireee(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Retireee.
    Note: all filter are optional
     * @param startdte (optional) 
     * @param enddte (optional) 
     * @param searchText (optional) 
     * @param searchType (optional) 
     * @param page (optional) 
     * @param _selected (optional) 
     * @param startdate (optional) 
     * @param endate (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllRetire(startdte: string | null | undefined, enddte: string | null | undefined, searchText: string | null | undefined, searchType: number | null | undefined, page: number | null | undefined, _selected: string | null | undefined, startdate: Date | null | undefined, endate: Date | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<RetirmentDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/GetAllRetire?";
        if (startdte !== undefined && startdte !== null)
            url_ += "startdte=" + encodeURIComponent("" + startdte) + "&";
        if (enddte !== undefined && enddte !== null)
            url_ += "enddte=" + encodeURIComponent("" + enddte) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (_selected !== undefined && _selected !== null)
            url_ += "_selected=" + encodeURIComponent("" + _selected) + "&";
        if (startdate !== undefined && startdate !== null)
            url_ += "startdate=" + encodeURIComponent(startdate ? "" + startdate.toJSON() : "") + "&";
        if (endate !== undefined && endate !== null)
            url_ += "endate=" + encodeURIComponent(endate ? "" + endate.toJSON() : "") + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetire(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetire(<any>response_);
                } catch (e) {
                    return <Observable<RetirmentDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirmentDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetire(response: HttpResponseBase): Observable<RetirmentDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirmentDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirmentDTOListApiResult>(<any>null);
    }

    /**
     * API to Fetch Retireee.
    Note: all filter are optional
     * @param iD (optional) 
     * @param fullName (optional) 
     * @param dateRequested (optional) 
     * @param type (optional) 
     * @param status (optional) 
     * @param isCleared (optional) 
     * @param retirmentTypeid (optional) 
     * @return Success
     */
    getRetirees(iD: number | undefined, fullName: string | null | undefined, dateRequested: Date | null | undefined, type: string | null | undefined, status: string | null | undefined, isCleared: boolean | undefined, retirmentTypeid: number | undefined): Observable<RetirmentDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/GetRetirees?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (fullName !== undefined && fullName !== null)
            url_ += "FullName=" + encodeURIComponent("" + fullName) + "&";
        if (dateRequested !== undefined && dateRequested !== null)
            url_ += "DateRequested=" + encodeURIComponent(dateRequested ? "" + dateRequested.toJSON() : "") + "&";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (isCleared === null)
            throw new Error("The parameter 'isCleared' cannot be null.");
        else if (isCleared !== undefined)
            url_ += "IsCleared=" + encodeURIComponent("" + isCleared) + "&";
        if (retirmentTypeid === null)
            throw new Error("The parameter 'retirmentTypeid' cannot be null.");
        else if (retirmentTypeid !== undefined)
            url_ += "retirmentTypeid=" + encodeURIComponent("" + retirmentTypeid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetirees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetirees(<any>response_);
                } catch (e) {
                    return <Observable<RetirmentDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirmentDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetirees(response: HttpResponseBase): Observable<RetirmentDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirmentDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirmentDTOListApiResult>(<any>null);
    }

    /**
     * API to Fetch post Retireee.
    Note: all filter are optional
     * @return Success
     */
    getPostRetirees(): Observable<RetirementLogListApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/Get-Post-Retirees";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostRetirees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostRetirees(<any>response_);
                } catch (e) {
                    return <Observable<RetirementLogListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirementLogListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPostRetirees(response: HttpResponseBase): Observable<RetirementLogListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementLogListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementLogListApiResult>(<any>null);
    }

    /**
     * API to Fetch Retireee.
    Note: all filter are optional
     * @param startdte (optional) 
     * @param enddte (optional) 
     * @param searchText (optional) 
     * @param searchType (optional) 
     * @param page (optional) 
     * @param _selected (optional) 
     * @param startdate (optional) 
     * @param endate (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    searchRetiree(startdte: string | null | undefined, enddte: string | null | undefined, searchText: string | null | undefined, searchType: number | null | undefined, page: number | null | undefined, _selected: string | null | undefined, startdate: Date | null | undefined, endate: Date | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<RetirmentDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/SearchRetiree?";
        if (startdte !== undefined && startdte !== null)
            url_ += "startdte=" + encodeURIComponent("" + startdte) + "&";
        if (enddte !== undefined && enddte !== null)
            url_ += "enddte=" + encodeURIComponent("" + enddte) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (searchType !== undefined && searchType !== null)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (_selected !== undefined && _selected !== null)
            url_ += "_selected=" + encodeURIComponent("" + _selected) + "&";
        if (startdate !== undefined && startdate !== null)
            url_ += "startdate=" + encodeURIComponent(startdate ? "" + startdate.toJSON() : "") + "&";
        if (endate !== undefined && endate !== null)
            url_ += "endate=" + encodeURIComponent(endate ? "" + endate.toJSON() : "") + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchRetiree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchRetiree(<any>response_);
                } catch (e) {
                    return <Observable<RetirmentDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirmentDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearchRetiree(response: HttpResponseBase): Observable<RetirmentDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirmentDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirmentDTOListApiResult>(<any>null);
    }

    /**
     * API to Fetch Retirement by Id.
    Note: all filter are optional
     * @param id (optional) 
     * @return Success
     */
    getRetirmentByid(id: number | undefined): Observable<RetirmentDTOApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/GetRetirmentByid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetirmentByid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetirmentByid(<any>response_);
                } catch (e) {
                    return <Observable<RetirmentDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirmentDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetirmentByid(response: HttpResponseBase): Observable<RetirmentDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirmentDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirmentDTOApiResult>(<any>null);
    }

    /**
     * API to Fetch Retirement by Employee Id.
    Note: all filter are optional
     * @param user_id (optional) 
     * @param employee_id (optional) 
     * @param employee_number (optional) 
     * @param employee_contract_id (optional) 
     * @param companyProfile_Id (optional) 
     * @param companyProfile_UserId (optional) 
     * @param companyProfile_RCNo (optional) 
     * @param companyProfile_LogoName (optional) 
     * @param companyProfile_ShortText (optional) 
     * @param companyProfile_FirstName (optional) 
     * @param companyProfile_LastName (optional) 
     * @param companyProfile_Address (optional) 
     * @param companyProfile_DomainName (optional) 
     * @param companyProfile_AuditorEmail (optional) 
     * @param companyProfile_MaxEmployeeCount (optional) 
     * @param companyProfile_SubscriptionPlanId (optional) 
     * @param companyProfile_SubscriptionPlanName (optional) 
     * @param companyProfile_LastBillingDate (optional) 
     * @param companyProfile_LastPaymentDate (optional) 
     * @param companyProfile_LicenseUsage (optional) 
     * @param companyProfile_IsActiveByAdmin (optional) 
     * @param companyProfile_IsTrial (optional) 
     * @param companyProfile_FrequencyId (optional) 
     * @param companyProfile_TempRef (optional) 
     * @param companyProfile_ReferenceNumber (optional) 
     * @param grade_id (optional) 
     * @param confirmation_date (optional) 
     * @param serial_no (optional) 
     * @param first_name (optional) 
     * @param last_name (optional) 
     * @param full_name (optional) 
     * @param other_name (optional) 
     * @param department (optional) 
     * @param department_id (optional) 
     * @param email (optional) 
     * @param phone_number (optional) 
     * @param email_confirmed (optional) 
     * @param session_token (optional) 
     * @param jwt_token (optional) 
     * @param user_token (optional) 
     * @param company_id (optional) 
     * @param licenseUsuage (optional) 
     * @param licenseCount (optional) 
     * @param company_name (optional) 
     * @param sub_id (optional) 
     * @param isAdmin (optional) 
     * @param isSuperAdmin (optional) 
     * @param isTenantAdmin (optional) 
     * @param isActiveBySysOrAdmin (optional) 
     * @param lstPermissions (optional) 
     * @param message (optional) 
     * @param isSuccessful (optional) 
     * @param retId (optional) 
     * @param bulkUploadId (optional) 
     * @param bulkUploadHtmlData (optional) 
     * @param redirectUrl (optional) 
     * @param referenceNumber (optional) 
     * @param errors (optional) 
     * @return Success
     */
    getRetirmentByEmployeeId(user_id: number | undefined, employee_id: number | undefined, employee_number: string | null | undefined, employee_contract_id: number | undefined, companyProfile_Id: number | undefined, companyProfile_UserId: number | undefined, companyProfile_Name: string, companyProfile_RCNo: string | null | undefined, companyProfile_LogoName: string | null | undefined, companyProfile_ShortText: string | null | undefined, companyProfile_Email: string, companyProfile_PhoneNumber: string, companyProfile_FirstName: string | null | undefined, companyProfile_LastName: string | null | undefined, companyProfile_Address: string | null | undefined, companyProfile_AdministratorEmail: string, companyProfile_DomainName: string | null | undefined, companyProfile_AuditorEmail: string | null | undefined, companyProfile_MaxEmployeeCount: number | undefined, companyProfile_SubscriptionPlanId: number | undefined, companyProfile_SubscriptionPlanName: string | null | undefined, companyProfile_LastBillingDate: Date | null | undefined, companyProfile_LastPaymentDate: Date | null | undefined, companyProfile_LicenseUsage: number | undefined, companyProfile_IsActiveByAdmin: boolean | undefined, companyProfile_IsTrial: boolean | undefined, companyProfile_Password: string, companyProfile_FrequencyId: number | undefined, companyProfile_TempRef: string | null | undefined, companyProfile_ReferenceNumber: string | null | undefined, grade_id: number | null | undefined, confirmation_date: Date | null | undefined, serial_no: string | null | undefined, first_name: string | null | undefined, last_name: string | null | undefined, full_name: string | null | undefined, other_name: string | null | undefined, department: string | null | undefined, department_id: number | undefined, email: string | null | undefined, phone_number: string | null | undefined, email_confirmed: boolean | undefined, session_token: string | null | undefined, jwt_token: string | null | undefined, user_token: string | null | undefined, company_id: number | undefined, licenseUsuage: number | undefined, licenseCount: number | undefined, company_name: string | null | undefined, sub_id: number | undefined, isAdmin: boolean | undefined, isSuperAdmin: boolean | undefined, isTenantAdmin: boolean | undefined, isActiveBySysOrAdmin: boolean | undefined, lstPermissions: string[] | null | undefined, message: string | null | undefined, isSuccessful: boolean | undefined, retId: number | undefined, bulkUploadId: number | undefined, bulkUploadHtmlData: string | null | undefined, redirectUrl: string | null | undefined, referenceNumber: string | null | undefined, errors: string[] | null | undefined): Observable<RetirementApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/GetRetirmentByEmployeeId?";
        if (user_id === null)
            throw new Error("The parameter 'user_id' cannot be null.");
        else if (user_id !== undefined)
            url_ += "user_id=" + encodeURIComponent("" + user_id) + "&";
        if (employee_id === null)
            throw new Error("The parameter 'employee_id' cannot be null.");
        else if (employee_id !== undefined)
            url_ += "employee_id=" + encodeURIComponent("" + employee_id) + "&";
        if (employee_number !== undefined && employee_number !== null)
            url_ += "employee_number=" + encodeURIComponent("" + employee_number) + "&";
        if (employee_contract_id === null)
            throw new Error("The parameter 'employee_contract_id' cannot be null.");
        else if (employee_contract_id !== undefined)
            url_ += "employee_contract_id=" + encodeURIComponent("" + employee_contract_id) + "&";
        if (companyProfile_Id === null)
            throw new Error("The parameter 'companyProfile_Id' cannot be null.");
        else if (companyProfile_Id !== undefined)
            url_ += "CompanyProfile.Id=" + encodeURIComponent("" + companyProfile_Id) + "&";
        if (companyProfile_UserId === null)
            throw new Error("The parameter 'companyProfile_UserId' cannot be null.");
        else if (companyProfile_UserId !== undefined)
            url_ += "CompanyProfile.UserId=" + encodeURIComponent("" + companyProfile_UserId) + "&";
        if (companyProfile_Name === undefined || companyProfile_Name === null)
            throw new Error("The parameter 'companyProfile_Name' must be defined and cannot be null.");
        else
            url_ += "CompanyProfile.Name=" + encodeURIComponent("" + companyProfile_Name) + "&";
        if (companyProfile_RCNo !== undefined && companyProfile_RCNo !== null)
            url_ += "CompanyProfile.RCNo=" + encodeURIComponent("" + companyProfile_RCNo) + "&";
        if (companyProfile_LogoName !== undefined && companyProfile_LogoName !== null)
            url_ += "CompanyProfile.LogoName=" + encodeURIComponent("" + companyProfile_LogoName) + "&";
        if (companyProfile_ShortText !== undefined && companyProfile_ShortText !== null)
            url_ += "CompanyProfile.ShortText=" + encodeURIComponent("" + companyProfile_ShortText) + "&";
        if (companyProfile_Email === undefined || companyProfile_Email === null)
            throw new Error("The parameter 'companyProfile_Email' must be defined and cannot be null.");
        else
            url_ += "CompanyProfile.Email=" + encodeURIComponent("" + companyProfile_Email) + "&";
        if (companyProfile_PhoneNumber === undefined || companyProfile_PhoneNumber === null)
            throw new Error("The parameter 'companyProfile_PhoneNumber' must be defined and cannot be null.");
        else
            url_ += "CompanyProfile.PhoneNumber=" + encodeURIComponent("" + companyProfile_PhoneNumber) + "&";
        if (companyProfile_FirstName !== undefined && companyProfile_FirstName !== null)
            url_ += "CompanyProfile.FirstName=" + encodeURIComponent("" + companyProfile_FirstName) + "&";
        if (companyProfile_LastName !== undefined && companyProfile_LastName !== null)
            url_ += "CompanyProfile.LastName=" + encodeURIComponent("" + companyProfile_LastName) + "&";
        if (companyProfile_Address !== undefined && companyProfile_Address !== null)
            url_ += "CompanyProfile.Address=" + encodeURIComponent("" + companyProfile_Address) + "&";
        if (companyProfile_AdministratorEmail === undefined || companyProfile_AdministratorEmail === null)
            throw new Error("The parameter 'companyProfile_AdministratorEmail' must be defined and cannot be null.");
        else
            url_ += "CompanyProfile.AdministratorEmail=" + encodeURIComponent("" + companyProfile_AdministratorEmail) + "&";
        if (companyProfile_DomainName !== undefined && companyProfile_DomainName !== null)
            url_ += "CompanyProfile.DomainName=" + encodeURIComponent("" + companyProfile_DomainName) + "&";
        if (companyProfile_AuditorEmail !== undefined && companyProfile_AuditorEmail !== null)
            url_ += "CompanyProfile.AuditorEmail=" + encodeURIComponent("" + companyProfile_AuditorEmail) + "&";
        if (companyProfile_MaxEmployeeCount === null)
            throw new Error("The parameter 'companyProfile_MaxEmployeeCount' cannot be null.");
        else if (companyProfile_MaxEmployeeCount !== undefined)
            url_ += "CompanyProfile.MaxEmployeeCount=" + encodeURIComponent("" + companyProfile_MaxEmployeeCount) + "&";
        if (companyProfile_SubscriptionPlanId === null)
            throw new Error("The parameter 'companyProfile_SubscriptionPlanId' cannot be null.");
        else if (companyProfile_SubscriptionPlanId !== undefined)
            url_ += "CompanyProfile.SubscriptionPlanId=" + encodeURIComponent("" + companyProfile_SubscriptionPlanId) + "&";
        if (companyProfile_SubscriptionPlanName !== undefined && companyProfile_SubscriptionPlanName !== null)
            url_ += "CompanyProfile.SubscriptionPlanName=" + encodeURIComponent("" + companyProfile_SubscriptionPlanName) + "&";
        if (companyProfile_LastBillingDate !== undefined && companyProfile_LastBillingDate !== null)
            url_ += "CompanyProfile.LastBillingDate=" + encodeURIComponent(companyProfile_LastBillingDate ? "" + companyProfile_LastBillingDate.toJSON() : "") + "&";
        if (companyProfile_LastPaymentDate !== undefined && companyProfile_LastPaymentDate !== null)
            url_ += "CompanyProfile.LastPaymentDate=" + encodeURIComponent(companyProfile_LastPaymentDate ? "" + companyProfile_LastPaymentDate.toJSON() : "") + "&";
        if (companyProfile_LicenseUsage === null)
            throw new Error("The parameter 'companyProfile_LicenseUsage' cannot be null.");
        else if (companyProfile_LicenseUsage !== undefined)
            url_ += "CompanyProfile.LicenseUsage=" + encodeURIComponent("" + companyProfile_LicenseUsage) + "&";
        if (companyProfile_IsActiveByAdmin === null)
            throw new Error("The parameter 'companyProfile_IsActiveByAdmin' cannot be null.");
        else if (companyProfile_IsActiveByAdmin !== undefined)
            url_ += "CompanyProfile.IsActiveByAdmin=" + encodeURIComponent("" + companyProfile_IsActiveByAdmin) + "&";
        if (companyProfile_IsTrial === null)
            throw new Error("The parameter 'companyProfile_IsTrial' cannot be null.");
        else if (companyProfile_IsTrial !== undefined)
            url_ += "CompanyProfile.IsTrial=" + encodeURIComponent("" + companyProfile_IsTrial) + "&";
        if (companyProfile_Password === undefined || companyProfile_Password === null)
            throw new Error("The parameter 'companyProfile_Password' must be defined and cannot be null.");
        else
            url_ += "CompanyProfile.Password=" + encodeURIComponent("" + companyProfile_Password) + "&";
        if (companyProfile_FrequencyId === null)
            throw new Error("The parameter 'companyProfile_FrequencyId' cannot be null.");
        else if (companyProfile_FrequencyId !== undefined)
            url_ += "CompanyProfile.FrequencyId=" + encodeURIComponent("" + companyProfile_FrequencyId) + "&";
        if (companyProfile_TempRef !== undefined && companyProfile_TempRef !== null)
            url_ += "CompanyProfile.TempRef=" + encodeURIComponent("" + companyProfile_TempRef) + "&";
        if (companyProfile_ReferenceNumber !== undefined && companyProfile_ReferenceNumber !== null)
            url_ += "CompanyProfile.ReferenceNumber=" + encodeURIComponent("" + companyProfile_ReferenceNumber) + "&";
        if (grade_id !== undefined && grade_id !== null)
            url_ += "grade_id=" + encodeURIComponent("" + grade_id) + "&";
        if (confirmation_date !== undefined && confirmation_date !== null)
            url_ += "confirmation_date=" + encodeURIComponent(confirmation_date ? "" + confirmation_date.toJSON() : "") + "&";
        if (serial_no !== undefined && serial_no !== null)
            url_ += "serial_no=" + encodeURIComponent("" + serial_no) + "&";
        if (first_name !== undefined && first_name !== null)
            url_ += "first_name=" + encodeURIComponent("" + first_name) + "&";
        if (last_name !== undefined && last_name !== null)
            url_ += "last_name=" + encodeURIComponent("" + last_name) + "&";
        if (full_name !== undefined && full_name !== null)
            url_ += "full_name=" + encodeURIComponent("" + full_name) + "&";
        if (other_name !== undefined && other_name !== null)
            url_ += "other_name=" + encodeURIComponent("" + other_name) + "&";
        if (department !== undefined && department !== null)
            url_ += "department=" + encodeURIComponent("" + department) + "&";
        if (department_id === null)
            throw new Error("The parameter 'department_id' cannot be null.");
        else if (department_id !== undefined)
            url_ += "department_id=" + encodeURIComponent("" + department_id) + "&";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (phone_number !== undefined && phone_number !== null)
            url_ += "phone_number=" + encodeURIComponent("" + phone_number) + "&";
        if (email_confirmed === null)
            throw new Error("The parameter 'email_confirmed' cannot be null.");
        else if (email_confirmed !== undefined)
            url_ += "email_confirmed=" + encodeURIComponent("" + email_confirmed) + "&";
        if (session_token !== undefined && session_token !== null)
            url_ += "session_token=" + encodeURIComponent("" + session_token) + "&";
        if (jwt_token !== undefined && jwt_token !== null)
            url_ += "jwt_token=" + encodeURIComponent("" + jwt_token) + "&";
        if (user_token !== undefined && user_token !== null)
            url_ += "user_token=" + encodeURIComponent("" + user_token) + "&";
        if (company_id === null)
            throw new Error("The parameter 'company_id' cannot be null.");
        else if (company_id !== undefined)
            url_ += "company_id=" + encodeURIComponent("" + company_id) + "&";
        if (licenseUsuage === null)
            throw new Error("The parameter 'licenseUsuage' cannot be null.");
        else if (licenseUsuage !== undefined)
            url_ += "LicenseUsuage=" + encodeURIComponent("" + licenseUsuage) + "&";
        if (licenseCount === null)
            throw new Error("The parameter 'licenseCount' cannot be null.");
        else if (licenseCount !== undefined)
            url_ += "LicenseCount=" + encodeURIComponent("" + licenseCount) + "&";
        if (company_name !== undefined && company_name !== null)
            url_ += "company_name=" + encodeURIComponent("" + company_name) + "&";
        if (sub_id === null)
            throw new Error("The parameter 'sub_id' cannot be null.");
        else if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&";
        if (isAdmin === null)
            throw new Error("The parameter 'isAdmin' cannot be null.");
        else if (isAdmin !== undefined)
            url_ += "IsAdmin=" + encodeURIComponent("" + isAdmin) + "&";
        if (isSuperAdmin === null)
            throw new Error("The parameter 'isSuperAdmin' cannot be null.");
        else if (isSuperAdmin !== undefined)
            url_ += "IsSuperAdmin=" + encodeURIComponent("" + isSuperAdmin) + "&";
        if (isTenantAdmin === null)
            throw new Error("The parameter 'isTenantAdmin' cannot be null.");
        else if (isTenantAdmin !== undefined)
            url_ += "IsTenantAdmin=" + encodeURIComponent("" + isTenantAdmin) + "&";
        if (isActiveBySysOrAdmin === null)
            throw new Error("The parameter 'isActiveBySysOrAdmin' cannot be null.");
        else if (isActiveBySysOrAdmin !== undefined)
            url_ += "IsActiveBySysOrAdmin=" + encodeURIComponent("" + isActiveBySysOrAdmin) + "&";
        if (lstPermissions !== undefined && lstPermissions !== null)
            lstPermissions && lstPermissions.forEach(item => { url_ += "lstPermissions=" + encodeURIComponent("" + item) + "&"; });
        if (message !== undefined && message !== null)
            url_ += "Message=" + encodeURIComponent("" + message) + "&";
        if (isSuccessful === null)
            throw new Error("The parameter 'isSuccessful' cannot be null.");
        else if (isSuccessful !== undefined)
            url_ += "IsSuccessful=" + encodeURIComponent("" + isSuccessful) + "&";
        if (retId === null)
            throw new Error("The parameter 'retId' cannot be null.");
        else if (retId !== undefined)
            url_ += "RetId=" + encodeURIComponent("" + retId) + "&";
        if (bulkUploadId === null)
            throw new Error("The parameter 'bulkUploadId' cannot be null.");
        else if (bulkUploadId !== undefined)
            url_ += "BulkUploadId=" + encodeURIComponent("" + bulkUploadId) + "&";
        if (bulkUploadHtmlData !== undefined && bulkUploadHtmlData !== null)
            url_ += "BulkUploadHtmlData=" + encodeURIComponent("" + bulkUploadHtmlData) + "&";
        if (redirectUrl !== undefined && redirectUrl !== null)
            url_ += "RedirectUrl=" + encodeURIComponent("" + redirectUrl) + "&";
        if (referenceNumber !== undefined && referenceNumber !== null)
            url_ += "ReferenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        if (errors !== undefined && errors !== null)
            errors && errors.forEach(item => { url_ += "Errors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetirmentByEmployeeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetirmentByEmployeeId(<any>response_);
                } catch (e) {
                    return <Observable<RetirementApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetirementApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetirmentByEmployeeId(response: HttpResponseBase): Observable<RetirementApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementApiResult>(<any>null);
    }

    /**
     * API for adding/updating RetirementType
     * @param body (optional) 
     * @return Success
     */
    addUpdateRetirementype(body: ManageRetirmentTypeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Retirement/Add-Update-Retirementype";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateRetirementype(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateRetirementype(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateRetirementype(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateRequestTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateRequestType(body: AddRequestViewModel | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RewardDisciplinary/AddUpdateRequestType/AddUpdateRequestType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateRequestType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateRequestType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateRequestType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllRequestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param _PageSize (optional) 
     * @param log_status (optional) 
     * @return Success
     */
    getAllRequests(startDate: Date | null | undefined, endDate: Date | null | undefined, _PageSize: number | undefined, log_status: number | undefined): Observable<RequestViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/RewardDisciplinary/GetAllRequests/GetAllRequests?";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (_PageSize === null)
            throw new Error("The parameter '_PageSize' cannot be null.");
        else if (_PageSize !== undefined)
            url_ += "_PageSize=" + encodeURIComponent("" + _PageSize) + "&";
        if (log_status === null)
            throw new Error("The parameter 'log_status' cannot be null.");
        else if (log_status !== undefined)
            url_ += "log_status=" + encodeURIComponent("" + log_status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRequests(<any>response_);
                } catch (e) {
                    return <Observable<RequestViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRequests(response: HttpResponseBase): Observable<RequestViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestViewModelIListApiResult>(<any>null);
    }
}

@Injectable()
export class RequestDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    requestDetails(id: number | null | undefined): Observable<RequestFileDtoIListApiResult> {
        let url_ = this.baseUrl + "/api/RewardDisciplinary/RequestDetails/RequestDetails?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestDetails(<any>response_);
                } catch (e) {
                    return <Observable<RequestFileDtoIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestFileDtoIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRequestDetails(response: HttpResponseBase): Observable<RequestFileDtoIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestFileDtoIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestFileDtoIListApiResult>(<any>null);
    }
}

@Injectable()
export class RequestTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @return Success
     */
    requestTypes(): Observable<RequestTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/RewardDisciplinary/RequestTypes/RequestTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestTypes(<any>response_);
                } catch (e) {
                    return <Observable<RequestTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRequestTypes(response: HttpResponseBase): Observable<RequestTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting all Roles for creating/updating Admin User as a Tenant Admin
     * @return Success
     */
    getRoles(): Observable<ApplicationRoleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchRoles/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ApplicationRoleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllRolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting all Roles for CRUD operation as a Super Admin that possesses
    'Role Management' Privilege
     * @return Success
     */
    getAllRoles(): Observable<ApplicationRoleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchAllRoles/GetAllRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<ApplicationRoleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for getting single Role for CRUD operation as a Super Admin that possesses
    'Role Management' Privilege
     * @param id (optional) 
     * @return Success
     */
    getRole(id: number | undefined): Observable<ApplicationRoleDTOApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchRole/GetRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRole(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRole(response: HttpResponseBase): Observable<ApplicationRoleDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOApiResult>(<any>null);
    }
}

@Injectable()
export class CreateRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for Adding/Updating Roles as a Super Admin that possesses
    'Role Management' Privilege
     * @param body (optional) 
     * @return Success
     */
    createRole(body: ApplicationRoleDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Role/CreateRole/CreateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolePermissionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @return Success
     */
    getRolePermissions(): Observable<RolePermissionDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/FetchRolePermissions/GetRolePermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermissions(<any>response_);
                } catch (e) {
                    return <Observable<RolePermissionDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RolePermissionDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolePermissions(response: HttpResponseBase): Observable<RolePermissionDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermissionDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RolePermissionDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolePermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param roleId (optional) 
     * @return Success
     */
    getRolePermission(roleId: number | undefined): Observable<RolePermissionDTOApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/FetchRolePermission/GetRolePermission?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermission(<any>response_);
                } catch (e) {
                    return <Observable<RolePermissionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RolePermissionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolePermission(response: HttpResponseBase): Observable<RolePermissionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermissionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RolePermissionDTOApiResult>(<any>null);
    }
}

@Injectable()
export class RolePermissionMappingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolePermissionMapping(body: RolePermissionMappingDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/RolePermissionMapping/RolePermissionMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePermissionMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePermissionMapping(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRolePermissionMapping(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class SalaryscaleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding/updating Salaryscale
     * @param body (optional) 
     * @return Success
     */
    addUpdateSalaryscale(body: ManageSalaryscaleDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Salaryscale/Add-Update-Salaryscale";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateSalaryscale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateSalaryscale(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateSalaryscale(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Salaryscale.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllSalaryscale(pageSize: number | undefined, pageNumber: number | undefined): Observable<SalaryscaleDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Salaryscale/GetAllSalaryscale?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSalaryscale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSalaryscale(<any>response_);
                } catch (e) {
                    return <Observable<SalaryscaleDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SalaryscaleDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSalaryscale(response: HttpResponseBase): Observable<SalaryscaleDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryscaleDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryscaleDTOListApiResult>(<any>null);
    }

    /**
     * API to get Salaryscale by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getSalarybyId(id: number | undefined): Observable<SalaryscaleDTOApiResult> {
        let url_ = this.baseUrl + "/api/Salaryscale/GetSalarybyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalarybyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalarybyId(<any>response_);
                } catch (e) {
                    return <Observable<SalaryscaleDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SalaryscaleDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalarybyId(response: HttpResponseBase): Observable<SalaryscaleDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryscaleDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryscaleDTOApiResult>(<any>null);
    }

    /**
     * this method is used to delete Salaryscale
     * @param id (optional) 
     * @return Success
     */
    deleteSalaryscale(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Salaryscale/DeleteSalaryscale?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSalaryscale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSalaryscale(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSalaryscale(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddSkillsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for adding Skill
     * @param body (optional) 
     * @return Success
     */
    addSkills(body: ManageSkillDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Skill/AddSkills/AddSkills";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSkills(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSkills(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddSkills(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllSkillsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to Fetch Skills.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param categoryId (optional) 
     * @return Success
     */
    getAllSkills(pageSize: number | undefined, pageNumber: number | undefined, categoryId: number | undefined): Observable<SkillListApiResult> {
        let url_ = this.baseUrl + "/api/Skill/GetAllSkills/GetAllSkills?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSkills(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSkills(<any>response_);
                } catch (e) {
                    return <Observable<SkillListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSkills(response: HttpResponseBase): Observable<SkillListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkillListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillListApiResult>(<any>null);
    }
}

@Injectable()
export class GetSkillByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to get Skill by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getSkill(id: number | undefined): Observable<SkillApiResult> {
        let url_ = this.baseUrl + "/api/Skill/GetSkillById/GetSkill?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkill(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkill(<any>response_);
                } catch (e) {
                    return <Observable<SkillApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkill(response: HttpResponseBase): Observable<SkillApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkillApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillApiResult>(<any>null);
    }
}

@Injectable()
export class CreateSubscriptionPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSubscriptionPlan(body: SubscriptionPlan | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/CreateSubscriptionPlan/CreateSubscriptionPlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubscriptionPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubscriptionPlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubscriptionPlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchSubscriptionPlansServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @return Success
     */
    getSubscriptionPlans(): Observable<SubscriptionPlanIListApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/FetchSubscriptionPlans/GetSubscriptionPlans";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionPlans(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionPlans(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPlanIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPlanIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionPlans(response: HttpResponseBase): Observable<SubscriptionPlanIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPlanIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchSubscriptionPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param planId (optional) 
     * @return Success
     */
    getSubscriptionPlan(planId: number | undefined): Observable<SubscriptionPlanApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/FetchSubscriptionPlan/GetSubscriptionPlan?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionPlan(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPlanApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPlanApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionPlan(response: HttpResponseBase): Observable<SubscriptionPlanApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPlanApiResult>(<any>null);
    }
}

@Injectable()
export class FetchSubscriptionPlanModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param planId (optional) 
     * @return Success
     */
    getSubscriptionPlanModules(planId: number | undefined): Observable<SubscriptionPlanModuleIListApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/FetchSubscriptionPlanModules/GetSubscriptionPlanModules?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionPlanModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionPlanModules(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPlanModuleIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPlanModuleIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionPlanModules(response: HttpResponseBase): Observable<SubscriptionPlanModuleIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanModuleIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPlanModuleIListApiResult>(<any>null);
    }
}

@Injectable()
export class TalentManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for Creating  Talent Management Pool
     * @param body (optional) 
     * @return Success
     */
    createTalentManagementPool(body: AddTalentMangementDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/TalentManagement/CreateTalentManagementPool";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTalentManagementPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTalentManagementPool(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTalentManagementPool(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API for Remove Requirment from TalentManagementPool
     * @param requirementId (optional) 
     * @return Success
     */
    removeRequirementFromTalentManagementPool(requirementId: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/TalentManagement/RemoveRequirementFromTalentManagementPool?";
        if (requirementId === null)
            throw new Error("The parameter 'requirementId' cannot be null.");
        else if (requirementId !== undefined)
            url_ += "RequirementId=" + encodeURIComponent("" + requirementId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRequirementFromTalentManagementPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRequirementFromTalentManagementPool(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRequirementFromTalentManagementPool(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API for adding/updating Employee  to Talent Management Pool
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmployeetoTalentManagementPool(body: AddEmployyeetoPoolDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/TalentManagement/Add-Update-EmployeetoTalentManagementPool";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmployeetoTalentManagementPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmployeetoTalentManagementPool(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmployeetoTalentManagementPool(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API for  Delete  Employee from Talent Management Pool
     * @param talentPoolId (optional) 
     * @return Success
     */
    deleteEmployeeFromTalentManagmentPool(talentPoolId: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/TalentManagement/DeleteEmployeeFromTalentManagmentPool?";
        if (talentPoolId === null)
            throw new Error("The parameter 'talentPoolId' cannot be null.");
        else if (talentPoolId !== undefined)
            url_ += "TalentPoolId=" + encodeURIComponent("" + talentPoolId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEmployeeFromTalentManagmentPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEmployeeFromTalentManagmentPool(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEmployeeFromTalentManagmentPool(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API to Fetch Talent ManagementsPools.
    Note: all filter are optional
     * @return Success
     */
    fetchTalentManagementPool(): Observable<AddTalentMangementDTOListApiResult> {
        let url_ = this.baseUrl + "/api/TalentManagement/FetchTalentManagementPool";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchTalentManagementPool(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchTalentManagementPool(<any>response_);
                } catch (e) {
                    return <Observable<AddTalentMangementDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddTalentMangementDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchTalentManagementPool(response: HttpResponseBase): Observable<AddTalentMangementDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddTalentMangementDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddTalentMangementDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class VerifySubscriptionPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for verifying and updating Tenant's Subscription Payment
    with payment reference and userid
     * @param reference (optional) 
     * @param userId (optional) 
     * @return Success
     */
    verifySubscriptionPayment(reference: string | null | undefined, userId: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/VerifySubscriptionPayment/VerifySubscriptionPayment?";
        if (reference !== undefined && reference !== null)
            url_ += "reference=" + encodeURIComponent("" + reference) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySubscriptionPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySubscriptionPayment(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySubscriptionPayment(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class TenantSignUpServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for signing up Tenant's account on the system
     * @param body (optional) 
     * @return Success
     */
    tenantSignUp(body: CompanySignUpDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/TenantSignUp/TenantSignUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSignUp(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processTenantSignUp(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ConfirmTenantEmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for confirming Tenant's email account by providing the two querystring inside
    the Confirmation link ('userid' and 'token')
     * @param userId (optional) 
     * @param token (optional) 
     * @return Success
     */
    confirmTenantEmail(userId: string | null | undefined, token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/ConfirmTenantEmail/ConfirmTenantEmail?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmTenantEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmTenantEmail(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmTenantEmail(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class RegisterCompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerCompany(body: CompanyDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/RegisterCompany/RegisterCompany";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterCompany(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterCompany(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllTenantsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving All Tenant on the system with filtering parameters
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchText (optional) 
     * @param status (optional) 
     * @return Success
     */
    getAllTenants(startDate: Date | undefined, endDate: Date | undefined, searchText: string | null | undefined, status: number | undefined): Observable<CompanyIListApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/FetchAllTenants/GetAllTenants?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTenants(<any>response_);
                } catch (e) {
                    return <Observable<CompanyIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTenants(response: HttpResponseBase): Observable<CompanyIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchTenantModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for retrieving Tenant's registered modules based on their subscription plan
     * @return Success
     */
    getTenantModules(): Observable<CompanyModuleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/FetchTenantModules/GetTenantModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantModules(<any>response_);
                } catch (e) {
                    return <Observable<CompanyModuleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyModuleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantModules(response: HttpResponseBase): Observable<CompanyModuleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyModuleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyModuleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateTenantModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for updating Tenant's Modules
     * @param payload (optional) 
     * @return Success
     */
    updateTenantModules(payload: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/UpdateTenantModules/UpdateTenantModules?";
        if (payload !== undefined && payload !== null)
            url_ += "payload=" + encodeURIComponent("" + payload) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantModules(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantModules(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddTenantModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API for creating Tenant's Modules
     * @param payload (optional) 
     * @return Success
     */
    createTenantModules(payload: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/AddTenantModules/CreateTenantModules?";
        if (payload !== undefined && payload !== null)
            url_ += "payload=" + encodeURIComponent("" + payload) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenantModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenantModules(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenantModules(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class TrainingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * this method is used to create  or update  training vendor.  if it is update, training vendor Id is required
     * @param body (optional) 
     * @return Success
     */
    createvendor(body: TrainingVendorPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/createvendor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatevendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatevendor(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreatevendor(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training vendor. all filter are optional
     * @param name (optional) 
     * @param trainingSpecializationId (optional) 
     * @param trainingTag (optional) 
     * @return Success
     */
    vendors(name: string | null | undefined, trainingSpecializationId: number | null | undefined, trainingTag: string | null | undefined): Observable<TrainingVendorResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/vendors?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (trainingSpecializationId !== undefined && trainingSpecializationId !== null)
            url_ += "TrainingSpecializationId=" + encodeURIComponent("" + trainingSpecializationId) + "&";
        if (trainingTag !== undefined && trainingTag !== null)
            url_ += "TrainingTag=" + encodeURIComponent("" + trainingTag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVendors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVendors(<any>response_);
                } catch (e) {
                    return <Observable<TrainingVendorResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingVendorResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processVendors(response: HttpResponseBase): Observable<TrainingVendorResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingVendorResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingVendorResourceListApiResult>(<any>null);
    }

    /**
     * this method is used get training vendor by Id.
     * @param id (optional) 
     * @return Success
     */
    getVendor(id: number | undefined): Observable<TrainingVendorResourceApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetVendor?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendor(<any>response_);
                } catch (e) {
                    return <Observable<TrainingVendorResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingVendorResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendor(response: HttpResponseBase): Observable<TrainingVendorResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingVendorResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingVendorResourceApiResult>(<any>null);
    }

    /**
     * this method is used to delete training vendor
     * @param id (optional) 
     * @return Success
     */
    deleteVendor(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteVendor?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVendor(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteVendor(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to upload excel file of vendors. accepted file format ".xlsx", ".xls"
     * @param file (optional) 
     * @return Success
     */
    uploadVendor(file: FileParameter | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/UploadVendor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadVendor(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUploadVendor(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create  or update  training type.  if it is update, training vendour Id is required
     * @param costPer_Head (optional) 
     * @param no_Of_Trainees (optional) 
     * @param overAll_Budget (optional) 
     * @param trainingTypeId (optional) 
     * @param employeeId (optional) 
     * @param trainingVendorId (optional) 
     * @param trainingSpecializationId (optional) 
     * @param name (optional) 
     * @param tempRef (optional) 
     * @param trainingCategoryId (optional) 
     * @return Success
     */
    createtype(costPer_Head: number | undefined, no_Of_Trainees: number | undefined, overAll_Budget: number | undefined, trainingTypeId: number | undefined, employeeId: number | undefined, trainingVendorId: number | undefined, trainingSpecializationId: number | undefined, name: string | null | undefined, tempRef: string | null | undefined, trainingCategoryId: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/createtype";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (costPer_Head === null || costPer_Head === undefined)
            throw new Error("The parameter 'costPer_Head' cannot be null.");
        else
            content_.append("CostPer_Head", costPer_Head.toString());
        if (no_Of_Trainees === null || no_Of_Trainees === undefined)
            throw new Error("The parameter 'no_Of_Trainees' cannot be null.");
        else
            content_.append("No_Of_Trainees", no_Of_Trainees.toString());
        if (overAll_Budget === null || overAll_Budget === undefined)
            throw new Error("The parameter 'overAll_Budget' cannot be null.");
        else
            content_.append("OverAll_Budget", overAll_Budget.toString());
        if (trainingTypeId === null || trainingTypeId === undefined)
            throw new Error("The parameter 'trainingTypeId' cannot be null.");
        else
            content_.append("TrainingTypeId", trainingTypeId.toString());
        if (employeeId === null || employeeId === undefined)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else
            content_.append("EmployeeId", employeeId.toString());
        if (trainingVendorId === null || trainingVendorId === undefined)
            throw new Error("The parameter 'trainingVendorId' cannot be null.");
        else
            content_.append("TrainingVendorId", trainingVendorId.toString());
        if (trainingSpecializationId === null || trainingSpecializationId === undefined)
            throw new Error("The parameter 'trainingSpecializationId' cannot be null.");
        else
            content_.append("TrainingSpecializationId", trainingSpecializationId.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (tempRef !== null && tempRef !== undefined)
            content_.append("TempRef", tempRef.toString());
        if (trainingCategoryId === null || trainingCategoryId === undefined)
            throw new Error("The parameter 'trainingCategoryId' cannot be null.");
        else
            content_.append("TrainingCategoryId", trainingCategoryId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatetype(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatetype(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreatetype(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training types. all filter are optional
     * @param name (optional) 
     * @param trainingVendorId (optional) 
     * @param trainingSpecializationId (optional) 
     * @param trainingCategoryId (optional) 
     * @return Success
     */
    types(name: string | null | undefined, trainingVendorId: number | null | undefined, trainingSpecializationId: number | null | undefined, trainingCategoryId: number | null | undefined): Observable<TrainingTypeResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/types?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (trainingVendorId !== undefined && trainingVendorId !== null)
            url_ += "TrainingVendorId=" + encodeURIComponent("" + trainingVendorId) + "&";
        if (trainingSpecializationId !== undefined && trainingSpecializationId !== null)
            url_ += "TrainingSpecializationId=" + encodeURIComponent("" + trainingSpecializationId) + "&";
        if (trainingCategoryId !== undefined && trainingCategoryId !== null)
            url_ += "TrainingCategoryId=" + encodeURIComponent("" + trainingCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTypes(<any>response_);
                } catch (e) {
                    return <Observable<TrainingTypeResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingTypeResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processTypes(response: HttpResponseBase): Observable<TrainingTypeResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingTypeResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingTypeResourceListApiResult>(<any>null);
    }

    /**
     * this method is used get training type by Id.
     * @param id (optional) 
     * @return Success
     */
    getTrainingType(id: number | undefined): Observable<TrainingTypeResourceApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetTrainingType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingType(<any>response_);
                } catch (e) {
                    return <Observable<TrainingTypeResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingTypeResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingType(response: HttpResponseBase): Observable<TrainingTypeResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingTypeResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingTypeResourceApiResult>(<any>null);
    }

    /**
     * this method is use to change training type status. Note:  if status false, it means inactive while true means active
     * @param body (optional) 
     * @return Success
     */
    changetypestatus(body: ToggleTrainingType | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/changetypestatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangetypestatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangetypestatus(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processChangetypestatus(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete training type
     * @param id (optional) 
     * @return Success
     */
    deleteTrainingType(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteTrainingType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTrainingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTrainingType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTrainingType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create  or update  training Category.  if it is update, training Category Id is required
     * @param body (optional) 
     * @return Success
     */
    createorupdatecategory(body: TrainingCategoryPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/createorupdatecategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdatecategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdatecategory(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateorupdatecategory(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training categories.
     * @return Success
     */
    categories(): Observable<TrainingCategoryResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategories(<any>response_);
                } catch (e) {
                    return <Observable<TrainingCategoryResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingCategoryResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCategories(response: HttpResponseBase): Observable<TrainingCategoryResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingCategoryResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingCategoryResourceListApiResult>(<any>null);
    }

    /**
     * this method is used get training Category by Id.
     * @param id (optional) 
     * @return Success
     */
    getCategory(id: number | undefined): Observable<TrainingCategoryResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategory(<any>response_);
                } catch (e) {
                    return <Observable<TrainingCategoryResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingCategoryResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategory(response: HttpResponseBase): Observable<TrainingCategoryResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingCategoryResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingCategoryResourceListApiResult>(<any>null);
    }

    /**
     * this method is used to delete training category
     * @param id (optional) 
     * @return Success
     */
    deleteCategory(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create  or update  training Specialization/Expertise.  if it is update, training specialization Id is required
     * @param body (optional) 
     * @return Success
     */
    addUpdateSpecialization(body: TrainingSpecializationPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/AddUpdateSpecialization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateSpecialization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateSpecialization(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateSpecialization(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training Specialization/Expertise.
     * @return Success
     */
    getTrainingSpecializations(): Observable<TrainingSpecializationDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetTrainingSpecializations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainingSpecializations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingSpecializations(<any>response_);
                } catch (e) {
                    return <Observable<TrainingSpecializationDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingSpecializationDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingSpecializations(response: HttpResponseBase): Observable<TrainingSpecializationDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSpecializationDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingSpecializationDTOListApiResult>(<any>null);
    }

    /**
     * this method is used get training Specialization by Id.
     * @param id (optional) 
     * @return Success
     */
    getSpecializationById(id: number | undefined): Observable<TrainingSpecializationDTOApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetSpecializationById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpecializationById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpecializationById(<any>response_);
                } catch (e) {
                    return <Observable<TrainingSpecializationDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingSpecializationDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSpecializationById(response: HttpResponseBase): Observable<TrainingSpecializationDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSpecializationDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingSpecializationDTOApiResult>(<any>null);
    }

    /**
     * this method is used to delete training Specialization
     * @param id (optional) 
     * @return Success
     */
    deleteSpecialization(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteSpecialization?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSpecialization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSpecialization(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSpecialization(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * API for adding/updating Training Plan.
     * @param id (optional) 
     * @param name (optional) 
     * @param description (optional) 
     * @param status (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param trainingTypeId (optional) 
     * @param specializationId (optional) 
     * @param vendorId (optional) 
     * @param totalCost (optional) 
     * @param costPerEmployee (optional) 
     * @param selectedEmployees (optional) 
     * @param tempRef (optional) 
     * @return Success
     */
    addUpdateTrainingPlan(id: number | undefined, name: string | undefined, description: string | undefined, status: boolean | undefined, startDate: Date | undefined, endDate: Date | undefined, trainingTypeId: number | undefined, specializationId: number | undefined, vendorId: number | undefined, totalCost: number | null | undefined, costPerEmployee: number | null | undefined, selectedEmployees: string | null | undefined, tempRef: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/Add-Update-TrainingPlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (status === null || status === undefined)
            throw new Error("The parameter 'status' cannot be null.");
        else
            content_.append("Status", status.toString());
        if (startDate === null || startDate === undefined)
            throw new Error("The parameter 'startDate' cannot be null.");
        else
            content_.append("StartDate", startDate.toJSON());
        if (endDate === null || endDate === undefined)
            throw new Error("The parameter 'endDate' cannot be null.");
        else
            content_.append("EndDate", endDate.toJSON());
        if (trainingTypeId === null || trainingTypeId === undefined)
            throw new Error("The parameter 'trainingTypeId' cannot be null.");
        else
            content_.append("TrainingTypeId", trainingTypeId.toString());
        if (specializationId === null || specializationId === undefined)
            throw new Error("The parameter 'specializationId' cannot be null.");
        else
            content_.append("SpecializationId", specializationId.toString());
        if (vendorId === null || vendorId === undefined)
            throw new Error("The parameter 'vendorId' cannot be null.");
        else
            content_.append("VendorId", vendorId.toString());
        if (totalCost !== null && totalCost !== undefined)
            content_.append("TotalCost", totalCost.toString());
        if (costPerEmployee !== null && costPerEmployee !== undefined)
            content_.append("CostPerEmployee", costPerEmployee.toString());
        if (selectedEmployees !== null && selectedEmployees !== undefined)
            content_.append("SelectedEmployees", selectedEmployees.toString());
        if (tempRef !== null && tempRef !== undefined)
            content_.append("TempRef", tempRef.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateTrainingPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateTrainingPlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateTrainingPlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training plan. Note filters are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param trainingTypeId (optional) 
     * @param specializationId (optional) 
     * @param vendorId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param totalCost (optional) 
     * @param costPerEmployee (optional) 
     * @return Success
     */
    getAllTrainingPlans(pageSize: number | undefined, pageNumber: number | undefined, trainingTypeId: number | undefined, specializationId: number | undefined, vendorId: number | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, totalCost: number | undefined, costPerEmployee: number | undefined): Observable<TrainingDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetAllTrainingPlans?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (trainingTypeId === null)
            throw new Error("The parameter 'trainingTypeId' cannot be null.");
        else if (trainingTypeId !== undefined)
            url_ += "TrainingTypeId=" + encodeURIComponent("" + trainingTypeId) + "&";
        if (specializationId === null)
            throw new Error("The parameter 'specializationId' cannot be null.");
        else if (specializationId !== undefined)
            url_ += "SpecializationId=" + encodeURIComponent("" + specializationId) + "&";
        if (vendorId === null)
            throw new Error("The parameter 'vendorId' cannot be null.");
        else if (vendorId !== undefined)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (totalCost === null)
            throw new Error("The parameter 'totalCost' cannot be null.");
        else if (totalCost !== undefined)
            url_ += "TotalCost=" + encodeURIComponent("" + totalCost) + "&";
        if (costPerEmployee === null)
            throw new Error("The parameter 'costPerEmployee' cannot be null.");
        else if (costPerEmployee !== undefined)
            url_ += "CostPerEmployee=" + encodeURIComponent("" + costPerEmployee) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTrainingPlans(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTrainingPlans(<any>response_);
                } catch (e) {
                    return <Observable<TrainingDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTrainingPlans(response: HttpResponseBase): Observable<TrainingDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingDTOListApiResult>(<any>null);
    }

    /**
     * API to get Training Plan by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getTrainingPlan(id: number | undefined): Observable<TrainingDTOApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetTrainingPlan?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainingPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingPlan(<any>response_);
                } catch (e) {
                    return <Observable<TrainingDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingPlan(response: HttpResponseBase): Observable<TrainingDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingDTOApiResult>(<any>null);
    }

    /**
     * this method is used to change Training Plan status. if training status: false = inactive, true = active
     * @param id (optional) 
     * @return Success
     */
    toggleTrainingPlan(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/ToggleTrainingPlan?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleTrainingPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleTrainingPlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleTrainingPlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete Training Plan
     * @param id (optional) 
     * @return Success
     */
    deleteTrainingPlan(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteTrainingPlan?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTrainingPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTrainingPlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTrainingPlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create or update  training Criteria. if it is update, training specialization Id is required
     * @param body (optional) 
     * @return Success
     */
    createUpdateCriteria(body: TrainingCriteriaPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/Create-Update-Criteria";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUpdateCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUpdateCriteria(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUpdateCriteria(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training criteria.
     * @param name (optional) 
     * @param min_Age (optional) 
     * @param min_LengthOfService (optional) 
     * @return Success
     */
    getCriterias(trainingTypeId: number, name: string | null | undefined, min_Age: number | undefined, min_LengthOfService: number | undefined): Observable<TrainingCriteriaResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetCriterias?";
        if (trainingTypeId === undefined || trainingTypeId === null)
            throw new Error("The parameter 'trainingTypeId' must be defined and cannot be null.");
        else
            url_ += "TrainingTypeId=" + encodeURIComponent("" + trainingTypeId) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (min_Age === null)
            throw new Error("The parameter 'min_Age' cannot be null.");
        else if (min_Age !== undefined)
            url_ += "Min_Age=" + encodeURIComponent("" + min_Age) + "&";
        if (min_LengthOfService === null)
            throw new Error("The parameter 'min_LengthOfService' cannot be null.");
        else if (min_LengthOfService !== undefined)
            url_ += "Min_LengthOfService=" + encodeURIComponent("" + min_LengthOfService) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCriterias(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCriterias(<any>response_);
                } catch (e) {
                    return <Observable<TrainingCriteriaResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingCriteriaResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCriterias(response: HttpResponseBase): Observable<TrainingCriteriaResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingCriteriaResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingCriteriaResourceListApiResult>(<any>null);
    }

    /**
     * this method is used get training criteria by Id.
     * @param id (optional) 
     * @return Success
     */
    getCriteria(id: number | undefined): Observable<TrainingCriteriaResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetCriteria?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCriteria(<any>response_);
                } catch (e) {
                    return <Observable<TrainingCriteriaResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingCriteriaResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCriteria(response: HttpResponseBase): Observable<TrainingCriteriaResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingCriteriaResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingCriteriaResourceListApiResult>(<any>null);
    }

    /**
     * this method is used to delete training Criteria
     * @param id (optional) 
     * @return Success
     */
    deleteCriteria(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteCriteria?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCriteria(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCriteria(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to asign training to employees.  Note: file is not required
     * @param body (optional) 
     * @return Success
     */
    addEmployeeToTraining(body: AssignTrainingToEmpPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/AddEmployeeToTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEmployeeToTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEmployeeToTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddEmployeeToTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training assigned to employee. all filter are optional
     * @param specializationName (optional) 
     * @param trainingTypeName (optional) 
     * @param name (optional) 
     * @param trainingVendorName (optional) 
     * @return Success
     */
    getEmployeeTrainings(specializationName: string | null | undefined, trainingTypeName: string | null | undefined, name: string | null | undefined, trainingVendorName: string | null | undefined): Observable<EmpTrainingResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetEmployeeTrainings?";
        if (specializationName !== undefined && specializationName !== null)
            url_ += "SpecializationName=" + encodeURIComponent("" + specializationName) + "&";
        if (trainingTypeName !== undefined && trainingTypeName !== null)
            url_ += "TrainingTypeName=" + encodeURIComponent("" + trainingTypeName) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (trainingVendorName !== undefined && trainingVendorName !== null)
            url_ += "TrainingVendorName=" + encodeURIComponent("" + trainingVendorName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeTrainings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeTrainings(<any>response_);
                } catch (e) {
                    return <Observable<EmpTrainingResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmpTrainingResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeTrainings(response: HttpResponseBase): Observable<EmpTrainingResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpTrainingResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmpTrainingResourceListApiResult>(<any>null);
    }

    /**
     * this method is used send training for approval.
     * @param id (optional) 
     * @return Success
     */
    sendTrainingForApproval(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/SendTrainingForApproval?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTrainingForApproval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTrainingForApproval(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSendTrainingForApproval(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to notify employee for assigned training.
     * @param id (optional) 
     * @return Success
     */
    notifyEmployee(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/NotifyEmployee?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotifyEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotifyEmployee(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processNotifyEmployee(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to remove employees from training.
     * @param body (optional) 
     * @return Success
     */
    removeBulkEmployeeFromTraining(body: AssignTrainingToEmpPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/RemoveBulkEmployeeFromTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBulkEmployeeFromTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBulkEmployeeFromTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBulkEmployeeFromTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to remove employee from training
     * @param body (optional) 
     * @return Success
     */
    removeEmployeeFromTraining(body: AssignTrainingToOneEmpPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/RemoveEmployeeFromTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveEmployeeFromTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveEmployeeFromTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveEmployeeFromTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete employee added to training
     * @param id (optional) 
     * @return Success
     */
    deleteEmployeeTraining(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteEmployeeTraining?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEmployeeTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEmployeeTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEmployeeTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used get emp training by Id.
     * @param id (optional) 
     * @return Success
     */
    getEmpTraining(id: number | undefined): Observable<EmpTrainingResourceApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetEmpTraining?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmpTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmpTraining(<any>response_);
                } catch (e) {
                    return <Observable<EmpTrainingResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmpTrainingResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmpTraining(response: HttpResponseBase): Observable<EmpTrainingResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpTrainingResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmpTrainingResourceApiResult>(<any>null);
    }

    /**
     * this method is used to  save employee feedback after training.
     * @param body (optional) 
     * @return Success
     */
    employeeTrainingFeedback(body: EmpFeedBack | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/EmployeeTrainingFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeTrainingFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeTrainingFeedback(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeTrainingFeedback(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to upload excel file of vendors. accepted file format ".xlsx", ".xls"
     * @param body (optional) 
     * @return Success
     */
    postEmployeeTraining(body: EmployeeTrainingDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/PostEmployeeTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostEmployeeTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostEmployeeTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostEmployeeTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to update emp training
     * @param body (optional) 
     * @return Success
     */
    updateEmployeeTraining(body: EmployeeTrainingDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/UpdateEmployeeTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmployeeTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmployeeTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEmployeeTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class UploadDocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * API to upload document(s) in all any part of the system.
     * @param userId (optional) 
     * @param title (optional) 
     * @param itemId (optional) 
     * @param entityId (optional) 
     * @param isReadOnly (optional) 
     * @param tempRef (optional) 
     * @param files (optional) 
     * @return Success
     */
    uploadDocs(userId: number | undefined, title: string | null | undefined, itemId: number | undefined, entityId: number | undefined, isReadOnly: boolean | undefined, tempRef: string | undefined, files: FileParameter[] | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/UploadDocument/UploadDocs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (userId === null || userId === undefined)
            throw new Error("The parameter 'userId' cannot be null.");
        else
            content_.append("UserId", userId.toString());
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (itemId === null || itemId === undefined)
            throw new Error("The parameter 'itemId' cannot be null.");
        else
            content_.append("ItemId", itemId.toString());
        if (entityId === null || entityId === undefined)
            throw new Error("The parameter 'entityId' cannot be null.");
        else
            content_.append("EntityId", entityId.toString());
        if (isReadOnly === null || isReadOnly === undefined)
            throw new Error("The parameter 'isReadOnly' cannot be null.");
        else
            content_.append("IsReadOnly", isReadOnly.toString());
        if (tempRef === null || tempRef === undefined)
            throw new Error("The parameter 'tempRef' cannot be null.");
        else
            content_.append("TempRef", tempRef.toString());
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("Files", item_.data, item_.fileName ? item_.fileName : "Files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadDocs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadDocs(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUploadDocs(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * Fetch Document's File List for a specific type of Document or all.
    By supplying EntityId which represent the Document entity container
    (e.g. TRAINING, CONFIRMATION, OTHERS, etc Documents)
    or ItemId which can represent EmployeeId, Other record Id that was added along with docs.
    ItemId is optional but EntityId is required.
    All Doc. EntityType list will be available on Data controller endpoints
     * @param itemId (optional) 
     * @return Success
     */
    loadDocumentFiles(entityId: number, itemId: number | undefined): Observable<DocFileDTOListApiResult> {
        let url_ = this.baseUrl + "/api/UploadDocument/LoadDocumentFiles?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined and cannot be null.");
        else
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "ItemId=" + encodeURIComponent("" + itemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadDocumentFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadDocumentFiles(<any>response_);
                } catch (e) {
                    return <Observable<DocFileDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocFileDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processLoadDocumentFiles(response: HttpResponseBase): Observable<DocFileDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocFileDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocFileDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class RegisterUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerUser(body: RegisterUserDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/RegisterUser/RegisterUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body: RegisterUserDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/UpdateUser/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllUsersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param email (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllUsers(firstName: string | null | undefined, lastName: string | null | undefined, email: string | null | undefined, pageSize: number | undefined): Observable<ApplicationUserDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/FetchAllUsers/GetAllUsers?";
        if (firstName !== undefined && firstName !== null)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName !== undefined && lastName !== null)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationUserDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationUserDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<ApplicationUserDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUserDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUserDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateVisaTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateVisaType(body: VisaTypeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/VisaType/AddUpdateVisaType/Add-Update-VisaType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateVisaType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateVisaType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateVisaType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleVisaTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    toggleVisaType(body: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/VisaType/ToggleVisaType/Toggle-Visa-Type";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleVisaType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleVisaType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleVisaType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetVisaTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://hrv2-api.azurewebsites.net";
    }

    /**
     * @param iD (optional) 
     * @param companyId (optional) 
     * @param subId (optional) 
     * @param visaName (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getVisaType(iD: number | undefined, companyId: number | undefined, subId: number | undefined, visaName: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<VisaTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/VisaType/GetVisaType/GetVisaType?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (subId === null)
            throw new Error("The parameter 'subId' cannot be null.");
        else if (subId !== undefined)
            url_ += "SubId=" + encodeURIComponent("" + subId) + "&";
        if (visaName !== undefined && visaName !== null)
            url_ += "VisaName=" + encodeURIComponent("" + visaName) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVisaType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVisaType(<any>response_);
                } catch (e) {
                    return <Observable<VisaTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VisaTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetVisaType(response: HttpResponseBase): Observable<VisaTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VisaTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VisaTypeIListApiResult>(<any>null);
    }
}

export class UserLoginDTO implements IUserLoginDTO {
    email!: string | undefined;
    password!: string | undefined;

    constructor(data?: IUserLoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UserLoginDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }

    clone(): UserLoginDTO {
        const json = this.toJSON();
        let result = new UserLoginDTO();
        result.init(json);
        return result;
    }
}

export interface IUserLoginDTO {
    email: string | undefined;
    password: string | undefined;
}

export class CompanyDTO implements ICompanyDTO {
    id!: number;
    userId!: number;
    name!: string;
    rcNo!: string | undefined;
    logoName!: string | undefined;
    shortText!: string | undefined;
    email!: string;
    phoneNumber!: string;
    firstName!: string | undefined;
    lastName!: string | undefined;
    address!: string | undefined;
    administratorEmail!: string;
    domainName!: string | undefined;
    auditorEmail!: string | undefined;
    maxEmployeeCount!: number;
    subscriptionPlanId!: number;
    subscriptionPlanName!: string | undefined;
    lastBillingDate!: Date | undefined;
    lastPaymentDate!: Date | undefined;
    licenseUsage!: number;
    isActiveByAdmin!: boolean;
    isTrial!: boolean;
    password!: string;
    frequencyId!: number;
    tempRef!: string | undefined;
    referenceNumber!: string | undefined;

    constructor(data?: ICompanyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.rcNo = _data["rcNo"];
            this.logoName = _data["logoName"];
            this.shortText = _data["shortText"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.address = _data["address"];
            this.administratorEmail = _data["administratorEmail"];
            this.domainName = _data["domainName"];
            this.auditorEmail = _data["auditorEmail"];
            this.maxEmployeeCount = _data["maxEmployeeCount"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.subscriptionPlanName = _data["subscriptionPlanName"];
            this.lastBillingDate = _data["lastBillingDate"] ? new Date(_data["lastBillingDate"].toString()) : <any>undefined;
            this.lastPaymentDate = _data["lastPaymentDate"] ? new Date(_data["lastPaymentDate"].toString()) : <any>undefined;
            this.licenseUsage = _data["licenseUsage"];
            this.isActiveByAdmin = _data["isActiveByAdmin"];
            this.isTrial = _data["isTrial"];
            this.password = _data["password"];
            this.frequencyId = _data["frequencyId"];
            this.tempRef = _data["tempRef"];
            this.referenceNumber = _data["referenceNumber"];
        }
    }

    static fromJS(data: any): CompanyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["rcNo"] = this.rcNo;
        data["logoName"] = this.logoName;
        data["shortText"] = this.shortText;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["address"] = this.address;
        data["administratorEmail"] = this.administratorEmail;
        data["domainName"] = this.domainName;
        data["auditorEmail"] = this.auditorEmail;
        data["maxEmployeeCount"] = this.maxEmployeeCount;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["subscriptionPlanName"] = this.subscriptionPlanName;
        data["lastBillingDate"] = this.lastBillingDate ? this.lastBillingDate.toISOString() : <any>undefined;
        data["lastPaymentDate"] = this.lastPaymentDate ? this.lastPaymentDate.toISOString() : <any>undefined;
        data["licenseUsage"] = this.licenseUsage;
        data["isActiveByAdmin"] = this.isActiveByAdmin;
        data["isTrial"] = this.isTrial;
        data["password"] = this.password;
        data["frequencyId"] = this.frequencyId;
        data["tempRef"] = this.tempRef;
        data["referenceNumber"] = this.referenceNumber;
        return data; 
    }

    clone(): CompanyDTO {
        const json = this.toJSON();
        let result = new CompanyDTO();
        result.init(json);
        return result;
    }
}

export interface ICompanyDTO {
    id: number;
    userId: number;
    name: string;
    rcNo: string | undefined;
    logoName: string | undefined;
    shortText: string | undefined;
    email: string;
    phoneNumber: string;
    firstName: string | undefined;
    lastName: string | undefined;
    address: string | undefined;
    administratorEmail: string;
    domainName: string | undefined;
    auditorEmail: string | undefined;
    maxEmployeeCount: number;
    subscriptionPlanId: number;
    subscriptionPlanName: string | undefined;
    lastBillingDate: Date | undefined;
    lastPaymentDate: Date | undefined;
    licenseUsage: number;
    isActiveByAdmin: boolean;
    isTrial: boolean;
    password: string;
    frequencyId: number;
    tempRef: string | undefined;
    referenceNumber: string | undefined;
}

export class VwUserObj implements IVwUserObj {
    user_id!: number;
    employee_id!: number;
    employee_number!: string | undefined;
    employee_contract_id!: number;
    companyProfile!: CompanyDTO;
    grade_id!: number | undefined;
    confirmation_date!: Date | undefined;
    serial_no!: string | undefined;
    first_name!: string | undefined;
    last_name!: string | undefined;
    readonly full_name!: string | undefined;
    other_name!: string | undefined;
    department!: string | undefined;
    department_id!: number;
    email!: string | undefined;
    phone_number!: string | undefined;
    email_confirmed!: boolean;
    session_token!: string | undefined;
    jwt_token!: string | undefined;
    user_token!: string | undefined;
    company_id!: number;
    licenseUsuage!: number;
    licenseCount!: number;
    company_name!: string | undefined;
    sub_id!: number;
    isAdmin!: boolean;
    isSuperAdmin!: boolean;
    isTenantAdmin!: boolean;
    isActiveBySysOrAdmin!: boolean;
    lstPermissions!: string[] | undefined;
    message!: string | undefined;
    isSuccessful!: boolean;
    retId!: number;
    bulkUploadId!: number;
    bulkUploadHtmlData!: string | undefined;
    redirectUrl!: string | undefined;
    referenceNumber!: string | undefined;
    errors!: string[] | undefined;

    constructor(data?: IVwUserObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user_id = _data["user_id"];
            this.employee_id = _data["employee_id"];
            this.employee_number = _data["employee_number"];
            this.employee_contract_id = _data["employee_contract_id"];
            this.companyProfile = _data["companyProfile"] ? CompanyDTO.fromJS(_data["companyProfile"]) : <any>undefined;
            this.grade_id = _data["grade_id"];
            this.confirmation_date = _data["confirmation_date"] ? new Date(_data["confirmation_date"].toString()) : <any>undefined;
            this.serial_no = _data["serial_no"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            (<any>this).full_name = _data["full_name"];
            this.other_name = _data["other_name"];
            this.department = _data["department"];
            this.department_id = _data["department_id"];
            this.email = _data["email"];
            this.phone_number = _data["phone_number"];
            this.email_confirmed = _data["email_confirmed"];
            this.session_token = _data["session_token"];
            this.jwt_token = _data["jwt_token"];
            this.user_token = _data["user_token"];
            this.company_id = _data["company_id"];
            this.licenseUsuage = _data["licenseUsuage"];
            this.licenseCount = _data["licenseCount"];
            this.company_name = _data["company_name"];
            this.sub_id = _data["sub_id"];
            this.isAdmin = _data["isAdmin"];
            this.isSuperAdmin = _data["isSuperAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.isActiveBySysOrAdmin = _data["isActiveBySysOrAdmin"];
            if (Array.isArray(_data["lstPermissions"])) {
                this.lstPermissions = [] as any;
                for (let item of _data["lstPermissions"])
                    this.lstPermissions!.push(item);
            }
            this.message = _data["message"];
            this.isSuccessful = _data["isSuccessful"];
            this.retId = _data["retId"];
            this.bulkUploadId = _data["bulkUploadId"];
            this.bulkUploadHtmlData = _data["bulkUploadHtmlData"];
            this.redirectUrl = _data["redirectUrl"];
            this.referenceNumber = _data["referenceNumber"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): VwUserObj {
        data = typeof data === 'object' ? data : {};
        let result = new VwUserObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_id"] = this.user_id;
        data["employee_id"] = this.employee_id;
        data["employee_number"] = this.employee_number;
        data["employee_contract_id"] = this.employee_contract_id;
        data["companyProfile"] = this.companyProfile ? this.companyProfile.toJSON() : <any>undefined;
        data["grade_id"] = this.grade_id;
        data["confirmation_date"] = this.confirmation_date ? this.confirmation_date.toISOString() : <any>undefined;
        data["serial_no"] = this.serial_no;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["full_name"] = this.full_name;
        data["other_name"] = this.other_name;
        data["department"] = this.department;
        data["department_id"] = this.department_id;
        data["email"] = this.email;
        data["phone_number"] = this.phone_number;
        data["email_confirmed"] = this.email_confirmed;
        data["session_token"] = this.session_token;
        data["jwt_token"] = this.jwt_token;
        data["user_token"] = this.user_token;
        data["company_id"] = this.company_id;
        data["licenseUsuage"] = this.licenseUsuage;
        data["licenseCount"] = this.licenseCount;
        data["company_name"] = this.company_name;
        data["sub_id"] = this.sub_id;
        data["isAdmin"] = this.isAdmin;
        data["isSuperAdmin"] = this.isSuperAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["isActiveBySysOrAdmin"] = this.isActiveBySysOrAdmin;
        if (Array.isArray(this.lstPermissions)) {
            data["lstPermissions"] = [];
            for (let item of this.lstPermissions)
                data["lstPermissions"].push(item);
        }
        data["message"] = this.message;
        data["isSuccessful"] = this.isSuccessful;
        data["retId"] = this.retId;
        data["bulkUploadId"] = this.bulkUploadId;
        data["bulkUploadHtmlData"] = this.bulkUploadHtmlData;
        data["redirectUrl"] = this.redirectUrl;
        data["referenceNumber"] = this.referenceNumber;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }

    clone(): VwUserObj {
        const json = this.toJSON();
        let result = new VwUserObj();
        result.init(json);
        return result;
    }
}

export interface IVwUserObj {
    user_id: number;
    employee_id: number;
    employee_number: string | undefined;
    employee_contract_id: number;
    companyProfile: CompanyDTO;
    grade_id: number | undefined;
    confirmation_date: Date | undefined;
    serial_no: string | undefined;
    first_name: string | undefined;
    last_name: string | undefined;
    full_name: string | undefined;
    other_name: string | undefined;
    department: string | undefined;
    department_id: number;
    email: string | undefined;
    phone_number: string | undefined;
    email_confirmed: boolean;
    session_token: string | undefined;
    jwt_token: string | undefined;
    user_token: string | undefined;
    company_id: number;
    licenseUsuage: number;
    licenseCount: number;
    company_name: string | undefined;
    sub_id: number;
    isAdmin: boolean;
    isSuperAdmin: boolean;
    isTenantAdmin: boolean;
    isActiveBySysOrAdmin: boolean;
    lstPermissions: string[] | undefined;
    message: string | undefined;
    isSuccessful: boolean;
    retId: number;
    bulkUploadId: number;
    bulkUploadHtmlData: string | undefined;
    redirectUrl: string | undefined;
    referenceNumber: string | undefined;
    errors: string[] | undefined;
}

export class VwUserObjApiResult implements IVwUserObjApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwUserObj;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IVwUserObjApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? VwUserObj.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): VwUserObjApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwUserObjApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): VwUserObjApiResult {
        const json = this.toJSON();
        let result = new VwUserObjApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwUserObjApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwUserObj;
    totalCount: number;
    totalRecord: number;
}

export class MessageOut implements IMessageOut {
    message!: string | undefined;
    isSuccessful!: boolean;
    retId!: number;
    bulkUploadId!: number;
    bulkUploadHtmlData!: string | undefined;
    redirectUrl!: string | undefined;
    referenceNumber!: string | undefined;
    errors!: string[] | undefined;

    constructor(data?: IMessageOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.isSuccessful = _data["isSuccessful"];
            this.retId = _data["retId"];
            this.bulkUploadId = _data["bulkUploadId"];
            this.bulkUploadHtmlData = _data["bulkUploadHtmlData"];
            this.redirectUrl = _data["redirectUrl"];
            this.referenceNumber = _data["referenceNumber"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MessageOut {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["isSuccessful"] = this.isSuccessful;
        data["retId"] = this.retId;
        data["bulkUploadId"] = this.bulkUploadId;
        data["bulkUploadHtmlData"] = this.bulkUploadHtmlData;
        data["redirectUrl"] = this.redirectUrl;
        data["referenceNumber"] = this.referenceNumber;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }

    clone(): MessageOut {
        const json = this.toJSON();
        let result = new MessageOut();
        result.init(json);
        return result;
    }
}

export interface IMessageOut {
    message: string | undefined;
    isSuccessful: boolean;
    retId: number;
    bulkUploadId: number;
    bulkUploadHtmlData: string | undefined;
    redirectUrl: string | undefined;
    referenceNumber: string | undefined;
    errors: string[] | undefined;
}

export class MessageOutApiResult implements IMessageOutApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MessageOut;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IMessageOutApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? MessageOut.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): MessageOutApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOutApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): MessageOutApiResult {
        const json = this.toJSON();
        let result = new MessageOutApiResult();
        result.init(json);
        return result;
    }
}

export interface IMessageOutApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MessageOut;
    totalCount: number;
    totalRecord: number;
}

export class ResestPasswordDTO implements IResestPasswordDTO {
    token!: string | undefined;
    email!: string;
    password!: string;
    confirmPassword!: string | undefined;

    constructor(data?: IResestPasswordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResestPasswordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResestPasswordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }

    clone(): ResestPasswordDTO {
        const json = this.toJSON();
        let result = new ResestPasswordDTO();
        result.init(json);
        return result;
    }
}

export interface IResestPasswordDTO {
    token: string | undefined;
    email: string;
    password: string;
    confirmPassword: string | undefined;
}

export class ActivityLog implements IActivityLog {
    userId!: number | undefined;
    moduleName!: string | undefined;
    moduleAction!: string | undefined;
    description!: string | undefined;
    record!: string | undefined;
    ipAdress!: string | undefined;
    operationType!: string | undefined;
    employeeId!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IActivityLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.moduleName = _data["moduleName"];
            this.moduleAction = _data["moduleAction"];
            this.description = _data["description"];
            this.record = _data["record"];
            this.ipAdress = _data["ipAdress"];
            this.operationType = _data["operationType"];
            this.employeeId = _data["employeeId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ActivityLog {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["moduleName"] = this.moduleName;
        data["moduleAction"] = this.moduleAction;
        data["description"] = this.description;
        data["record"] = this.record;
        data["ipAdress"] = this.ipAdress;
        data["operationType"] = this.operationType;
        data["employeeId"] = this.employeeId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ActivityLog {
        const json = this.toJSON();
        let result = new ActivityLog();
        result.init(json);
        return result;
    }
}

export interface IActivityLog {
    userId: number | undefined;
    moduleName: string | undefined;
    moduleAction: string | undefined;
    description: string | undefined;
    record: string | undefined;
    ipAdress: string | undefined;
    operationType: string | undefined;
    employeeId: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ActivityLogIListApiResult implements IActivityLogIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ActivityLog[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IActivityLogIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ActivityLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ActivityLogIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLogIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ActivityLogIListApiResult {
        const json = this.toJSON();
        let result = new ActivityLogIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IActivityLogIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ActivityLog[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AnnouncementTypeDto implements IAnnouncementTypeDto {
    id!: number;
    catalog!: string;
    companyId!: number;
    subId!: number;
    departmentId!: number;

    constructor(data?: IAnnouncementTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.catalog = _data["catalog"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.departmentId = _data["departmentId"];
        }
    }

    static fromJS(data: any): AnnouncementTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnnouncementTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["catalog"] = this.catalog;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["departmentId"] = this.departmentId;
        return data; 
    }

    clone(): AnnouncementTypeDto {
        const json = this.toJSON();
        let result = new AnnouncementTypeDto();
        result.init(json);
        return result;
    }
}

export interface IAnnouncementTypeDto {
    id: number;
    catalog: string;
    companyId: number;
    subId: number;
    departmentId: number;
}

export class AnnouncementType implements IAnnouncementType {
    catalog!: string | undefined;
    departmentId!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IAnnouncementType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalog = _data["catalog"];
            this.departmentId = _data["departmentId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): AnnouncementType {
        data = typeof data === 'object' ? data : {};
        let result = new AnnouncementType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalog"] = this.catalog;
        data["departmentId"] = this.departmentId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): AnnouncementType {
        const json = this.toJSON();
        let result = new AnnouncementType();
        result.init(json);
        return result;
    }
}

export interface IAnnouncementType {
    catalog: string | undefined;
    departmentId: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class AnnouncementTypeListApiResult implements IAnnouncementTypeListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AnnouncementType[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAnnouncementTypeListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AnnouncementType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AnnouncementTypeListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AnnouncementTypeListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AnnouncementTypeListApiResult {
        const json = this.toJSON();
        let result = new AnnouncementTypeListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAnnouncementTypeListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AnnouncementType[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AnnouncementDto implements IAnnouncementDto {
    id!: number;
    announcementTypeId!: number;
    announcementMessage!: string | undefined;
    departmentId!: number;
    externalUrl!: string | undefined;
    startDate!: Date;
    closeDate!: Date;
    companyId!: number;
    subId!: number;

    constructor(data?: IAnnouncementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.announcementTypeId = _data["announcementTypeId"];
            this.announcementMessage = _data["announcementMessage"];
            this.departmentId = _data["departmentId"];
            this.externalUrl = _data["externalUrl"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.closeDate = _data["closeDate"] ? new Date(_data["closeDate"].toString()) : <any>undefined;
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
        }
    }

    static fromJS(data: any): AnnouncementDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnnouncementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["announcementTypeId"] = this.announcementTypeId;
        data["announcementMessage"] = this.announcementMessage;
        data["departmentId"] = this.departmentId;
        data["externalUrl"] = this.externalUrl;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["closeDate"] = this.closeDate ? this.closeDate.toISOString() : <any>undefined;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        return data; 
    }

    clone(): AnnouncementDto {
        const json = this.toJSON();
        let result = new AnnouncementDto();
        result.init(json);
        return result;
    }
}

export interface IAnnouncementDto {
    id: number;
    announcementTypeId: number;
    announcementMessage: string | undefined;
    departmentId: number;
    externalUrl: string | undefined;
    startDate: Date;
    closeDate: Date;
    companyId: number;
    subId: number;
}

export class Announcement implements IAnnouncement {
    announcementTypeId!: number;
    announcementMessage!: string | undefined;
    departmentId!: number;
    externalUrl!: string | undefined;
    startDate!: Date;
    closeDate!: Date;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IAnnouncement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.announcementTypeId = _data["announcementTypeId"];
            this.announcementMessage = _data["announcementMessage"];
            this.departmentId = _data["departmentId"];
            this.externalUrl = _data["externalUrl"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.closeDate = _data["closeDate"] ? new Date(_data["closeDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Announcement {
        data = typeof data === 'object' ? data : {};
        let result = new Announcement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["announcementTypeId"] = this.announcementTypeId;
        data["announcementMessage"] = this.announcementMessage;
        data["departmentId"] = this.departmentId;
        data["externalUrl"] = this.externalUrl;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["closeDate"] = this.closeDate ? this.closeDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Announcement {
        const json = this.toJSON();
        let result = new Announcement();
        result.init(json);
        return result;
    }
}

export interface IAnnouncement {
    announcementTypeId: number;
    announcementMessage: string | undefined;
    departmentId: number;
    externalUrl: string | undefined;
    startDate: Date;
    closeDate: Date;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class AnnouncementListApiResult implements IAnnouncementListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Announcement[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAnnouncementListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Announcement.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AnnouncementListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AnnouncementListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AnnouncementListApiResult {
        const json = this.toJSON();
        let result = new AnnouncementListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAnnouncementListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Announcement[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AppraisalReviewerListDTO implements IAppraisalReviewerListDTO {
    contractId!: number;
    employeeId!: number;
    firstName!: string | undefined;
    otherNames!: string | undefined;
    lastName!: string | undefined;
    fullName!: string | undefined;
    employeeNumber!: string | undefined;
    departmentId!: number;
    department!: string | undefined;
    supervisorId!: number | undefined;
    supervisorContractId!: number;
    periodId!: number;
    period!: string | undefined;
    assignedKra!: number;
    assignedKpi!: number;
    cycleStatus!: number;
    startDate!: Date | undefined;
    isSubmitted!: boolean;
    supervisorFullName!: string | undefined;
    reviewStatus!: number;
    isApproved!: boolean;
    isReviewerSubmitted!: boolean | undefined;
    isReviewerStartedAppraisal!: boolean | undefined;
    readonly employeeStatus!: string | undefined;
    readonly reviewerStatus!: string | undefined;

    constructor(data?: IAppraisalReviewerListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.employeeId = _data["employeeId"];
            this.firstName = _data["firstName"];
            this.otherNames = _data["otherNames"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.employeeNumber = _data["employeeNumber"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"];
            this.supervisorId = _data["supervisorId"];
            this.supervisorContractId = _data["supervisorContractId"];
            this.periodId = _data["periodId"];
            this.period = _data["period"];
            this.assignedKra = _data["assignedKra"];
            this.assignedKpi = _data["assignedKpi"];
            this.cycleStatus = _data["cycleStatus"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.isSubmitted = _data["isSubmitted"];
            this.supervisorFullName = _data["supervisorFullName"];
            this.reviewStatus = _data["reviewStatus"];
            this.isApproved = _data["isApproved"];
            this.isReviewerSubmitted = _data["isReviewerSubmitted"];
            this.isReviewerStartedAppraisal = _data["isReviewerStartedAppraisal"];
            (<any>this).employeeStatus = _data["employeeStatus"];
            (<any>this).reviewerStatus = _data["reviewerStatus"];
        }
    }

    static fromJS(data: any): AppraisalReviewerListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AppraisalReviewerListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["employeeId"] = this.employeeId;
        data["firstName"] = this.firstName;
        data["otherNames"] = this.otherNames;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["employeeNumber"] = this.employeeNumber;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department;
        data["supervisorId"] = this.supervisorId;
        data["supervisorContractId"] = this.supervisorContractId;
        data["periodId"] = this.periodId;
        data["period"] = this.period;
        data["assignedKra"] = this.assignedKra;
        data["assignedKpi"] = this.assignedKpi;
        data["cycleStatus"] = this.cycleStatus;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["isSubmitted"] = this.isSubmitted;
        data["supervisorFullName"] = this.supervisorFullName;
        data["reviewStatus"] = this.reviewStatus;
        data["isApproved"] = this.isApproved;
        data["isReviewerSubmitted"] = this.isReviewerSubmitted;
        data["isReviewerStartedAppraisal"] = this.isReviewerStartedAppraisal;
        data["employeeStatus"] = this.employeeStatus;
        data["reviewerStatus"] = this.reviewerStatus;
        return data; 
    }

    clone(): AppraisalReviewerListDTO {
        const json = this.toJSON();
        let result = new AppraisalReviewerListDTO();
        result.init(json);
        return result;
    }
}

export interface IAppraisalReviewerListDTO {
    contractId: number;
    employeeId: number;
    firstName: string | undefined;
    otherNames: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    employeeNumber: string | undefined;
    departmentId: number;
    department: string | undefined;
    supervisorId: number | undefined;
    supervisorContractId: number;
    periodId: number;
    period: string | undefined;
    assignedKra: number;
    assignedKpi: number;
    cycleStatus: number;
    startDate: Date | undefined;
    isSubmitted: boolean;
    supervisorFullName: string | undefined;
    reviewStatus: number;
    isApproved: boolean;
    isReviewerSubmitted: boolean | undefined;
    isReviewerStartedAppraisal: boolean | undefined;
    employeeStatus: string | undefined;
    reviewerStatus: string | undefined;
}

export class AppraisalReviewerListDTOIListApiResult implements IAppraisalReviewerListDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AppraisalReviewerListDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAppraisalReviewerListDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AppraisalReviewerListDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AppraisalReviewerListDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AppraisalReviewerListDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AppraisalReviewerListDTOIListApiResult {
        const json = this.toJSON();
        let result = new AppraisalReviewerListDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAppraisalReviewerListDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AppraisalReviewerListDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AssignedKPIs implements IAssignedKPIs {
    title!: string | undefined;
    responseId!: number;
    appraisalId!: number;
    employeeComment!: string | undefined;
    employeeScore!: number;
    reviewerComment!: string | undefined;
    reviewerScore!: number;
    averageScore!: number;
    kraId!: number;
    kpiId!: number;

    constructor(data?: IAssignedKPIs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.responseId = _data["responseId"];
            this.appraisalId = _data["appraisalId"];
            this.employeeComment = _data["employeeComment"];
            this.employeeScore = _data["employeeScore"];
            this.reviewerComment = _data["reviewerComment"];
            this.reviewerScore = _data["reviewerScore"];
            this.averageScore = _data["averageScore"];
            this.kraId = _data["kraId"];
            this.kpiId = _data["kpiId"];
        }
    }

    static fromJS(data: any): AssignedKPIs {
        data = typeof data === 'object' ? data : {};
        let result = new AssignedKPIs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["responseId"] = this.responseId;
        data["appraisalId"] = this.appraisalId;
        data["employeeComment"] = this.employeeComment;
        data["employeeScore"] = this.employeeScore;
        data["reviewerComment"] = this.reviewerComment;
        data["reviewerScore"] = this.reviewerScore;
        data["averageScore"] = this.averageScore;
        data["kraId"] = this.kraId;
        data["kpiId"] = this.kpiId;
        return data; 
    }

    clone(): AssignedKPIs {
        const json = this.toJSON();
        let result = new AssignedKPIs();
        result.init(json);
        return result;
    }
}

export interface IAssignedKPIs {
    title: string | undefined;
    responseId: number;
    appraisalId: number;
    employeeComment: string | undefined;
    employeeScore: number;
    reviewerComment: string | undefined;
    reviewerScore: number;
    averageScore: number;
    kraId: number;
    kpiId: number;
}

export class KpiReviewDTO implements IKpiReviewDTO {
    cycleId!: number;
    kraId!: number;
    reviewerContractId!: number;
    reviewerName!: string | undefined;
    reviewerTitle!: string | undefined;
    employeeId!: number;
    employeeContractId!: number;
    employeeName!: string | undefined;
    department!: string | undefined;
    position!: string | undefined;
    appraisalTypeId!: number;
    lastAppraisedDate!: string | undefined;
    periodUnderReview!: string | undefined;
    dueDate!: Date;
    appraisalType!: string | undefined;
    assignedKPIs!: AssignedKPIs[] | undefined;

    constructor(data?: IKpiReviewDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cycleId = _data["cycleId"];
            this.kraId = _data["kraId"];
            this.reviewerContractId = _data["reviewerContractId"];
            this.reviewerName = _data["reviewerName"];
            this.reviewerTitle = _data["reviewerTitle"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
            this.employeeName = _data["employeeName"];
            this.department = _data["department"];
            this.position = _data["position"];
            this.appraisalTypeId = _data["appraisalTypeId"];
            this.lastAppraisedDate = _data["lastAppraisedDate"];
            this.periodUnderReview = _data["periodUnderReview"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.appraisalType = _data["appraisalType"];
            if (Array.isArray(_data["assignedKPIs"])) {
                this.assignedKPIs = [] as any;
                for (let item of _data["assignedKPIs"])
                    this.assignedKPIs!.push(AssignedKPIs.fromJS(item));
            }
        }
    }

    static fromJS(data: any): KpiReviewDTO {
        data = typeof data === 'object' ? data : {};
        let result = new KpiReviewDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cycleId"] = this.cycleId;
        data["kraId"] = this.kraId;
        data["reviewerContractId"] = this.reviewerContractId;
        data["reviewerName"] = this.reviewerName;
        data["reviewerTitle"] = this.reviewerTitle;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        data["employeeName"] = this.employeeName;
        data["department"] = this.department;
        data["position"] = this.position;
        data["appraisalTypeId"] = this.appraisalTypeId;
        data["lastAppraisedDate"] = this.lastAppraisedDate;
        data["periodUnderReview"] = this.periodUnderReview;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["appraisalType"] = this.appraisalType;
        if (Array.isArray(this.assignedKPIs)) {
            data["assignedKPIs"] = [];
            for (let item of this.assignedKPIs)
                data["assignedKPIs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): KpiReviewDTO {
        const json = this.toJSON();
        let result = new KpiReviewDTO();
        result.init(json);
        return result;
    }
}

export interface IKpiReviewDTO {
    cycleId: number;
    kraId: number;
    reviewerContractId: number;
    reviewerName: string | undefined;
    reviewerTitle: string | undefined;
    employeeId: number;
    employeeContractId: number;
    employeeName: string | undefined;
    department: string | undefined;
    position: string | undefined;
    appraisalTypeId: number;
    lastAppraisedDate: string | undefined;
    periodUnderReview: string | undefined;
    dueDate: Date;
    appraisalType: string | undefined;
    assignedKPIs: AssignedKPIs[] | undefined;
}

export class KpiReviewDTOApiResult implements IKpiReviewDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: KpiReviewDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IKpiReviewDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? KpiReviewDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): KpiReviewDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new KpiReviewDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): KpiReviewDTOApiResult {
        const json = this.toJSON();
        let result = new KpiReviewDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IKpiReviewDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: KpiReviewDTO;
    totalCount: number;
    totalRecord: number;
}

export class PerformanceReviewDTO implements IPerformanceReviewDTO {
    appraisalId!: number;
    employeeId!: number;
    employeeContractId!: number;
    reviewerContractId!: number;
    cycleId!: number;
    kraId!: number;
    employeeComment!: string | undefined;
    reviewerComment!: string | undefined;
    assignedKPIs!: string | undefined;

    constructor(data?: IPerformanceReviewDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appraisalId = _data["appraisalId"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
            this.reviewerContractId = _data["reviewerContractId"];
            this.cycleId = _data["cycleId"];
            this.kraId = _data["kraId"];
            this.employeeComment = _data["employeeComment"];
            this.reviewerComment = _data["reviewerComment"];
            this.assignedKPIs = _data["assignedKPIs"];
        }
    }

    static fromJS(data: any): PerformanceReviewDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PerformanceReviewDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appraisalId"] = this.appraisalId;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        data["reviewerContractId"] = this.reviewerContractId;
        data["cycleId"] = this.cycleId;
        data["kraId"] = this.kraId;
        data["employeeComment"] = this.employeeComment;
        data["reviewerComment"] = this.reviewerComment;
        data["assignedKPIs"] = this.assignedKPIs;
        return data; 
    }

    clone(): PerformanceReviewDTO {
        const json = this.toJSON();
        let result = new PerformanceReviewDTO();
        result.init(json);
        return result;
    }
}

export interface IPerformanceReviewDTO {
    appraisalId: number;
    employeeId: number;
    employeeContractId: number;
    reviewerContractId: number;
    cycleId: number;
    kraId: number;
    employeeComment: string | undefined;
    reviewerComment: string | undefined;
    assignedKPIs: string | undefined;
}

export class EmployeeAppraisalHistoryDTO implements IEmployeeAppraisalHistoryDTO {
    appraisalId!: number;
    cycleId!: number;
    cycle!: string | undefined;
    appraisalTypeId!: number;
    appraisalType!: string | undefined;
    ratingTypeId!: number;
    ratingType!: string | undefined;
    periodUnderReview!: string | undefined;
    totalPercentageScore!: number;
    grade!: string | undefined;
    recommendationId!: number;
    recommendation!: string | undefined;

    constructor(data?: IEmployeeAppraisalHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appraisalId = _data["appraisalId"];
            this.cycleId = _data["cycleId"];
            this.cycle = _data["cycle"];
            this.appraisalTypeId = _data["appraisalTypeId"];
            this.appraisalType = _data["appraisalType"];
            this.ratingTypeId = _data["ratingTypeId"];
            this.ratingType = _data["ratingType"];
            this.periodUnderReview = _data["periodUnderReview"];
            this.totalPercentageScore = _data["totalPercentageScore"];
            this.grade = _data["grade"];
            this.recommendationId = _data["recommendationId"];
            this.recommendation = _data["recommendation"];
        }
    }

    static fromJS(data: any): EmployeeAppraisalHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeAppraisalHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appraisalId"] = this.appraisalId;
        data["cycleId"] = this.cycleId;
        data["cycle"] = this.cycle;
        data["appraisalTypeId"] = this.appraisalTypeId;
        data["appraisalType"] = this.appraisalType;
        data["ratingTypeId"] = this.ratingTypeId;
        data["ratingType"] = this.ratingType;
        data["periodUnderReview"] = this.periodUnderReview;
        data["totalPercentageScore"] = this.totalPercentageScore;
        data["grade"] = this.grade;
        data["recommendationId"] = this.recommendationId;
        data["recommendation"] = this.recommendation;
        return data; 
    }

    clone(): EmployeeAppraisalHistoryDTO {
        const json = this.toJSON();
        let result = new EmployeeAppraisalHistoryDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeAppraisalHistoryDTO {
    appraisalId: number;
    cycleId: number;
    cycle: string | undefined;
    appraisalTypeId: number;
    appraisalType: string | undefined;
    ratingTypeId: number;
    ratingType: string | undefined;
    periodUnderReview: string | undefined;
    totalPercentageScore: number;
    grade: string | undefined;
    recommendationId: number;
    recommendation: string | undefined;
}

export class EmployeeAppraisalHistoryDTOIListApiResult implements IEmployeeAppraisalHistoryDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeAppraisalHistoryDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmployeeAppraisalHistoryDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmployeeAppraisalHistoryDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmployeeAppraisalHistoryDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeAppraisalHistoryDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmployeeAppraisalHistoryDTOIListApiResult {
        const json = this.toJSON();
        let result = new EmployeeAppraisalHistoryDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeAppraisalHistoryDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeAppraisalHistoryDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ApprovalLog implements IApprovalLog {
    approvalProcessId!: number;
    stepSn!: number;
    itemId!: number;
    userId!: number | undefined;
    privilegeId!: number;
    reviewStatus!: number | undefined;
    employeeId!: number | undefined;
    reviewDate!: Date | undefined;
    notifyDate!: Date | undefined;
    reviewedBy!: string | undefined;
    fileName!: string | undefined;
    filePath!: string | undefined;
    base64str!: string | undefined;
    comment!: string | undefined;
    otp!: string | undefined;
    otP_ExpiryDate!: Date | undefined;
    locationId!: number | undefined;
    ministryId!: number | undefined;
    departmentId!: number | undefined;
    schoolId!: number | undefined;
    approvalAmount!: number | undefined;
    stepLabel!: string | undefined;
    bpmnStepId!: string | undefined;
    approvalProcess!: ApprovalProcess;
    title!: string | undefined;
    isRequestType!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IApprovalLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approvalProcessId = _data["approvalProcessId"];
            this.stepSn = _data["stepSn"];
            this.itemId = _data["itemId"];
            this.userId = _data["userId"];
            this.privilegeId = _data["privilegeId"];
            this.reviewStatus = _data["reviewStatus"];
            this.employeeId = _data["employeeId"];
            this.reviewDate = _data["reviewDate"] ? new Date(_data["reviewDate"].toString()) : <any>undefined;
            this.notifyDate = _data["notifyDate"] ? new Date(_data["notifyDate"].toString()) : <any>undefined;
            this.reviewedBy = _data["reviewedBy"];
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.base64str = _data["base64str"];
            this.comment = _data["comment"];
            this.otp = _data["otp"];
            this.otP_ExpiryDate = _data["otP_ExpiryDate"] ? new Date(_data["otP_ExpiryDate"].toString()) : <any>undefined;
            this.locationId = _data["locationId"];
            this.ministryId = _data["ministryId"];
            this.departmentId = _data["departmentId"];
            this.schoolId = _data["schoolId"];
            this.approvalAmount = _data["approvalAmount"];
            this.stepLabel = _data["stepLabel"];
            this.bpmnStepId = _data["bpmnStepId"];
            this.approvalProcess = _data["approvalProcess"] ? ApprovalProcess.fromJS(_data["approvalProcess"]) : <any>undefined;
            this.title = _data["title"];
            this.isRequestType = _data["isRequestType"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ApprovalLog {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvalProcessId"] = this.approvalProcessId;
        data["stepSn"] = this.stepSn;
        data["itemId"] = this.itemId;
        data["userId"] = this.userId;
        data["privilegeId"] = this.privilegeId;
        data["reviewStatus"] = this.reviewStatus;
        data["employeeId"] = this.employeeId;
        data["reviewDate"] = this.reviewDate ? this.reviewDate.toISOString() : <any>undefined;
        data["notifyDate"] = this.notifyDate ? this.notifyDate.toISOString() : <any>undefined;
        data["reviewedBy"] = this.reviewedBy;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["base64str"] = this.base64str;
        data["comment"] = this.comment;
        data["otp"] = this.otp;
        data["otP_ExpiryDate"] = this.otP_ExpiryDate ? this.otP_ExpiryDate.toISOString() : <any>undefined;
        data["locationId"] = this.locationId;
        data["ministryId"] = this.ministryId;
        data["departmentId"] = this.departmentId;
        data["schoolId"] = this.schoolId;
        data["approvalAmount"] = this.approvalAmount;
        data["stepLabel"] = this.stepLabel;
        data["bpmnStepId"] = this.bpmnStepId;
        data["approvalProcess"] = this.approvalProcess ? this.approvalProcess.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["isRequestType"] = this.isRequestType;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ApprovalLog {
        const json = this.toJSON();
        let result = new ApprovalLog();
        result.init(json);
        return result;
    }
}

export interface IApprovalLog {
    approvalProcessId: number;
    stepSn: number;
    itemId: number;
    userId: number | undefined;
    privilegeId: number;
    reviewStatus: number | undefined;
    employeeId: number | undefined;
    reviewDate: Date | undefined;
    notifyDate: Date | undefined;
    reviewedBy: string | undefined;
    fileName: string | undefined;
    filePath: string | undefined;
    base64str: string | undefined;
    comment: string | undefined;
    otp: string | undefined;
    otP_ExpiryDate: Date | undefined;
    locationId: number | undefined;
    ministryId: number | undefined;
    departmentId: number | undefined;
    schoolId: number | undefined;
    approvalAmount: number | undefined;
    stepLabel: string | undefined;
    bpmnStepId: string | undefined;
    approvalProcess: ApprovalProcess;
    title: string | undefined;
    isRequestType: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ApprovalStep implements IApprovalStep {
    approvalProcessId!: number;
    stepSn!: number;
    privilegeId!: number;
    userId!: number;
    isnabled!: number;
    check_location!: boolean;
    check_ministry!: boolean;
    check_school!: boolean;
    check_department!: boolean;
    approvalLogs!: ApprovalLog[] | undefined;
    stepType!: string | undefined;
    stepName!: string | undefined;
    userEmail!: string | undefined;
    approvalProcess!: ApprovalProcess;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IApprovalStep) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approvalProcessId = _data["approvalProcessId"];
            this.stepSn = _data["stepSn"];
            this.privilegeId = _data["privilegeId"];
            this.userId = _data["userId"];
            this.isnabled = _data["isnabled"];
            this.check_location = _data["check_location"];
            this.check_ministry = _data["check_ministry"];
            this.check_school = _data["check_school"];
            this.check_department = _data["check_department"];
            if (Array.isArray(_data["approvalLogs"])) {
                this.approvalLogs = [] as any;
                for (let item of _data["approvalLogs"])
                    this.approvalLogs!.push(ApprovalLog.fromJS(item));
            }
            this.stepType = _data["stepType"];
            this.stepName = _data["stepName"];
            this.userEmail = _data["userEmail"];
            this.approvalProcess = _data["approvalProcess"] ? ApprovalProcess.fromJS(_data["approvalProcess"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ApprovalStep {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalStep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvalProcessId"] = this.approvalProcessId;
        data["stepSn"] = this.stepSn;
        data["privilegeId"] = this.privilegeId;
        data["userId"] = this.userId;
        data["isnabled"] = this.isnabled;
        data["check_location"] = this.check_location;
        data["check_ministry"] = this.check_ministry;
        data["check_school"] = this.check_school;
        data["check_department"] = this.check_department;
        if (Array.isArray(this.approvalLogs)) {
            data["approvalLogs"] = [];
            for (let item of this.approvalLogs)
                data["approvalLogs"].push(item.toJSON());
        }
        data["stepType"] = this.stepType;
        data["stepName"] = this.stepName;
        data["userEmail"] = this.userEmail;
        data["approvalProcess"] = this.approvalProcess ? this.approvalProcess.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ApprovalStep {
        const json = this.toJSON();
        let result = new ApprovalStep();
        result.init(json);
        return result;
    }
}

export interface IApprovalStep {
    approvalProcessId: number;
    stepSn: number;
    privilegeId: number;
    userId: number;
    isnabled: number;
    check_location: boolean;
    check_ministry: boolean;
    check_school: boolean;
    check_department: boolean;
    approvalLogs: ApprovalLog[] | undefined;
    stepType: string | undefined;
    stepName: string | undefined;
    userEmail: string | undefined;
    approvalProcess: ApprovalProcess;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ApprovalProcess implements IApprovalProcess {
    name!: string | undefined;
    isSystem!: number;
    useOTP!: boolean | undefined;
    category!: string | undefined;
    flowType!: string | undefined;
    partialViewName!: string | undefined;
    approvalLogs!: ApprovalLog[] | undefined;
    approvalSteps!: ApprovalStep[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IApprovalProcess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isSystem = _data["isSystem"];
            this.useOTP = _data["useOTP"];
            this.category = _data["category"];
            this.flowType = _data["flowType"];
            this.partialViewName = _data["partialViewName"];
            if (Array.isArray(_data["approvalLogs"])) {
                this.approvalLogs = [] as any;
                for (let item of _data["approvalLogs"])
                    this.approvalLogs!.push(ApprovalLog.fromJS(item));
            }
            if (Array.isArray(_data["approvalSteps"])) {
                this.approvalSteps = [] as any;
                for (let item of _data["approvalSteps"])
                    this.approvalSteps!.push(ApprovalStep.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ApprovalProcess {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSystem"] = this.isSystem;
        data["useOTP"] = this.useOTP;
        data["category"] = this.category;
        data["flowType"] = this.flowType;
        data["partialViewName"] = this.partialViewName;
        if (Array.isArray(this.approvalLogs)) {
            data["approvalLogs"] = [];
            for (let item of this.approvalLogs)
                data["approvalLogs"].push(item.toJSON());
        }
        if (Array.isArray(this.approvalSteps)) {
            data["approvalSteps"] = [];
            for (let item of this.approvalSteps)
                data["approvalSteps"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ApprovalProcess {
        const json = this.toJSON();
        let result = new ApprovalProcess();
        result.init(json);
        return result;
    }
}

export interface IApprovalProcess {
    name: string | undefined;
    isSystem: number;
    useOTP: boolean | undefined;
    category: string | undefined;
    flowType: string | undefined;
    partialViewName: string | undefined;
    approvalLogs: ApprovalLog[] | undefined;
    approvalSteps: ApprovalStep[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ApprovalProcessListApiResult implements IApprovalProcessListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApprovalProcess[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IApprovalProcessListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApprovalProcess.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ApprovalProcessListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalProcessListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ApprovalProcessListApiResult {
        const json = this.toJSON();
        let result = new ApprovalProcessListApiResult();
        result.init(json);
        return result;
    }
}

export interface IApprovalProcessListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApprovalProcess[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ApprovalStepListApiResult implements IApprovalStepListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApprovalStep[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IApprovalStepListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApprovalStep.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ApprovalStepListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalStepListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ApprovalStepListApiResult {
        const json = this.toJSON();
        let result = new ApprovalStepListApiResult();
        result.init(json);
        return result;
    }
}

export interface IApprovalStepListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApprovalStep[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class VwPendingApproval implements IVwPendingApproval {
    id!: number;
    approval_process_id!: number;
    process_name!: string | undefined;
    privilege!: string | undefined;
    privilege_code!: string | undefined;
    step_sn!: number;
    privilege_id!: number;
    item_id!: number;
    title!: string | undefined;
    employee_id!: number | undefined;
    notify_date!: Date | undefined;
    pending_duration!: string | undefined;
    description!: string | undefined;
    stepLabel!: string | undefined;
    fullName!: string | undefined;

    constructor(data?: IVwPendingApproval) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.approval_process_id = _data["approval_process_id"];
            this.process_name = _data["process_name"];
            this.privilege = _data["privilege"];
            this.privilege_code = _data["privilege_code"];
            this.step_sn = _data["step_sn"];
            this.privilege_id = _data["privilege_id"];
            this.item_id = _data["item_id"];
            this.title = _data["title"];
            this.employee_id = _data["employee_id"];
            this.notify_date = _data["notify_date"] ? new Date(_data["notify_date"].toString()) : <any>undefined;
            this.pending_duration = _data["pending_duration"];
            this.description = _data["description"];
            this.stepLabel = _data["stepLabel"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): VwPendingApproval {
        data = typeof data === 'object' ? data : {};
        let result = new VwPendingApproval();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["approval_process_id"] = this.approval_process_id;
        data["process_name"] = this.process_name;
        data["privilege"] = this.privilege;
        data["privilege_code"] = this.privilege_code;
        data["step_sn"] = this.step_sn;
        data["privilege_id"] = this.privilege_id;
        data["item_id"] = this.item_id;
        data["title"] = this.title;
        data["employee_id"] = this.employee_id;
        data["notify_date"] = this.notify_date ? this.notify_date.toISOString() : <any>undefined;
        data["pending_duration"] = this.pending_duration;
        data["description"] = this.description;
        data["stepLabel"] = this.stepLabel;
        data["fullName"] = this.fullName;
        return data; 
    }

    clone(): VwPendingApproval {
        const json = this.toJSON();
        let result = new VwPendingApproval();
        result.init(json);
        return result;
    }
}

export interface IVwPendingApproval {
    id: number;
    approval_process_id: number;
    process_name: string | undefined;
    privilege: string | undefined;
    privilege_code: string | undefined;
    step_sn: number;
    privilege_id: number;
    item_id: number;
    title: string | undefined;
    employee_id: number | undefined;
    notify_date: Date | undefined;
    pending_duration: string | undefined;
    description: string | undefined;
    stepLabel: string | undefined;
    fullName: string | undefined;
}

export class VwPendingApprovalListApiResult implements IVwPendingApprovalListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwPendingApproval[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IVwPendingApprovalListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(VwPendingApproval.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): VwPendingApprovalListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwPendingApprovalListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): VwPendingApprovalListApiResult {
        const json = this.toJSON();
        let result = new VwPendingApprovalListApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwPendingApprovalListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwPendingApproval[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ApprovalLogViewModel implements IApprovalLogViewModel {
    approvalProcessId!: number;
    itemId!: number;
    stepSn!: number;
    title!: string | undefined;
    has_Authorithy!: boolean;
    file_Uploaded!: boolean;
    log_Status_Desc!: string | undefined;
    companyId!: number;
    subId!: number;
    _ServerDocURL!: string | undefined;
    returnUrl!: string | undefined;
    logId!: number;
    otp!: string | undefined;
    useOTP!: boolean | undefined;
    otpExpiryDate!: Date | undefined;
    alog!: ApprovalLog;
    isRequestTypeApproval!: boolean;
    category!: string | undefined;
    partialViewName!: string | undefined;

    constructor(data?: IApprovalLogViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approvalProcessId = _data["approvalProcessId"];
            this.itemId = _data["itemId"];
            this.stepSn = _data["stepSn"];
            this.title = _data["title"];
            this.has_Authorithy = _data["has_Authorithy"];
            this.file_Uploaded = _data["file_Uploaded"];
            this.log_Status_Desc = _data["log_Status_Desc"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this._ServerDocURL = _data["_ServerDocURL"];
            this.returnUrl = _data["returnUrl"];
            this.logId = _data["logId"];
            this.otp = _data["otp"];
            this.useOTP = _data["useOTP"];
            this.otpExpiryDate = _data["otpExpiryDate"] ? new Date(_data["otpExpiryDate"].toString()) : <any>undefined;
            this.alog = _data["alog"] ? ApprovalLog.fromJS(_data["alog"]) : <any>undefined;
            this.isRequestTypeApproval = _data["isRequestTypeApproval"];
            this.category = _data["category"];
            this.partialViewName = _data["partialViewName"];
        }
    }

    static fromJS(data: any): ApprovalLogViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalLogViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvalProcessId"] = this.approvalProcessId;
        data["itemId"] = this.itemId;
        data["stepSn"] = this.stepSn;
        data["title"] = this.title;
        data["has_Authorithy"] = this.has_Authorithy;
        data["file_Uploaded"] = this.file_Uploaded;
        data["log_Status_Desc"] = this.log_Status_Desc;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["_ServerDocURL"] = this._ServerDocURL;
        data["returnUrl"] = this.returnUrl;
        data["logId"] = this.logId;
        data["otp"] = this.otp;
        data["useOTP"] = this.useOTP;
        data["otpExpiryDate"] = this.otpExpiryDate ? this.otpExpiryDate.toISOString() : <any>undefined;
        data["alog"] = this.alog ? this.alog.toJSON() : <any>undefined;
        data["isRequestTypeApproval"] = this.isRequestTypeApproval;
        data["category"] = this.category;
        data["partialViewName"] = this.partialViewName;
        return data; 
    }

    clone(): ApprovalLogViewModel {
        const json = this.toJSON();
        let result = new ApprovalLogViewModel();
        result.init(json);
        return result;
    }
}

export interface IApprovalLogViewModel {
    approvalProcessId: number;
    itemId: number;
    stepSn: number;
    title: string | undefined;
    has_Authorithy: boolean;
    file_Uploaded: boolean;
    log_Status_Desc: string | undefined;
    companyId: number;
    subId: number;
    _ServerDocURL: string | undefined;
    returnUrl: string | undefined;
    logId: number;
    otp: string | undefined;
    useOTP: boolean | undefined;
    otpExpiryDate: Date | undefined;
    alog: ApprovalLog;
    isRequestTypeApproval: boolean;
    category: string | undefined;
    partialViewName: string | undefined;
}

export class ApprovalLogViewModelApiResult implements IApprovalLogViewModelApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApprovalLogViewModel;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IApprovalLogViewModelApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? ApprovalLogViewModel.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ApprovalLogViewModelApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalLogViewModelApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ApprovalLogViewModelApiResult {
        const json = this.toJSON();
        let result = new ApprovalLogViewModelApiResult();
        result.init(json);
        return result;
    }
}

export interface IApprovalLogViewModelApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApprovalLogViewModel;
    totalCount: number;
    totalRecord: number;
}

export class ApprovalResponseObj implements IApprovalResponseObj {
    status!: boolean;
    message!: string | undefined;
    next_approver!: string | undefined;
    isApprovalStepExist!: boolean;

    constructor(data?: IApprovalResponseObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.message = _data["message"];
            this.next_approver = _data["next_approver"];
            this.isApprovalStepExist = _data["isApprovalStepExist"];
        }
    }

    static fromJS(data: any): ApprovalResponseObj {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalResponseObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["message"] = this.message;
        data["next_approver"] = this.next_approver;
        data["isApprovalStepExist"] = this.isApprovalStepExist;
        return data; 
    }

    clone(): ApprovalResponseObj {
        const json = this.toJSON();
        let result = new ApprovalResponseObj();
        result.init(json);
        return result;
    }
}

export interface IApprovalResponseObj {
    status: boolean;
    message: string | undefined;
    next_approver: string | undefined;
    isApprovalStepExist: boolean;
}

export class ApprovalResponseObjApiResult implements IApprovalResponseObjApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApprovalResponseObj;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IApprovalResponseObjApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? ApprovalResponseObj.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ApprovalResponseObjApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalResponseObjApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ApprovalResponseObjApiResult {
        const json = this.toJSON();
        let result = new ApprovalResponseObjApiResult();
        result.init(json);
        return result;
    }
}

export interface IApprovalResponseObjApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApprovalResponseObj;
    totalCount: number;
    totalRecord: number;
}

export class AssetTypeDTO implements IAssetTypeDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetTypeDTO {
        const json = this.toJSON();
        let result = new AssetTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetTypeDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class MessageOutIListApiResult implements IMessageOutIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MessageOut[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IMessageOutIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MessageOut.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): MessageOutIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOutIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): MessageOutIListApiResult {
        const json = this.toJSON();
        let result = new MessageOutIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IMessageOutIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MessageOut[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AssetDeperciationProfileDTO implements IAssetDeperciationProfileDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    code!: number;
    deperciationDate!: Date | undefined;
    purchaseYear!: number | undefined;
    depriciationType!: string | undefined;
    peroidicity!: Date | undefined;
    deperciationPercentage!: number | undefined;

    constructor(data?: IAssetDeperciationProfileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
            this.deperciationDate = _data["deperciationDate"] ? new Date(_data["deperciationDate"].toString()) : <any>undefined;
            this.purchaseYear = _data["purchaseYear"];
            this.depriciationType = _data["depriciationType"];
            this.peroidicity = _data["peroidicity"] ? new Date(_data["peroidicity"].toString()) : <any>undefined;
            this.deperciationPercentage = _data["deperciationPercentage"];
        }
    }

    static fromJS(data: any): AssetDeperciationProfileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDeperciationProfileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        data["deperciationDate"] = this.deperciationDate ? this.deperciationDate.toISOString() : <any>undefined;
        data["purchaseYear"] = this.purchaseYear;
        data["depriciationType"] = this.depriciationType;
        data["peroidicity"] = this.peroidicity ? this.peroidicity.toISOString() : <any>undefined;
        data["deperciationPercentage"] = this.deperciationPercentage;
        return data; 
    }

    clone(): AssetDeperciationProfileDTO {
        const json = this.toJSON();
        let result = new AssetDeperciationProfileDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetDeperciationProfileDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    code: number;
    deperciationDate: Date | undefined;
    purchaseYear: number | undefined;
    depriciationType: string | undefined;
    peroidicity: Date | undefined;
    deperciationPercentage: number | undefined;
}

export class AssetSubTypeDTO implements IAssetSubTypeDTO {
    id!: number;
    assetTypeId!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    code!: number;
    assetTypeName!: string | undefined;

    constructor(data?: IAssetSubTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetTypeId = _data["assetTypeId"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
            this.assetTypeName = _data["assetTypeName"];
        }
    }

    static fromJS(data: any): AssetSubTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetSubTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetTypeId"] = this.assetTypeId;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        data["assetTypeName"] = this.assetTypeName;
        return data; 
    }

    clone(): AssetSubTypeDTO {
        const json = this.toJSON();
        let result = new AssetSubTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetSubTypeDTO {
    id: number;
    assetTypeId: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    code: number;
    assetTypeName: string | undefined;
}

export class AssetCategoryDTO implements IAssetCategoryDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetCategoryDTO {
        const json = this.toJSON();
        let result = new AssetCategoryDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetCategoryDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetStatusDTO implements IAssetStatusDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    assetid!: number;
    statusName!: string | undefined;
    subID!: number;
    description!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetStatusDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.assetid = _data["assetid"];
            this.statusName = _data["statusName"];
            this.subID = _data["subID"];
            this.description = _data["description"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetStatusDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetStatusDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["assetid"] = this.assetid;
        data["statusName"] = this.statusName;
        data["subID"] = this.subID;
        data["description"] = this.description;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetStatusDTO {
        const json = this.toJSON();
        let result = new AssetStatusDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetStatusDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    assetid: number;
    statusName: string | undefined;
    subID: number;
    description: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetMakeDTO implements IAssetMakeDTO {
    id!: number;
    companyID!: number;
    brandModel!: string | undefined;
    assetid!: number;
    depreciation!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetMakeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.brandModel = _data["brandModel"];
            this.assetid = _data["assetid"];
            this.depreciation = _data["depreciation"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetMakeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetMakeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["brandModel"] = this.brandModel;
        data["assetid"] = this.assetid;
        data["depreciation"] = this.depreciation;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetMakeDTO {
        const json = this.toJSON();
        let result = new AssetMakeDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetMakeDTO {
    id: number;
    companyID: number;
    brandModel: string | undefined;
    assetid: number;
    depreciation: string | undefined;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetModelDTO implements IAssetModelDTO {
    id!: number;
    assetMakeId!: number | undefined;
    companyID!: number;
    description!: string | undefined;
    modelname!: string | undefined;
    assetid!: number;
    name!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetModelDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetMakeId = _data["assetMakeId"];
            this.companyID = _data["companyID"];
            this.description = _data["description"];
            this.modelname = _data["modelname"];
            this.assetid = _data["assetid"];
            this.name = _data["name"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetModelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetModelDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetMakeId"] = this.assetMakeId;
        data["companyID"] = this.companyID;
        data["description"] = this.description;
        data["modelname"] = this.modelname;
        data["assetid"] = this.assetid;
        data["name"] = this.name;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetModelDTO {
        const json = this.toJSON();
        let result = new AssetModelDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetModelDTO {
    id: number;
    assetMakeId: number | undefined;
    companyID: number;
    description: string | undefined;
    modelname: string | undefined;
    assetid: number;
    name: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetDTO implements IAssetDTO {
    referenceNumber!: string | undefined;
    employeeFullName!: string | undefined;
    modelName!: string | undefined;
    depreciationName!: string | undefined;
    assetTypeName!: string | undefined;
    assetSubTypeName!: string | undefined;
    statusName!: string | undefined;
    locationName!: string | undefined;
    makeName!: string | undefined;
    assetid!: number;
    assignedEmployeeid!: number;
    name!: string | undefined;
    assetNumber!: string | undefined;
    serialNumber!: string | undefined;
    custodianDepartmentId!: number;
    custodianId!: number;
    assetStatusId!: number;
    assetCategoryId!: number;
    assetSubTypeId!: number;
    deperciationMethod!: number;
    depreciationFrequency!: number;
    createdBy!: string | undefined;
    assetTypeId!: number;
    assetModelId!: number;
    assetModelName!: string | undefined;
    assetDepreciationProfileId!: number;
    assetMakeId!: number;
    assetMakeName!: string | undefined;
    locationId!: number;
    manufactureDate!: Date | undefined;
    purchaseDate!: Date | undefined;
    purchaseAmount!: number;
    description!: string | undefined;
    barCode!: string | undefined;
    qrCode!: string | undefined;
    depreciationDate!: Date | undefined;
    lostAsset!: boolean | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date | undefined;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.referenceNumber = _data["referenceNumber"];
            this.employeeFullName = _data["employeeFullName"];
            this.modelName = _data["modelName"];
            this.depreciationName = _data["depreciationName"];
            this.assetTypeName = _data["assetTypeName"];
            this.assetSubTypeName = _data["assetSubTypeName"];
            this.statusName = _data["statusName"];
            this.locationName = _data["locationName"];
            this.makeName = _data["makeName"];
            this.assetid = _data["assetid"];
            this.assignedEmployeeid = _data["assignedEmployeeid"];
            this.name = _data["name"];
            this.assetNumber = _data["assetNumber"];
            this.serialNumber = _data["serialNumber"];
            this.custodianDepartmentId = _data["custodianDepartmentId"];
            this.custodianId = _data["custodianId"];
            this.assetStatusId = _data["assetStatusId"];
            this.assetCategoryId = _data["assetCategoryId"];
            this.assetSubTypeId = _data["assetSubTypeId"];
            this.deperciationMethod = _data["deperciationMethod"];
            this.depreciationFrequency = _data["depreciationFrequency"];
            this.createdBy = _data["createdBy"];
            this.assetTypeId = _data["assetTypeId"];
            this.assetModelId = _data["assetModelId"];
            this.assetModelName = _data["assetModelName"];
            this.assetDepreciationProfileId = _data["assetDepreciationProfileId"];
            this.assetMakeId = _data["assetMakeId"];
            this.assetMakeName = _data["assetMakeName"];
            this.locationId = _data["locationId"];
            this.manufactureDate = _data["manufactureDate"] ? new Date(_data["manufactureDate"].toString()) : <any>undefined;
            this.purchaseDate = _data["purchaseDate"] ? new Date(_data["purchaseDate"].toString()) : <any>undefined;
            this.purchaseAmount = _data["purchaseAmount"];
            this.description = _data["description"];
            this.barCode = _data["barCode"];
            this.qrCode = _data["qrCode"];
            this.depreciationDate = _data["depreciationDate"] ? new Date(_data["depreciationDate"].toString()) : <any>undefined;
            this.lostAsset = _data["lostAsset"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceNumber"] = this.referenceNumber;
        data["employeeFullName"] = this.employeeFullName;
        data["modelName"] = this.modelName;
        data["depreciationName"] = this.depreciationName;
        data["assetTypeName"] = this.assetTypeName;
        data["assetSubTypeName"] = this.assetSubTypeName;
        data["statusName"] = this.statusName;
        data["locationName"] = this.locationName;
        data["makeName"] = this.makeName;
        data["assetid"] = this.assetid;
        data["assignedEmployeeid"] = this.assignedEmployeeid;
        data["name"] = this.name;
        data["assetNumber"] = this.assetNumber;
        data["serialNumber"] = this.serialNumber;
        data["custodianDepartmentId"] = this.custodianDepartmentId;
        data["custodianId"] = this.custodianId;
        data["assetStatusId"] = this.assetStatusId;
        data["assetCategoryId"] = this.assetCategoryId;
        data["assetSubTypeId"] = this.assetSubTypeId;
        data["deperciationMethod"] = this.deperciationMethod;
        data["depreciationFrequency"] = this.depreciationFrequency;
        data["createdBy"] = this.createdBy;
        data["assetTypeId"] = this.assetTypeId;
        data["assetModelId"] = this.assetModelId;
        data["assetModelName"] = this.assetModelName;
        data["assetDepreciationProfileId"] = this.assetDepreciationProfileId;
        data["assetMakeId"] = this.assetMakeId;
        data["assetMakeName"] = this.assetMakeName;
        data["locationId"] = this.locationId;
        data["manufactureDate"] = this.manufactureDate ? this.manufactureDate.toISOString() : <any>undefined;
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>undefined;
        data["purchaseAmount"] = this.purchaseAmount;
        data["description"] = this.description;
        data["barCode"] = this.barCode;
        data["qrCode"] = this.qrCode;
        data["depreciationDate"] = this.depreciationDate ? this.depreciationDate.toISOString() : <any>undefined;
        data["lostAsset"] = this.lostAsset;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetDTO {
        const json = this.toJSON();
        let result = new AssetDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetDTO {
    referenceNumber: string | undefined;
    employeeFullName: string | undefined;
    modelName: string | undefined;
    depreciationName: string | undefined;
    assetTypeName: string | undefined;
    assetSubTypeName: string | undefined;
    statusName: string | undefined;
    locationName: string | undefined;
    makeName: string | undefined;
    assetid: number;
    assignedEmployeeid: number;
    name: string | undefined;
    assetNumber: string | undefined;
    serialNumber: string | undefined;
    custodianDepartmentId: number;
    custodianId: number;
    assetStatusId: number;
    assetCategoryId: number;
    assetSubTypeId: number;
    deperciationMethod: number;
    depreciationFrequency: number;
    createdBy: string | undefined;
    assetTypeId: number;
    assetModelId: number;
    assetModelName: string | undefined;
    assetDepreciationProfileId: number;
    assetMakeId: number;
    assetMakeName: string | undefined;
    locationId: number;
    manufactureDate: Date | undefined;
    purchaseDate: Date | undefined;
    purchaseAmount: number;
    description: string | undefined;
    barCode: string | undefined;
    qrCode: string | undefined;
    depreciationDate: Date | undefined;
    lostAsset: boolean | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date | undefined;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetRequestDTO implements IAssetRequestDTO {
    assetid!: number | undefined;
    assetTypeid!: number | undefined;
    assetName!: string | undefined;
    employeeid!: number;
    employeeName!: string | undefined;
    assetSubTypeName!: string | undefined;
    expectedusedate!: Date | undefined;
    assetSubTypeid!: number;
    returndate!: Date | undefined;
    purpose!: string | undefined;
    decisionComment!: string | undefined;
    departmentId!: number;
    location!: number;
    prioity!: number;
    justification!: string | undefined;
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    status!: number;
    assignedbyId!: number;
    approvedId!: number;
    statusName!: string | undefined;
    assignedbyName!: string | undefined;
    approveedbyName!: string | undefined;
    dateCreated!: Date | undefined;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assetid = _data["assetid"];
            this.assetTypeid = _data["assetTypeid"];
            this.assetName = _data["assetName"];
            this.employeeid = _data["employeeid"];
            this.employeeName = _data["employeeName"];
            this.assetSubTypeName = _data["assetSubTypeName"];
            this.expectedusedate = _data["expectedusedate"] ? new Date(_data["expectedusedate"].toString()) : <any>undefined;
            this.assetSubTypeid = _data["assetSubTypeid"];
            this.returndate = _data["returndate"] ? new Date(_data["returndate"].toString()) : <any>undefined;
            this.purpose = _data["purpose"];
            this.decisionComment = _data["decisionComment"];
            this.departmentId = _data["departmentId"];
            this.location = _data["location"];
            this.prioity = _data["prioity"];
            this.justification = _data["justification"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.status = _data["status"];
            this.assignedbyId = _data["assignedbyId"];
            this.approvedId = _data["approvedId"];
            this.statusName = _data["statusName"];
            this.assignedbyName = _data["assignedbyName"];
            this.approveedbyName = _data["approveedbyName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetid"] = this.assetid;
        data["assetTypeid"] = this.assetTypeid;
        data["assetName"] = this.assetName;
        data["employeeid"] = this.employeeid;
        data["employeeName"] = this.employeeName;
        data["assetSubTypeName"] = this.assetSubTypeName;
        data["expectedusedate"] = this.expectedusedate ? this.expectedusedate.toISOString() : <any>undefined;
        data["assetSubTypeid"] = this.assetSubTypeid;
        data["returndate"] = this.returndate ? this.returndate.toISOString() : <any>undefined;
        data["purpose"] = this.purpose;
        data["decisionComment"] = this.decisionComment;
        data["departmentId"] = this.departmentId;
        data["location"] = this.location;
        data["prioity"] = this.prioity;
        data["justification"] = this.justification;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["status"] = this.status;
        data["assignedbyId"] = this.assignedbyId;
        data["approvedId"] = this.approvedId;
        data["statusName"] = this.statusName;
        data["assignedbyName"] = this.assignedbyName;
        data["approveedbyName"] = this.approveedbyName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetRequestDTO {
        const json = this.toJSON();
        let result = new AssetRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetRequestDTO {
    assetid: number | undefined;
    assetTypeid: number | undefined;
    assetName: string | undefined;
    employeeid: number;
    employeeName: string | undefined;
    assetSubTypeName: string | undefined;
    expectedusedate: Date | undefined;
    assetSubTypeid: number;
    returndate: Date | undefined;
    purpose: string | undefined;
    decisionComment: string | undefined;
    departmentId: number;
    location: number;
    prioity: number;
    justification: string | undefined;
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    status: number;
    assignedbyId: number;
    approvedId: number;
    statusName: string | undefined;
    assignedbyName: string | undefined;
    approveedbyName: string | undefined;
    dateCreated: Date | undefined;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssignmentDTO implements IAssignmentDTO {
    id!: number;
    assetid!: number;
    comment!: string | undefined;

    constructor(data?: IAssignmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetid = _data["assetid"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): AssignmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssignmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetid"] = this.assetid;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): AssignmentDTO {
        const json = this.toJSON();
        let result = new AssignmentDTO();
        result.init(json);
        return result;
    }
}

export interface IAssignmentDTO {
    id: number;
    assetid: number;
    comment: string | undefined;
}

export class AssetCallbackDTO implements IAssetCallbackDTO {
    companyID!: number;
    message!: string | undefined;
    processcode!: number;
    itemId!: number;
    approvalProcessId!: number;
    isapproved!: boolean;

    constructor(data?: IAssetCallbackDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyID = _data["companyID"];
            this.message = _data["message"];
            this.processcode = _data["processcode"];
            this.itemId = _data["itemId"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.isapproved = _data["isapproved"];
        }
    }

    static fromJS(data: any): AssetCallbackDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCallbackDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyID"] = this.companyID;
        data["message"] = this.message;
        data["processcode"] = this.processcode;
        data["itemId"] = this.itemId;
        data["approvalProcessId"] = this.approvalProcessId;
        data["isapproved"] = this.isapproved;
        return data; 
    }

    clone(): AssetCallbackDTO {
        const json = this.toJSON();
        let result = new AssetCallbackDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetCallbackDTO {
    companyID: number;
    message: string | undefined;
    processcode: number;
    itemId: number;
    approvalProcessId: number;
    isapproved: boolean;
}

export class AssetcheckInFilter implements IAssetcheckInFilter {
    id!: number;
    pageNumber!: number;
    pageSize!: number;
    name!: string | undefined;
    isFilter!: boolean;
    isActive!: boolean | undefined;

    constructor(data?: IAssetcheckInFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.name = _data["name"];
            this.isFilter = _data["isFilter"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetcheckInFilter {
        data = typeof data === 'object' ? data : {};
        let result = new AssetcheckInFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["name"] = this.name;
        data["isFilter"] = this.isFilter;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetcheckInFilter {
        const json = this.toJSON();
        let result = new AssetcheckInFilter();
        result.init(json);
        return result;
    }
}

export interface IAssetcheckInFilter {
    id: number;
    pageNumber: number;
    pageSize: number;
    name: string | undefined;
    isFilter: boolean;
    isActive: boolean | undefined;
}

export class UpdateAssetRequest implements IUpdateAssetRequest {
    id!: number;
    assetid!: number;
    assetRequestDTO!: AssetRequestDTO;
    pageNumber!: number;
    pageSize!: number;
    name!: string | undefined;
    isFilter!: boolean;
    isActive!: boolean | undefined;

    constructor(data?: IUpdateAssetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetid = _data["assetid"];
            this.assetRequestDTO = _data["assetRequestDTO"] ? AssetRequestDTO.fromJS(_data["assetRequestDTO"]) : <any>undefined;
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.name = _data["name"];
            this.isFilter = _data["isFilter"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateAssetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAssetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetid"] = this.assetid;
        data["assetRequestDTO"] = this.assetRequestDTO ? this.assetRequestDTO.toJSON() : <any>undefined;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["name"] = this.name;
        data["isFilter"] = this.isFilter;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): UpdateAssetRequest {
        const json = this.toJSON();
        let result = new UpdateAssetRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateAssetRequest {
    id: number;
    assetid: number;
    assetRequestDTO: AssetRequestDTO;
    pageNumber: number;
    pageSize: number;
    name: string | undefined;
    isFilter: boolean;
    isActive: boolean | undefined;
}

export class AssetDTOIListApiResult implements IAssetDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAssetDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AssetDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AssetDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AssetTypeDTOIListApiResult implements IAssetTypeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetTypeDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAssetTypeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AssetTypeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetTypeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AssetTypeDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetTypeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetTypeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetTypeDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AssetSubTypeDTOIListApiResult implements IAssetSubTypeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetSubTypeDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAssetSubTypeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetSubTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AssetSubTypeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetSubTypeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AssetSubTypeDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetSubTypeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetSubTypeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetSubTypeDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AssetCategoryDTOIListApiResult implements IAssetCategoryDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetCategoryDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAssetCategoryDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetCategoryDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AssetCategoryDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCategoryDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AssetCategoryDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetCategoryDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetCategoryDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetCategoryDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AssetMakeDTOIListApiResult implements IAssetMakeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetMakeDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAssetMakeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetMakeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AssetMakeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetMakeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AssetMakeDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetMakeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetMakeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetMakeDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AssetModelDTOIListApiResult implements IAssetModelDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetModelDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAssetModelDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetModelDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AssetModelDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetModelDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AssetModelDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetModelDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetModelDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetModelDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AssetStatusDTOIListApiResult implements IAssetStatusDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetStatusDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAssetStatusDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetStatusDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AssetStatusDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetStatusDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AssetStatusDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetStatusDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetStatusDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetStatusDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AssetDeperciationProfileDTOIListApiResult implements IAssetDeperciationProfileDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetDeperciationProfileDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAssetDeperciationProfileDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetDeperciationProfileDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AssetDeperciationProfileDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDeperciationProfileDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AssetDeperciationProfileDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetDeperciationProfileDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetDeperciationProfileDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetDeperciationProfileDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AssetHistoryDTO implements IAssetHistoryDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    assignedEmployeeName!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    assetId!: number;
    status!: number;
    assignedEmployeeid!: number;
    assetName!: string | undefined;
    statusName!: string | undefined;
    employeeId!: number;
    employeeName!: string | undefined;
    departmentAssignedTo!: number;
    departmentNameAssignedTo!: string | undefined;
    assignedDate!: Date;
    employeelocationName!: string | undefined;

    constructor(data?: IAssetHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.assignedEmployeeName = _data["assignedEmployeeName"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.assetId = _data["assetId"];
            this.status = _data["status"];
            this.assignedEmployeeid = _data["assignedEmployeeid"];
            this.assetName = _data["assetName"];
            this.statusName = _data["statusName"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.departmentAssignedTo = _data["departmentAssignedTo"];
            this.departmentNameAssignedTo = _data["departmentNameAssignedTo"];
            this.assignedDate = _data["assignedDate"] ? new Date(_data["assignedDate"].toString()) : <any>undefined;
            this.employeelocationName = _data["employeelocationName"];
        }
    }

    static fromJS(data: any): AssetHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["assignedEmployeeName"] = this.assignedEmployeeName;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["assetId"] = this.assetId;
        data["status"] = this.status;
        data["assignedEmployeeid"] = this.assignedEmployeeid;
        data["assetName"] = this.assetName;
        data["statusName"] = this.statusName;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["departmentAssignedTo"] = this.departmentAssignedTo;
        data["departmentNameAssignedTo"] = this.departmentNameAssignedTo;
        data["assignedDate"] = this.assignedDate ? this.assignedDate.toISOString() : <any>undefined;
        data["employeelocationName"] = this.employeelocationName;
        return data; 
    }

    clone(): AssetHistoryDTO {
        const json = this.toJSON();
        let result = new AssetHistoryDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetHistoryDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    assignedEmployeeName: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    assetId: number;
    status: number;
    assignedEmployeeid: number;
    assetName: string | undefined;
    statusName: string | undefined;
    employeeId: number;
    employeeName: string | undefined;
    departmentAssignedTo: number;
    departmentNameAssignedTo: string | undefined;
    assignedDate: Date;
    employeelocationName: string | undefined;
}

export class AssetHistoryDTOIListApiResult implements IAssetHistoryDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetHistoryDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAssetHistoryDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetHistoryDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AssetHistoryDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetHistoryDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AssetHistoryDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetHistoryDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetHistoryDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetHistoryDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class BenefitPlanDTO implements IBenefitPlanDTO {
    id!: number;
    benefitType!: string;
    companyID!: number;
    subID!: number;

    constructor(data?: IBenefitPlanDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.benefitType = _data["benefitType"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
        }
    }

    static fromJS(data: any): BenefitPlanDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BenefitPlanDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["benefitType"] = this.benefitType;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        return data; 
    }

    clone(): BenefitPlanDTO {
        const json = this.toJSON();
        let result = new BenefitPlanDTO();
        result.init(json);
        return result;
    }
}

export interface IBenefitPlanDTO {
    id: number;
    benefitType: string;
    companyID: number;
    subID: number;
}

export class DeleteDTO implements IDeleteDTO {
    id!: number;

    constructor(data?: IDeleteDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): DeleteDTO {
        const json = this.toJSON();
        let result = new DeleteDTO();
        result.init(json);
        return result;
    }
}

export interface IDeleteDTO {
    id: number;
}

export class BenefitPlan implements IBenefitPlan {
    benefitType!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IBenefitPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.benefitType = _data["benefitType"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): BenefitPlan {
        data = typeof data === 'object' ? data : {};
        let result = new BenefitPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["benefitType"] = this.benefitType;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): BenefitPlan {
        const json = this.toJSON();
        let result = new BenefitPlan();
        result.init(json);
        return result;
    }
}

export interface IBenefitPlan {
    benefitType: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class BenefitPlanListApiResult implements IBenefitPlanListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: BenefitPlan[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IBenefitPlanListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(BenefitPlan.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): BenefitPlanListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BenefitPlanListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): BenefitPlanListApiResult {
        const json = this.toJSON();
        let result = new BenefitPlanListApiResult();
        result.init(json);
        return result;
    }
}

export interface IBenefitPlanListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: BenefitPlan[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class EmployeeCoverageBenefitDTO implements IEmployeeCoverageBenefitDTO {
    id!: number;
    coveragePlanId!: number;
    planName!: string | undefined;
    employeeId!: number;
    eligibilityTypeId!: number;
    addtionalComment!: string | undefined;
    benefitIcon!: string;

    constructor(data?: IEmployeeCoverageBenefitDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.coveragePlanId = _data["coveragePlanId"];
            this.planName = _data["planName"];
            this.employeeId = _data["employeeId"];
            this.eligibilityTypeId = _data["eligibilityTypeId"];
            this.addtionalComment = _data["addtionalComment"];
            this.benefitIcon = _data["benefitIcon"];
        }
    }

    static fromJS(data: any): EmployeeCoverageBenefitDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeCoverageBenefitDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coveragePlanId"] = this.coveragePlanId;
        data["planName"] = this.planName;
        data["employeeId"] = this.employeeId;
        data["eligibilityTypeId"] = this.eligibilityTypeId;
        data["addtionalComment"] = this.addtionalComment;
        data["benefitIcon"] = this.benefitIcon;
        return data; 
    }

    clone(): EmployeeCoverageBenefitDTO {
        const json = this.toJSON();
        let result = new EmployeeCoverageBenefitDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeCoverageBenefitDTO {
    id: number;
    coveragePlanId: number;
    planName: string | undefined;
    employeeId: number;
    eligibilityTypeId: number;
    addtionalComment: string | undefined;
    benefitIcon: string;
}

export class CoveragePlan implements ICoveragePlan {
    coverageName!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICoveragePlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coverageName = _data["coverageName"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): CoveragePlan {
        data = typeof data === 'object' ? data : {};
        let result = new CoveragePlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coverageName"] = this.coverageName;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): CoveragePlan {
        const json = this.toJSON();
        let result = new CoveragePlan();
        result.init(json);
        return result;
    }
}

export interface ICoveragePlan {
    coverageName: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeCoverage implements IEmployeeCoverage {
    employeeId!: number;
    coveragePlanId!: number;
    eligibilityTypeId!: number;
    addtionalComment!: string | undefined;
    benefitIconName!: string | undefined;
    coveragePlan!: CoveragePlan[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeCoverage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.coveragePlanId = _data["coveragePlanId"];
            this.eligibilityTypeId = _data["eligibilityTypeId"];
            this.addtionalComment = _data["addtionalComment"];
            this.benefitIconName = _data["benefitIconName"];
            if (Array.isArray(_data["coveragePlan"])) {
                this.coveragePlan = [] as any;
                for (let item of _data["coveragePlan"])
                    this.coveragePlan!.push(CoveragePlan.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeCoverage {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeCoverage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["coveragePlanId"] = this.coveragePlanId;
        data["eligibilityTypeId"] = this.eligibilityTypeId;
        data["addtionalComment"] = this.addtionalComment;
        data["benefitIconName"] = this.benefitIconName;
        if (Array.isArray(this.coveragePlan)) {
            data["coveragePlan"] = [];
            for (let item of this.coveragePlan)
                data["coveragePlan"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeCoverage {
        const json = this.toJSON();
        let result = new EmployeeCoverage();
        result.init(json);
        return result;
    }
}

export interface IEmployeeCoverage {
    employeeId: number;
    coveragePlanId: number;
    eligibilityTypeId: number;
    addtionalComment: string | undefined;
    benefitIconName: string | undefined;
    coveragePlan: CoveragePlan[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeCoverageListApiResult implements IEmployeeCoverageListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeCoverage[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmployeeCoverageListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmployeeCoverage.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmployeeCoverageListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeCoverageListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmployeeCoverageListApiResult {
        const json = this.toJSON();
        let result = new EmployeeCoverageListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeCoverageListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeCoverage[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class CoveragePlanDTO implements ICoveragePlanDTO {
    id!: number;
    coverageName!: string | undefined;
    companyID!: number;
    subId!: number;

    constructor(data?: ICoveragePlanDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.coverageName = _data["coverageName"];
            this.companyID = _data["companyID"];
            this.subId = _data["subId"];
        }
    }

    static fromJS(data: any): CoveragePlanDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CoveragePlanDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coverageName"] = this.coverageName;
        data["companyID"] = this.companyID;
        data["subId"] = this.subId;
        return data; 
    }

    clone(): CoveragePlanDTO {
        const json = this.toJSON();
        let result = new CoveragePlanDTO();
        result.init(json);
        return result;
    }
}

export interface ICoveragePlanDTO {
    id: number;
    coverageName: string | undefined;
    companyID: number;
    subId: number;
}

export class CoveragePlanListApiResult implements ICoveragePlanListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CoveragePlan[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICoveragePlanListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CoveragePlan.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CoveragePlanListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CoveragePlanListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CoveragePlanListApiResult {
        const json = this.toJSON();
        let result = new CoveragePlanListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICoveragePlanListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CoveragePlan[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class EligibilityTypeDTO implements IEligibilityTypeDTO {
    id!: number;
    eligibilityTypes!: string | undefined;
    companyID!: number;
    subId!: number;

    constructor(data?: IEligibilityTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.eligibilityTypes = _data["eligibilityTypes"];
            this.companyID = _data["companyID"];
            this.subId = _data["subId"];
        }
    }

    static fromJS(data: any): EligibilityTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EligibilityTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["eligibilityTypes"] = this.eligibilityTypes;
        data["companyID"] = this.companyID;
        data["subId"] = this.subId;
        return data; 
    }

    clone(): EligibilityTypeDTO {
        const json = this.toJSON();
        let result = new EligibilityTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IEligibilityTypeDTO {
    id: number;
    eligibilityTypes: string | undefined;
    companyID: number;
    subId: number;
}

export class EligibilityType implements IEligibilityType {
    eligibilityTypes!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEligibilityType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eligibilityTypes = _data["eligibilityTypes"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EligibilityType {
        data = typeof data === 'object' ? data : {};
        let result = new EligibilityType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eligibilityTypes"] = this.eligibilityTypes;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EligibilityType {
        const json = this.toJSON();
        let result = new EligibilityType();
        result.init(json);
        return result;
    }
}

export interface IEligibilityType {
    eligibilityTypes: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EligibilityTypeListApiResult implements IEligibilityTypeListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EligibilityType[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEligibilityTypeListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EligibilityType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EligibilityTypeListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EligibilityTypeListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EligibilityTypeListApiResult {
        const json = this.toJSON();
        let result = new EligibilityTypeListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEligibilityTypeListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EligibilityType[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ManageBudgetDTO implements IManageBudgetDTO {
    id!: number;
    financialYearStartDate!: Date;
    financialYearEndDate!: Date;
    totalBudgetAmount!: number;
    spent!: number | undefined;

    constructor(data?: IManageBudgetDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.financialYearStartDate = _data["financialYearStartDate"] ? new Date(_data["financialYearStartDate"].toString()) : <any>undefined;
            this.financialYearEndDate = _data["financialYearEndDate"] ? new Date(_data["financialYearEndDate"].toString()) : <any>undefined;
            this.totalBudgetAmount = _data["totalBudgetAmount"];
            this.spent = _data["spent"];
        }
    }

    static fromJS(data: any): ManageBudgetDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageBudgetDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["financialYearStartDate"] = this.financialYearStartDate ? this.financialYearStartDate.toISOString() : <any>undefined;
        data["financialYearEndDate"] = this.financialYearEndDate ? this.financialYearEndDate.toISOString() : <any>undefined;
        data["totalBudgetAmount"] = this.totalBudgetAmount;
        data["spent"] = this.spent;
        return data; 
    }

    clone(): ManageBudgetDTO {
        const json = this.toJSON();
        let result = new ManageBudgetDTO();
        result.init(json);
        return result;
    }
}

export interface IManageBudgetDTO {
    id: number;
    financialYearStartDate: Date;
    financialYearEndDate: Date;
    totalBudgetAmount: number;
    spent: number | undefined;
}

export class DisbursementBudgetItemAllocationDTO implements IDisbursementBudgetItemAllocationDTO {
    id!: number;
    disbursementBudgetItemId!: number;
    departmentId!: number;
    department!: string | undefined;
    allocatedAmount!: number;

    constructor(data?: IDisbursementBudgetItemAllocationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.disbursementBudgetItemId = _data["disbursementBudgetItemId"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"];
            this.allocatedAmount = _data["allocatedAmount"];
        }
    }

    static fromJS(data: any): DisbursementBudgetItemAllocationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DisbursementBudgetItemAllocationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["disbursementBudgetItemId"] = this.disbursementBudgetItemId;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department;
        data["allocatedAmount"] = this.allocatedAmount;
        return data; 
    }

    clone(): DisbursementBudgetItemAllocationDTO {
        const json = this.toJSON();
        let result = new DisbursementBudgetItemAllocationDTO();
        result.init(json);
        return result;
    }
}

export interface IDisbursementBudgetItemAllocationDTO {
    id: number;
    disbursementBudgetItemId: number;
    departmentId: number;
    department: string | undefined;
    allocatedAmount: number;
}

export class BudgetItemDTO implements IBudgetItemDTO {
    id!: number;
    budgetID!: number;
    budgetName!: string | undefined;
    financialYearStartDate!: Date;
    financialYearEndDate!: Date;
    name!: string | undefined;
    code!: string | undefined;
    totalBudget!: number;
    spent!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    budgetItemAllocations!: DisbursementBudgetItemAllocationDTO[] | undefined;

    constructor(data?: IBudgetItemDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.budgetID = _data["budgetID"];
            this.budgetName = _data["budgetName"];
            this.financialYearStartDate = _data["financialYearStartDate"] ? new Date(_data["financialYearStartDate"].toString()) : <any>undefined;
            this.financialYearEndDate = _data["financialYearEndDate"] ? new Date(_data["financialYearEndDate"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.code = _data["code"];
            this.totalBudget = _data["totalBudget"];
            this.spent = _data["spent"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            if (Array.isArray(_data["budgetItemAllocations"])) {
                this.budgetItemAllocations = [] as any;
                for (let item of _data["budgetItemAllocations"])
                    this.budgetItemAllocations!.push(DisbursementBudgetItemAllocationDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BudgetItemDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetItemDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["budgetID"] = this.budgetID;
        data["budgetName"] = this.budgetName;
        data["financialYearStartDate"] = this.financialYearStartDate ? this.financialYearStartDate.toISOString() : <any>undefined;
        data["financialYearEndDate"] = this.financialYearEndDate ? this.financialYearEndDate.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["totalBudget"] = this.totalBudget;
        data["spent"] = this.spent;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        if (Array.isArray(this.budgetItemAllocations)) {
            data["budgetItemAllocations"] = [];
            for (let item of this.budgetItemAllocations)
                data["budgetItemAllocations"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BudgetItemDTO {
        const json = this.toJSON();
        let result = new BudgetItemDTO();
        result.init(json);
        return result;
    }
}

export interface IBudgetItemDTO {
    id: number;
    budgetID: number;
    budgetName: string | undefined;
    financialYearStartDate: Date;
    financialYearEndDate: Date;
    name: string | undefined;
    code: string | undefined;
    totalBudget: number;
    spent: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    budgetItemAllocations: DisbursementBudgetItemAllocationDTO[] | undefined;
}

export class BudgetDTO implements IBudgetDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    financialYearStartDate!: Date;
    financialYearEndDate!: Date;
    totalBudgetAmount!: number;
    spent!: number | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    budgetItems!: BudgetItemDTO[] | undefined;

    constructor(data?: IBudgetDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.financialYearStartDate = _data["financialYearStartDate"] ? new Date(_data["financialYearStartDate"].toString()) : <any>undefined;
            this.financialYearEndDate = _data["financialYearEndDate"] ? new Date(_data["financialYearEndDate"].toString()) : <any>undefined;
            this.totalBudgetAmount = _data["totalBudgetAmount"];
            this.spent = _data["spent"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            if (Array.isArray(_data["budgetItems"])) {
                this.budgetItems = [] as any;
                for (let item of _data["budgetItems"])
                    this.budgetItems!.push(BudgetItemDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BudgetDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["financialYearStartDate"] = this.financialYearStartDate ? this.financialYearStartDate.toISOString() : <any>undefined;
        data["financialYearEndDate"] = this.financialYearEndDate ? this.financialYearEndDate.toISOString() : <any>undefined;
        data["totalBudgetAmount"] = this.totalBudgetAmount;
        data["spent"] = this.spent;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        if (Array.isArray(this.budgetItems)) {
            data["budgetItems"] = [];
            for (let item of this.budgetItems)
                data["budgetItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BudgetDTO {
        const json = this.toJSON();
        let result = new BudgetDTO();
        result.init(json);
        return result;
    }
}

export interface IBudgetDTO {
    id: number;
    companyID: number;
    subID: number;
    financialYearStartDate: Date;
    financialYearEndDate: Date;
    totalBudgetAmount: number;
    spent: number | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    budgetItems: BudgetItemDTO[] | undefined;
}

export class BudgetDTOIListApiResult implements IBudgetDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: BudgetDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IBudgetDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(BudgetDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): BudgetDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): BudgetDTOIListApiResult {
        const json = this.toJSON();
        let result = new BudgetDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IBudgetDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: BudgetDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class BudgetDTOApiResult implements IBudgetDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: BudgetDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IBudgetDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? BudgetDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): BudgetDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): BudgetDTOApiResult {
        const json = this.toJSON();
        let result = new BudgetDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IBudgetDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: BudgetDTO;
    totalCount: number;
    totalRecord: number;
}

export class ManageBudgetItemDTO implements IManageBudgetItemDTO {
    id!: number;
    budgetID!: number;
    name!: string | undefined;
    code!: string | undefined;
    totalBudget!: number;
    spent!: number | undefined;
    budgetAllocations!: string | undefined;

    constructor(data?: IManageBudgetItemDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.budgetID = _data["budgetID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.totalBudget = _data["totalBudget"];
            this.spent = _data["spent"];
            this.budgetAllocations = _data["budgetAllocations"];
        }
    }

    static fromJS(data: any): ManageBudgetItemDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageBudgetItemDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["budgetID"] = this.budgetID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["totalBudget"] = this.totalBudget;
        data["spent"] = this.spent;
        data["budgetAllocations"] = this.budgetAllocations;
        return data; 
    }

    clone(): ManageBudgetItemDTO {
        const json = this.toJSON();
        let result = new ManageBudgetItemDTO();
        result.init(json);
        return result;
    }
}

export interface IManageBudgetItemDTO {
    id: number;
    budgetID: number;
    name: string | undefined;
    code: string | undefined;
    totalBudget: number;
    spent: number | undefined;
    budgetAllocations: string | undefined;
}

export class BudgetItemDTOIListApiResult implements IBudgetItemDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: BudgetItemDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IBudgetItemDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(BudgetItemDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): BudgetItemDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetItemDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): BudgetItemDTOIListApiResult {
        const json = this.toJSON();
        let result = new BudgetItemDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IBudgetItemDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: BudgetItemDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class DisbursementBudget implements IDisbursementBudget {
    financialYearStartDate!: Date;
    financialYearEndDate!: Date;
    totalBudgetAmount!: number;
    spent!: number | undefined;
    disbursementBudgetItems!: DisbursementBudgetItem[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDisbursementBudget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.financialYearStartDate = _data["financialYearStartDate"] ? new Date(_data["financialYearStartDate"].toString()) : <any>undefined;
            this.financialYearEndDate = _data["financialYearEndDate"] ? new Date(_data["financialYearEndDate"].toString()) : <any>undefined;
            this.totalBudgetAmount = _data["totalBudgetAmount"];
            this.spent = _data["spent"];
            if (Array.isArray(_data["disbursementBudgetItems"])) {
                this.disbursementBudgetItems = [] as any;
                for (let item of _data["disbursementBudgetItems"])
                    this.disbursementBudgetItems!.push(DisbursementBudgetItem.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DisbursementBudget {
        data = typeof data === 'object' ? data : {};
        let result = new DisbursementBudget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["financialYearStartDate"] = this.financialYearStartDate ? this.financialYearStartDate.toISOString() : <any>undefined;
        data["financialYearEndDate"] = this.financialYearEndDate ? this.financialYearEndDate.toISOString() : <any>undefined;
        data["totalBudgetAmount"] = this.totalBudgetAmount;
        data["spent"] = this.spent;
        if (Array.isArray(this.disbursementBudgetItems)) {
            data["disbursementBudgetItems"] = [];
            for (let item of this.disbursementBudgetItems)
                data["disbursementBudgetItems"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DisbursementBudget {
        const json = this.toJSON();
        let result = new DisbursementBudget();
        result.init(json);
        return result;
    }
}

export interface IDisbursementBudget {
    financialYearStartDate: Date;
    financialYearEndDate: Date;
    totalBudgetAmount: number;
    spent: number | undefined;
    disbursementBudgetItems: DisbursementBudgetItem[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Department implements IDepartment {
    name!: string;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    headOfDepartment!: number;
    scheduleOfDuties!: string | undefined;
    disbursementBudgetItemAllocations!: DisbursementBudgetItemAllocation[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDepartment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.headOfDepartment = _data["headOfDepartment"];
            this.scheduleOfDuties = _data["scheduleOfDuties"];
            if (Array.isArray(_data["disbursementBudgetItemAllocations"])) {
                this.disbursementBudgetItemAllocations = [] as any;
                for (let item of _data["disbursementBudgetItemAllocations"])
                    this.disbursementBudgetItemAllocations!.push(DisbursementBudgetItemAllocation.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Department {
        data = typeof data === 'object' ? data : {};
        let result = new Department();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["headOfDepartment"] = this.headOfDepartment;
        data["scheduleOfDuties"] = this.scheduleOfDuties;
        if (Array.isArray(this.disbursementBudgetItemAllocations)) {
            data["disbursementBudgetItemAllocations"] = [];
            for (let item of this.disbursementBudgetItemAllocations)
                data["disbursementBudgetItemAllocations"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Department {
        const json = this.toJSON();
        let result = new Department();
        result.init(json);
        return result;
    }
}

export interface IDepartment {
    name: string;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    headOfDepartment: number;
    scheduleOfDuties: string | undefined;
    disbursementBudgetItemAllocations: DisbursementBudgetItemAllocation[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DisbursementBudgetItemAllocation implements IDisbursementBudgetItemAllocation {
    disbursementBudgetItemId!: number;
    departmentId!: number;
    allocatedAmount!: number;
    department!: Department;
    disbursementBudgetItem!: DisbursementBudgetItem;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDisbursementBudgetItemAllocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disbursementBudgetItemId = _data["disbursementBudgetItemId"];
            this.departmentId = _data["departmentId"];
            this.allocatedAmount = _data["allocatedAmount"];
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.disbursementBudgetItem = _data["disbursementBudgetItem"] ? DisbursementBudgetItem.fromJS(_data["disbursementBudgetItem"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DisbursementBudgetItemAllocation {
        data = typeof data === 'object' ? data : {};
        let result = new DisbursementBudgetItemAllocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disbursementBudgetItemId"] = this.disbursementBudgetItemId;
        data["departmentId"] = this.departmentId;
        data["allocatedAmount"] = this.allocatedAmount;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["disbursementBudgetItem"] = this.disbursementBudgetItem ? this.disbursementBudgetItem.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DisbursementBudgetItemAllocation {
        const json = this.toJSON();
        let result = new DisbursementBudgetItemAllocation();
        result.init(json);
        return result;
    }
}

export interface IDisbursementBudgetItemAllocation {
    disbursementBudgetItemId: number;
    departmentId: number;
    allocatedAmount: number;
    department: Department;
    disbursementBudgetItem: DisbursementBudgetItem;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ProjectActivity implements IProjectActivity {
    projectId!: number;
    name!: string | undefined;
    description!: string | undefined;
    typeId!: number;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    expectedDuration!: number;
    startingTime!: Date | undefined;
    expectedCompletionTime!: Date | undefined;
    completionDate!: Date;
    employeeId!: number | undefined;
    inApproval!: boolean;
    priority!: number;
    status!: number;
    referenceId!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    project!: Project;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IProjectActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.typeId = _data["typeId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.expectedDuration = _data["expectedDuration"];
            this.startingTime = _data["startingTime"] ? new Date(_data["startingTime"].toString()) : <any>undefined;
            this.expectedCompletionTime = _data["expectedCompletionTime"] ? new Date(_data["expectedCompletionTime"].toString()) : <any>undefined;
            this.completionDate = _data["completionDate"] ? new Date(_data["completionDate"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.inApproval = _data["inApproval"];
            this.priority = _data["priority"];
            this.status = _data["status"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ProjectActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["typeId"] = this.typeId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["expectedDuration"] = this.expectedDuration;
        data["startingTime"] = this.startingTime ? this.startingTime.toISOString() : <any>undefined;
        data["expectedCompletionTime"] = this.expectedCompletionTime ? this.expectedCompletionTime.toISOString() : <any>undefined;
        data["completionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["inApproval"] = this.inApproval;
        data["priority"] = this.priority;
        data["status"] = this.status;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ProjectActivity {
        const json = this.toJSON();
        let result = new ProjectActivity();
        result.init(json);
        return result;
    }
}

export interface IProjectActivity {
    projectId: number;
    name: string | undefined;
    description: string | undefined;
    typeId: number;
    startDate: Date | undefined;
    endDate: Date | undefined;
    expectedDuration: number;
    startingTime: Date | undefined;
    expectedCompletionTime: Date | undefined;
    completionDate: Date;
    employeeId: number | undefined;
    inApproval: boolean;
    priority: number;
    status: number;
    referenceId: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    project: Project;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Project implements IProject {
    name!: string | undefined;
    departmentId!: number;
    supervisorId!: number;
    description!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    completionDate!: Date | undefined;
    status!: number;
    inApproval!: boolean;
    postApprovalStage!: number;
    referenceId!: string | undefined;
    code!: string | undefined;
    isClosedEnded!: boolean;
    projectActivities!: ProjectActivity[] | undefined;
    fundDisbursements!: FundDisbursement[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.departmentId = _data["departmentId"];
            this.supervisorId = _data["supervisorId"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.completionDate = _data["completionDate"] ? new Date(_data["completionDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.inApproval = _data["inApproval"];
            this.postApprovalStage = _data["postApprovalStage"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isClosedEnded = _data["isClosedEnded"];
            if (Array.isArray(_data["projectActivities"])) {
                this.projectActivities = [] as any;
                for (let item of _data["projectActivities"])
                    this.projectActivities!.push(ProjectActivity.fromJS(item));
            }
            if (Array.isArray(_data["fundDisbursements"])) {
                this.fundDisbursements = [] as any;
                for (let item of _data["fundDisbursements"])
                    this.fundDisbursements!.push(FundDisbursement.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["departmentId"] = this.departmentId;
        data["supervisorId"] = this.supervisorId;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["completionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["inApproval"] = this.inApproval;
        data["postApprovalStage"] = this.postApprovalStage;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isClosedEnded"] = this.isClosedEnded;
        if (Array.isArray(this.projectActivities)) {
            data["projectActivities"] = [];
            for (let item of this.projectActivities)
                data["projectActivities"].push(item.toJSON());
        }
        if (Array.isArray(this.fundDisbursements)) {
            data["fundDisbursements"] = [];
            for (let item of this.fundDisbursements)
                data["fundDisbursements"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Project {
        const json = this.toJSON();
        let result = new Project();
        result.init(json);
        return result;
    }
}

export interface IProject {
    name: string | undefined;
    departmentId: number;
    supervisorId: number;
    description: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    completionDate: Date | undefined;
    status: number;
    inApproval: boolean;
    postApprovalStage: number;
    referenceId: string | undefined;
    code: string | undefined;
    isClosedEnded: boolean;
    projectActivities: ProjectActivity[] | undefined;
    fundDisbursements: FundDisbursement[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class FundDisbursement implements IFundDisbursement {
    categoryId!: number;
    disbursementBudgetItemId!: number | undefined;
    projectId!: number | undefined;
    channelId!: number;
    isRecurring!: boolean;
    frequencyId!: number | undefined;
    addHasBeneficiary!: boolean;
    amount!: number;
    accountNumber!: string | undefined;
    accountName!: string | undefined;
    bankCode!: string | undefined;
    bankName!: string | undefined;
    bankId!: number;
    disbursementDate!: Date;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    description!: string | undefined;
    comment!: string | undefined;
    mode!: number | undefined;
    transferStatus!: number;
    refNo!: string | undefined;
    fundType!: number;
    isPicked!: boolean;
    log_status!: number;
    isAutoGenerated!: boolean;
    initiatedById!: number;
    initiatedBy!: string | undefined;
    secretKey!: string | undefined;
    reasonFailed!: string | undefined;
    failRunCount!: number;
    disbursementBudgetItem!: DisbursementBudgetItem;
    project!: Project;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IFundDisbursement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.disbursementBudgetItemId = _data["disbursementBudgetItemId"];
            this.projectId = _data["projectId"];
            this.channelId = _data["channelId"];
            this.isRecurring = _data["isRecurring"];
            this.frequencyId = _data["frequencyId"];
            this.addHasBeneficiary = _data["addHasBeneficiary"];
            this.amount = _data["amount"];
            this.accountNumber = _data["accountNumber"];
            this.accountName = _data["accountName"];
            this.bankCode = _data["bankCode"];
            this.bankName = _data["bankName"];
            this.bankId = _data["bankId"];
            this.disbursementDate = _data["disbursementDate"] ? new Date(_data["disbursementDate"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.comment = _data["comment"];
            this.mode = _data["mode"];
            this.transferStatus = _data["transferStatus"];
            this.refNo = _data["refNo"];
            this.fundType = _data["fundType"];
            this.isPicked = _data["isPicked"];
            this.log_status = _data["log_status"];
            this.isAutoGenerated = _data["isAutoGenerated"];
            this.initiatedById = _data["initiatedById"];
            this.initiatedBy = _data["initiatedBy"];
            this.secretKey = _data["secretKey"];
            this.reasonFailed = _data["reasonFailed"];
            this.failRunCount = _data["failRunCount"];
            this.disbursementBudgetItem = _data["disbursementBudgetItem"] ? DisbursementBudgetItem.fromJS(_data["disbursementBudgetItem"]) : <any>undefined;
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): FundDisbursement {
        data = typeof data === 'object' ? data : {};
        let result = new FundDisbursement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["disbursementBudgetItemId"] = this.disbursementBudgetItemId;
        data["projectId"] = this.projectId;
        data["channelId"] = this.channelId;
        data["isRecurring"] = this.isRecurring;
        data["frequencyId"] = this.frequencyId;
        data["addHasBeneficiary"] = this.addHasBeneficiary;
        data["amount"] = this.amount;
        data["accountNumber"] = this.accountNumber;
        data["accountName"] = this.accountName;
        data["bankCode"] = this.bankCode;
        data["bankName"] = this.bankName;
        data["bankId"] = this.bankId;
        data["disbursementDate"] = this.disbursementDate ? this.disbursementDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["comment"] = this.comment;
        data["mode"] = this.mode;
        data["transferStatus"] = this.transferStatus;
        data["refNo"] = this.refNo;
        data["fundType"] = this.fundType;
        data["isPicked"] = this.isPicked;
        data["log_status"] = this.log_status;
        data["isAutoGenerated"] = this.isAutoGenerated;
        data["initiatedById"] = this.initiatedById;
        data["initiatedBy"] = this.initiatedBy;
        data["secretKey"] = this.secretKey;
        data["reasonFailed"] = this.reasonFailed;
        data["failRunCount"] = this.failRunCount;
        data["disbursementBudgetItem"] = this.disbursementBudgetItem ? this.disbursementBudgetItem.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): FundDisbursement {
        const json = this.toJSON();
        let result = new FundDisbursement();
        result.init(json);
        return result;
    }
}

export interface IFundDisbursement {
    categoryId: number;
    disbursementBudgetItemId: number | undefined;
    projectId: number | undefined;
    channelId: number;
    isRecurring: boolean;
    frequencyId: number | undefined;
    addHasBeneficiary: boolean;
    amount: number;
    accountNumber: string | undefined;
    accountName: string | undefined;
    bankCode: string | undefined;
    bankName: string | undefined;
    bankId: number;
    disbursementDate: Date;
    startDate: Date | undefined;
    endDate: Date | undefined;
    description: string | undefined;
    comment: string | undefined;
    mode: number | undefined;
    transferStatus: number;
    refNo: string | undefined;
    fundType: number;
    isPicked: boolean;
    log_status: number;
    isAutoGenerated: boolean;
    initiatedById: number;
    initiatedBy: string | undefined;
    secretKey: string | undefined;
    reasonFailed: string | undefined;
    failRunCount: number;
    disbursementBudgetItem: DisbursementBudgetItem;
    project: Project;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DisbursementBudgetItem implements IDisbursementBudgetItem {
    disbursementBudgetId!: number;
    name!: string | undefined;
    code!: string | undefined;
    totalBudget!: number;
    spent!: number | undefined;
    disbursementBudget!: DisbursementBudget;
    disbursementBudgetItemAllocations!: DisbursementBudgetItemAllocation[] | undefined;
    fundDisbursements!: FundDisbursement[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDisbursementBudgetItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disbursementBudgetId = _data["disbursementBudgetId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.totalBudget = _data["totalBudget"];
            this.spent = _data["spent"];
            this.disbursementBudget = _data["disbursementBudget"] ? DisbursementBudget.fromJS(_data["disbursementBudget"]) : <any>undefined;
            if (Array.isArray(_data["disbursementBudgetItemAllocations"])) {
                this.disbursementBudgetItemAllocations = [] as any;
                for (let item of _data["disbursementBudgetItemAllocations"])
                    this.disbursementBudgetItemAllocations!.push(DisbursementBudgetItemAllocation.fromJS(item));
            }
            if (Array.isArray(_data["fundDisbursements"])) {
                this.fundDisbursements = [] as any;
                for (let item of _data["fundDisbursements"])
                    this.fundDisbursements!.push(FundDisbursement.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DisbursementBudgetItem {
        data = typeof data === 'object' ? data : {};
        let result = new DisbursementBudgetItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disbursementBudgetId"] = this.disbursementBudgetId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["totalBudget"] = this.totalBudget;
        data["spent"] = this.spent;
        data["disbursementBudget"] = this.disbursementBudget ? this.disbursementBudget.toJSON() : <any>undefined;
        if (Array.isArray(this.disbursementBudgetItemAllocations)) {
            data["disbursementBudgetItemAllocations"] = [];
            for (let item of this.disbursementBudgetItemAllocations)
                data["disbursementBudgetItemAllocations"].push(item.toJSON());
        }
        if (Array.isArray(this.fundDisbursements)) {
            data["fundDisbursements"] = [];
            for (let item of this.fundDisbursements)
                data["fundDisbursements"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DisbursementBudgetItem {
        const json = this.toJSON();
        let result = new DisbursementBudgetItem();
        result.init(json);
        return result;
    }
}

export interface IDisbursementBudgetItem {
    disbursementBudgetId: number;
    name: string | undefined;
    code: string | undefined;
    totalBudget: number;
    spent: number | undefined;
    disbursementBudget: DisbursementBudget;
    disbursementBudgetItemAllocations: DisbursementBudgetItemAllocation[] | undefined;
    fundDisbursements: FundDisbursement[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DisbursementBudgetItemIListApiResult implements IDisbursementBudgetItemIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DisbursementBudgetItem[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDisbursementBudgetItemIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DisbursementBudgetItem.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DisbursementBudgetItemIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DisbursementBudgetItemIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DisbursementBudgetItemIListApiResult {
        const json = this.toJSON();
        let result = new DisbursementBudgetItemIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDisbursementBudgetItemIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DisbursementBudgetItem[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class BudgetItemDTOApiResult implements IBudgetItemDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: BudgetItemDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IBudgetItemDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? BudgetItemDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): BudgetItemDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetItemDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): BudgetItemDTOApiResult {
        const json = this.toJSON();
        let result = new BudgetItemDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IBudgetItemDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: BudgetItemDTO;
    totalCount: number;
    totalRecord: number;
}

export class File implements IFile {

    constructor(data?: IFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): File {
        data = typeof data === 'object' ? data : {};
        let result = new File();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): File {
        const json = this.toJSON();
        let result = new File();
        result.init(json);
        return result;
    }
}

export interface IFile {
}

export class NineGridBoxMovementDTO implements INineGridBoxMovementDTO {
    id!: number;
    companyID!: number;
    gridboxId!: number;
    employeeId!: number;
    employeeName!: string | undefined;
    employeeDepartment!: string | undefined;
    justification!: string | undefined;
    departmentId!: number;
    fromGridBoxId!: number | undefined;
    movementType!: string | undefined;
    loggedDate!: Date | undefined;
    loggedByUserId!: number;
    loggedByUserName!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: INineGridBoxMovementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.gridboxId = _data["gridboxId"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.employeeDepartment = _data["employeeDepartment"];
            this.justification = _data["justification"];
            this.departmentId = _data["departmentId"];
            this.fromGridBoxId = _data["fromGridBoxId"];
            this.movementType = _data["movementType"];
            this.loggedDate = _data["loggedDate"] ? new Date(_data["loggedDate"].toString()) : <any>undefined;
            this.loggedByUserId = _data["loggedByUserId"];
            this.loggedByUserName = _data["loggedByUserName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): NineGridBoxMovementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NineGridBoxMovementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["gridboxId"] = this.gridboxId;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["employeeDepartment"] = this.employeeDepartment;
        data["justification"] = this.justification;
        data["departmentId"] = this.departmentId;
        data["fromGridBoxId"] = this.fromGridBoxId;
        data["movementType"] = this.movementType;
        data["loggedDate"] = this.loggedDate ? this.loggedDate.toISOString() : <any>undefined;
        data["loggedByUserId"] = this.loggedByUserId;
        data["loggedByUserName"] = this.loggedByUserName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): NineGridBoxMovementDTO {
        const json = this.toJSON();
        let result = new NineGridBoxMovementDTO();
        result.init(json);
        return result;
    }
}

export interface INineGridBoxMovementDTO {
    id: number;
    companyID: number;
    gridboxId: number;
    employeeId: number;
    employeeName: string | undefined;
    employeeDepartment: string | undefined;
    justification: string | undefined;
    departmentId: number;
    fromGridBoxId: number | undefined;
    movementType: string | undefined;
    loggedDate: Date | undefined;
    loggedByUserId: number;
    loggedByUserName: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class NineGridBoxDTO implements INineGridBoxDTO {
    id!: number;
    companyID!: number;
    gridboxId!: number;
    employeeId!: number;
    employeeName!: string | undefined;
    employeeDepartment!: string | undefined;
    justification!: string;
    departmentId!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    movementHistory!: NineGridBoxMovementDTO[] | undefined;

    constructor(data?: INineGridBoxDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.gridboxId = _data["gridboxId"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.employeeDepartment = _data["employeeDepartment"];
            this.justification = _data["justification"];
            this.departmentId = _data["departmentId"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["movementHistory"])) {
                this.movementHistory = [] as any;
                for (let item of _data["movementHistory"])
                    this.movementHistory!.push(NineGridBoxMovementDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NineGridBoxDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NineGridBoxDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["gridboxId"] = this.gridboxId;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["employeeDepartment"] = this.employeeDepartment;
        data["justification"] = this.justification;
        data["departmentId"] = this.departmentId;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.movementHistory)) {
            data["movementHistory"] = [];
            for (let item of this.movementHistory)
                data["movementHistory"].push(item.toJSON());
        }
        return data; 
    }

    clone(): NineGridBoxDTO {
        const json = this.toJSON();
        let result = new NineGridBoxDTO();
        result.init(json);
        return result;
    }
}

export interface INineGridBoxDTO {
    id: number;
    companyID: number;
    gridboxId: number;
    employeeId: number;
    employeeName: string | undefined;
    employeeDepartment: string | undefined;
    justification: string;
    departmentId: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    movementHistory: NineGridBoxMovementDTO[] | undefined;
}

export class ManageMoveEmployeeFilterDTO implements IManageMoveEmployeeFilterDTO {
    togridboxId!: number;
    fromgridboxId!: number;
    employeeId!: number;
    justification!: string | undefined;

    constructor(data?: IManageMoveEmployeeFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.togridboxId = _data["togridboxId"];
            this.fromgridboxId = _data["fromgridboxId"];
            this.employeeId = _data["employeeId"];
            this.justification = _data["justification"];
        }
    }

    static fromJS(data: any): ManageMoveEmployeeFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageMoveEmployeeFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["togridboxId"] = this.togridboxId;
        data["fromgridboxId"] = this.fromgridboxId;
        data["employeeId"] = this.employeeId;
        data["justification"] = this.justification;
        return data; 
    }

    clone(): ManageMoveEmployeeFilterDTO {
        const json = this.toJSON();
        let result = new ManageMoveEmployeeFilterDTO();
        result.init(json);
        return result;
    }
}

export interface IManageMoveEmployeeFilterDTO {
    togridboxId: number;
    fromgridboxId: number;
    employeeId: number;
    justification: string | undefined;
}

export class NineGridBoxDTOListApiResult implements INineGridBoxDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: NineGridBoxDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: INineGridBoxDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(NineGridBoxDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): NineGridBoxDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new NineGridBoxDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): NineGridBoxDTOListApiResult {
        const json = this.toJSON();
        let result = new NineGridBoxDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface INineGridBoxDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: NineGridBoxDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class GridBoxCountDTO implements IGridBoxCountDTO {
    gridboxId!: number;
    gridboxCount!: number;

    constructor(data?: IGridBoxCountDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gridboxId = _data["gridboxId"];
            this.gridboxCount = _data["gridboxCount"];
        }
    }

    static fromJS(data: any): GridBoxCountDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GridBoxCountDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gridboxId"] = this.gridboxId;
        data["gridboxCount"] = this.gridboxCount;
        return data; 
    }

    clone(): GridBoxCountDTO {
        const json = this.toJSON();
        let result = new GridBoxCountDTO();
        result.init(json);
        return result;
    }
}

export interface IGridBoxCountDTO {
    gridboxId: number;
    gridboxCount: number;
}

export class GridBoxCountDTOListApiResult implements IGridBoxCountDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: GridBoxCountDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IGridBoxCountDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GridBoxCountDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): GridBoxCountDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GridBoxCountDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): GridBoxCountDTOListApiResult {
        const json = this.toJSON();
        let result = new GridBoxCountDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGridBoxCountDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: GridBoxCountDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class EmployeeTalentPoolHistoryDTO implements IEmployeeTalentPoolHistoryDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    employeeTalentPoolId!: number;
    talentPoolId!: number;
    fromTalentPoolId!: number;
    employeeId!: number;
    comment!: string | undefined;
    employeePoints!: number;
    talentPoints!: number;
    recommendations!: string | undefined;
    actionType!: string | undefined;
    loggedByUserId!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IEmployeeTalentPoolHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.employeeTalentPoolId = _data["employeeTalentPoolId"];
            this.talentPoolId = _data["talentPoolId"];
            this.fromTalentPoolId = _data["fromTalentPoolId"];
            this.employeeId = _data["employeeId"];
            this.comment = _data["comment"];
            this.employeePoints = _data["employeePoints"];
            this.talentPoints = _data["talentPoints"];
            this.recommendations = _data["recommendations"];
            this.actionType = _data["actionType"];
            this.loggedByUserId = _data["loggedByUserId"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): EmployeeTalentPoolHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTalentPoolHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["employeeTalentPoolId"] = this.employeeTalentPoolId;
        data["talentPoolId"] = this.talentPoolId;
        data["fromTalentPoolId"] = this.fromTalentPoolId;
        data["employeeId"] = this.employeeId;
        data["comment"] = this.comment;
        data["employeePoints"] = this.employeePoints;
        data["talentPoints"] = this.talentPoints;
        data["recommendations"] = this.recommendations;
        data["actionType"] = this.actionType;
        data["loggedByUserId"] = this.loggedByUserId;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): EmployeeTalentPoolHistoryDTO {
        const json = this.toJSON();
        let result = new EmployeeTalentPoolHistoryDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeTalentPoolHistoryDTO {
    id: number;
    companyID: number;
    subID: number;
    employeeTalentPoolId: number;
    talentPoolId: number;
    fromTalentPoolId: number;
    employeeId: number;
    comment: string | undefined;
    employeePoints: number;
    talentPoints: number;
    recommendations: string | undefined;
    actionType: string | undefined;
    loggedByUserId: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class EmployeeTalentPoolDTO implements IEmployeeTalentPoolDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    talentPoolId!: number;
    talentPoolName!: string | undefined;
    employeeId!: number;
    comment!: string | undefined;
    employeePoints!: number;
    talentPoints!: number;
    recommendations!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    employeeTalentPoolHistory!: EmployeeTalentPoolHistoryDTO[] | undefined;

    constructor(data?: IEmployeeTalentPoolDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.talentPoolId = _data["talentPoolId"];
            this.talentPoolName = _data["talentPoolName"];
            this.employeeId = _data["employeeId"];
            this.comment = _data["comment"];
            this.employeePoints = _data["employeePoints"];
            this.talentPoints = _data["talentPoints"];
            this.recommendations = _data["recommendations"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["employeeTalentPoolHistory"])) {
                this.employeeTalentPoolHistory = [] as any;
                for (let item of _data["employeeTalentPoolHistory"])
                    this.employeeTalentPoolHistory!.push(EmployeeTalentPoolHistoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmployeeTalentPoolDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTalentPoolDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["talentPoolId"] = this.talentPoolId;
        data["talentPoolName"] = this.talentPoolName;
        data["employeeId"] = this.employeeId;
        data["comment"] = this.comment;
        data["employeePoints"] = this.employeePoints;
        data["talentPoints"] = this.talentPoints;
        data["recommendations"] = this.recommendations;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.employeeTalentPoolHistory)) {
            data["employeeTalentPoolHistory"] = [];
            for (let item of this.employeeTalentPoolHistory)
                data["employeeTalentPoolHistory"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EmployeeTalentPoolDTO {
        const json = this.toJSON();
        let result = new EmployeeTalentPoolDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeTalentPoolDTO {
    id: number;
    companyID: number;
    subID: number;
    talentPoolId: number;
    talentPoolName: string | undefined;
    employeeId: number;
    comment: string | undefined;
    employeePoints: number;
    talentPoints: number;
    recommendations: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    employeeTalentPoolHistory: EmployeeTalentPoolHistoryDTO[] | undefined;
}

export class SuccessorcompetencyDTO implements ISuccessorcompetencyDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    careerSuccessorId!: number;
    requirementCategory!: string;
    skillId!: number | undefined;
    skillName!: string | undefined;
    trainingId!: number | undefined;
    trainingName!: string | undefined;
    certificationId!: number | undefined;
    certificationName!: string | undefined;
    qualificationId!: number | undefined;
    qualificationName!: string | undefined;
    abilityId!: number | undefined;
    abilityName!: string | undefined;
    experience!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: ISuccessorcompetencyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.careerSuccessorId = _data["careerSuccessorId"];
            this.requirementCategory = _data["requirementCategory"];
            this.skillId = _data["skillId"];
            this.skillName = _data["skillName"];
            this.trainingId = _data["trainingId"];
            this.trainingName = _data["trainingName"];
            this.certificationId = _data["certificationId"];
            this.certificationName = _data["certificationName"];
            this.qualificationId = _data["qualificationId"];
            this.qualificationName = _data["qualificationName"];
            this.abilityId = _data["abilityId"];
            this.abilityName = _data["abilityName"];
            this.experience = _data["experience"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SuccessorcompetencyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SuccessorcompetencyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["careerSuccessorId"] = this.careerSuccessorId;
        data["requirementCategory"] = this.requirementCategory;
        data["skillId"] = this.skillId;
        data["skillName"] = this.skillName;
        data["trainingId"] = this.trainingId;
        data["trainingName"] = this.trainingName;
        data["certificationId"] = this.certificationId;
        data["certificationName"] = this.certificationName;
        data["qualificationId"] = this.qualificationId;
        data["qualificationName"] = this.qualificationName;
        data["abilityId"] = this.abilityId;
        data["abilityName"] = this.abilityName;
        data["experience"] = this.experience;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): SuccessorcompetencyDTO {
        const json = this.toJSON();
        let result = new SuccessorcompetencyDTO();
        result.init(json);
        return result;
    }
}

export interface ISuccessorcompetencyDTO {
    id: number;
    companyID: number;
    subID: number;
    careerSuccessorId: number;
    requirementCategory: string;
    skillId: number | undefined;
    skillName: string | undefined;
    trainingId: number | undefined;
    trainingName: string | undefined;
    certificationId: number | undefined;
    certificationName: string | undefined;
    qualificationId: number | undefined;
    qualificationName: string | undefined;
    abilityId: number | undefined;
    abilityName: string | undefined;
    experience: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class CareerSuccessorDTO implements ICareerSuccessorDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    employeeId!: number;
    employeeName!: string | undefined;
    growthDuration!: number;
    currentPositionId!: number;
    currentPositionName!: string | undefined;
    currentJobPositionName!: string | undefined;
    targetPositionId!: number;
    positionHolderId!: number;
    positionHolderName!: string | undefined;
    comment!: string | undefined;
    careerSuccessionId!: number;
    isNotification!: boolean;
    successionCompetency!: SuccessorcompetencyDTO[] | undefined;
    successionAdditionalCompetency!: SuccessorcompetencyDTO[] | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: ICareerSuccessorDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.growthDuration = _data["growthDuration"];
            this.currentPositionId = _data["currentPositionId"];
            this.currentPositionName = _data["currentPositionName"];
            this.currentJobPositionName = _data["currentJobPositionName"];
            this.targetPositionId = _data["targetPositionId"];
            this.positionHolderId = _data["positionHolderId"];
            this.positionHolderName = _data["positionHolderName"];
            this.comment = _data["comment"];
            this.careerSuccessionId = _data["careerSuccessionId"];
            this.isNotification = _data["isNotification"];
            if (Array.isArray(_data["successionCompetency"])) {
                this.successionCompetency = [] as any;
                for (let item of _data["successionCompetency"])
                    this.successionCompetency!.push(SuccessorcompetencyDTO.fromJS(item));
            }
            if (Array.isArray(_data["successionAdditionalCompetency"])) {
                this.successionAdditionalCompetency = [] as any;
                for (let item of _data["successionAdditionalCompetency"])
                    this.successionAdditionalCompetency!.push(SuccessorcompetencyDTO.fromJS(item));
            }
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CareerSuccessorDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CareerSuccessorDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["growthDuration"] = this.growthDuration;
        data["currentPositionId"] = this.currentPositionId;
        data["currentPositionName"] = this.currentPositionName;
        data["currentJobPositionName"] = this.currentJobPositionName;
        data["targetPositionId"] = this.targetPositionId;
        data["positionHolderId"] = this.positionHolderId;
        data["positionHolderName"] = this.positionHolderName;
        data["comment"] = this.comment;
        data["careerSuccessionId"] = this.careerSuccessionId;
        data["isNotification"] = this.isNotification;
        if (Array.isArray(this.successionCompetency)) {
            data["successionCompetency"] = [];
            for (let item of this.successionCompetency)
                data["successionCompetency"].push(item.toJSON());
        }
        if (Array.isArray(this.successionAdditionalCompetency)) {
            data["successionAdditionalCompetency"] = [];
            for (let item of this.successionAdditionalCompetency)
                data["successionAdditionalCompetency"].push(item.toJSON());
        }
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CareerSuccessorDTO {
        const json = this.toJSON();
        let result = new CareerSuccessorDTO();
        result.init(json);
        return result;
    }
}

export interface ICareerSuccessorDTO {
    id: number;
    companyID: number;
    subID: number;
    employeeId: number;
    employeeName: string | undefined;
    growthDuration: number;
    currentPositionId: number;
    currentPositionName: string | undefined;
    currentJobPositionName: string | undefined;
    targetPositionId: number;
    positionHolderId: number;
    positionHolderName: string | undefined;
    comment: string | undefined;
    careerSuccessionId: number;
    isNotification: boolean;
    successionCompetency: SuccessorcompetencyDTO[] | undefined;
    successionAdditionalCompetency: SuccessorcompetencyDTO[] | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class ManageCareerSuccessionDto implements IManageCareerSuccessionDto {
    id!: number;
    companyID!: number;
    subID!: number;
    planTitle!: string;
    holderId!: number;
    positionId!: number;
    competencyId!: number;
    startDate!: Date;
    purpose!: string;
    isActive!: boolean;
    readinessToStart!: number;
    stringSuccessionEmployee!: string | undefined;
    successionEmployee!: CareerSuccessorDTO[] | undefined;

    constructor(data?: IManageCareerSuccessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.planTitle = _data["planTitle"];
            this.holderId = _data["holderId"];
            this.positionId = _data["positionId"];
            this.competencyId = _data["competencyId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.purpose = _data["purpose"];
            this.isActive = _data["isActive"];
            this.readinessToStart = _data["readinessToStart"];
            this.stringSuccessionEmployee = _data["stringSuccessionEmployee"];
            if (Array.isArray(_data["successionEmployee"])) {
                this.successionEmployee = [] as any;
                for (let item of _data["successionEmployee"])
                    this.successionEmployee!.push(CareerSuccessorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ManageCareerSuccessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ManageCareerSuccessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["planTitle"] = this.planTitle;
        data["holderId"] = this.holderId;
        data["positionId"] = this.positionId;
        data["competencyId"] = this.competencyId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["purpose"] = this.purpose;
        data["isActive"] = this.isActive;
        data["readinessToStart"] = this.readinessToStart;
        data["stringSuccessionEmployee"] = this.stringSuccessionEmployee;
        if (Array.isArray(this.successionEmployee)) {
            data["successionEmployee"] = [];
            for (let item of this.successionEmployee)
                data["successionEmployee"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ManageCareerSuccessionDto {
        const json = this.toJSON();
        let result = new ManageCareerSuccessionDto();
        result.init(json);
        return result;
    }
}

export interface IManageCareerSuccessionDto {
    id: number;
    companyID: number;
    subID: number;
    planTitle: string;
    holderId: number;
    positionId: number;
    competencyId: number;
    startDate: Date;
    purpose: string;
    isActive: boolean;
    readinessToStart: number;
    stringSuccessionEmployee: string | undefined;
    successionEmployee: CareerSuccessorDTO[] | undefined;
}

export class TalentpoolrequirementDTO implements ITalentpoolrequirementDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    requirementCategory!: string;
    skillId!: number | undefined;
    skillName!: string | undefined;
    trainingId!: number | undefined;
    trainingName!: string | undefined;
    certificationId!: number | undefined;
    certificationName!: string | undefined;
    qualificationId!: number | undefined;
    qualificationName!: string | undefined;
    abilityId!: number | undefined;
    abilityName!: string | undefined;
    experience!: string | undefined;
    yearsofExperience!: number;
    experienceWeight!: number | undefined;
    skillWeight!: number | undefined;
    points!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: ITalentpoolrequirementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.requirementCategory = _data["requirementCategory"];
            this.skillId = _data["skillId"];
            this.skillName = _data["skillName"];
            this.trainingId = _data["trainingId"];
            this.trainingName = _data["trainingName"];
            this.certificationId = _data["certificationId"];
            this.certificationName = _data["certificationName"];
            this.qualificationId = _data["qualificationId"];
            this.qualificationName = _data["qualificationName"];
            this.abilityId = _data["abilityId"];
            this.abilityName = _data["abilityName"];
            this.experience = _data["experience"];
            this.yearsofExperience = _data["yearsofExperience"];
            this.experienceWeight = _data["experienceWeight"];
            this.skillWeight = _data["skillWeight"];
            this.points = _data["points"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TalentpoolrequirementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TalentpoolrequirementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["requirementCategory"] = this.requirementCategory;
        data["skillId"] = this.skillId;
        data["skillName"] = this.skillName;
        data["trainingId"] = this.trainingId;
        data["trainingName"] = this.trainingName;
        data["certificationId"] = this.certificationId;
        data["certificationName"] = this.certificationName;
        data["qualificationId"] = this.qualificationId;
        data["qualificationName"] = this.qualificationName;
        data["abilityId"] = this.abilityId;
        data["abilityName"] = this.abilityName;
        data["experience"] = this.experience;
        data["yearsofExperience"] = this.yearsofExperience;
        data["experienceWeight"] = this.experienceWeight;
        data["skillWeight"] = this.skillWeight;
        data["points"] = this.points;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): TalentpoolrequirementDTO {
        const json = this.toJSON();
        let result = new TalentpoolrequirementDTO();
        result.init(json);
        return result;
    }
}

export interface ITalentpoolrequirementDTO {
    id: number;
    companyID: number;
    subID: number;
    requirementCategory: string;
    skillId: number | undefined;
    skillName: string | undefined;
    trainingId: number | undefined;
    trainingName: string | undefined;
    certificationId: number | undefined;
    certificationName: string | undefined;
    qualificationId: number | undefined;
    qualificationName: string | undefined;
    abilityId: number | undefined;
    abilityName: string | undefined;
    experience: string | undefined;
    yearsofExperience: number;
    experienceWeight: number | undefined;
    skillWeight: number | undefined;
    points: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AddTalentPoolDTO implements IAddTalentPoolDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    talentPoolName!: string;
    employeeCount!: number;
    description!: string;
    loggedByUserId!: number;
    loggedByUserName!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    competencyId!: number;
    talentPoolRequirement!: TalentpoolrequirementDTO[] | undefined;

    constructor(data?: IAddTalentPoolDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.talentPoolName = _data["talentPoolName"];
            this.employeeCount = _data["employeeCount"];
            this.description = _data["description"];
            this.loggedByUserId = _data["loggedByUserId"];
            this.loggedByUserName = _data["loggedByUserName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.competencyId = _data["competencyId"];
            if (Array.isArray(_data["talentPoolRequirement"])) {
                this.talentPoolRequirement = [] as any;
                for (let item of _data["talentPoolRequirement"])
                    this.talentPoolRequirement!.push(TalentpoolrequirementDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddTalentPoolDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AddTalentPoolDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["talentPoolName"] = this.talentPoolName;
        data["employeeCount"] = this.employeeCount;
        data["description"] = this.description;
        data["loggedByUserId"] = this.loggedByUserId;
        data["loggedByUserName"] = this.loggedByUserName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["competencyId"] = this.competencyId;
        if (Array.isArray(this.talentPoolRequirement)) {
            data["talentPoolRequirement"] = [];
            for (let item of this.talentPoolRequirement)
                data["talentPoolRequirement"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AddTalentPoolDTO {
        const json = this.toJSON();
        let result = new AddTalentPoolDTO();
        result.init(json);
        return result;
    }
}

export interface IAddTalentPoolDTO {
    id: number;
    companyID: number;
    subID: number;
    talentPoolName: string;
    employeeCount: number;
    description: string;
    loggedByUserId: number;
    loggedByUserName: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    competencyId: number;
    talentPoolRequirement: TalentpoolrequirementDTO[] | undefined;
}

export class AddTalentPoolDTOListApiResult implements IAddTalentPoolDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AddTalentPoolDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAddTalentPoolDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AddTalentPoolDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AddTalentPoolDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AddTalentPoolDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AddTalentPoolDTOListApiResult {
        const json = this.toJSON();
        let result = new AddTalentPoolDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAddTalentPoolDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AddTalentPoolDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class SuccessorCompetency implements ISuccessorCompetency {
    careerSuccessorId!: number;
    requirementCategory!: string | undefined;
    skillId!: number | undefined;
    trainingId!: number | undefined;
    certificationId!: number | undefined;
    qualificationId!: number | undefined;
    experience!: string | undefined;
    careerSuccessor!: CareerSuccessor;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISuccessorCompetency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.careerSuccessorId = _data["careerSuccessorId"];
            this.requirementCategory = _data["requirementCategory"];
            this.skillId = _data["skillId"];
            this.trainingId = _data["trainingId"];
            this.certificationId = _data["certificationId"];
            this.qualificationId = _data["qualificationId"];
            this.experience = _data["experience"];
            this.careerSuccessor = _data["careerSuccessor"] ? CareerSuccessor.fromJS(_data["careerSuccessor"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): SuccessorCompetency {
        data = typeof data === 'object' ? data : {};
        let result = new SuccessorCompetency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["careerSuccessorId"] = this.careerSuccessorId;
        data["requirementCategory"] = this.requirementCategory;
        data["skillId"] = this.skillId;
        data["trainingId"] = this.trainingId;
        data["certificationId"] = this.certificationId;
        data["qualificationId"] = this.qualificationId;
        data["experience"] = this.experience;
        data["careerSuccessor"] = this.careerSuccessor ? this.careerSuccessor.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): SuccessorCompetency {
        const json = this.toJSON();
        let result = new SuccessorCompetency();
        result.init(json);
        return result;
    }
}

export interface ISuccessorCompetency {
    careerSuccessorId: number;
    requirementCategory: string | undefined;
    skillId: number | undefined;
    trainingId: number | undefined;
    certificationId: number | undefined;
    qualificationId: number | undefined;
    experience: string | undefined;
    careerSuccessor: CareerSuccessor;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CareerSuccessor implements ICareerSuccessor {
    careerSuccessionId!: number;
    employeeId!: number;
    growthDuration!: number;
    currentPositionId!: number;
    targetPositionId!: number;
    positionHolderId!: number;
    comment!: string | undefined;
    isNotification!: boolean;
    careerSuccession!: CareerSuccession;
    successorCompetencies!: SuccessorCompetency[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICareerSuccessor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.careerSuccessionId = _data["careerSuccessionId"];
            this.employeeId = _data["employeeId"];
            this.growthDuration = _data["growthDuration"];
            this.currentPositionId = _data["currentPositionId"];
            this.targetPositionId = _data["targetPositionId"];
            this.positionHolderId = _data["positionHolderId"];
            this.comment = _data["comment"];
            this.isNotification = _data["isNotification"];
            this.careerSuccession = _data["careerSuccession"] ? CareerSuccession.fromJS(_data["careerSuccession"]) : <any>undefined;
            if (Array.isArray(_data["successorCompetencies"])) {
                this.successorCompetencies = [] as any;
                for (let item of _data["successorCompetencies"])
                    this.successorCompetencies!.push(SuccessorCompetency.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): CareerSuccessor {
        data = typeof data === 'object' ? data : {};
        let result = new CareerSuccessor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["careerSuccessionId"] = this.careerSuccessionId;
        data["employeeId"] = this.employeeId;
        data["growthDuration"] = this.growthDuration;
        data["currentPositionId"] = this.currentPositionId;
        data["targetPositionId"] = this.targetPositionId;
        data["positionHolderId"] = this.positionHolderId;
        data["comment"] = this.comment;
        data["isNotification"] = this.isNotification;
        data["careerSuccession"] = this.careerSuccession ? this.careerSuccession.toJSON() : <any>undefined;
        if (Array.isArray(this.successorCompetencies)) {
            data["successorCompetencies"] = [];
            for (let item of this.successorCompetencies)
                data["successorCompetencies"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): CareerSuccessor {
        const json = this.toJSON();
        let result = new CareerSuccessor();
        result.init(json);
        return result;
    }
}

export interface ICareerSuccessor {
    careerSuccessionId: number;
    employeeId: number;
    growthDuration: number;
    currentPositionId: number;
    targetPositionId: number;
    positionHolderId: number;
    comment: string | undefined;
    isNotification: boolean;
    careerSuccession: CareerSuccession;
    successorCompetencies: SuccessorCompetency[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CareerSuccession implements ICareerSuccession {
    categoryType!: string | undefined;
    planJustification!: string | undefined;
    holderId!: number;
    title!: string | undefined;
    positionId!: number;
    purpose!: string | undefined;
    startDate!: Date;
    competencyId!: number;
    careerSuccessors!: CareerSuccessor[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICareerSuccession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryType = _data["categoryType"];
            this.planJustification = _data["planJustification"];
            this.holderId = _data["holderId"];
            this.title = _data["title"];
            this.positionId = _data["positionId"];
            this.purpose = _data["purpose"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.competencyId = _data["competencyId"];
            if (Array.isArray(_data["careerSuccessors"])) {
                this.careerSuccessors = [] as any;
                for (let item of _data["careerSuccessors"])
                    this.careerSuccessors!.push(CareerSuccessor.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): CareerSuccession {
        data = typeof data === 'object' ? data : {};
        let result = new CareerSuccession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryType"] = this.categoryType;
        data["planJustification"] = this.planJustification;
        data["holderId"] = this.holderId;
        data["title"] = this.title;
        data["positionId"] = this.positionId;
        data["purpose"] = this.purpose;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["competencyId"] = this.competencyId;
        if (Array.isArray(this.careerSuccessors)) {
            data["careerSuccessors"] = [];
            for (let item of this.careerSuccessors)
                data["careerSuccessors"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): CareerSuccession {
        const json = this.toJSON();
        let result = new CareerSuccession();
        result.init(json);
        return result;
    }
}

export interface ICareerSuccession {
    categoryType: string | undefined;
    planJustification: string | undefined;
    holderId: number;
    title: string | undefined;
    positionId: number;
    purpose: string | undefined;
    startDate: Date;
    competencyId: number;
    careerSuccessors: CareerSuccessor[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CareerSuccessionIListApiResult implements ICareerSuccessionIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CareerSuccession[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICareerSuccessionIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CareerSuccession.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CareerSuccessionIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CareerSuccessionIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CareerSuccessionIListApiResult {
        const json = this.toJSON();
        let result = new CareerSuccessionIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICareerSuccessionIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CareerSuccession[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ManageCertificationDTO implements IManageCertificationDTO {
    id!: number;
    professionalBodyId!: number;
    name!: string | undefined;
    code!: string | undefined;
    point!: number;

    constructor(data?: IManageCertificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.professionalBodyId = _data["professionalBodyId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
        }
    }

    static fromJS(data: any): ManageCertificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageCertificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["professionalBodyId"] = this.professionalBodyId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        return data; 
    }

    clone(): ManageCertificationDTO {
        const json = this.toJSON();
        let result = new ManageCertificationDTO();
        result.init(json);
        return result;
    }
}

export interface IManageCertificationDTO {
    id: number;
    professionalBodyId: number;
    name: string | undefined;
    code: string | undefined;
    point: number;
}

export class CertificationDTO implements ICertificationDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    professionalBodyId!: number;
    professionalBody!: string | undefined;
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICertificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.professionalBodyId = _data["professionalBodyId"];
            this.professionalBody = _data["professionalBody"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): CertificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["professionalBodyId"] = this.professionalBodyId;
        data["professionalBody"] = this.professionalBody;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): CertificationDTO {
        const json = this.toJSON();
        let result = new CertificationDTO();
        result.init(json);
        return result;
    }
}

export interface ICertificationDTO {
    id: number;
    companyID: number;
    subID: number;
    professionalBodyId: number;
    professionalBody: string | undefined;
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CertificationDTOListApiResult implements ICertificationDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CertificationDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICertificationDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CertificationDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CertificationDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CertificationDTOListApiResult {
        const json = this.toJSON();
        let result = new CertificationDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICertificationDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CertificationDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class CertificationDTOApiResult implements ICertificationDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CertificationDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICertificationDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? CertificationDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CertificationDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CertificationDTOApiResult {
        const json = this.toJSON();
        let result = new CertificationDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ICertificationDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CertificationDTO;
    totalCount: number;
    totalRecord: number;
}

export class ElementTypeDTO implements IElementTypeDTO {
    id!: number;
    name!: string | undefined;

    constructor(data?: IElementTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ElementTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ElementTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): ElementTypeDTO {
        const json = this.toJSON();
        let result = new ElementTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IElementTypeDTO {
    id: number;
    name: string | undefined;
}

export class ElementTypeDTOIListApiResult implements IElementTypeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ElementTypeDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IElementTypeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ElementTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ElementTypeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ElementTypeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ElementTypeDTOIListApiResult {
        const json = this.toJSON();
        let result = new ElementTypeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IElementTypeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ElementTypeDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ElementCategoryDTO implements IElementCategoryDTO {
    id!: number;
    name!: string | undefined;

    constructor(data?: IElementCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ElementCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ElementCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): ElementCategoryDTO {
        const json = this.toJSON();
        let result = new ElementCategoryDTO();
        result.init(json);
        return result;
    }
}

export interface IElementCategoryDTO {
    id: number;
    name: string | undefined;
}

export class ElementCategoryDTOIListApiResult implements IElementCategoryDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ElementCategoryDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IElementCategoryDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ElementCategoryDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ElementCategoryDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ElementCategoryDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ElementCategoryDTOIListApiResult {
        const json = this.toJSON();
        let result = new ElementCategoryDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IElementCategoryDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ElementCategoryDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class PayslipCategory implements IPayslipCategory {
    name!: string | undefined;
    elements!: Element[] | undefined;
    id!: number;
    company_id!: number;
    sub_id!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    row_version!: string | undefined;

    constructor(data?: IPayslipCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["elements"])) {
                this.elements = [] as any;
                for (let item of _data["elements"])
                    this.elements!.push(Element.fromJS(item));
            }
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            this.row_version = _data["row_version"];
        }
    }

    static fromJS(data: any): PayslipCategory {
        data = typeof data === 'object' ? data : {};
        let result = new PayslipCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.elements)) {
            data["elements"] = [];
            for (let item of this.elements)
                data["elements"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        data["row_version"] = this.row_version;
        return data; 
    }

    clone(): PayslipCategory {
        const json = this.toJSON();
        let result = new PayslipCategory();
        result.init(json);
        return result;
    }
}

export interface IPayslipCategory {
    name: string | undefined;
    elements: Element[] | undefined;
    id: number;
    company_id: number;
    sub_id: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    row_version: string | undefined;
}

export class ElementClassification implements IElementClassification {
    name!: string | undefined;
    type!: string | undefined;
    priority_id!: number;
    is_earning!: boolean;
    is_tax_relief!: boolean;
    elements!: Element[] | undefined;
    id!: number;
    company_id!: number;
    sub_id!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    row_version!: string | undefined;

    constructor(data?: IElementClassification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.priority_id = _data["priority_id"];
            this.is_earning = _data["is_earning"];
            this.is_tax_relief = _data["is_tax_relief"];
            if (Array.isArray(_data["elements"])) {
                this.elements = [] as any;
                for (let item of _data["elements"])
                    this.elements!.push(Element.fromJS(item));
            }
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            this.row_version = _data["row_version"];
        }
    }

    static fromJS(data: any): ElementClassification {
        data = typeof data === 'object' ? data : {};
        let result = new ElementClassification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["priority_id"] = this.priority_id;
        data["is_earning"] = this.is_earning;
        data["is_tax_relief"] = this.is_tax_relief;
        if (Array.isArray(this.elements)) {
            data["elements"] = [];
            for (let item of this.elements)
                data["elements"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        data["row_version"] = this.row_version;
        return data; 
    }

    clone(): ElementClassification {
        const json = this.toJSON();
        let result = new ElementClassification();
        result.init(json);
        return result;
    }
}

export interface IElementClassification {
    name: string | undefined;
    type: string | undefined;
    priority_id: number;
    is_earning: boolean;
    is_tax_relief: boolean;
    elements: Element[] | undefined;
    id: number;
    company_id: number;
    sub_id: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    row_version: string | undefined;
}

export class Element implements IElement {
    payrollItemId!: number | undefined;
    payTypeId!: number | undefined;
    paymentInstitutionId!: number;
    name!: string | undefined;
    proirity_id!: number;
    report_name!: string | undefined;
    description!: string | undefined;
    element_classification_id!: number;
    payslipCategoryId!: number;
    currency!: string | undefined;
    is_reoccuring!: boolean;
    is_variable!: boolean;
    is_system_default!: boolean;
    amount!: number | undefined;
    ratio!: number | undefined;
    isTaxDeduct!: boolean;
    taxPercentage!: number | undefined;
    hourlyPay!: number | undefined;
    noOfWorkHours!: number | undefined;
    short_text!: string | undefined;
    effective_start_date!: Date | undefined;
    termination_end_date!: Date | undefined;
    sys_Code!: string | undefined;
    paymentInstitution!: PaymentInstitution;
    payslipCategory!: PayslipCategory;
    elementClassification!: ElementClassification;
    id!: number;
    company_id!: number;
    sub_id!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    row_version!: string | undefined;

    constructor(data?: IElement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.payrollItemId = _data["payrollItemId"];
            this.payTypeId = _data["payTypeId"];
            this.paymentInstitutionId = _data["paymentInstitutionId"];
            this.name = _data["name"];
            this.proirity_id = _data["proirity_id"];
            this.report_name = _data["report_name"];
            this.description = _data["description"];
            this.element_classification_id = _data["element_classification_id"];
            this.payslipCategoryId = _data["payslipCategoryId"];
            this.currency = _data["currency"];
            this.is_reoccuring = _data["is_reoccuring"];
            this.is_variable = _data["is_variable"];
            this.is_system_default = _data["is_system_default"];
            this.amount = _data["amount"];
            this.ratio = _data["ratio"];
            this.isTaxDeduct = _data["isTaxDeduct"];
            this.taxPercentage = _data["taxPercentage"];
            this.hourlyPay = _data["hourlyPay"];
            this.noOfWorkHours = _data["noOfWorkHours"];
            this.short_text = _data["short_text"];
            this.effective_start_date = _data["effective_start_date"] ? new Date(_data["effective_start_date"].toString()) : <any>undefined;
            this.termination_end_date = _data["termination_end_date"] ? new Date(_data["termination_end_date"].toString()) : <any>undefined;
            this.sys_Code = _data["sys_Code"];
            this.paymentInstitution = _data["paymentInstitution"] ? PaymentInstitution.fromJS(_data["paymentInstitution"]) : <any>undefined;
            this.payslipCategory = _data["payslipCategory"] ? PayslipCategory.fromJS(_data["payslipCategory"]) : <any>undefined;
            this.elementClassification = _data["elementClassification"] ? ElementClassification.fromJS(_data["elementClassification"]) : <any>undefined;
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            this.row_version = _data["row_version"];
        }
    }

    static fromJS(data: any): Element {
        data = typeof data === 'object' ? data : {};
        let result = new Element();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payrollItemId"] = this.payrollItemId;
        data["payTypeId"] = this.payTypeId;
        data["paymentInstitutionId"] = this.paymentInstitutionId;
        data["name"] = this.name;
        data["proirity_id"] = this.proirity_id;
        data["report_name"] = this.report_name;
        data["description"] = this.description;
        data["element_classification_id"] = this.element_classification_id;
        data["payslipCategoryId"] = this.payslipCategoryId;
        data["currency"] = this.currency;
        data["is_reoccuring"] = this.is_reoccuring;
        data["is_variable"] = this.is_variable;
        data["is_system_default"] = this.is_system_default;
        data["amount"] = this.amount;
        data["ratio"] = this.ratio;
        data["isTaxDeduct"] = this.isTaxDeduct;
        data["taxPercentage"] = this.taxPercentage;
        data["hourlyPay"] = this.hourlyPay;
        data["noOfWorkHours"] = this.noOfWorkHours;
        data["short_text"] = this.short_text;
        data["effective_start_date"] = this.effective_start_date ? this.effective_start_date.toISOString() : <any>undefined;
        data["termination_end_date"] = this.termination_end_date ? this.termination_end_date.toISOString() : <any>undefined;
        data["sys_Code"] = this.sys_Code;
        data["paymentInstitution"] = this.paymentInstitution ? this.paymentInstitution.toJSON() : <any>undefined;
        data["payslipCategory"] = this.payslipCategory ? this.payslipCategory.toJSON() : <any>undefined;
        data["elementClassification"] = this.elementClassification ? this.elementClassification.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        data["row_version"] = this.row_version;
        return data; 
    }

    clone(): Element {
        const json = this.toJSON();
        let result = new Element();
        result.init(json);
        return result;
    }
}

export interface IElement {
    payrollItemId: number | undefined;
    payTypeId: number | undefined;
    paymentInstitutionId: number;
    name: string | undefined;
    proirity_id: number;
    report_name: string | undefined;
    description: string | undefined;
    element_classification_id: number;
    payslipCategoryId: number;
    currency: string | undefined;
    is_reoccuring: boolean;
    is_variable: boolean;
    is_system_default: boolean;
    amount: number | undefined;
    ratio: number | undefined;
    isTaxDeduct: boolean;
    taxPercentage: number | undefined;
    hourlyPay: number | undefined;
    noOfWorkHours: number | undefined;
    short_text: string | undefined;
    effective_start_date: Date | undefined;
    termination_end_date: Date | undefined;
    sys_Code: string | undefined;
    paymentInstitution: PaymentInstitution;
    payslipCategory: PayslipCategory;
    elementClassification: ElementClassification;
    id: number;
    company_id: number;
    sub_id: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    row_version: string | undefined;
}

export class PaymentInstitution implements IPaymentInstitution {
    categoryId!: number;
    name!: string | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    bankId!: number;
    elements!: Element[] | undefined;
    id!: number;
    company_id!: number;
    sub_id!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    row_version!: string | undefined;

    constructor(data?: IPaymentInstitution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.accountName = _data["accountName"];
            this.accountNumber = _data["accountNumber"];
            this.bankId = _data["bankId"];
            if (Array.isArray(_data["elements"])) {
                this.elements = [] as any;
                for (let item of _data["elements"])
                    this.elements!.push(Element.fromJS(item));
            }
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            this.row_version = _data["row_version"];
        }
    }

    static fromJS(data: any): PaymentInstitution {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInstitution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["bankId"] = this.bankId;
        if (Array.isArray(this.elements)) {
            data["elements"] = [];
            for (let item of this.elements)
                data["elements"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        data["row_version"] = this.row_version;
        return data; 
    }

    clone(): PaymentInstitution {
        const json = this.toJSON();
        let result = new PaymentInstitution();
        result.init(json);
        return result;
    }
}

export interface IPaymentInstitution {
    categoryId: number;
    name: string | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    bankId: number;
    elements: Element[] | undefined;
    id: number;
    company_id: number;
    sub_id: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    row_version: string | undefined;
}

export class PaymentInstitutionIListApiResult implements IPaymentInstitutionIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PaymentInstitution[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPaymentInstitutionIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PaymentInstitution.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PaymentInstitutionIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInstitutionIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PaymentInstitutionIListApiResult {
        const json = this.toJSON();
        let result = new PaymentInstitutionIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPaymentInstitutionIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PaymentInstitution[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ElementIListApiResult implements IElementIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Element[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IElementIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Element.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ElementIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ElementIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ElementIListApiResult {
        const json = this.toJSON();
        let result = new ElementIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IElementIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Element[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class EmployeeContractAssignment implements IEmployeeContractAssignment {
    assignmentNumber!: string;
    employeeId!: number;
    supervisorId!: number | undefined;
    departmentId!: number | undefined;
    payRollTypeId!: number | undefined;
    jobId!: number | undefined;
    gradeId!: number | undefined;
    gradeStepId!: number | undefined;
    locationId!: number | undefined;
    positionId!: number | undefined;
    ministryId!: number | undefined;
    employmentTypeId!: number;
    contractEndDate!: Date | undefined;
    salaryScaleId!: number;
    dateofPresentAppointment!: Date;
    dateOfAppointment!: Date;
    dateOfLastDeployment!: Date | undefined;
    dateOfConversion!: Date | undefined;
    dateOfConfirmation!: Date | undefined;
    dateDeployed!: Date | undefined;
    datePromotion!: Date | undefined;
    dateOfRetirement!: Date | undefined;
    retirementTypeId!: number | undefined;
    isContractActive!: boolean;
    isDefaultContract!: boolean;
    noOfLeaveDays!: number | undefined;
    peopleGroupId!: number | undefined;
    lastPromotionDate!: Date | undefined;
    schoolId!: number | undefined;
    unitId!: number | undefined;
    cadreID!: number | undefined;
    directorateID!: number | undefined;
    lcdaID!: number | undefined;
    isOffPayrolled!: number | undefined;
    payrollType!: PayrollType;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeContractAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assignmentNumber = _data["assignmentNumber"];
            this.employeeId = _data["employeeId"];
            this.supervisorId = _data["supervisorId"];
            this.departmentId = _data["departmentId"];
            this.payRollTypeId = _data["payRollTypeId"];
            this.jobId = _data["jobId"];
            this.gradeId = _data["gradeId"];
            this.gradeStepId = _data["gradeStepId"];
            this.locationId = _data["locationId"];
            this.positionId = _data["positionId"];
            this.ministryId = _data["ministryId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.contractEndDate = _data["contractEndDate"] ? new Date(_data["contractEndDate"].toString()) : <any>undefined;
            this.salaryScaleId = _data["salaryScaleId"];
            this.dateofPresentAppointment = _data["dateofPresentAppointment"] ? new Date(_data["dateofPresentAppointment"].toString()) : <any>undefined;
            this.dateOfAppointment = _data["dateOfAppointment"] ? new Date(_data["dateOfAppointment"].toString()) : <any>undefined;
            this.dateOfLastDeployment = _data["dateOfLastDeployment"] ? new Date(_data["dateOfLastDeployment"].toString()) : <any>undefined;
            this.dateOfConversion = _data["dateOfConversion"] ? new Date(_data["dateOfConversion"].toString()) : <any>undefined;
            this.dateOfConfirmation = _data["dateOfConfirmation"] ? new Date(_data["dateOfConfirmation"].toString()) : <any>undefined;
            this.dateDeployed = _data["dateDeployed"] ? new Date(_data["dateDeployed"].toString()) : <any>undefined;
            this.datePromotion = _data["datePromotion"] ? new Date(_data["datePromotion"].toString()) : <any>undefined;
            this.dateOfRetirement = _data["dateOfRetirement"] ? new Date(_data["dateOfRetirement"].toString()) : <any>undefined;
            this.retirementTypeId = _data["retirementTypeId"];
            this.isContractActive = _data["isContractActive"];
            this.isDefaultContract = _data["isDefaultContract"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.peopleGroupId = _data["peopleGroupId"];
            this.lastPromotionDate = _data["lastPromotionDate"] ? new Date(_data["lastPromotionDate"].toString()) : <any>undefined;
            this.schoolId = _data["schoolId"];
            this.unitId = _data["unitId"];
            this.cadreID = _data["cadreID"];
            this.directorateID = _data["directorateID"];
            this.lcdaID = _data["lcdaID"];
            this.isOffPayrolled = _data["isOffPayrolled"];
            this.payrollType = _data["payrollType"] ? PayrollType.fromJS(_data["payrollType"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeContractAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeContractAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assignmentNumber"] = this.assignmentNumber;
        data["employeeId"] = this.employeeId;
        data["supervisorId"] = this.supervisorId;
        data["departmentId"] = this.departmentId;
        data["payRollTypeId"] = this.payRollTypeId;
        data["jobId"] = this.jobId;
        data["gradeId"] = this.gradeId;
        data["gradeStepId"] = this.gradeStepId;
        data["locationId"] = this.locationId;
        data["positionId"] = this.positionId;
        data["ministryId"] = this.ministryId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["contractEndDate"] = this.contractEndDate ? this.contractEndDate.toISOString() : <any>undefined;
        data["salaryScaleId"] = this.salaryScaleId;
        data["dateofPresentAppointment"] = this.dateofPresentAppointment ? this.dateofPresentAppointment.toISOString() : <any>undefined;
        data["dateOfAppointment"] = this.dateOfAppointment ? this.dateOfAppointment.toISOString() : <any>undefined;
        data["dateOfLastDeployment"] = this.dateOfLastDeployment ? this.dateOfLastDeployment.toISOString() : <any>undefined;
        data["dateOfConversion"] = this.dateOfConversion ? this.dateOfConversion.toISOString() : <any>undefined;
        data["dateOfConfirmation"] = this.dateOfConfirmation ? this.dateOfConfirmation.toISOString() : <any>undefined;
        data["dateDeployed"] = this.dateDeployed ? this.dateDeployed.toISOString() : <any>undefined;
        data["datePromotion"] = this.datePromotion ? this.datePromotion.toISOString() : <any>undefined;
        data["dateOfRetirement"] = this.dateOfRetirement ? this.dateOfRetirement.toISOString() : <any>undefined;
        data["retirementTypeId"] = this.retirementTypeId;
        data["isContractActive"] = this.isContractActive;
        data["isDefaultContract"] = this.isDefaultContract;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["peopleGroupId"] = this.peopleGroupId;
        data["lastPromotionDate"] = this.lastPromotionDate ? this.lastPromotionDate.toISOString() : <any>undefined;
        data["schoolId"] = this.schoolId;
        data["unitId"] = this.unitId;
        data["cadreID"] = this.cadreID;
        data["directorateID"] = this.directorateID;
        data["lcdaID"] = this.lcdaID;
        data["isOffPayrolled"] = this.isOffPayrolled;
        data["payrollType"] = this.payrollType ? this.payrollType.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeContractAssignment {
        const json = this.toJSON();
        let result = new EmployeeContractAssignment();
        result.init(json);
        return result;
    }
}

export interface IEmployeeContractAssignment {
    assignmentNumber: string;
    employeeId: number;
    supervisorId: number | undefined;
    departmentId: number | undefined;
    payRollTypeId: number | undefined;
    jobId: number | undefined;
    gradeId: number | undefined;
    gradeStepId: number | undefined;
    locationId: number | undefined;
    positionId: number | undefined;
    ministryId: number | undefined;
    employmentTypeId: number;
    contractEndDate: Date | undefined;
    salaryScaleId: number;
    dateofPresentAppointment: Date;
    dateOfAppointment: Date;
    dateOfLastDeployment: Date | undefined;
    dateOfConversion: Date | undefined;
    dateOfConfirmation: Date | undefined;
    dateDeployed: Date | undefined;
    datePromotion: Date | undefined;
    dateOfRetirement: Date | undefined;
    retirementTypeId: number | undefined;
    isContractActive: boolean;
    isDefaultContract: boolean;
    noOfLeaveDays: number | undefined;
    peopleGroupId: number | undefined;
    lastPromotionDate: Date | undefined;
    schoolId: number | undefined;
    unitId: number | undefined;
    cadreID: number | undefined;
    directorateID: number | undefined;
    lcdaID: number | undefined;
    isOffPayrolled: number | undefined;
    payrollType: PayrollType;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class FrequencyRule implements IFrequencyRule {
    name!: string | undefined;
    type!: number;
    payrollTypes!: PayrollType[] | undefined;
    id!: number;
    company_id!: number;
    sub_id!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    row_version!: string | undefined;

    constructor(data?: IFrequencyRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            if (Array.isArray(_data["payrollTypes"])) {
                this.payrollTypes = [] as any;
                for (let item of _data["payrollTypes"])
                    this.payrollTypes!.push(PayrollType.fromJS(item));
            }
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            this.row_version = _data["row_version"];
        }
    }

    static fromJS(data: any): FrequencyRule {
        data = typeof data === 'object' ? data : {};
        let result = new FrequencyRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        if (Array.isArray(this.payrollTypes)) {
            data["payrollTypes"] = [];
            for (let item of this.payrollTypes)
                data["payrollTypes"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        data["row_version"] = this.row_version;
        return data; 
    }

    clone(): FrequencyRule {
        const json = this.toJSON();
        let result = new FrequencyRule();
        result.init(json);
        return result;
    }
}

export interface IFrequencyRule {
    name: string | undefined;
    type: number;
    payrollTypes: PayrollType[] | undefined;
    id: number;
    company_id: number;
    sub_id: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    row_version: string | undefined;
}

export class PayrollType implements IPayrollType {
    name!: string | undefined;
    frequencyRuleId!: number;
    firstPeriodEndDate!: Date;
    strFirstPeriodEndDate!: string | undefined;
    noOfYears!: number;
    effectiveDate!: Date;
    strEffectiveDate!: string | undefined;
    payslipDate_Offset!: number;
    scheduleRunDate_Offset!: number;
    negativePaymentAllowed!: boolean;
    code!: string | undefined;
    employees!: EmployeeContractAssignment[] | undefined;
    frequencyRule!: FrequencyRule;
    id!: number;
    company_id!: number;
    sub_id!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    row_version!: string | undefined;

    constructor(data?: IPayrollType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.frequencyRuleId = _data["frequencyRuleId"];
            this.firstPeriodEndDate = _data["firstPeriodEndDate"] ? new Date(_data["firstPeriodEndDate"].toString()) : <any>undefined;
            this.strFirstPeriodEndDate = _data["strFirstPeriodEndDate"];
            this.noOfYears = _data["noOfYears"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.strEffectiveDate = _data["strEffectiveDate"];
            this.payslipDate_Offset = _data["payslipDate_Offset"];
            this.scheduleRunDate_Offset = _data["scheduleRunDate_Offset"];
            this.negativePaymentAllowed = _data["negativePaymentAllowed"];
            this.code = _data["code"];
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(EmployeeContractAssignment.fromJS(item));
            }
            this.frequencyRule = _data["frequencyRule"] ? FrequencyRule.fromJS(_data["frequencyRule"]) : <any>undefined;
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            this.row_version = _data["row_version"];
        }
    }

    static fromJS(data: any): PayrollType {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["frequencyRuleId"] = this.frequencyRuleId;
        data["firstPeriodEndDate"] = this.firstPeriodEndDate ? this.firstPeriodEndDate.toISOString() : <any>undefined;
        data["strFirstPeriodEndDate"] = this.strFirstPeriodEndDate;
        data["noOfYears"] = this.noOfYears;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["strEffectiveDate"] = this.strEffectiveDate;
        data["payslipDate_Offset"] = this.payslipDate_Offset;
        data["scheduleRunDate_Offset"] = this.scheduleRunDate_Offset;
        data["negativePaymentAllowed"] = this.negativePaymentAllowed;
        data["code"] = this.code;
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        data["frequencyRule"] = this.frequencyRule ? this.frequencyRule.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        data["row_version"] = this.row_version;
        return data; 
    }

    clone(): PayrollType {
        const json = this.toJSON();
        let result = new PayrollType();
        result.init(json);
        return result;
    }
}

export interface IPayrollType {
    name: string | undefined;
    frequencyRuleId: number;
    firstPeriodEndDate: Date;
    strFirstPeriodEndDate: string | undefined;
    noOfYears: number;
    effectiveDate: Date;
    strEffectiveDate: string | undefined;
    payslipDate_Offset: number;
    scheduleRunDate_Offset: number;
    negativePaymentAllowed: boolean;
    code: string | undefined;
    employees: EmployeeContractAssignment[] | undefined;
    frequencyRule: FrequencyRule;
    id: number;
    company_id: number;
    sub_id: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    row_version: string | undefined;
}

export class PayrollTypeIListApiResult implements IPayrollTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayrollType[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPayrollTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PayrollType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PayrollTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PayrollTypeIListApiResult {
        const json = this.toJSON();
        let result = new PayrollTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayrollTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayrollType[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class FrequencyRuleIListApiResult implements IFrequencyRuleIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: FrequencyRule[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IFrequencyRuleIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(FrequencyRule.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): FrequencyRuleIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new FrequencyRuleIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): FrequencyRuleIListApiResult {
        const json = this.toJSON();
        let result = new FrequencyRuleIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IFrequencyRuleIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: FrequencyRule[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class Institution implements IInstitution {
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IInstitution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Institution {
        data = typeof data === 'object' ? data : {};
        let result = new Institution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Institution {
        const json = this.toJSON();
        let result = new Institution();
        result.init(json);
        return result;
    }
}

export interface IInstitution {
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class InstitutionIListApiResult implements IInstitutionIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Institution[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IInstitutionIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Institution.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): InstitutionIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): InstitutionIListApiResult {
        const json = this.toJSON();
        let result = new InstitutionIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IInstitutionIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Institution[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class Skill implements ISkill {
    sectorId!: number;
    name!: string | undefined;
    sector!: string | undefined;
    point!: number | undefined;
    employeeSkills!: EmployeeSkill[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISkill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sectorId = _data["sectorId"];
            this.name = _data["name"];
            this.sector = _data["sector"];
            this.point = _data["point"];
            if (Array.isArray(_data["employeeSkills"])) {
                this.employeeSkills = [] as any;
                for (let item of _data["employeeSkills"])
                    this.employeeSkills!.push(EmployeeSkill.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Skill {
        data = typeof data === 'object' ? data : {};
        let result = new Skill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectorId"] = this.sectorId;
        data["name"] = this.name;
        data["sector"] = this.sector;
        data["point"] = this.point;
        if (Array.isArray(this.employeeSkills)) {
            data["employeeSkills"] = [];
            for (let item of this.employeeSkills)
                data["employeeSkills"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Skill {
        const json = this.toJSON();
        let result = new Skill();
        result.init(json);
        return result;
    }
}

export interface ISkill {
    sectorId: number;
    name: string | undefined;
    sector: string | undefined;
    point: number | undefined;
    employeeSkills: EmployeeSkill[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeSkill implements IEmployeeSkill {
    employeeId!: number;
    skillId!: number;
    skillName!: string | undefined;
    startDate!: Date | undefined;
    numberOfExperienceInMonth!: number | undefined;
    point!: number | undefined;
    employee!: Employee;
    skill!: Skill;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeSkill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.skillId = _data["skillId"];
            this.skillName = _data["skillName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.numberOfExperienceInMonth = _data["numberOfExperienceInMonth"];
            this.point = _data["point"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.skill = _data["skill"] ? Skill.fromJS(_data["skill"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeSkill {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeSkill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["skillId"] = this.skillId;
        data["skillName"] = this.skillName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["numberOfExperienceInMonth"] = this.numberOfExperienceInMonth;
        data["point"] = this.point;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["skill"] = this.skill ? this.skill.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeSkill {
        const json = this.toJSON();
        let result = new EmployeeSkill();
        result.init(json);
        return result;
    }
}

export interface IEmployeeSkill {
    employeeId: number;
    skillId: number;
    skillName: string | undefined;
    startDate: Date | undefined;
    numberOfExperienceInMonth: number | undefined;
    point: number | undefined;
    employee: Employee;
    skill: Skill;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ProfessionalBody implements IProfessionalBody {
    sectorId!: number;
    name!: string | undefined;
    code!: string | undefined;
    website!: string | undefined;
    certifications!: Certification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IProfessionalBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sectorId = _data["sectorId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.website = _data["website"];
            if (Array.isArray(_data["certifications"])) {
                this.certifications = [] as any;
                for (let item of _data["certifications"])
                    this.certifications!.push(Certification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ProfessionalBody {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectorId"] = this.sectorId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["website"] = this.website;
        if (Array.isArray(this.certifications)) {
            data["certifications"] = [];
            for (let item of this.certifications)
                data["certifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ProfessionalBody {
        const json = this.toJSON();
        let result = new ProfessionalBody();
        result.init(json);
        return result;
    }
}

export interface IProfessionalBody {
    sectorId: number;
    name: string | undefined;
    code: string | undefined;
    website: string | undefined;
    certifications: Certification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Certification implements ICertification {
    professionalBodyId!: number;
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    professionalBody!: ProfessionalBody;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.professionalBodyId = _data["professionalBodyId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            this.professionalBody = _data["professionalBody"] ? ProfessionalBody.fromJS(_data["professionalBody"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Certification {
        data = typeof data === 'object' ? data : {};
        let result = new Certification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["professionalBodyId"] = this.professionalBodyId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        data["professionalBody"] = this.professionalBody ? this.professionalBody.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Certification {
        const json = this.toJSON();
        let result = new Certification();
        result.init(json);
        return result;
    }
}

export interface ICertification {
    professionalBodyId: number;
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    professionalBody: ProfessionalBody;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeCertification implements IEmployeeCertification {
    employeeId!: number;
    certificationId!: number;
    institution!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    comment!: string | undefined;
    numberOfExperienceInMonth!: number | undefined;
    certification!: Certification;
    employee!: Employee;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeCertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.certificationId = _data["certificationId"];
            this.institution = _data["institution"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.numberOfExperienceInMonth = _data["numberOfExperienceInMonth"];
            this.certification = _data["certification"] ? Certification.fromJS(_data["certification"]) : <any>undefined;
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeCertification {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeCertification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["certificationId"] = this.certificationId;
        data["institution"] = this.institution;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["numberOfExperienceInMonth"] = this.numberOfExperienceInMonth;
        data["certification"] = this.certification ? this.certification.toJSON() : <any>undefined;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeCertification {
        const json = this.toJSON();
        let result = new EmployeeCertification();
        result.init(json);
        return result;
    }
}

export interface IEmployeeCertification {
    employeeId: number;
    certificationId: number;
    institution: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    comment: string | undefined;
    numberOfExperienceInMonth: number | undefined;
    certification: Certification;
    employee: Employee;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class State implements IState {
    country_id!: number;
    state_name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.country_id = _data["country_id"];
            this.state_name = _data["state_name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): State {
        data = typeof data === 'object' ? data : {};
        let result = new State();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country_id"] = this.country_id;
        data["state_name"] = this.state_name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): State {
        const json = this.toJSON();
        let result = new State();
        result.init(json);
        return result;
    }
}

export interface IState {
    country_id: number;
    state_name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LGA implements ILGA {
    state_id!: number | undefined;
    lga_name!: string | undefined;
    directorate_id!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILGA) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state_id = _data["state_id"];
            this.lga_name = _data["lga_name"];
            this.directorate_id = _data["directorate_id"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LGA {
        data = typeof data === 'object' ? data : {};
        let result = new LGA();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state_id"] = this.state_id;
        data["lga_name"] = this.lga_name;
        data["directorate_id"] = this.directorate_id;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LGA {
        const json = this.toJSON();
        let result = new LGA();
        result.init(json);
        return result;
    }
}

export interface ILGA {
    state_id: number | undefined;
    lga_name: string | undefined;
    directorate_id: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Address implements IAddress {
    employee_id!: number;
    country_id!: number;
    state_id!: number;
    lga_id!: number;
    address1!: string | undefined;
    address2!: string | undefined;
    address_type!: number;
    is_primary_address!: boolean;
    employee!: Employee;
    state!: State;
    lga!: LGA;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employee_id = _data["employee_id"];
            this.country_id = _data["country_id"];
            this.state_id = _data["state_id"];
            this.lga_id = _data["lga_id"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.address_type = _data["address_type"];
            this.is_primary_address = _data["is_primary_address"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.state = _data["state"] ? State.fromJS(_data["state"]) : <any>undefined;
            this.lga = _data["lga"] ? LGA.fromJS(_data["lga"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employee_id"] = this.employee_id;
        data["country_id"] = this.country_id;
        data["state_id"] = this.state_id;
        data["lga_id"] = this.lga_id;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["address_type"] = this.address_type;
        data["is_primary_address"] = this.is_primary_address;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["lga"] = this.lga ? this.lga.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Address {
        const json = this.toJSON();
        let result = new Address();
        result.init(json);
        return result;
    }
}

export interface IAddress {
    employee_id: number;
    country_id: number;
    state_id: number;
    lga_id: number;
    address1: string | undefined;
    address2: string | undefined;
    address_type: number;
    is_primary_address: boolean;
    employee: Employee;
    state: State;
    lga: LGA;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Employee implements IEmployee {
    userId!: number;
    titleId!: number;
    religionId!: number | undefined;
    serialNo!: string | undefined;
    firstName!: string;
    lastName!: string;
    otherNames!: string | undefined;
    employeeNumber!: string;
    dateOfBirth!: Date | undefined;
    maritalStatusId!: number;
    genderId!: number;
    lasraaNumber!: string | undefined;
    regNo!: string | undefined;
    estabFileNo!: string | undefined;
    personalEmail!: string | undefined;
    workEmail!: string | undefined;
    fullName!: string | undefined;
    peopleGroupId!: number | undefined;
    niNumber!: string | undefined;
    profilePic!: string | undefined;
    workMobile!: string | undefined;
    defaultMobile!: string | undefined;
    subjectSpecialization!: string | undefined;
    selfServiceStatus!: string | undefined;
    employmentStatusId!: number | undefined;
    pensionerFileNo!: string | undefined;
    pfaId!: number | undefined;
    rsaNumber!: string | undefined;
    stateOfOrigion!: string | undefined;
    lgaOfOrigion!: string | undefined;
    internalAddressLine!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    originCountry!: number | undefined;
    originState!: number | undefined;
    residentialCountry!: number | undefined;
    residentialState!: number | undefined;
    residentialLga!: number | undefined;
    residentialAddress!: string | undefined;
    created_by!: string | undefined;
    bvn!: string | undefined;
    bvnStatus!: number;
    bvnValidationResponse!: string | undefined;
    lastBVNValidation!: Date | undefined;
    deviceId!: number | undefined;
    employeeSkills!: EmployeeSkill[] | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    employeeCertifications!: EmployeeCertification[] | undefined;
    addresses!: Address[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.titleId = _data["titleId"];
            this.religionId = _data["religionId"];
            this.serialNo = _data["serialNo"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherNames = _data["otherNames"];
            this.employeeNumber = _data["employeeNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.maritalStatusId = _data["maritalStatusId"];
            this.genderId = _data["genderId"];
            this.lasraaNumber = _data["lasraaNumber"];
            this.regNo = _data["regNo"];
            this.estabFileNo = _data["estabFileNo"];
            this.personalEmail = _data["personalEmail"];
            this.workEmail = _data["workEmail"];
            this.fullName = _data["fullName"];
            this.peopleGroupId = _data["peopleGroupId"];
            this.niNumber = _data["niNumber"];
            this.profilePic = _data["profilePic"];
            this.workMobile = _data["workMobile"];
            this.defaultMobile = _data["defaultMobile"];
            this.subjectSpecialization = _data["subjectSpecialization"];
            this.selfServiceStatus = _data["selfServiceStatus"];
            this.employmentStatusId = _data["employmentStatusId"];
            this.pensionerFileNo = _data["pensionerFileNo"];
            this.pfaId = _data["pfaId"];
            this.rsaNumber = _data["rsaNumber"];
            this.stateOfOrigion = _data["stateOfOrigion"];
            this.lgaOfOrigion = _data["lgaOfOrigion"];
            this.internalAddressLine = _data["internalAddressLine"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.originCountry = _data["originCountry"];
            this.originState = _data["originState"];
            this.residentialCountry = _data["residentialCountry"];
            this.residentialState = _data["residentialState"];
            this.residentialLga = _data["residentialLga"];
            this.residentialAddress = _data["residentialAddress"];
            this.created_by = _data["created_by"];
            this.bvn = _data["bvn"];
            this.bvnStatus = _data["bvnStatus"];
            this.bvnValidationResponse = _data["bvnValidationResponse"];
            this.lastBVNValidation = _data["lastBVNValidation"] ? new Date(_data["lastBVNValidation"].toString()) : <any>undefined;
            this.deviceId = _data["deviceId"];
            if (Array.isArray(_data["employeeSkills"])) {
                this.employeeSkills = [] as any;
                for (let item of _data["employeeSkills"])
                    this.employeeSkills!.push(EmployeeSkill.fromJS(item));
            }
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            if (Array.isArray(_data["employeeCertifications"])) {
                this.employeeCertifications = [] as any;
                for (let item of _data["employeeCertifications"])
                    this.employeeCertifications!.push(EmployeeCertification.fromJS(item));
            }
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(Address.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Employee {
        data = typeof data === 'object' ? data : {};
        let result = new Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["titleId"] = this.titleId;
        data["religionId"] = this.religionId;
        data["serialNo"] = this.serialNo;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherNames"] = this.otherNames;
        data["employeeNumber"] = this.employeeNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["maritalStatusId"] = this.maritalStatusId;
        data["genderId"] = this.genderId;
        data["lasraaNumber"] = this.lasraaNumber;
        data["regNo"] = this.regNo;
        data["estabFileNo"] = this.estabFileNo;
        data["personalEmail"] = this.personalEmail;
        data["workEmail"] = this.workEmail;
        data["fullName"] = this.fullName;
        data["peopleGroupId"] = this.peopleGroupId;
        data["niNumber"] = this.niNumber;
        data["profilePic"] = this.profilePic;
        data["workMobile"] = this.workMobile;
        data["defaultMobile"] = this.defaultMobile;
        data["subjectSpecialization"] = this.subjectSpecialization;
        data["selfServiceStatus"] = this.selfServiceStatus;
        data["employmentStatusId"] = this.employmentStatusId;
        data["pensionerFileNo"] = this.pensionerFileNo;
        data["pfaId"] = this.pfaId;
        data["rsaNumber"] = this.rsaNumber;
        data["stateOfOrigion"] = this.stateOfOrigion;
        data["lgaOfOrigion"] = this.lgaOfOrigion;
        data["internalAddressLine"] = this.internalAddressLine;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["originCountry"] = this.originCountry;
        data["originState"] = this.originState;
        data["residentialCountry"] = this.residentialCountry;
        data["residentialState"] = this.residentialState;
        data["residentialLga"] = this.residentialLga;
        data["residentialAddress"] = this.residentialAddress;
        data["created_by"] = this.created_by;
        data["bvn"] = this.bvn;
        data["bvnStatus"] = this.bvnStatus;
        data["bvnValidationResponse"] = this.bvnValidationResponse;
        data["lastBVNValidation"] = this.lastBVNValidation ? this.lastBVNValidation.toISOString() : <any>undefined;
        data["deviceId"] = this.deviceId;
        if (Array.isArray(this.employeeSkills)) {
            data["employeeSkills"] = [];
            for (let item of this.employeeSkills)
                data["employeeSkills"].push(item.toJSON());
        }
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        if (Array.isArray(this.employeeCertifications)) {
            data["employeeCertifications"] = [];
            for (let item of this.employeeCertifications)
                data["employeeCertifications"].push(item.toJSON());
        }
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Employee {
        const json = this.toJSON();
        let result = new Employee();
        result.init(json);
        return result;
    }
}

export interface IEmployee {
    userId: number;
    titleId: number;
    religionId: number | undefined;
    serialNo: string | undefined;
    firstName: string;
    lastName: string;
    otherNames: string | undefined;
    employeeNumber: string;
    dateOfBirth: Date | undefined;
    maritalStatusId: number;
    genderId: number;
    lasraaNumber: string | undefined;
    regNo: string | undefined;
    estabFileNo: string | undefined;
    personalEmail: string | undefined;
    workEmail: string | undefined;
    fullName: string | undefined;
    peopleGroupId: number | undefined;
    niNumber: string | undefined;
    profilePic: string | undefined;
    workMobile: string | undefined;
    defaultMobile: string | undefined;
    subjectSpecialization: string | undefined;
    selfServiceStatus: string | undefined;
    employmentStatusId: number | undefined;
    pensionerFileNo: string | undefined;
    pfaId: number | undefined;
    rsaNumber: string | undefined;
    stateOfOrigion: string | undefined;
    lgaOfOrigion: string | undefined;
    internalAddressLine: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    originCountry: number | undefined;
    originState: number | undefined;
    residentialCountry: number | undefined;
    residentialState: number | undefined;
    residentialLga: number | undefined;
    residentialAddress: string | undefined;
    created_by: string | undefined;
    bvn: string | undefined;
    bvnStatus: number;
    bvnValidationResponse: string | undefined;
    lastBVNValidation: Date | undefined;
    deviceId: number | undefined;
    employeeSkills: EmployeeSkill[] | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    employeeCertifications: EmployeeCertification[] | undefined;
    addresses: Address[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class QualificationGrade implements IQualificationGrade {
    name!: string | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IQualificationGrade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): QualificationGrade {
        data = typeof data === 'object' ? data : {};
        let result = new QualificationGrade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): QualificationGrade {
        const json = this.toJSON();
        let result = new QualificationGrade();
        result.init(json);
        return result;
    }
}

export interface IQualificationGrade {
    name: string | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Qualification implements IQualification {
    categoryId!: number;
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IQualification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Qualification {
        data = typeof data === 'object' ? data : {};
        let result = new Qualification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Qualification {
        const json = this.toJSON();
        let result = new Qualification();
        result.init(json);
        return result;
    }
}

export interface IQualification {
    categoryId: number;
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeQualification implements IEmployeeQualification {
    employeeId!: number;
    name!: string;
    typeId!: number;
    type!: string;
    qualificationId!: number;
    qualificationGradeId!: number;
    courseId!: number;
    courseName!: string | undefined;
    institutionId!: number;
    grade!: string | undefined;
    startdate!: Date | undefined;
    stopdate!: Date | undefined;
    comment!: string | undefined;
    is_professional!: number | undefined;
    employee!: Employee;
    course!: Course;
    qualificationGrade!: QualificationGrade;
    qualification!: Qualification;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeQualification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.type = _data["type"];
            this.qualificationId = _data["qualificationId"];
            this.qualificationGradeId = _data["qualificationGradeId"];
            this.courseId = _data["courseId"];
            this.courseName = _data["courseName"];
            this.institutionId = _data["institutionId"];
            this.grade = _data["grade"];
            this.startdate = _data["startdate"] ? new Date(_data["startdate"].toString()) : <any>undefined;
            this.stopdate = _data["stopdate"] ? new Date(_data["stopdate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.is_professional = _data["is_professional"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.qualificationGrade = _data["qualificationGrade"] ? QualificationGrade.fromJS(_data["qualificationGrade"]) : <any>undefined;
            this.qualification = _data["qualification"] ? Qualification.fromJS(_data["qualification"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeQualification {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeQualification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["type"] = this.type;
        data["qualificationId"] = this.qualificationId;
        data["qualificationGradeId"] = this.qualificationGradeId;
        data["courseId"] = this.courseId;
        data["courseName"] = this.courseName;
        data["institutionId"] = this.institutionId;
        data["grade"] = this.grade;
        data["startdate"] = this.startdate ? this.startdate.toISOString() : <any>undefined;
        data["stopdate"] = this.stopdate ? this.stopdate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["is_professional"] = this.is_professional;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["qualificationGrade"] = this.qualificationGrade ? this.qualificationGrade.toJSON() : <any>undefined;
        data["qualification"] = this.qualification ? this.qualification.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeQualification {
        const json = this.toJSON();
        let result = new EmployeeQualification();
        result.init(json);
        return result;
    }
}

export interface IEmployeeQualification {
    employeeId: number;
    name: string;
    typeId: number;
    type: string;
    qualificationId: number;
    qualificationGradeId: number;
    courseId: number;
    courseName: string | undefined;
    institutionId: number;
    grade: string | undefined;
    startdate: Date | undefined;
    stopdate: Date | undefined;
    comment: string | undefined;
    is_professional: number | undefined;
    employee: Employee;
    course: Course;
    qualificationGrade: QualificationGrade;
    qualification: Qualification;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Course implements ICourse {
    name!: string | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Course {
        const json = this.toJSON();
        let result = new Course();
        result.init(json);
        return result;
    }
}

export interface ICourse {
    name: string | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CourseIListApiResult implements ICourseIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Course[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICourseIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Course.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CourseIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CourseIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CourseIListApiResult {
        const json = this.toJSON();
        let result = new CourseIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICourseIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Course[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class QualificationIListApiResult implements IQualificationIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Qualification[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IQualificationIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Qualification.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): QualificationIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new QualificationIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): QualificationIListApiResult {
        const json = this.toJSON();
        let result = new QualificationIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IQualificationIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Qualification[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ChannelParameter implements IChannelParameter {
    channelId!: number;
    name!: string | undefined;
    value!: string | undefined;
    urlType!: number;
    type!: number;
    mode!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IChannelParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.channelId = _data["channelId"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.urlType = _data["urlType"];
            this.type = _data["type"];
            this.mode = _data["mode"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ChannelParameter {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["channelId"] = this.channelId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["urlType"] = this.urlType;
        data["type"] = this.type;
        data["mode"] = this.mode;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ChannelParameter {
        const json = this.toJSON();
        let result = new ChannelParameter();
        result.init(json);
        return result;
    }
}

export interface IChannelParameter {
    channelId: number;
    name: string | undefined;
    value: string | undefined;
    urlType: number;
    type: number;
    mode: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Channel implements IChannel {
    name!: string | undefined;
    channelParameters!: ChannelParameter[] | undefined;
    fundDisbursements!: FundDisbursement[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IChannel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["channelParameters"])) {
                this.channelParameters = [] as any;
                for (let item of _data["channelParameters"])
                    this.channelParameters!.push(ChannelParameter.fromJS(item));
            }
            if (Array.isArray(_data["fundDisbursements"])) {
                this.fundDisbursements = [] as any;
                for (let item of _data["fundDisbursements"])
                    this.fundDisbursements!.push(FundDisbursement.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Channel {
        data = typeof data === 'object' ? data : {};
        let result = new Channel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.channelParameters)) {
            data["channelParameters"] = [];
            for (let item of this.channelParameters)
                data["channelParameters"].push(item.toJSON());
        }
        if (Array.isArray(this.fundDisbursements)) {
            data["fundDisbursements"] = [];
            for (let item of this.fundDisbursements)
                data["fundDisbursements"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Channel {
        const json = this.toJSON();
        let result = new Channel();
        result.init(json);
        return result;
    }
}

export interface IChannel {
    name: string | undefined;
    channelParameters: ChannelParameter[] | undefined;
    fundDisbursements: FundDisbursement[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ChannelIListApiResult implements IChannelIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Channel[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IChannelIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Channel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ChannelIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ChannelIListApiResult {
        const json = this.toJSON();
        let result = new ChannelIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IChannelIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Channel[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class SkillIListApiResult implements ISkillIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Skill[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISkillIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Skill.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SkillIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SkillIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SkillIListApiResult {
        const json = this.toJSON();
        let result = new SkillIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISkillIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Skill[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class Sector implements ISector {
    name!: string | undefined;
    skills!: Skill[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISector) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(Skill.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Sector {
        data = typeof data === 'object' ? data : {};
        let result = new Sector();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Sector {
        const json = this.toJSON();
        let result = new Sector();
        result.init(json);
        return result;
    }
}

export interface ISector {
    name: string | undefined;
    skills: Skill[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class SectorIListApiResult implements ISectorIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Sector[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISectorIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Sector.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SectorIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SectorIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SectorIListApiResult {
        const json = this.toJSON();
        let result = new SectorIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISectorIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Sector[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ProfessionalBodyIListApiResult implements IProfessionalBodyIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ProfessionalBody[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IProfessionalBodyIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ProfessionalBody.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ProfessionalBodyIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalBodyIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ProfessionalBodyIListApiResult {
        const json = this.toJSON();
        let result = new ProfessionalBodyIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IProfessionalBodyIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ProfessionalBody[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class CertificationIListApiResult implements ICertificationIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Certification[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICertificationIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Certification.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CertificationIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CertificationIListApiResult {
        const json = this.toJSON();
        let result = new CertificationIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICertificationIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Certification[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class TenantBeneficiary implements ITenantBeneficiary {
    accountNo!: string | undefined;
    accountName!: string | undefined;
    bankId!: number;
    bankName!: string | undefined;
    bankCode!: string | undefined;
    initiatedById!: number;
    initiatedBy!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ITenantBeneficiary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountNo = _data["accountNo"];
            this.accountName = _data["accountName"];
            this.bankId = _data["bankId"];
            this.bankName = _data["bankName"];
            this.bankCode = _data["bankCode"];
            this.initiatedById = _data["initiatedById"];
            this.initiatedBy = _data["initiatedBy"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): TenantBeneficiary {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBeneficiary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountNo"] = this.accountNo;
        data["accountName"] = this.accountName;
        data["bankId"] = this.bankId;
        data["bankName"] = this.bankName;
        data["bankCode"] = this.bankCode;
        data["initiatedById"] = this.initiatedById;
        data["initiatedBy"] = this.initiatedBy;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): TenantBeneficiary {
        const json = this.toJSON();
        let result = new TenantBeneficiary();
        result.init(json);
        return result;
    }
}

export interface ITenantBeneficiary {
    accountNo: string | undefined;
    accountName: string | undefined;
    bankId: number;
    bankName: string | undefined;
    bankCode: string | undefined;
    initiatedById: number;
    initiatedBy: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class TenantBeneficiaryIListApiResult implements ITenantBeneficiaryIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TenantBeneficiary[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ITenantBeneficiaryIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TenantBeneficiary.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): TenantBeneficiaryIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBeneficiaryIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): TenantBeneficiaryIListApiResult {
        const json = this.toJSON();
        let result = new TenantBeneficiaryIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITenantBeneficiaryIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TenantBeneficiary[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class DeploymentLog implements IDeploymentLog {
    employeeContractid!: number;
    refNo!: string | undefined;
    comment!: string;
    request_by!: string | undefined;
    is_new!: boolean;
    last_deployment_date!: Date | undefined;
    current_location_id!: number;
    current_school_id!: number | undefined;
    current_ministry_id!: number | undefined;
    justification!: string | undefined;
    requested_location_id!: number;
    requested_school_id!: number | undefined;
    requested_ministry_id!: number | undefined;
    log_status!: number;
    bulkaction_id!: number | undefined;
    request_date!: Date;
    effective_date!: Date | undefined;
    is_treated!: boolean | undefined;
    fileName!: string | undefined;
    filePath!: string | undefined;
    location!: Location;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDeploymentLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeContractid = _data["employeeContractid"];
            this.refNo = _data["refNo"];
            this.comment = _data["comment"];
            this.request_by = _data["request_by"];
            this.is_new = _data["is_new"];
            this.last_deployment_date = _data["last_deployment_date"] ? new Date(_data["last_deployment_date"].toString()) : <any>undefined;
            this.current_location_id = _data["current_location_id"];
            this.current_school_id = _data["current_school_id"];
            this.current_ministry_id = _data["current_ministry_id"];
            this.justification = _data["justification"];
            this.requested_location_id = _data["requested_location_id"];
            this.requested_school_id = _data["requested_school_id"];
            this.requested_ministry_id = _data["requested_ministry_id"];
            this.log_status = _data["log_status"];
            this.bulkaction_id = _data["bulkaction_id"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.effective_date = _data["effective_date"] ? new Date(_data["effective_date"].toString()) : <any>undefined;
            this.is_treated = _data["is_treated"];
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DeploymentLog {
        data = typeof data === 'object' ? data : {};
        let result = new DeploymentLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeContractid"] = this.employeeContractid;
        data["refNo"] = this.refNo;
        data["comment"] = this.comment;
        data["request_by"] = this.request_by;
        data["is_new"] = this.is_new;
        data["last_deployment_date"] = this.last_deployment_date ? this.last_deployment_date.toISOString() : <any>undefined;
        data["current_location_id"] = this.current_location_id;
        data["current_school_id"] = this.current_school_id;
        data["current_ministry_id"] = this.current_ministry_id;
        data["justification"] = this.justification;
        data["requested_location_id"] = this.requested_location_id;
        data["requested_school_id"] = this.requested_school_id;
        data["requested_ministry_id"] = this.requested_ministry_id;
        data["log_status"] = this.log_status;
        data["bulkaction_id"] = this.bulkaction_id;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["effective_date"] = this.effective_date ? this.effective_date.toISOString() : <any>undefined;
        data["is_treated"] = this.is_treated;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DeploymentLog {
        const json = this.toJSON();
        let result = new DeploymentLog();
        result.init(json);
        return result;
    }
}

export interface IDeploymentLog {
    employeeContractid: number;
    refNo: string | undefined;
    comment: string;
    request_by: string | undefined;
    is_new: boolean;
    last_deployment_date: Date | undefined;
    current_location_id: number;
    current_school_id: number | undefined;
    current_ministry_id: number | undefined;
    justification: string | undefined;
    requested_location_id: number;
    requested_school_id: number | undefined;
    requested_ministry_id: number | undefined;
    log_status: number;
    bulkaction_id: number | undefined;
    request_date: Date;
    effective_date: Date | undefined;
    is_treated: boolean | undefined;
    fileName: string | undefined;
    filePath: string | undefined;
    location: Location;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Location implements ILocation {
    location_name!: string;
    lga_id!: number | undefined;
    state_id!: number | undefined;
    is_enabled!: boolean;
    deploymentLogs!: DeploymentLog[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location_name = _data["location_name"];
            this.lga_id = _data["lga_id"];
            this.state_id = _data["state_id"];
            this.is_enabled = _data["is_enabled"];
            if (Array.isArray(_data["deploymentLogs"])) {
                this.deploymentLogs = [] as any;
                for (let item of _data["deploymentLogs"])
                    this.deploymentLogs!.push(DeploymentLog.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location_name"] = this.location_name;
        data["lga_id"] = this.lga_id;
        data["state_id"] = this.state_id;
        data["is_enabled"] = this.is_enabled;
        if (Array.isArray(this.deploymentLogs)) {
            data["deploymentLogs"] = [];
            for (let item of this.deploymentLogs)
                data["deploymentLogs"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Location {
        const json = this.toJSON();
        let result = new Location();
        result.init(json);
        return result;
    }
}

export interface ILocation {
    location_name: string;
    lga_id: number | undefined;
    state_id: number | undefined;
    is_enabled: boolean;
    deploymentLogs: DeploymentLog[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LocationIListApiResult implements ILocationIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Location[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILocationIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Location.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LocationIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LocationIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LocationIListApiResult {
        const json = this.toJSON();
        let result = new LocationIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILocationIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Location[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class DepartmentIListApiResult implements IDepartmentIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Department[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDepartmentIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Department.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DepartmentIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DepartmentIListApiResult {
        const json = this.toJSON();
        let result = new DepartmentIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDepartmentIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Department[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class JobRole implements IJobRole {
    name!: string;
    code!: string | undefined;
    amount!: number | undefined;
    promotion_min_years!: number | undefined;
    next_job_role_id!: number | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    parent_id!: number | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IJobRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.amount = _data["amount"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.next_job_role_id = _data["next_job_role_id"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.parent_id = _data["parent_id"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): JobRole {
        data = typeof data === 'object' ? data : {};
        let result = new JobRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["amount"] = this.amount;
        data["promotion_min_years"] = this.promotion_min_years;
        data["next_job_role_id"] = this.next_job_role_id;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["parent_id"] = this.parent_id;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): JobRole {
        const json = this.toJSON();
        let result = new JobRole();
        result.init(json);
        return result;
    }
}

export interface IJobRole {
    name: string;
    code: string | undefined;
    amount: number | undefined;
    promotion_min_years: number | undefined;
    next_job_role_id: number | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    parent_id: number | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class JobRoleIListApiResult implements IJobRoleIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: JobRole[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IJobRoleIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(JobRole.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): JobRoleIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobRoleIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): JobRoleIListApiResult {
        const json = this.toJSON();
        let result = new JobRoleIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IJobRoleIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: JobRole[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class Event implements IEvent {
    eventTypeID!: number;
    title!: string | undefined;
    isSystem!: boolean;
    notify_Employee!: boolean;
    description!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventTypeID = _data["eventTypeID"];
            this.title = _data["title"];
            this.isSystem = _data["isSystem"];
            this.notify_Employee = _data["notify_Employee"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Event {
        data = typeof data === 'object' ? data : {};
        let result = new Event();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventTypeID"] = this.eventTypeID;
        data["title"] = this.title;
        data["isSystem"] = this.isSystem;
        data["notify_Employee"] = this.notify_Employee;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Event {
        const json = this.toJSON();
        let result = new Event();
        result.init(json);
        return result;
    }
}

export interface IEvent {
    eventTypeID: number;
    title: string | undefined;
    isSystem: boolean;
    notify_Employee: boolean;
    description: string | undefined;
    startDate: Date;
    endDate: Date;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EventIListApiResult implements IEventIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Event[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEventIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Event.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EventIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EventIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EventIListApiResult {
        const json = this.toJSON();
        let result = new EventIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEventIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Event[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class PositionRequirement implements IPositionRequirement {
    positionId!: number;
    requirementId!: number;
    requirementValue!: string | undefined;
    requirementTypeId!: number;
    requirementTypeName!: string | undefined;
    position!: Position;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IPositionRequirement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.positionId = _data["positionId"];
            this.requirementId = _data["requirementId"];
            this.requirementValue = _data["requirementValue"];
            this.requirementTypeId = _data["requirementTypeId"];
            this.requirementTypeName = _data["requirementTypeName"];
            this.position = _data["position"] ? Position.fromJS(_data["position"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): PositionRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new PositionRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["positionId"] = this.positionId;
        data["requirementId"] = this.requirementId;
        data["requirementValue"] = this.requirementValue;
        data["requirementTypeId"] = this.requirementTypeId;
        data["requirementTypeName"] = this.requirementTypeName;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): PositionRequirement {
        const json = this.toJSON();
        let result = new PositionRequirement();
        result.init(json);
        return result;
    }
}

export interface IPositionRequirement {
    positionId: number;
    requirementId: number;
    requirementValue: string | undefined;
    requirementTypeId: number;
    requirementTypeName: string | undefined;
    position: Position;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Position implements IPosition {
    title!: string | undefined;
    amount!: number | undefined;
    promotion_min_years!: number | undefined;
    min_years_experience!: number | undefined;
    min_years_experience_in_days!: number | undefined;
    promotion_min_in_days!: number;
    next_position_id!: number | undefined;
    description!: string | undefined;
    parent_id!: number | undefined;
    has_requirement!: boolean;
    positionRequirements!: PositionRequirement[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.amount = _data["amount"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.min_years_experience = _data["min_years_experience"];
            this.min_years_experience_in_days = _data["min_years_experience_in_days"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.next_position_id = _data["next_position_id"];
            this.description = _data["description"];
            this.parent_id = _data["parent_id"];
            this.has_requirement = _data["has_requirement"];
            if (Array.isArray(_data["positionRequirements"])) {
                this.positionRequirements = [] as any;
                for (let item of _data["positionRequirements"])
                    this.positionRequirements!.push(PositionRequirement.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Position {
        data = typeof data === 'object' ? data : {};
        let result = new Position();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["amount"] = this.amount;
        data["promotion_min_years"] = this.promotion_min_years;
        data["min_years_experience"] = this.min_years_experience;
        data["min_years_experience_in_days"] = this.min_years_experience_in_days;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["next_position_id"] = this.next_position_id;
        data["description"] = this.description;
        data["parent_id"] = this.parent_id;
        data["has_requirement"] = this.has_requirement;
        if (Array.isArray(this.positionRequirements)) {
            data["positionRequirements"] = [];
            for (let item of this.positionRequirements)
                data["positionRequirements"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Position {
        const json = this.toJSON();
        let result = new Position();
        result.init(json);
        return result;
    }
}

export interface IPosition {
    title: string | undefined;
    amount: number | undefined;
    promotion_min_years: number | undefined;
    min_years_experience: number | undefined;
    min_years_experience_in_days: number | undefined;
    promotion_min_in_days: number;
    next_position_id: number | undefined;
    description: string | undefined;
    parent_id: number | undefined;
    has_requirement: boolean;
    positionRequirements: PositionRequirement[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class PositionIListApiResult implements IPositionIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Position[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPositionIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Position.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PositionIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PositionIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PositionIListApiResult {
        const json = this.toJSON();
        let result = new PositionIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPositionIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Position[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class SalaryScale implements ISalaryScale {
    code!: string | undefined;
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISalaryScale) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): SalaryScale {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryScale();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): SalaryScale {
        const json = this.toJSON();
        let result = new SalaryScale();
        result.init(json);
        return result;
    }
}

export interface ISalaryScale {
    code: string | undefined;
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class SalaryScaleIListApiResult implements ISalaryScaleIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SalaryScale[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISalaryScaleIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SalaryScale.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SalaryScaleIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryScaleIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SalaryScaleIListApiResult {
        const json = this.toJSON();
        let result = new SalaryScaleIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISalaryScaleIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SalaryScale[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class Grade implements IGrade {
    name!: string;
    code!: string | undefined;
    created_by!: string | undefined;
    promotion_min_years!: number;
    promotion_min_in_days!: number | undefined;
    noOfLeaveDays!: number;
    salaryScaleId!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IGrade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Grade {
        data = typeof data === 'object' ? data : {};
        let result = new Grade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["promotion_min_years"] = this.promotion_min_years;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["salaryScaleId"] = this.salaryScaleId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Grade {
        const json = this.toJSON();
        let result = new Grade();
        result.init(json);
        return result;
    }
}

export interface IGrade {
    name: string;
    code: string | undefined;
    created_by: string | undefined;
    promotion_min_years: number;
    promotion_min_in_days: number | undefined;
    noOfLeaveDays: number;
    salaryScaleId: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class GradeIListApiResult implements IGradeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Grade[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IGradeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Grade.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): GradeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): GradeIListApiResult {
        const json = this.toJSON();
        let result = new GradeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Grade[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class GradeStep implements IGradeStep {
    grade_id!: number;
    step_no!: number;
    name!: string;
    created_by!: string | undefined;
    promotion_min_years!: number | undefined;
    promotion_min_in_days!: number | undefined;
    ministry_id!: number | undefined;
    next_grade_step_id!: number | undefined;
    grade!: Grade;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IGradeStep) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grade_id = _data["grade_id"];
            this.step_no = _data["step_no"];
            this.name = _data["name"];
            this.created_by = _data["created_by"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.ministry_id = _data["ministry_id"];
            this.next_grade_step_id = _data["next_grade_step_id"];
            this.grade = _data["grade"] ? Grade.fromJS(_data["grade"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): GradeStep {
        data = typeof data === 'object' ? data : {};
        let result = new GradeStep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grade_id"] = this.grade_id;
        data["step_no"] = this.step_no;
        data["name"] = this.name;
        data["created_by"] = this.created_by;
        data["promotion_min_years"] = this.promotion_min_years;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["ministry_id"] = this.ministry_id;
        data["next_grade_step_id"] = this.next_grade_step_id;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): GradeStep {
        const json = this.toJSON();
        let result = new GradeStep();
        result.init(json);
        return result;
    }
}

export interface IGradeStep {
    grade_id: number;
    step_no: number;
    name: string;
    created_by: string | undefined;
    promotion_min_years: number | undefined;
    promotion_min_in_days: number | undefined;
    ministry_id: number | undefined;
    next_grade_step_id: number | undefined;
    grade: Grade;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class GradeStepIListApiResult implements IGradeStepIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: GradeStep[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IGradeStepIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GradeStep.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): GradeStepIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeStepIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): GradeStepIListApiResult {
        const json = this.toJSON();
        let result = new GradeStepIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeStepIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: GradeStep[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class GradeLevelBenefit implements IGradeLevelBenefit {
    salaryScaleId!: number;
    gradeId!: number;
    gradeStepId!: number;
    benefitId!: number;
    amount!: number;
    salaryScaleName!: string | undefined;
    gradeName!: string | undefined;
    stepName!: string | undefined;
    benefitName!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IGradeLevelBenefit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salaryScaleId = _data["salaryScaleId"];
            this.gradeId = _data["gradeId"];
            this.gradeStepId = _data["gradeStepId"];
            this.benefitId = _data["benefitId"];
            this.amount = _data["amount"];
            this.salaryScaleName = _data["salaryScaleName"];
            this.gradeName = _data["gradeName"];
            this.stepName = _data["stepName"];
            this.benefitName = _data["benefitName"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): GradeLevelBenefit {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelBenefit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salaryScaleId"] = this.salaryScaleId;
        data["gradeId"] = this.gradeId;
        data["gradeStepId"] = this.gradeStepId;
        data["benefitId"] = this.benefitId;
        data["amount"] = this.amount;
        data["salaryScaleName"] = this.salaryScaleName;
        data["gradeName"] = this.gradeName;
        data["stepName"] = this.stepName;
        data["benefitName"] = this.benefitName;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): GradeLevelBenefit {
        const json = this.toJSON();
        let result = new GradeLevelBenefit();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelBenefit {
    salaryScaleId: number;
    gradeId: number;
    gradeStepId: number;
    benefitId: number;
    amount: number;
    salaryScaleName: string | undefined;
    gradeName: string | undefined;
    stepName: string | undefined;
    benefitName: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class GradeLevelBenefitIListApiResult implements IGradeLevelBenefitIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: GradeLevelBenefit[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IGradeLevelBenefitIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GradeLevelBenefit.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): GradeLevelBenefitIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelBenefitIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): GradeLevelBenefitIListApiResult {
        const json = this.toJSON();
        let result = new GradeLevelBenefitIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelBenefitIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: GradeLevelBenefit[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RequestType implements IRequestType {
    name!: string;
    typeId!: string | undefined;
    approval!: string | undefined;
    processid!: number;
    code!: string | undefined;
    enable_step_notify!: boolean;
    is_system_requirement!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRequestType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.approval = _data["approval"];
            this.processid = _data["processid"];
            this.code = _data["code"];
            this.enable_step_notify = _data["enable_step_notify"];
            this.is_system_requirement = _data["is_system_requirement"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RequestType {
        data = typeof data === 'object' ? data : {};
        let result = new RequestType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["approval"] = this.approval;
        data["processid"] = this.processid;
        data["code"] = this.code;
        data["enable_step_notify"] = this.enable_step_notify;
        data["is_system_requirement"] = this.is_system_requirement;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RequestType {
        const json = this.toJSON();
        let result = new RequestType();
        result.init(json);
        return result;
    }
}

export interface IRequestType {
    name: string;
    typeId: string | undefined;
    approval: string | undefined;
    processid: number;
    code: string | undefined;
    enable_step_notify: boolean;
    is_system_requirement: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RequestTypeIListApiResult implements IRequestTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestType[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRequestTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RequestType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RequestTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RequestTypeIListApiResult {
        const json = this.toJSON();
        let result = new RequestTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestType[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RequestFile implements IRequestFile {
    request_id!: number;
    filename!: string | undefined;
    filepath!: string | undefined;
    requests!: Request;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRequestFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.request_id = _data["request_id"];
            this.filename = _data["filename"];
            this.filepath = _data["filepath"];
            this.requests = _data["requests"] ? Request.fromJS(_data["requests"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RequestFile {
        data = typeof data === 'object' ? data : {};
        let result = new RequestFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["request_id"] = this.request_id;
        data["filename"] = this.filename;
        data["filepath"] = this.filepath;
        data["requests"] = this.requests ? this.requests.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RequestFile {
        const json = this.toJSON();
        let result = new RequestFile();
        result.init(json);
        return result;
    }
}

export interface IRequestFile {
    request_id: number;
    filename: string | undefined;
    filepath: string | undefined;
    requests: Request;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Request implements IRequest {
    requestTypeId!: number;
    employeeId!: number;
    employeeContractId!: number;
    request_date!: Date;
    title!: string;
    description!: string;
    log_status!: number;
    resolution!: string | undefined;
    temp_resolution!: string | undefined;
    submitted_by!: string | undefined;
    date_resolved!: Date;
    refNo!: string | undefined;
    requestType!: RequestType;
    employees!: Employee;
    employeeContractAssignment!: EmployeeContractAssignment;
    requestFiles!: RequestFile[] | undefined;
    employeeName!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestTypeId = _data["requestTypeId"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.log_status = _data["log_status"];
            this.resolution = _data["resolution"];
            this.temp_resolution = _data["temp_resolution"];
            this.submitted_by = _data["submitted_by"];
            this.date_resolved = _data["date_resolved"] ? new Date(_data["date_resolved"].toString()) : <any>undefined;
            this.refNo = _data["refNo"];
            this.requestType = _data["requestType"] ? RequestType.fromJS(_data["requestType"]) : <any>undefined;
            this.employees = _data["employees"] ? Employee.fromJS(_data["employees"]) : <any>undefined;
            this.employeeContractAssignment = _data["employeeContractAssignment"] ? EmployeeContractAssignment.fromJS(_data["employeeContractAssignment"]) : <any>undefined;
            if (Array.isArray(_data["requestFiles"])) {
                this.requestFiles = [] as any;
                for (let item of _data["requestFiles"])
                    this.requestFiles!.push(RequestFile.fromJS(item));
            }
            this.employeeName = _data["employeeName"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestTypeId"] = this.requestTypeId;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["log_status"] = this.log_status;
        data["resolution"] = this.resolution;
        data["temp_resolution"] = this.temp_resolution;
        data["submitted_by"] = this.submitted_by;
        data["date_resolved"] = this.date_resolved ? this.date_resolved.toISOString() : <any>undefined;
        data["refNo"] = this.refNo;
        data["requestType"] = this.requestType ? this.requestType.toJSON() : <any>undefined;
        data["employees"] = this.employees ? this.employees.toJSON() : <any>undefined;
        data["employeeContractAssignment"] = this.employeeContractAssignment ? this.employeeContractAssignment.toJSON() : <any>undefined;
        if (Array.isArray(this.requestFiles)) {
            data["requestFiles"] = [];
            for (let item of this.requestFiles)
                data["requestFiles"].push(item.toJSON());
        }
        data["employeeName"] = this.employeeName;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Request {
        const json = this.toJSON();
        let result = new Request();
        result.init(json);
        return result;
    }
}

export interface IRequest {
    requestTypeId: number;
    employeeId: number;
    employeeContractId: number;
    request_date: Date;
    title: string;
    description: string;
    log_status: number;
    resolution: string | undefined;
    temp_resolution: string | undefined;
    submitted_by: string | undefined;
    date_resolved: Date;
    refNo: string | undefined;
    requestType: RequestType;
    employees: Employee;
    employeeContractAssignment: EmployeeContractAssignment;
    requestFiles: RequestFile[] | undefined;
    employeeName: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RequestIListApiResult implements IRequestIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Request[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRequestIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Request.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RequestIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RequestIListApiResult {
        const json = this.toJSON();
        let result = new RequestIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Request[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RetirementDocAttachment implements IRetirementDocAttachment {
    id!: number;
    retirementId!: number;
    documentName!: string | undefined;
    docUrl!: string | undefined;
    retirement!: Retirement;

    constructor(data?: IRetirementDocAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.retirementId = _data["retirementId"];
            this.documentName = _data["documentName"];
            this.docUrl = _data["docUrl"];
            this.retirement = _data["retirement"] ? Retirement.fromJS(_data["retirement"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RetirementDocAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementDocAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["retirementId"] = this.retirementId;
        data["documentName"] = this.documentName;
        data["docUrl"] = this.docUrl;
        data["retirement"] = this.retirement ? this.retirement.toJSON() : <any>undefined;
        return data; 
    }

    clone(): RetirementDocAttachment {
        const json = this.toJSON();
        let result = new RetirementDocAttachment();
        result.init(json);
        return result;
    }
}

export interface IRetirementDocAttachment {
    id: number;
    retirementId: number;
    documentName: string | undefined;
    docUrl: string | undefined;
    retirement: Retirement;
}

export class Retirement implements IRetirement {
    id!: number;
    retirementTypeId!: number;
    retirementUserId!: number;
    comment!: string | undefined;
    dateRetired!: Date;
    loggedDate!: Date;
    createdBy!: string | undefined;
    requriesBenefits!: boolean;
    retirmentDocAttachments!: RetirementDocAttachment[] | undefined;

    constructor(data?: IRetirement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.retirementTypeId = _data["retirementTypeId"];
            this.retirementUserId = _data["retirementUserId"];
            this.comment = _data["comment"];
            this.dateRetired = _data["dateRetired"] ? new Date(_data["dateRetired"].toString()) : <any>undefined;
            this.loggedDate = _data["loggedDate"] ? new Date(_data["loggedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.requriesBenefits = _data["requriesBenefits"];
            if (Array.isArray(_data["retirmentDocAttachments"])) {
                this.retirmentDocAttachments = [] as any;
                for (let item of _data["retirmentDocAttachments"])
                    this.retirmentDocAttachments!.push(RetirementDocAttachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Retirement {
        data = typeof data === 'object' ? data : {};
        let result = new Retirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["retirementTypeId"] = this.retirementTypeId;
        data["retirementUserId"] = this.retirementUserId;
        data["comment"] = this.comment;
        data["dateRetired"] = this.dateRetired ? this.dateRetired.toISOString() : <any>undefined;
        data["loggedDate"] = this.loggedDate ? this.loggedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["requriesBenefits"] = this.requriesBenefits;
        if (Array.isArray(this.retirmentDocAttachments)) {
            data["retirmentDocAttachments"] = [];
            for (let item of this.retirmentDocAttachments)
                data["retirmentDocAttachments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Retirement {
        const json = this.toJSON();
        let result = new Retirement();
        result.init(json);
        return result;
    }
}

export interface IRetirement {
    id: number;
    retirementTypeId: number;
    retirementUserId: number;
    comment: string | undefined;
    dateRetired: Date;
    loggedDate: Date;
    createdBy: string | undefined;
    requriesBenefits: boolean;
    retirmentDocAttachments: RetirementDocAttachment[] | undefined;
}

export class RetirementIListApiResult implements IRetirementIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Retirement[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRetirementIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Retirement.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RetirementIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RetirementIListApiResult {
        const json = this.toJSON();
        let result = new RetirementIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRetirementIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Retirement[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RetirementType implements IRetirementType {
    id!: number;
    name!: string | undefined;
    requirements!: string | undefined;
    isEntitledToBenefits!: boolean;

    constructor(data?: IRetirementType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.requirements = _data["requirements"];
            this.isEntitledToBenefits = _data["isEntitledToBenefits"];
        }
    }

    static fromJS(data: any): RetirementType {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["requirements"] = this.requirements;
        data["isEntitledToBenefits"] = this.isEntitledToBenefits;
        return data; 
    }

    clone(): RetirementType {
        const json = this.toJSON();
        let result = new RetirementType();
        result.init(json);
        return result;
    }
}

export interface IRetirementType {
    id: number;
    name: string | undefined;
    requirements: string | undefined;
    isEntitledToBenefits: boolean;
}

export class RetirementTypeIListApiResult implements IRetirementTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RetirementType[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRetirementTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RetirementType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RetirementTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RetirementTypeIListApiResult {
        const json = this.toJSON();
        let result = new RetirementTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRetirementTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RetirementType[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class CompetencyRequirments implements ICompetencyRequirments {
    competencyId!: number;
    requirementCategory!: string | undefined;
    skillId!: number | undefined;
    trainingId!: number | undefined;
    certificationId!: number | undefined;
    qualificationId!: number | undefined;
    points!: number;
    experience!: string | undefined;
    yearsofExperience!: number;
    experienceWeight!: number | undefined;
    skillWeight!: number | undefined;
    competences!: Competency;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICompetencyRequirments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.competencyId = _data["competencyId"];
            this.requirementCategory = _data["requirementCategory"];
            this.skillId = _data["skillId"];
            this.trainingId = _data["trainingId"];
            this.certificationId = _data["certificationId"];
            this.qualificationId = _data["qualificationId"];
            this.points = _data["points"];
            this.experience = _data["experience"];
            this.yearsofExperience = _data["yearsofExperience"];
            this.experienceWeight = _data["experienceWeight"];
            this.skillWeight = _data["skillWeight"];
            this.competences = _data["competences"] ? Competency.fromJS(_data["competences"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): CompetencyRequirments {
        data = typeof data === 'object' ? data : {};
        let result = new CompetencyRequirments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["competencyId"] = this.competencyId;
        data["requirementCategory"] = this.requirementCategory;
        data["skillId"] = this.skillId;
        data["trainingId"] = this.trainingId;
        data["certificationId"] = this.certificationId;
        data["qualificationId"] = this.qualificationId;
        data["points"] = this.points;
        data["experience"] = this.experience;
        data["yearsofExperience"] = this.yearsofExperience;
        data["experienceWeight"] = this.experienceWeight;
        data["skillWeight"] = this.skillWeight;
        data["competences"] = this.competences ? this.competences.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): CompetencyRequirments {
        const json = this.toJSON();
        let result = new CompetencyRequirments();
        result.init(json);
        return result;
    }
}

export interface ICompetencyRequirments {
    competencyId: number;
    requirementCategory: string | undefined;
    skillId: number | undefined;
    trainingId: number | undefined;
    certificationId: number | undefined;
    qualificationId: number | undefined;
    points: number;
    experience: string | undefined;
    yearsofExperience: number;
    experienceWeight: number | undefined;
    skillWeight: number | undefined;
    competences: Competency;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Competency implements ICompetency {
    competencyTitle!: string | undefined;
    jobRoleId!: number;
    positionId!: number;
    description!: string | undefined;
    departmentId!: number;
    competencesRequirements!: CompetencyRequirments[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICompetency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.competencyTitle = _data["competencyTitle"];
            this.jobRoleId = _data["jobRoleId"];
            this.positionId = _data["positionId"];
            this.description = _data["description"];
            this.departmentId = _data["departmentId"];
            if (Array.isArray(_data["competencesRequirements"])) {
                this.competencesRequirements = [] as any;
                for (let item of _data["competencesRequirements"])
                    this.competencesRequirements!.push(CompetencyRequirments.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Competency {
        data = typeof data === 'object' ? data : {};
        let result = new Competency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["competencyTitle"] = this.competencyTitle;
        data["jobRoleId"] = this.jobRoleId;
        data["positionId"] = this.positionId;
        data["description"] = this.description;
        data["departmentId"] = this.departmentId;
        if (Array.isArray(this.competencesRequirements)) {
            data["competencesRequirements"] = [];
            for (let item of this.competencesRequirements)
                data["competencesRequirements"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Competency {
        const json = this.toJSON();
        let result = new Competency();
        result.init(json);
        return result;
    }
}

export interface ICompetency {
    competencyTitle: string | undefined;
    jobRoleId: number;
    positionId: number;
    description: string | undefined;
    departmentId: number;
    competencesRequirements: CompetencyRequirments[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CompetencyIListApiResult implements ICompetencyIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Competency[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICompetencyIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Competency.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CompetencyIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CompetencyIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CompetencyIListApiResult {
        const json = this.toJSON();
        let result = new CompetencyIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICompetencyIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Competency[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class EmailSetting implements IEmailSetting {
    emailUserName!: string | undefined;
    emailHost!: string | undefined;
    emailPort!: number;
    emailPassword!: string | undefined;
    enableSSLForEmail!: boolean;
    emailFromAddress!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmailSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailUserName = _data["emailUserName"];
            this.emailHost = _data["emailHost"];
            this.emailPort = _data["emailPort"];
            this.emailPassword = _data["emailPassword"];
            this.enableSSLForEmail = _data["enableSSLForEmail"];
            this.emailFromAddress = _data["emailFromAddress"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmailSetting {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailUserName"] = this.emailUserName;
        data["emailHost"] = this.emailHost;
        data["emailPort"] = this.emailPort;
        data["emailPassword"] = this.emailPassword;
        data["enableSSLForEmail"] = this.enableSSLForEmail;
        data["emailFromAddress"] = this.emailFromAddress;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmailSetting {
        const json = this.toJSON();
        let result = new EmailSetting();
        result.init(json);
        return result;
    }
}

export interface IEmailSetting {
    emailUserName: string | undefined;
    emailHost: string | undefined;
    emailPort: number;
    emailPassword: string | undefined;
    enableSSLForEmail: boolean;
    emailFromAddress: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmailSettingListApiResult implements IEmailSettingListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailSetting[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmailSettingListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmailSetting.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmailSettingListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmailSettingListApiResult {
        const json = this.toJSON();
        let result = new EmailSettingListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailSetting[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class EmailSettingApiResult implements IEmailSettingApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailSetting;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmailSettingApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmailSetting.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmailSettingApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmailSettingApiResult {
        const json = this.toJSON();
        let result = new EmailSettingApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailSetting;
    totalCount: number;
    totalRecord: number;
}

export class IDTextViewModel implements IIDTextViewModel {
    id!: number;
    text!: string | undefined;

    constructor(data?: IIDTextViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): IDTextViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new IDTextViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        return data; 
    }

    clone(): IDTextViewModel {
        const json = this.toJSON();
        let result = new IDTextViewModel();
        result.init(json);
        return result;
    }
}

export interface IIDTextViewModel {
    id: number;
    text: string | undefined;
}

export class IDTextViewModelListApiResult implements IIDTextViewModelListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: IDTextViewModel[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IIDTextViewModelListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(IDTextViewModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): IDTextViewModelListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new IDTextViewModelListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): IDTextViewModelListApiResult {
        const json = this.toJSON();
        let result = new IDTextViewModelListApiResult();
        result.init(json);
        return result;
    }
}

export interface IIDTextViewModelListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: IDTextViewModel[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ManageMailTemplateDTO implements IManageMailTemplateDTO {
    id!: number;
    emailTemplateTypeId!: number;
    subject!: string;
    body!: string;

    constructor(data?: IManageMailTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailTemplateTypeId = _data["emailTemplateTypeId"];
            this.subject = _data["subject"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): ManageMailTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageMailTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailTemplateTypeId"] = this.emailTemplateTypeId;
        data["subject"] = this.subject;
        data["body"] = this.body;
        return data; 
    }

    clone(): ManageMailTemplateDTO {
        const json = this.toJSON();
        let result = new ManageMailTemplateDTO();
        result.init(json);
        return result;
    }
}

export interface IManageMailTemplateDTO {
    id: number;
    emailTemplateTypeId: number;
    subject: string;
    body: string;
}

export class MailTemplateDTO implements IMailTemplateDTO {
    id!: number;
    emailTemplateTypeId!: number;
    templateType!: string | undefined;
    subject!: string | undefined;
    body!: string | undefined;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IMailTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailTemplateTypeId = _data["emailTemplateTypeId"];
            this.templateType = _data["templateType"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): MailTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailTemplateTypeId"] = this.emailTemplateTypeId;
        data["templateType"] = this.templateType;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): MailTemplateDTO {
        const json = this.toJSON();
        let result = new MailTemplateDTO();
        result.init(json);
        return result;
    }
}

export interface IMailTemplateDTO {
    id: number;
    emailTemplateTypeId: number;
    templateType: string | undefined;
    subject: string | undefined;
    body: string | undefined;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class MailTemplateDTOListApiResult implements IMailTemplateDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MailTemplateDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IMailTemplateDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MailTemplateDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): MailTemplateDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): MailTemplateDTOListApiResult {
        const json = this.toJSON();
        let result = new MailTemplateDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IMailTemplateDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MailTemplateDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class MailTemplateDTOApiResult implements IMailTemplateDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MailTemplateDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IMailTemplateDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? MailTemplateDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): MailTemplateDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MailTemplateDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): MailTemplateDTOApiResult {
        const json = this.toJSON();
        let result = new MailTemplateDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IMailTemplateDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MailTemplateDTO;
    totalCount: number;
    totalRecord: number;
}

export class EmailLog implements IEmailLog {
    sender!: string | undefined;
    receiver!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    messageBody!: string | undefined;
    hasAttachment!: boolean;
    isSent!: boolean;
    retires!: number;
    dateSent!: Date | undefined;
    dateToSend!: Date | undefined;
    emailAttachments!: EmailLogAttachment[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmailLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sender = _data["sender"];
            this.receiver = _data["receiver"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.messageBody = _data["messageBody"];
            this.hasAttachment = _data["hasAttachment"];
            this.isSent = _data["isSent"];
            this.retires = _data["retires"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.dateToSend = _data["dateToSend"] ? new Date(_data["dateToSend"].toString()) : <any>undefined;
            if (Array.isArray(_data["emailAttachments"])) {
                this.emailAttachments = [] as any;
                for (let item of _data["emailAttachments"])
                    this.emailAttachments!.push(EmailLogAttachment.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmailLog {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sender"] = this.sender;
        data["receiver"] = this.receiver;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["messageBody"] = this.messageBody;
        data["hasAttachment"] = this.hasAttachment;
        data["isSent"] = this.isSent;
        data["retires"] = this.retires;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["dateToSend"] = this.dateToSend ? this.dateToSend.toISOString() : <any>undefined;
        if (Array.isArray(this.emailAttachments)) {
            data["emailAttachments"] = [];
            for (let item of this.emailAttachments)
                data["emailAttachments"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmailLog {
        const json = this.toJSON();
        let result = new EmailLog();
        result.init(json);
        return result;
    }
}

export interface IEmailLog {
    sender: string | undefined;
    receiver: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    messageBody: string | undefined;
    hasAttachment: boolean;
    isSent: boolean;
    retires: number;
    dateSent: Date | undefined;
    dateToSend: Date | undefined;
    emailAttachments: EmailLogAttachment[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmailLogAttachment implements IEmailLogAttachment {
    id!: number;
    emailLogID!: number;
    emailLog!: EmailLog;
    folderOnServer!: string | undefined;
    fileNameOnServer!: string | undefined;
    emailFileName!: string | undefined;
    dateCreated!: Date;

    constructor(data?: IEmailLogAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailLogID = _data["emailLogID"];
            this.emailLog = _data["emailLog"] ? EmailLog.fromJS(_data["emailLog"]) : <any>undefined;
            this.folderOnServer = _data["folderOnServer"];
            this.fileNameOnServer = _data["fileNameOnServer"];
            this.emailFileName = _data["emailFileName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmailLogAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailLogID"] = this.emailLogID;
        data["emailLog"] = this.emailLog ? this.emailLog.toJSON() : <any>undefined;
        data["folderOnServer"] = this.folderOnServer;
        data["fileNameOnServer"] = this.fileNameOnServer;
        data["emailFileName"] = this.emailFileName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        return data; 
    }

    clone(): EmailLogAttachment {
        const json = this.toJSON();
        let result = new EmailLogAttachment();
        result.init(json);
        return result;
    }
}

export interface IEmailLogAttachment {
    id: number;
    emailLogID: number;
    emailLog: EmailLog;
    folderOnServer: string | undefined;
    fileNameOnServer: string | undefined;
    emailFileName: string | undefined;
    dateCreated: Date;
}

export class EmailLogDTO implements IEmailLogDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    sender!: string | undefined;
    receiver!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    messageBody!: string | undefined;
    hasAttachment!: boolean;
    isSent!: boolean;
    retires!: number;
    dateSent!: Date | undefined;
    dateToSend!: Date | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    emailAttachments!: EmailLogAttachment[] | undefined;

    constructor(data?: IEmailLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.sender = _data["sender"];
            this.receiver = _data["receiver"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.messageBody = _data["messageBody"];
            this.hasAttachment = _data["hasAttachment"];
            this.isSent = _data["isSent"];
            this.retires = _data["retires"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.dateToSend = _data["dateToSend"] ? new Date(_data["dateToSend"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            if (Array.isArray(_data["emailAttachments"])) {
                this.emailAttachments = [] as any;
                for (let item of _data["emailAttachments"])
                    this.emailAttachments!.push(EmailLogAttachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["sender"] = this.sender;
        data["receiver"] = this.receiver;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["messageBody"] = this.messageBody;
        data["hasAttachment"] = this.hasAttachment;
        data["isSent"] = this.isSent;
        data["retires"] = this.retires;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["dateToSend"] = this.dateToSend ? this.dateToSend.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        if (Array.isArray(this.emailAttachments)) {
            data["emailAttachments"] = [];
            for (let item of this.emailAttachments)
                data["emailAttachments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EmailLogDTO {
        const json = this.toJSON();
        let result = new EmailLogDTO();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTO {
    id: number;
    companyID: number;
    subID: number;
    sender: string | undefined;
    receiver: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    messageBody: string | undefined;
    hasAttachment: boolean;
    isSent: boolean;
    retires: number;
    dateSent: Date | undefined;
    dateToSend: Date | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    emailAttachments: EmailLogAttachment[] | undefined;
}

export class EmailLogDTOIListApiResult implements IEmailLogDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailLogDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmailLogDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmailLogDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmailLogDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmailLogDTOIListApiResult {
        const json = this.toJSON();
        let result = new EmailLogDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailLogDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class EmailLogDTOApiResult implements IEmailLogDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailLogDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmailLogDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmailLogDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmailLogDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmailLogDTOApiResult {
        const json = this.toJSON();
        let result = new EmailLogDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailLogDTO;
    totalCount: number;
    totalRecord: number;
}

export class CompensationDTO implements ICompensationDTO {
    id!: number;
    compensationName!: string | undefined;
    companyID!: number;
    subID!: number;
    isActive!: number;

    constructor(data?: ICompensationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.compensationName = _data["compensationName"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CompensationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompensationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["compensationName"] = this.compensationName;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CompensationDTO {
        const json = this.toJSON();
        let result = new CompensationDTO();
        result.init(json);
        return result;
    }
}

export interface ICompensationDTO {
    id: number;
    compensationName: string | undefined;
    companyID: number;
    subID: number;
    isActive: number;
}

export class Dependant implements IDependant {
    employeeId!: number;
    firstName!: string | undefined;
    lastName!: string | undefined;
    dependantType!: string | undefined;
    gender!: string | undefined;
    nin!: string | undefined;
    dateofBirth!: Date;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDependant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dependantType = _data["dependantType"];
            this.gender = _data["gender"];
            this.nin = _data["nin"];
            this.dateofBirth = _data["dateofBirth"] ? new Date(_data["dateofBirth"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Dependant {
        data = typeof data === 'object' ? data : {};
        let result = new Dependant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dependantType"] = this.dependantType;
        data["gender"] = this.gender;
        data["nin"] = this.nin;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Dependant {
        const json = this.toJSON();
        let result = new Dependant();
        result.init(json);
        return result;
    }
}

export interface IDependant {
    employeeId: number;
    firstName: string | undefined;
    lastName: string | undefined;
    dependantType: string | undefined;
    gender: string | undefined;
    nin: string | undefined;
    dateofBirth: Date;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DependantListApiResult implements IDependantListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Dependant[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDependantListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Dependant.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DependantListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DependantListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DependantListApiResult {
        const json = this.toJSON();
        let result = new DependantListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDependantListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Dependant[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class EmployeeCompensationDTO implements IEmployeeCompensationDTO {
    id!: number;
    employeeId!: number;
    compensationId!: number;
    companyID!: number;
    subID!: number;
    payElementPercentage!: number;
    payableFixAmount!: number | undefined;
    paymentNarration!: string | undefined;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IEmployeeCompensationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.compensationId = _data["compensationId"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.payElementPercentage = _data["payElementPercentage"];
            this.payableFixAmount = _data["payableFixAmount"];
            this.paymentNarration = _data["paymentNarration"];
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): EmployeeCompensationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeCompensationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["compensationId"] = this.compensationId;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["payElementPercentage"] = this.payElementPercentage;
        data["payableFixAmount"] = this.payableFixAmount;
        data["paymentNarration"] = this.paymentNarration;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): EmployeeCompensationDTO {
        const json = this.toJSON();
        let result = new EmployeeCompensationDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeCompensationDTO {
    id: number;
    employeeId: number;
    compensationId: number;
    companyID: number;
    subID: number;
    payElementPercentage: number;
    payableFixAmount: number | undefined;
    paymentNarration: string | undefined;
    isDeleted: boolean;
    isActive: boolean;
}

export class CompetencyRequirmentsDTO implements ICompetencyRequirmentsDTO {
    competencyId!: number;
    requirementCategory!: string | undefined;
    skillId!: number | undefined;
    trainingId!: number | undefined;
    certificationId!: number | undefined;
    qualificationId!: number | undefined;
    points!: number;
    experience!: string | undefined;
    yearsofExperience!: number;
    experienceWeight!: number | undefined;
    skillWeight!: number | undefined;

    constructor(data?: ICompetencyRequirmentsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.competencyId = _data["competencyId"];
            this.requirementCategory = _data["requirementCategory"];
            this.skillId = _data["skillId"];
            this.trainingId = _data["trainingId"];
            this.certificationId = _data["certificationId"];
            this.qualificationId = _data["qualificationId"];
            this.points = _data["points"];
            this.experience = _data["experience"];
            this.yearsofExperience = _data["yearsofExperience"];
            this.experienceWeight = _data["experienceWeight"];
            this.skillWeight = _data["skillWeight"];
        }
    }

    static fromJS(data: any): CompetencyRequirmentsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompetencyRequirmentsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["competencyId"] = this.competencyId;
        data["requirementCategory"] = this.requirementCategory;
        data["skillId"] = this.skillId;
        data["trainingId"] = this.trainingId;
        data["certificationId"] = this.certificationId;
        data["qualificationId"] = this.qualificationId;
        data["points"] = this.points;
        data["experience"] = this.experience;
        data["yearsofExperience"] = this.yearsofExperience;
        data["experienceWeight"] = this.experienceWeight;
        data["skillWeight"] = this.skillWeight;
        return data; 
    }

    clone(): CompetencyRequirmentsDTO {
        const json = this.toJSON();
        let result = new CompetencyRequirmentsDTO();
        result.init(json);
        return result;
    }
}

export interface ICompetencyRequirmentsDTO {
    competencyId: number;
    requirementCategory: string | undefined;
    skillId: number | undefined;
    trainingId: number | undefined;
    certificationId: number | undefined;
    qualificationId: number | undefined;
    points: number;
    experience: string | undefined;
    yearsofExperience: number;
    experienceWeight: number | undefined;
    skillWeight: number | undefined;
}

export class ManageCompetencyDTO implements IManageCompetencyDTO {
    id!: number;
    competencyTitle!: string;
    jobRoleId!: number;
    positionId!: number;
    description!: string;
    departmentId!: number;
    selectedQualifications!: string | undefined;
    selectedSkills!: string | undefined;
    selectedAbilities!: string | undefined;
    selectedTrainings!: string | undefined;
    selectedCertifications!: string | undefined;
    selectedExperience!: string | undefined;
    competencyRequirmentAllocations!: string | undefined;
    competencesRequirementsDTO!: CompetencyRequirmentsDTO[] | undefined;

    constructor(data?: IManageCompetencyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.competencyTitle = _data["competencyTitle"];
            this.jobRoleId = _data["jobRoleId"];
            this.positionId = _data["positionId"];
            this.description = _data["description"];
            this.departmentId = _data["departmentId"];
            this.selectedQualifications = _data["selectedQualifications"];
            this.selectedSkills = _data["selectedSkills"];
            this.selectedAbilities = _data["selectedAbilities"];
            this.selectedTrainings = _data["selectedTrainings"];
            this.selectedCertifications = _data["selectedCertifications"];
            this.selectedExperience = _data["selectedExperience"];
            this.competencyRequirmentAllocations = _data["competencyRequirmentAllocations"];
            if (Array.isArray(_data["competencesRequirementsDTO"])) {
                this.competencesRequirementsDTO = [] as any;
                for (let item of _data["competencesRequirementsDTO"])
                    this.competencesRequirementsDTO!.push(CompetencyRequirmentsDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ManageCompetencyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageCompetencyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["competencyTitle"] = this.competencyTitle;
        data["jobRoleId"] = this.jobRoleId;
        data["positionId"] = this.positionId;
        data["description"] = this.description;
        data["departmentId"] = this.departmentId;
        data["selectedQualifications"] = this.selectedQualifications;
        data["selectedSkills"] = this.selectedSkills;
        data["selectedAbilities"] = this.selectedAbilities;
        data["selectedTrainings"] = this.selectedTrainings;
        data["selectedCertifications"] = this.selectedCertifications;
        data["selectedExperience"] = this.selectedExperience;
        data["competencyRequirmentAllocations"] = this.competencyRequirmentAllocations;
        if (Array.isArray(this.competencesRequirementsDTO)) {
            data["competencesRequirementsDTO"] = [];
            for (let item of this.competencesRequirementsDTO)
                data["competencesRequirementsDTO"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ManageCompetencyDTO {
        const json = this.toJSON();
        let result = new ManageCompetencyDTO();
        result.init(json);
        return result;
    }
}

export interface IManageCompetencyDTO {
    id: number;
    competencyTitle: string;
    jobRoleId: number;
    positionId: number;
    description: string;
    departmentId: number;
    selectedQualifications: string | undefined;
    selectedSkills: string | undefined;
    selectedAbilities: string | undefined;
    selectedTrainings: string | undefined;
    selectedCertifications: string | undefined;
    selectedExperience: string | undefined;
    competencyRequirmentAllocations: string | undefined;
    competencesRequirementsDTO: CompetencyRequirmentsDTO[] | undefined;
}

export class CompareSkillDTO implements ICompareSkillDTO {
    id!: number;
    employeeId!: number;
    skillId!: number;
    skillName!: string | undefined;
    point!: number;
    dateCreated!: Date;
    yearsofExperience!: number;
    employeeSkillPoint!: number;
    employeeExperiencePoint!: number;
    requiredSkillId!: number;
    requiredSkillName!: string | undefined;
    requiredSkillPoint!: number;
    requiredSkillYearsofExperience!: number;
    experienceWeight!: number;
    skillWeight!: number;
    employeeSkillStatus!: boolean;

    constructor(data?: ICompareSkillDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.skillId = _data["skillId"];
            this.skillName = _data["skillName"];
            this.point = _data["point"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.yearsofExperience = _data["yearsofExperience"];
            this.employeeSkillPoint = _data["employeeSkillPoint"];
            this.employeeExperiencePoint = _data["employeeExperiencePoint"];
            this.requiredSkillId = _data["requiredSkillId"];
            this.requiredSkillName = _data["requiredSkillName"];
            this.requiredSkillPoint = _data["requiredSkillPoint"];
            this.requiredSkillYearsofExperience = _data["requiredSkillYearsofExperience"];
            this.experienceWeight = _data["experienceWeight"];
            this.skillWeight = _data["skillWeight"];
            this.employeeSkillStatus = _data["employeeSkillStatus"];
        }
    }

    static fromJS(data: any): CompareSkillDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompareSkillDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["skillId"] = this.skillId;
        data["skillName"] = this.skillName;
        data["point"] = this.point;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["yearsofExperience"] = this.yearsofExperience;
        data["employeeSkillPoint"] = this.employeeSkillPoint;
        data["employeeExperiencePoint"] = this.employeeExperiencePoint;
        data["requiredSkillId"] = this.requiredSkillId;
        data["requiredSkillName"] = this.requiredSkillName;
        data["requiredSkillPoint"] = this.requiredSkillPoint;
        data["requiredSkillYearsofExperience"] = this.requiredSkillYearsofExperience;
        data["experienceWeight"] = this.experienceWeight;
        data["skillWeight"] = this.skillWeight;
        data["employeeSkillStatus"] = this.employeeSkillStatus;
        return data; 
    }

    clone(): CompareSkillDTO {
        const json = this.toJSON();
        let result = new CompareSkillDTO();
        result.init(json);
        return result;
    }
}

export interface ICompareSkillDTO {
    id: number;
    employeeId: number;
    skillId: number;
    skillName: string | undefined;
    point: number;
    dateCreated: Date;
    yearsofExperience: number;
    employeeSkillPoint: number;
    employeeExperiencePoint: number;
    requiredSkillId: number;
    requiredSkillName: string | undefined;
    requiredSkillPoint: number;
    requiredSkillYearsofExperience: number;
    experienceWeight: number;
    skillWeight: number;
    employeeSkillStatus: boolean;
}

export class CompareQualificationDTO implements ICompareQualificationDTO {
    id!: number;
    employeeId!: number;
    qualificationId!: number;
    qualificationCategoryId!: number;
    qualificationName!: string | undefined;
    point!: number;
    dateCreated!: Date;
    yearsofExperience!: number;
    employeeQualificationPoint!: number;
    employeeExperiencePoint!: number;
    requiredQualificationId!: number;
    requiredQualificationName!: string | undefined;
    requiredQualificationPoint!: number;
    requiredQualificationYearsofExperience!: number;
    experienceWeight!: number;
    qualificationWeight!: number;
    employeeQualificationStatus!: boolean;

    constructor(data?: ICompareQualificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.qualificationId = _data["qualificationId"];
            this.qualificationCategoryId = _data["qualificationCategoryId"];
            this.qualificationName = _data["qualificationName"];
            this.point = _data["point"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.yearsofExperience = _data["yearsofExperience"];
            this.employeeQualificationPoint = _data["employeeQualificationPoint"];
            this.employeeExperiencePoint = _data["employeeExperiencePoint"];
            this.requiredQualificationId = _data["requiredQualificationId"];
            this.requiredQualificationName = _data["requiredQualificationName"];
            this.requiredQualificationPoint = _data["requiredQualificationPoint"];
            this.requiredQualificationYearsofExperience = _data["requiredQualificationYearsofExperience"];
            this.experienceWeight = _data["experienceWeight"];
            this.qualificationWeight = _data["qualificationWeight"];
            this.employeeQualificationStatus = _data["employeeQualificationStatus"];
        }
    }

    static fromJS(data: any): CompareQualificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompareQualificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["qualificationId"] = this.qualificationId;
        data["qualificationCategoryId"] = this.qualificationCategoryId;
        data["qualificationName"] = this.qualificationName;
        data["point"] = this.point;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["yearsofExperience"] = this.yearsofExperience;
        data["employeeQualificationPoint"] = this.employeeQualificationPoint;
        data["employeeExperiencePoint"] = this.employeeExperiencePoint;
        data["requiredQualificationId"] = this.requiredQualificationId;
        data["requiredQualificationName"] = this.requiredQualificationName;
        data["requiredQualificationPoint"] = this.requiredQualificationPoint;
        data["requiredQualificationYearsofExperience"] = this.requiredQualificationYearsofExperience;
        data["experienceWeight"] = this.experienceWeight;
        data["qualificationWeight"] = this.qualificationWeight;
        data["employeeQualificationStatus"] = this.employeeQualificationStatus;
        return data; 
    }

    clone(): CompareQualificationDTO {
        const json = this.toJSON();
        let result = new CompareQualificationDTO();
        result.init(json);
        return result;
    }
}

export interface ICompareQualificationDTO {
    id: number;
    employeeId: number;
    qualificationId: number;
    qualificationCategoryId: number;
    qualificationName: string | undefined;
    point: number;
    dateCreated: Date;
    yearsofExperience: number;
    employeeQualificationPoint: number;
    employeeExperiencePoint: number;
    requiredQualificationId: number;
    requiredQualificationName: string | undefined;
    requiredQualificationPoint: number;
    requiredQualificationYearsofExperience: number;
    experienceWeight: number;
    qualificationWeight: number;
    employeeQualificationStatus: boolean;
}

export class CompareCertificationDTO implements ICompareCertificationDTO {
    id!: number;
    employeeId!: number;
    certificationId!: number;
    certificationName!: string | undefined;
    point!: number;
    dateCreated!: Date;
    yearsofExperience!: number;
    employeeCertificationPoint!: number;
    employeeExperiencePoint!: number;
    requiredCertificationId!: number;
    requiredCertificationName!: string | undefined;
    requiredCertificationPoint!: number;
    requiredCertificationYearsofExperience!: number;
    experienceWeight!: number;
    certificationWeight!: number;
    employeeCertificationStatus!: boolean;

    constructor(data?: ICompareCertificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.certificationId = _data["certificationId"];
            this.certificationName = _data["certificationName"];
            this.point = _data["point"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.yearsofExperience = _data["yearsofExperience"];
            this.employeeCertificationPoint = _data["employeeCertificationPoint"];
            this.employeeExperiencePoint = _data["employeeExperiencePoint"];
            this.requiredCertificationId = _data["requiredCertificationId"];
            this.requiredCertificationName = _data["requiredCertificationName"];
            this.requiredCertificationPoint = _data["requiredCertificationPoint"];
            this.requiredCertificationYearsofExperience = _data["requiredCertificationYearsofExperience"];
            this.experienceWeight = _data["experienceWeight"];
            this.certificationWeight = _data["certificationWeight"];
            this.employeeCertificationStatus = _data["employeeCertificationStatus"];
        }
    }

    static fromJS(data: any): CompareCertificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompareCertificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["certificationId"] = this.certificationId;
        data["certificationName"] = this.certificationName;
        data["point"] = this.point;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["yearsofExperience"] = this.yearsofExperience;
        data["employeeCertificationPoint"] = this.employeeCertificationPoint;
        data["employeeExperiencePoint"] = this.employeeExperiencePoint;
        data["requiredCertificationId"] = this.requiredCertificationId;
        data["requiredCertificationName"] = this.requiredCertificationName;
        data["requiredCertificationPoint"] = this.requiredCertificationPoint;
        data["requiredCertificationYearsofExperience"] = this.requiredCertificationYearsofExperience;
        data["experienceWeight"] = this.experienceWeight;
        data["certificationWeight"] = this.certificationWeight;
        data["employeeCertificationStatus"] = this.employeeCertificationStatus;
        return data; 
    }

    clone(): CompareCertificationDTO {
        const json = this.toJSON();
        let result = new CompareCertificationDTO();
        result.init(json);
        return result;
    }
}

export interface ICompareCertificationDTO {
    id: number;
    employeeId: number;
    certificationId: number;
    certificationName: string | undefined;
    point: number;
    dateCreated: Date;
    yearsofExperience: number;
    employeeCertificationPoint: number;
    employeeExperiencePoint: number;
    requiredCertificationId: number;
    requiredCertificationName: string | undefined;
    requiredCertificationPoint: number;
    requiredCertificationYearsofExperience: number;
    experienceWeight: number;
    certificationWeight: number;
    employeeCertificationStatus: boolean;
}

export class CompareTraningDTO implements ICompareTraningDTO {
    id!: number;
    employeeId!: number;
    trainingId!: number;
    trainingName!: string | undefined;
    point!: number;
    dateCreated!: Date;
    yearsofExperience!: number;
    employeeTrainingPoint!: number;
    employeeExperiencePoint!: number;
    requiredTrainingId!: number;
    requiredTrainingName!: string | undefined;
    requiredTrainingPoint!: number;
    requiredTrainingYearsofExperience!: number;
    experienceWeight!: number;
    trainingWeight!: number;
    employeeTrainingStatus!: boolean;

    constructor(data?: ICompareTraningDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.trainingId = _data["trainingId"];
            this.trainingName = _data["trainingName"];
            this.point = _data["point"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.yearsofExperience = _data["yearsofExperience"];
            this.employeeTrainingPoint = _data["employeeTrainingPoint"];
            this.employeeExperiencePoint = _data["employeeExperiencePoint"];
            this.requiredTrainingId = _data["requiredTrainingId"];
            this.requiredTrainingName = _data["requiredTrainingName"];
            this.requiredTrainingPoint = _data["requiredTrainingPoint"];
            this.requiredTrainingYearsofExperience = _data["requiredTrainingYearsofExperience"];
            this.experienceWeight = _data["experienceWeight"];
            this.trainingWeight = _data["trainingWeight"];
            this.employeeTrainingStatus = _data["employeeTrainingStatus"];
        }
    }

    static fromJS(data: any): CompareTraningDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompareTraningDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["trainingId"] = this.trainingId;
        data["trainingName"] = this.trainingName;
        data["point"] = this.point;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["yearsofExperience"] = this.yearsofExperience;
        data["employeeTrainingPoint"] = this.employeeTrainingPoint;
        data["employeeExperiencePoint"] = this.employeeExperiencePoint;
        data["requiredTrainingId"] = this.requiredTrainingId;
        data["requiredTrainingName"] = this.requiredTrainingName;
        data["requiredTrainingPoint"] = this.requiredTrainingPoint;
        data["requiredTrainingYearsofExperience"] = this.requiredTrainingYearsofExperience;
        data["experienceWeight"] = this.experienceWeight;
        data["trainingWeight"] = this.trainingWeight;
        data["employeeTrainingStatus"] = this.employeeTrainingStatus;
        return data; 
    }

    clone(): CompareTraningDTO {
        const json = this.toJSON();
        let result = new CompareTraningDTO();
        result.init(json);
        return result;
    }
}

export interface ICompareTraningDTO {
    id: number;
    employeeId: number;
    trainingId: number;
    trainingName: string | undefined;
    point: number;
    dateCreated: Date;
    yearsofExperience: number;
    employeeTrainingPoint: number;
    employeeExperiencePoint: number;
    requiredTrainingId: number;
    requiredTrainingName: string | undefined;
    requiredTrainingPoint: number;
    requiredTrainingYearsofExperience: number;
    experienceWeight: number;
    trainingWeight: number;
    employeeTrainingStatus: boolean;
}

export class VmListComparism implements IVmListComparism {
    listEmployeeSkills!: CompareSkillDTO[] | undefined;
    listEmployeeQualification!: CompareQualificationDTO[] | undefined;
    listEmployeeCertification!: CompareCertificationDTO[] | undefined;
    listEmployeeTrainings!: CompareTraningDTO[] | undefined;

    constructor(data?: IVmListComparism) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listEmployeeSkills"])) {
                this.listEmployeeSkills = [] as any;
                for (let item of _data["listEmployeeSkills"])
                    this.listEmployeeSkills!.push(CompareSkillDTO.fromJS(item));
            }
            if (Array.isArray(_data["listEmployeeQualification"])) {
                this.listEmployeeQualification = [] as any;
                for (let item of _data["listEmployeeQualification"])
                    this.listEmployeeQualification!.push(CompareQualificationDTO.fromJS(item));
            }
            if (Array.isArray(_data["listEmployeeCertification"])) {
                this.listEmployeeCertification = [] as any;
                for (let item of _data["listEmployeeCertification"])
                    this.listEmployeeCertification!.push(CompareCertificationDTO.fromJS(item));
            }
            if (Array.isArray(_data["listEmployeeTrainings"])) {
                this.listEmployeeTrainings = [] as any;
                for (let item of _data["listEmployeeTrainings"])
                    this.listEmployeeTrainings!.push(CompareTraningDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VmListComparism {
        data = typeof data === 'object' ? data : {};
        let result = new VmListComparism();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listEmployeeSkills)) {
            data["listEmployeeSkills"] = [];
            for (let item of this.listEmployeeSkills)
                data["listEmployeeSkills"].push(item.toJSON());
        }
        if (Array.isArray(this.listEmployeeQualification)) {
            data["listEmployeeQualification"] = [];
            for (let item of this.listEmployeeQualification)
                data["listEmployeeQualification"].push(item.toJSON());
        }
        if (Array.isArray(this.listEmployeeCertification)) {
            data["listEmployeeCertification"] = [];
            for (let item of this.listEmployeeCertification)
                data["listEmployeeCertification"].push(item.toJSON());
        }
        if (Array.isArray(this.listEmployeeTrainings)) {
            data["listEmployeeTrainings"] = [];
            for (let item of this.listEmployeeTrainings)
                data["listEmployeeTrainings"].push(item.toJSON());
        }
        return data; 
    }

    clone(): VmListComparism {
        const json = this.toJSON();
        let result = new VmListComparism();
        result.init(json);
        return result;
    }
}

export interface IVmListComparism {
    listEmployeeSkills: CompareSkillDTO[] | undefined;
    listEmployeeQualification: CompareQualificationDTO[] | undefined;
    listEmployeeCertification: CompareCertificationDTO[] | undefined;
    listEmployeeTrainings: CompareTraningDTO[] | undefined;
}

export class VmListComparismApiResult implements IVmListComparismApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VmListComparism;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IVmListComparismApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? VmListComparism.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): VmListComparismApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VmListComparismApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): VmListComparismApiResult {
        const json = this.toJSON();
        let result = new VmListComparismApiResult();
        result.init(json);
        return result;
    }
}

export interface IVmListComparismApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VmListComparism;
    totalCount: number;
    totalRecord: number;
}

export class VwConfirmationDTO implements IVwConfirmationDTO {
    id!: number;
    company_id!: number;
    subsidiary_id!: number;
    employee_id!: number;
    mgr_feedback!: string | undefined;
    mgr_advice!: string | undefined;
    appointment_date!: Date | undefined;
    probation_period!: string | undefined;
    log_status!: number;
    request_by!: string | undefined;
    request_date!: Date | undefined;
    employee_contractId!: number;
    employee_name!: string | undefined;
    status!: string | undefined;
    staff_no!: string | undefined;
    effective_date!: Date | undefined;
    str_effective_date!: string | undefined;
    confirmationDate!: Date | undefined;

    constructor(data?: IVwConfirmationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.subsidiary_id = _data["subsidiary_id"];
            this.employee_id = _data["employee_id"];
            this.mgr_feedback = _data["mgr_feedback"];
            this.mgr_advice = _data["mgr_advice"];
            this.appointment_date = _data["appointment_date"] ? new Date(_data["appointment_date"].toString()) : <any>undefined;
            this.probation_period = _data["probation_period"];
            this.log_status = _data["log_status"];
            this.request_by = _data["request_by"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.employee_contractId = _data["employee_contractId"];
            this.employee_name = _data["employee_name"];
            this.status = _data["status"];
            this.staff_no = _data["staff_no"];
            this.effective_date = _data["effective_date"] ? new Date(_data["effective_date"].toString()) : <any>undefined;
            this.str_effective_date = _data["str_effective_date"];
            this.confirmationDate = _data["confirmationDate"] ? new Date(_data["confirmationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VwConfirmationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new VwConfirmationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["subsidiary_id"] = this.subsidiary_id;
        data["employee_id"] = this.employee_id;
        data["mgr_feedback"] = this.mgr_feedback;
        data["mgr_advice"] = this.mgr_advice;
        data["appointment_date"] = this.appointment_date ? this.appointment_date.toISOString() : <any>undefined;
        data["probation_period"] = this.probation_period;
        data["log_status"] = this.log_status;
        data["request_by"] = this.request_by;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["employee_contractId"] = this.employee_contractId;
        data["employee_name"] = this.employee_name;
        data["status"] = this.status;
        data["staff_no"] = this.staff_no;
        data["effective_date"] = this.effective_date ? this.effective_date.toISOString() : <any>undefined;
        data["str_effective_date"] = this.str_effective_date;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): VwConfirmationDTO {
        const json = this.toJSON();
        let result = new VwConfirmationDTO();
        result.init(json);
        return result;
    }
}

export interface IVwConfirmationDTO {
    id: number;
    company_id: number;
    subsidiary_id: number;
    employee_id: number;
    mgr_feedback: string | undefined;
    mgr_advice: string | undefined;
    appointment_date: Date | undefined;
    probation_period: string | undefined;
    log_status: number;
    request_by: string | undefined;
    request_date: Date | undefined;
    employee_contractId: number;
    employee_name: string | undefined;
    status: string | undefined;
    staff_no: string | undefined;
    effective_date: Date | undefined;
    str_effective_date: string | undefined;
    confirmationDate: Date | undefined;
}

export class VwConfirmationDTOIListApiResult implements IVwConfirmationDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwConfirmationDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IVwConfirmationDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(VwConfirmationDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): VwConfirmationDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwConfirmationDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): VwConfirmationDTOIListApiResult {
        const json = this.toJSON();
        let result = new VwConfirmationDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwConfirmationDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwConfirmationDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class CourseListApiResult implements ICourseListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Course[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICourseListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Course.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CourseListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CourseListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CourseListApiResult {
        const json = this.toJSON();
        let result = new CourseListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICourseListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Course[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class CourseApiResult implements ICourseApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Course;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICourseApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? Course.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CourseApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CourseApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CourseApiResult {
        const json = this.toJSON();
        let result = new CourseApiResult();
        result.init(json);
        return result;
    }
}

export interface ICourseApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Course;
    totalCount: number;
    totalRecord: number;
}

export class VwDashboard implements IVwDashboard {
    countDueForRetirement!: number;
    dueForConfirmation!: number;
    dueForPromotion!: number;
    dueForDeployment!: number;
    totalNoOfEmployees!: number;

    constructor(data?: IVwDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countDueForRetirement = _data["countDueForRetirement"];
            this.dueForConfirmation = _data["dueForConfirmation"];
            this.dueForPromotion = _data["dueForPromotion"];
            this.dueForDeployment = _data["dueForDeployment"];
            this.totalNoOfEmployees = _data["totalNoOfEmployees"];
        }
    }

    static fromJS(data: any): VwDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new VwDashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countDueForRetirement"] = this.countDueForRetirement;
        data["dueForConfirmation"] = this.dueForConfirmation;
        data["dueForPromotion"] = this.dueForPromotion;
        data["dueForDeployment"] = this.dueForDeployment;
        data["totalNoOfEmployees"] = this.totalNoOfEmployees;
        return data; 
    }

    clone(): VwDashboard {
        const json = this.toJSON();
        let result = new VwDashboard();
        result.init(json);
        return result;
    }
}

export interface IVwDashboard {
    countDueForRetirement: number;
    dueForConfirmation: number;
    dueForPromotion: number;
    dueForDeployment: number;
    totalNoOfEmployees: number;
}

export class DashboardData implements IDashboardData {
    name!: string | undefined;
    value!: number;

    constructor(data?: IDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): DashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): DashboardData {
        const json = this.toJSON();
        let result = new DashboardData();
        result.init(json);
        return result;
    }
}

export interface IDashboardData {
    name: string | undefined;
    value: number;
}

export class DashboardData2 implements IDashboardData2 {
    name!: string | undefined;
    employeeNo!: string | undefined;
    email!: string | undefined;
    desc!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    itemId!: number;

    constructor(data?: IDashboardData2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.employeeNo = _data["employeeNo"];
            this.email = _data["email"];
            this.desc = _data["desc"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.itemId = _data["itemId"];
        }
    }

    static fromJS(data: any): DashboardData2 {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardData2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["employeeNo"] = this.employeeNo;
        data["email"] = this.email;
        data["desc"] = this.desc;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["itemId"] = this.itemId;
        return data; 
    }

    clone(): DashboardData2 {
        const json = this.toJSON();
        let result = new DashboardData2();
        result.init(json);
        return result;
    }
}

export interface IDashboardData2 {
    name: string | undefined;
    employeeNo: string | undefined;
    email: string | undefined;
    desc: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    itemId: number;
}

export class DashboardDTO implements IDashboardDTO {
    aggregateData!: VwDashboard;
    lstGenderData!: DashboardData[] | undefined;
    lstDepartmentData!: DashboardData[] | undefined;
    lstLocationData!: DashboardData[] | undefined;
    lstRetentionData!: DashboardData[] | undefined;
    lstUpcomingEventData!: DashboardData2[] | undefined;
    lstRequestComplaintData!: DashboardData2[] | undefined;
    lstUpcomingBirthdayData!: DashboardData2[] | undefined;
    lstUpcomingLeaveData!: DashboardData2[] | undefined;
    lstAnnouncementData!: DashboardData2[] | undefined;

    constructor(data?: IDashboardDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aggregateData = _data["aggregateData"] ? VwDashboard.fromJS(_data["aggregateData"]) : <any>undefined;
            if (Array.isArray(_data["lstGenderData"])) {
                this.lstGenderData = [] as any;
                for (let item of _data["lstGenderData"])
                    this.lstGenderData!.push(DashboardData.fromJS(item));
            }
            if (Array.isArray(_data["lstDepartmentData"])) {
                this.lstDepartmentData = [] as any;
                for (let item of _data["lstDepartmentData"])
                    this.lstDepartmentData!.push(DashboardData.fromJS(item));
            }
            if (Array.isArray(_data["lstLocationData"])) {
                this.lstLocationData = [] as any;
                for (let item of _data["lstLocationData"])
                    this.lstLocationData!.push(DashboardData.fromJS(item));
            }
            if (Array.isArray(_data["lstRetentionData"])) {
                this.lstRetentionData = [] as any;
                for (let item of _data["lstRetentionData"])
                    this.lstRetentionData!.push(DashboardData.fromJS(item));
            }
            if (Array.isArray(_data["lstUpcomingEventData"])) {
                this.lstUpcomingEventData = [] as any;
                for (let item of _data["lstUpcomingEventData"])
                    this.lstUpcomingEventData!.push(DashboardData2.fromJS(item));
            }
            if (Array.isArray(_data["lstRequestComplaintData"])) {
                this.lstRequestComplaintData = [] as any;
                for (let item of _data["lstRequestComplaintData"])
                    this.lstRequestComplaintData!.push(DashboardData2.fromJS(item));
            }
            if (Array.isArray(_data["lstUpcomingBirthdayData"])) {
                this.lstUpcomingBirthdayData = [] as any;
                for (let item of _data["lstUpcomingBirthdayData"])
                    this.lstUpcomingBirthdayData!.push(DashboardData2.fromJS(item));
            }
            if (Array.isArray(_data["lstUpcomingLeaveData"])) {
                this.lstUpcomingLeaveData = [] as any;
                for (let item of _data["lstUpcomingLeaveData"])
                    this.lstUpcomingLeaveData!.push(DashboardData2.fromJS(item));
            }
            if (Array.isArray(_data["lstAnnouncementData"])) {
                this.lstAnnouncementData = [] as any;
                for (let item of _data["lstAnnouncementData"])
                    this.lstAnnouncementData!.push(DashboardData2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregateData"] = this.aggregateData ? this.aggregateData.toJSON() : <any>undefined;
        if (Array.isArray(this.lstGenderData)) {
            data["lstGenderData"] = [];
            for (let item of this.lstGenderData)
                data["lstGenderData"].push(item.toJSON());
        }
        if (Array.isArray(this.lstDepartmentData)) {
            data["lstDepartmentData"] = [];
            for (let item of this.lstDepartmentData)
                data["lstDepartmentData"].push(item.toJSON());
        }
        if (Array.isArray(this.lstLocationData)) {
            data["lstLocationData"] = [];
            for (let item of this.lstLocationData)
                data["lstLocationData"].push(item.toJSON());
        }
        if (Array.isArray(this.lstRetentionData)) {
            data["lstRetentionData"] = [];
            for (let item of this.lstRetentionData)
                data["lstRetentionData"].push(item.toJSON());
        }
        if (Array.isArray(this.lstUpcomingEventData)) {
            data["lstUpcomingEventData"] = [];
            for (let item of this.lstUpcomingEventData)
                data["lstUpcomingEventData"].push(item.toJSON());
        }
        if (Array.isArray(this.lstRequestComplaintData)) {
            data["lstRequestComplaintData"] = [];
            for (let item of this.lstRequestComplaintData)
                data["lstRequestComplaintData"].push(item.toJSON());
        }
        if (Array.isArray(this.lstUpcomingBirthdayData)) {
            data["lstUpcomingBirthdayData"] = [];
            for (let item of this.lstUpcomingBirthdayData)
                data["lstUpcomingBirthdayData"].push(item.toJSON());
        }
        if (Array.isArray(this.lstUpcomingLeaveData)) {
            data["lstUpcomingLeaveData"] = [];
            for (let item of this.lstUpcomingLeaveData)
                data["lstUpcomingLeaveData"].push(item.toJSON());
        }
        if (Array.isArray(this.lstAnnouncementData)) {
            data["lstAnnouncementData"] = [];
            for (let item of this.lstAnnouncementData)
                data["lstAnnouncementData"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DashboardDTO {
        const json = this.toJSON();
        let result = new DashboardDTO();
        result.init(json);
        return result;
    }
}

export interface IDashboardDTO {
    aggregateData: VwDashboard;
    lstGenderData: DashboardData[] | undefined;
    lstDepartmentData: DashboardData[] | undefined;
    lstLocationData: DashboardData[] | undefined;
    lstRetentionData: DashboardData[] | undefined;
    lstUpcomingEventData: DashboardData2[] | undefined;
    lstRequestComplaintData: DashboardData2[] | undefined;
    lstUpcomingBirthdayData: DashboardData2[] | undefined;
    lstUpcomingLeaveData: DashboardData2[] | undefined;
    lstAnnouncementData: DashboardData2[] | undefined;
}

export class DashboardDTOApiResult implements IDashboardDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DashboardDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDashboardDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? DashboardDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DashboardDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DashboardDTOApiResult {
        const json = this.toJSON();
        let result = new DashboardDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IDashboardDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DashboardDTO;
    totalCount: number;
    totalRecord: number;
}

export class IDTextViewModelIListApiResult implements IIDTextViewModelIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: IDTextViewModel[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IIDTextViewModelIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(IDTextViewModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): IDTextViewModelIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new IDTextViewModelIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): IDTextViewModelIListApiResult {
        const json = this.toJSON();
        let result = new IDTextViewModelIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IIDTextViewModelIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: IDTextViewModel[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class DropdownValue implements IDropdownValue {
    dropdown_id!: number;
    option_text!: string;
    option_value!: number;
    is_deleted!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDropdownValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dropdown_id = _data["dropdown_id"];
            this.option_text = _data["option_text"];
            this.option_value = _data["option_value"];
            this.is_deleted = _data["is_deleted"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DropdownValue {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dropdown_id"] = this.dropdown_id;
        data["option_text"] = this.option_text;
        data["option_value"] = this.option_value;
        data["is_deleted"] = this.is_deleted;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DropdownValue {
        const json = this.toJSON();
        let result = new DropdownValue();
        result.init(json);
        return result;
    }
}

export interface IDropdownValue {
    dropdown_id: number;
    option_text: string;
    option_value: number;
    is_deleted: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DropdownValueIListApiResult implements IDropdownValueIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DropdownValue[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDropdownValueIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DropdownValue.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DropdownValueIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValueIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DropdownValueIListApiResult {
        const json = this.toJSON();
        let result = new DropdownValueIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDropdownValueIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DropdownValue[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class Country implements ICountry {
    name!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export interface ICountry {
    name: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CountryIListApiResult implements ICountryIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Country[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICountryIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Country.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CountryIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CountryIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CountryIListApiResult {
        const json = this.toJSON();
        let result = new CountryIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICountryIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Country[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class StateIListApiResult implements IStateIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: State[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IStateIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(State.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): StateIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new StateIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): StateIListApiResult {
        const json = this.toJSON();
        let result = new StateIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IStateIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: State[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class LGAIListApiResult implements ILGAIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LGA[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILGAIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LGA.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LGAIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LGAIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LGAIListApiResult {
        const json = this.toJSON();
        let result = new LGAIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILGAIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LGA[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ManageDepartmentDTO implements IManageDepartmentDTO {
    id!: number;
    name!: string;
    code!: string;

    constructor(data?: IManageDepartmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ManageDepartmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageDepartmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }

    clone(): ManageDepartmentDTO {
        const json = this.toJSON();
        let result = new ManageDepartmentDTO();
        result.init(json);
        return result;
    }
}

export interface IManageDepartmentDTO {
    id: number;
    name: string;
    code: string;
}

export class DepartmentDTO implements IDepartmentDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    headOfDepartment!: number;

    constructor(data?: IDepartmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.headOfDepartment = _data["headOfDepartment"];
        }
    }

    static fromJS(data: any): DepartmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["headOfDepartment"] = this.headOfDepartment;
        return data; 
    }

    clone(): DepartmentDTO {
        const json = this.toJSON();
        let result = new DepartmentDTO();
        result.init(json);
        return result;
    }
}

export interface IDepartmentDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    headOfDepartment: number;
}

export class DepartmentDTOListApiResult implements IDepartmentDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DepartmentDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDepartmentDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DepartmentDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DepartmentDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DepartmentDTOListApiResult {
        const json = this.toJSON();
        let result = new DepartmentDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDepartmentDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DepartmentDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class DepartmentDTOApiResult implements IDepartmentDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DepartmentDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDepartmentDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? DepartmentDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DepartmentDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DepartmentDTOApiResult {
        const json = this.toJSON();
        let result = new DepartmentDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IDepartmentDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DepartmentDTO;
    totalCount: number;
    totalRecord: number;
}

export class DependantDTO implements IDependantDTO {
    id!: number;
    employeeId!: number;
    firstName!: string | undefined;
    lastName!: string | undefined;
    dependantType!: string | undefined;
    gender!: string | undefined;
    nin!: string | undefined;
    dateofBirth!: Date;

    constructor(data?: IDependantDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dependantType = _data["dependantType"];
            this.gender = _data["gender"];
            this.nin = _data["nin"];
            this.dateofBirth = _data["dateofBirth"] ? new Date(_data["dateofBirth"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DependantDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DependantDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dependantType"] = this.dependantType;
        data["gender"] = this.gender;
        data["nin"] = this.nin;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        return data; 
    }

    clone(): DependantDTO {
        const json = this.toJSON();
        let result = new DependantDTO();
        result.init(json);
        return result;
    }
}

export interface IDependantDTO {
    id: number;
    employeeId: number;
    firstName: string | undefined;
    lastName: string | undefined;
    dependantType: string | undefined;
    gender: string | undefined;
    nin: string | undefined;
    dateofBirth: Date;
}

export class DependantResultDTO implements IDependantResultDTO {
    employeeId!: number;
    firstName!: string | undefined;
    lastName!: string | undefined;
    dependantType!: string | undefined;
    gender!: string | undefined;
    nin!: string | undefined;
    dateofBirth!: Date;
    isActive!: number;
    employeeName!: string | undefined;
    dependentId!: number;

    constructor(data?: IDependantResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dependantType = _data["dependantType"];
            this.gender = _data["gender"];
            this.nin = _data["nin"];
            this.dateofBirth = _data["dateofBirth"] ? new Date(_data["dateofBirth"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.employeeName = _data["employeeName"];
            this.dependentId = _data["dependentId"];
        }
    }

    static fromJS(data: any): DependantResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DependantResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dependantType"] = this.dependantType;
        data["gender"] = this.gender;
        data["nin"] = this.nin;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["employeeName"] = this.employeeName;
        data["dependentId"] = this.dependentId;
        return data; 
    }

    clone(): DependantResultDTO {
        const json = this.toJSON();
        let result = new DependantResultDTO();
        result.init(json);
        return result;
    }
}

export interface IDependantResultDTO {
    employeeId: number;
    firstName: string | undefined;
    lastName: string | undefined;
    dependantType: string | undefined;
    gender: string | undefined;
    nin: string | undefined;
    dateofBirth: Date;
    isActive: number;
    employeeName: string | undefined;
    dependentId: number;
}

export class DependantResultDTOListApiResult implements IDependantResultDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DependantResultDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDependantResultDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DependantResultDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DependantResultDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DependantResultDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DependantResultDTOListApiResult {
        const json = this.toJSON();
        let result = new DependantResultDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDependantResultDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DependantResultDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class DeploymentRegistrationPayLoad implements IDeploymentRegistrationPayLoad {
    id!: number;
    employee_id!: number;
    staff_no!: string | undefined;
    comment!: string | undefined;
    last_deployment_date!: Date | undefined;
    appointment_date!: Date | undefined;
    log_status!: number | undefined;
    is_new!: boolean | undefined;
    status!: string | undefined;
    requested_ministry_id!: number | undefined;
    requested_location_id!: number | undefined;
    requested_ministry!: string | undefined;
    requested_location!: string | undefined;
    requested_location_lga!: string | undefined;
    requested_location_state!: string | undefined;
    request_date!: Date;
    current_ministry_id!: number | undefined;
    current_location_id!: number | undefined;
    current_location!: string | undefined;
    current_location_lga!: string | undefined;
    current_location_state!: string | undefined;
    contractId!: number;
    effective_date!: Date | undefined;
    str_effective_date!: string | undefined;
    periodInCurrentLocation!: string | undefined;
    currentDepartment!: number;
    requestedDepartment!: number;
    justification!: string | undefined;
    tempRef!: string | undefined;

    constructor(data?: IDeploymentRegistrationPayLoad) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employee_id = _data["employee_id"];
            this.staff_no = _data["staff_no"];
            this.comment = _data["comment"];
            this.last_deployment_date = _data["last_deployment_date"] ? new Date(_data["last_deployment_date"].toString()) : <any>undefined;
            this.appointment_date = _data["appointment_date"] ? new Date(_data["appointment_date"].toString()) : <any>undefined;
            this.log_status = _data["log_status"];
            this.is_new = _data["is_new"];
            this.status = _data["status"];
            this.requested_ministry_id = _data["requested_ministry_id"];
            this.requested_location_id = _data["requested_location_id"];
            this.requested_ministry = _data["requested_ministry"];
            this.requested_location = _data["requested_location"];
            this.requested_location_lga = _data["requested_location_lga"];
            this.requested_location_state = _data["requested_location_state"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.current_ministry_id = _data["current_ministry_id"];
            this.current_location_id = _data["current_location_id"];
            this.current_location = _data["current_location"];
            this.current_location_lga = _data["current_location_lga"];
            this.current_location_state = _data["current_location_state"];
            this.contractId = _data["contractId"];
            this.effective_date = _data["effective_date"] ? new Date(_data["effective_date"].toString()) : <any>undefined;
            this.str_effective_date = _data["str_effective_date"];
            this.periodInCurrentLocation = _data["periodInCurrentLocation"];
            this.currentDepartment = _data["currentDepartment"];
            this.requestedDepartment = _data["requestedDepartment"];
            this.justification = _data["justification"];
            this.tempRef = _data["tempRef"];
        }
    }

    static fromJS(data: any): DeploymentRegistrationPayLoad {
        data = typeof data === 'object' ? data : {};
        let result = new DeploymentRegistrationPayLoad();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employee_id"] = this.employee_id;
        data["staff_no"] = this.staff_no;
        data["comment"] = this.comment;
        data["last_deployment_date"] = this.last_deployment_date ? this.last_deployment_date.toISOString() : <any>undefined;
        data["appointment_date"] = this.appointment_date ? this.appointment_date.toISOString() : <any>undefined;
        data["log_status"] = this.log_status;
        data["is_new"] = this.is_new;
        data["status"] = this.status;
        data["requested_ministry_id"] = this.requested_ministry_id;
        data["requested_location_id"] = this.requested_location_id;
        data["requested_ministry"] = this.requested_ministry;
        data["requested_location"] = this.requested_location;
        data["requested_location_lga"] = this.requested_location_lga;
        data["requested_location_state"] = this.requested_location_state;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["current_ministry_id"] = this.current_ministry_id;
        data["current_location_id"] = this.current_location_id;
        data["current_location"] = this.current_location;
        data["current_location_lga"] = this.current_location_lga;
        data["current_location_state"] = this.current_location_state;
        data["contractId"] = this.contractId;
        data["effective_date"] = this.effective_date ? this.effective_date.toISOString() : <any>undefined;
        data["str_effective_date"] = this.str_effective_date;
        data["periodInCurrentLocation"] = this.periodInCurrentLocation;
        data["currentDepartment"] = this.currentDepartment;
        data["requestedDepartment"] = this.requestedDepartment;
        data["justification"] = this.justification;
        data["tempRef"] = this.tempRef;
        return data; 
    }

    clone(): DeploymentRegistrationPayLoad {
        const json = this.toJSON();
        let result = new DeploymentRegistrationPayLoad();
        result.init(json);
        return result;
    }
}

export interface IDeploymentRegistrationPayLoad {
    id: number;
    employee_id: number;
    staff_no: string | undefined;
    comment: string | undefined;
    last_deployment_date: Date | undefined;
    appointment_date: Date | undefined;
    log_status: number | undefined;
    is_new: boolean | undefined;
    status: string | undefined;
    requested_ministry_id: number | undefined;
    requested_location_id: number | undefined;
    requested_ministry: string | undefined;
    requested_location: string | undefined;
    requested_location_lga: string | undefined;
    requested_location_state: string | undefined;
    request_date: Date;
    current_ministry_id: number | undefined;
    current_location_id: number | undefined;
    current_location: string | undefined;
    current_location_lga: string | undefined;
    current_location_state: string | undefined;
    contractId: number;
    effective_date: Date | undefined;
    str_effective_date: string | undefined;
    periodInCurrentLocation: string | undefined;
    currentDepartment: number;
    requestedDepartment: number;
    justification: string | undefined;
    tempRef: string | undefined;
}

export class DeploymentLogIListApiResult implements IDeploymentLogIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DeploymentLog[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDeploymentLogIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DeploymentLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DeploymentLogIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DeploymentLogIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DeploymentLogIListApiResult {
        const json = this.toJSON();
        let result = new DeploymentLogIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDeploymentLogIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DeploymentLog[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class DeploymentLogDTO implements IDeploymentLogDTO {
    employeeContractid!: number;
    employeeid!: number;
    employeeName!: string | undefined;
    staffNumber!: number;
    appointmentDate!: Date;
    probationPeriod!: string | undefined;
    refNo!: string | undefined;
    comment!: string | undefined;
    request_by!: string | undefined;
    is_new!: boolean;
    last_deployment_date!: Date;
    current_location_id!: number;
    current_school_id!: number;
    current_ministry_id!: number;
    justification!: string | undefined;
    requested_location_id!: number;
    requested_school_id!: number;
    requested_ministry_id!: number;
    log_status!: number;
    bulkaction_id!: number;
    request_date!: Date;
    effective_date!: Date;
    is_treated!: boolean;
    fileName!: string | undefined;
    filePath!: string | undefined;

    constructor(data?: IDeploymentLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeContractid = _data["employeeContractid"];
            this.employeeid = _data["employeeid"];
            this.employeeName = _data["employeeName"];
            this.staffNumber = _data["staffNumber"];
            this.appointmentDate = _data["appointmentDate"] ? new Date(_data["appointmentDate"].toString()) : <any>undefined;
            this.probationPeriod = _data["probationPeriod"];
            this.refNo = _data["refNo"];
            this.comment = _data["comment"];
            this.request_by = _data["request_by"];
            this.is_new = _data["is_new"];
            this.last_deployment_date = _data["last_deployment_date"] ? new Date(_data["last_deployment_date"].toString()) : <any>undefined;
            this.current_location_id = _data["current_location_id"];
            this.current_school_id = _data["current_school_id"];
            this.current_ministry_id = _data["current_ministry_id"];
            this.justification = _data["justification"];
            this.requested_location_id = _data["requested_location_id"];
            this.requested_school_id = _data["requested_school_id"];
            this.requested_ministry_id = _data["requested_ministry_id"];
            this.log_status = _data["log_status"];
            this.bulkaction_id = _data["bulkaction_id"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.effective_date = _data["effective_date"] ? new Date(_data["effective_date"].toString()) : <any>undefined;
            this.is_treated = _data["is_treated"];
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
        }
    }

    static fromJS(data: any): DeploymentLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DeploymentLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeContractid"] = this.employeeContractid;
        data["employeeid"] = this.employeeid;
        data["employeeName"] = this.employeeName;
        data["staffNumber"] = this.staffNumber;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>undefined;
        data["probationPeriod"] = this.probationPeriod;
        data["refNo"] = this.refNo;
        data["comment"] = this.comment;
        data["request_by"] = this.request_by;
        data["is_new"] = this.is_new;
        data["last_deployment_date"] = this.last_deployment_date ? this.last_deployment_date.toISOString() : <any>undefined;
        data["current_location_id"] = this.current_location_id;
        data["current_school_id"] = this.current_school_id;
        data["current_ministry_id"] = this.current_ministry_id;
        data["justification"] = this.justification;
        data["requested_location_id"] = this.requested_location_id;
        data["requested_school_id"] = this.requested_school_id;
        data["requested_ministry_id"] = this.requested_ministry_id;
        data["log_status"] = this.log_status;
        data["bulkaction_id"] = this.bulkaction_id;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["effective_date"] = this.effective_date ? this.effective_date.toISOString() : <any>undefined;
        data["is_treated"] = this.is_treated;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        return data; 
    }

    clone(): DeploymentLogDTO {
        const json = this.toJSON();
        let result = new DeploymentLogDTO();
        result.init(json);
        return result;
    }
}

export interface IDeploymentLogDTO {
    employeeContractid: number;
    employeeid: number;
    employeeName: string | undefined;
    staffNumber: number;
    appointmentDate: Date;
    probationPeriod: string | undefined;
    refNo: string | undefined;
    comment: string | undefined;
    request_by: string | undefined;
    is_new: boolean;
    last_deployment_date: Date;
    current_location_id: number;
    current_school_id: number;
    current_ministry_id: number;
    justification: string | undefined;
    requested_location_id: number;
    requested_school_id: number;
    requested_ministry_id: number;
    log_status: number;
    bulkaction_id: number;
    request_date: Date;
    effective_date: Date;
    is_treated: boolean;
    fileName: string | undefined;
    filePath: string | undefined;
}

export class DeploymentLogDTOIListApiResult implements IDeploymentLogDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DeploymentLogDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDeploymentLogDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DeploymentLogDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DeploymentLogDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DeploymentLogDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DeploymentLogDTOIListApiResult {
        const json = this.toJSON();
        let result = new DeploymentLogDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDeploymentLogDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DeploymentLogDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class IdNameObj implements IIdNameObj {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: IIdNameObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameObj {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }

    clone(): IdNameObj {
        const json = this.toJSON();
        let result = new IdNameObj();
        result.init(json);
        return result;
    }
}

export interface IIdNameObj {
    id: number;
    code: string | undefined;
    name: string | undefined;
}

export class CreateDeploymentViewModel implements ICreateDeploymentViewModel {
    lstLocations!: Location[] | undefined;
    ministries!: IdNameObj[] | undefined;

    constructor(data?: ICreateDeploymentViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lstLocations"])) {
                this.lstLocations = [] as any;
                for (let item of _data["lstLocations"])
                    this.lstLocations!.push(Location.fromJS(item));
            }
            if (Array.isArray(_data["ministries"])) {
                this.ministries = [] as any;
                for (let item of _data["ministries"])
                    this.ministries!.push(IdNameObj.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateDeploymentViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeploymentViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lstLocations)) {
            data["lstLocations"] = [];
            for (let item of this.lstLocations)
                data["lstLocations"].push(item.toJSON());
        }
        if (Array.isArray(this.ministries)) {
            data["ministries"] = [];
            for (let item of this.ministries)
                data["ministries"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateDeploymentViewModel {
        const json = this.toJSON();
        let result = new CreateDeploymentViewModel();
        result.init(json);
        return result;
    }
}

export interface ICreateDeploymentViewModel {
    lstLocations: Location[] | undefined;
    ministries: IdNameObj[] | undefined;
}

export class CreateDeploymentViewModelIListApiResult implements ICreateDeploymentViewModelIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CreateDeploymentViewModel[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICreateDeploymentViewModelIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CreateDeploymentViewModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CreateDeploymentViewModelIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeploymentViewModelIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CreateDeploymentViewModelIListApiResult {
        const json = this.toJSON();
        let result = new CreateDeploymentViewModelIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICreateDeploymentViewModelIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CreateDeploymentViewModel[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class DisburseChannelDTO implements IDisburseChannelDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    channelId!: number;
    channel!: string | undefined;
    secretKey!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDisburseChannelDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.channelId = _data["channelId"];
            this.channel = _data["channel"];
            this.secretKey = _data["secretKey"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DisburseChannelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DisburseChannelDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["channelId"] = this.channelId;
        data["channel"] = this.channel;
        data["secretKey"] = this.secretKey;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DisburseChannelDTO {
        const json = this.toJSON();
        let result = new DisburseChannelDTO();
        result.init(json);
        return result;
    }
}

export interface IDisburseChannelDTO {
    id: number;
    companyID: number;
    subID: number;
    channelId: number;
    channel: string | undefined;
    secretKey: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DisburseChannelDTOListApiResult implements IDisburseChannelDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DisburseChannelDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDisburseChannelDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DisburseChannelDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DisburseChannelDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DisburseChannelDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DisburseChannelDTOListApiResult {
        const json = this.toJSON();
        let result = new DisburseChannelDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDisburseChannelDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DisburseChannelDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class SingleDisbursementPostDTO implements ISingleDisbursementPostDTO {
    id!: number;
    categoryId!: number;
    disbursementBudgetItemId!: number | undefined;
    projectId!: number | undefined;
    channelId!: number;
    isRecurring!: boolean;
    frequencyId!: number;
    runCount!: number | undefined;
    saveAsBeneficiary!: boolean;
    amount!: number;
    accountNumber!: string;
    accountName!: string;
    bankId!: number;
    scheduledDate!: Date;
    description!: string;
    startDate!: Date | undefined;
    endDate!: Date | undefined;

    constructor(data?: ISingleDisbursementPostDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.disbursementBudgetItemId = _data["disbursementBudgetItemId"];
            this.projectId = _data["projectId"];
            this.channelId = _data["channelId"];
            this.isRecurring = _data["isRecurring"];
            this.frequencyId = _data["frequencyId"];
            this.runCount = _data["runCount"];
            this.saveAsBeneficiary = _data["saveAsBeneficiary"];
            this.amount = _data["amount"];
            this.accountNumber = _data["accountNumber"];
            this.accountName = _data["accountName"];
            this.bankId = _data["bankId"];
            this.scheduledDate = _data["scheduledDate"] ? new Date(_data["scheduledDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SingleDisbursementPostDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SingleDisbursementPostDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["disbursementBudgetItemId"] = this.disbursementBudgetItemId;
        data["projectId"] = this.projectId;
        data["channelId"] = this.channelId;
        data["isRecurring"] = this.isRecurring;
        data["frequencyId"] = this.frequencyId;
        data["runCount"] = this.runCount;
        data["saveAsBeneficiary"] = this.saveAsBeneficiary;
        data["amount"] = this.amount;
        data["accountNumber"] = this.accountNumber;
        data["accountName"] = this.accountName;
        data["bankId"] = this.bankId;
        data["scheduledDate"] = this.scheduledDate ? this.scheduledDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): SingleDisbursementPostDTO {
        const json = this.toJSON();
        let result = new SingleDisbursementPostDTO();
        result.init(json);
        return result;
    }
}

export interface ISingleDisbursementPostDTO {
    id: number;
    categoryId: number;
    disbursementBudgetItemId: number | undefined;
    projectId: number | undefined;
    channelId: number;
    isRecurring: boolean;
    frequencyId: number;
    runCount: number | undefined;
    saveAsBeneficiary: boolean;
    amount: number;
    accountNumber: string;
    accountName: string;
    bankId: number;
    scheduledDate: Date;
    description: string;
    startDate: Date | undefined;
    endDate: Date | undefined;
}

export class ManageEmployeeDTO implements IManageEmployeeDTO {
    id!: number;
    profileOperation!: number;
    titleId!: number;
    religionId!: number;
    firstName!: string;
    lastName!: string;
    otherNames!: string | undefined;
    staffNo!: string | undefined;
    employeeNumber!: string;
    dateOfBirth!: Date;
    maritalStatusId!: number;
    genderId!: number;
    personalEmail!: string | undefined;
    workEmail!: string;
    fullName!: string | undefined;
    profilePic!: string | undefined;
    phoneNumber!: string;
    employmentStatusId!: number;
    bvn!: string | undefined;
    contracts!: string | undefined;
    pension!: string | undefined;
    qualifications!: string | undefined;
    addresses!: string | undefined;
    banks!: string | undefined;
    nexkOfKin!: string | undefined;
    employmentHistories!: string | undefined;
    certifications!: string | undefined;
    skills!: string | undefined;
    documents!: string | undefined;

    constructor(data?: IManageEmployeeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.profileOperation = _data["profileOperation"];
            this.titleId = _data["titleId"];
            this.religionId = _data["religionId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherNames = _data["otherNames"];
            this.staffNo = _data["staffNo"];
            this.employeeNumber = _data["employeeNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.maritalStatusId = _data["maritalStatusId"];
            this.genderId = _data["genderId"];
            this.personalEmail = _data["personalEmail"];
            this.workEmail = _data["workEmail"];
            this.fullName = _data["fullName"];
            this.profilePic = _data["profilePic"];
            this.phoneNumber = _data["phoneNumber"];
            this.employmentStatusId = _data["employmentStatusId"];
            this.bvn = _data["bvn"];
            this.contracts = _data["contracts"];
            this.pension = _data["pension"];
            this.qualifications = _data["qualifications"];
            this.addresses = _data["addresses"];
            this.banks = _data["banks"];
            this.nexkOfKin = _data["nexkOfKin"];
            this.employmentHistories = _data["employmentHistories"];
            this.certifications = _data["certifications"];
            this.skills = _data["skills"];
            this.documents = _data["documents"];
        }
    }

    static fromJS(data: any): ManageEmployeeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageEmployeeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["profileOperation"] = this.profileOperation;
        data["titleId"] = this.titleId;
        data["religionId"] = this.religionId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherNames"] = this.otherNames;
        data["staffNo"] = this.staffNo;
        data["employeeNumber"] = this.employeeNumber;
        data["dateOfBirth"] = this.dateOfBirth ? formatDate(this.dateOfBirth) : <any>undefined;
        data["maritalStatusId"] = this.maritalStatusId;
        data["genderId"] = this.genderId;
        data["personalEmail"] = this.personalEmail;
        data["workEmail"] = this.workEmail;
        data["fullName"] = this.fullName;
        data["profilePic"] = this.profilePic;
        data["phoneNumber"] = this.phoneNumber;
        data["employmentStatusId"] = this.employmentStatusId;
        data["bvn"] = this.bvn;
        data["contracts"] = this.contracts;
        data["pension"] = this.pension;
        data["qualifications"] = this.qualifications;
        data["addresses"] = this.addresses;
        data["banks"] = this.banks;
        data["nexkOfKin"] = this.nexkOfKin;
        data["employmentHistories"] = this.employmentHistories;
        data["certifications"] = this.certifications;
        data["skills"] = this.skills;
        data["documents"] = this.documents;
        return data; 
    }

    clone(): ManageEmployeeDTO {
        const json = this.toJSON();
        let result = new ManageEmployeeDTO();
        result.init(json);
        return result;
    }
}

export interface IManageEmployeeDTO {
    id: number;
    profileOperation: number;
    titleId: number;
    religionId: number;
    firstName: string;
    lastName: string;
    otherNames: string | undefined;
    staffNo: string | undefined;
    employeeNumber: string;
    dateOfBirth: Date;
    maritalStatusId: number;
    genderId: number;
    personalEmail: string | undefined;
    workEmail: string;
    fullName: string | undefined;
    profilePic: string | undefined;
    phoneNumber: string;
    employmentStatusId: number;
    bvn: string | undefined;
    contracts: string | undefined;
    pension: string | undefined;
    qualifications: string | undefined;
    addresses: string | undefined;
    banks: string | undefined;
    nexkOfKin: string | undefined;
    employmentHistories: string | undefined;
    certifications: string | undefined;
    skills: string | undefined;
    documents: string | undefined;
}

export class DropdownValueDTO implements IDropdownValueDTO {
    option_text!: string | undefined;
    option_value!: number;
    employee_number!: string | undefined;
    company_id!: number;
    subsidary_id!: number;

    constructor(data?: IDropdownValueDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.option_text = _data["option_text"];
            this.option_value = _data["option_value"];
            this.employee_number = _data["employee_number"];
            this.company_id = _data["company_id"];
            this.subsidary_id = _data["subsidary_id"];
        }
    }

    static fromJS(data: any): DropdownValueDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValueDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["option_text"] = this.option_text;
        data["option_value"] = this.option_value;
        data["employee_number"] = this.employee_number;
        data["company_id"] = this.company_id;
        data["subsidary_id"] = this.subsidary_id;
        return data; 
    }

    clone(): DropdownValueDTO {
        const json = this.toJSON();
        let result = new DropdownValueDTO();
        result.init(json);
        return result;
    }
}

export interface IDropdownValueDTO {
    option_text: string | undefined;
    option_value: number;
    employee_number: string | undefined;
    company_id: number;
    subsidary_id: number;
}

export class DropdownValueDTOIListApiResult implements IDropdownValueDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DropdownValueDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDropdownValueDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DropdownValueDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DropdownValueDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValueDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DropdownValueDTOIListApiResult {
        const json = this.toJSON();
        let result = new DropdownValueDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDropdownValueDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DropdownValueDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class EmployeeContractAssignmentDTO implements IEmployeeContractAssignmentDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    supNumber!: string | undefined;
    assignmentNumber!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    otherName!: string | undefined;
    employeeId!: number;
    employmentTypeId!: number;
    contractEndDate!: Date | undefined;
    supervisorId!: number | undefined;
    supervisorName!: string | undefined;
    fullName!: string | undefined;
    departmentId!: number | undefined;
    departmentName!: string | undefined;
    jobId!: number;
    jobName!: string | undefined;
    gradeId!: number | undefined;
    gradeName!: string | undefined;
    gradeStepId!: number | undefined;
    stepNo!: string | undefined;
    locationId!: number;
    locationName!: string | undefined;
    locationCode!: string | undefined;
    positionId!: number | undefined;
    positionName!: string | undefined;
    ministryId!: number | undefined;
    ministryName!: string | undefined;
    salaryScaleId!: number | undefined;
    salaryScaleName!: string | undefined;
    dateofPresentAppointment!: Date;
    dateofPresentAppointmentStr!: string | undefined;
    dateOfAppointment!: Date;
    dateOfAppointmentStr!: string | undefined;
    dateOfLastDeployment!: Date | undefined;
    dateOfLastDeploymentStr!: string | undefined;
    dateOfConversion!: Date | undefined;
    dateOfConversionStr!: string | undefined;
    dateOfConfirmation!: Date | undefined;
    dateOfConfirmationStr!: string | undefined;
    dateDeployed!: Date | undefined;
    dateDeployedStr!: string | undefined;
    contractEndDateStr!: string | undefined;
    datePromotion!: Date | undefined;
    datePromotionStr!: string | undefined;
    dateOfRetirement!: Date | undefined;
    dateOfRetirementStr!: string | undefined;
    totalEarnings!: number | undefined;
    totalDeductions!: number | undefined;
    netPayment!: number | undefined;
    isContractActive!: boolean;
    isDefaultContract!: boolean;
    noOfLeaveDays!: number | undefined;
    peopleGroupId!: number | undefined;
    lastPromotionDate!: Date | undefined;
    url!: string | undefined;
    payRollTypeId!: number;
    cadreId!: number;
    directorate_id!: number;
    lcda_id!: number;
    lga_id!: number;

    constructor(data?: IEmployeeContractAssignmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.supNumber = _data["supNumber"];
            this.assignmentNumber = _data["assignmentNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherName = _data["otherName"];
            this.employeeId = _data["employeeId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.contractEndDate = _data["contractEndDate"] ? new Date(_data["contractEndDate"].toString()) : <any>undefined;
            this.supervisorId = _data["supervisorId"];
            this.supervisorName = _data["supervisorName"];
            this.fullName = _data["fullName"];
            this.departmentId = _data["departmentId"];
            this.departmentName = _data["departmentName"];
            this.jobId = _data["jobId"];
            this.jobName = _data["jobName"];
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.gradeStepId = _data["gradeStepId"];
            this.stepNo = _data["stepNo"];
            this.locationId = _data["locationId"];
            this.locationName = _data["locationName"];
            this.locationCode = _data["locationCode"];
            this.positionId = _data["positionId"];
            this.positionName = _data["positionName"];
            this.ministryId = _data["ministryId"];
            this.ministryName = _data["ministryName"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.salaryScaleName = _data["salaryScaleName"];
            this.dateofPresentAppointment = _data["dateofPresentAppointment"] ? new Date(_data["dateofPresentAppointment"].toString()) : <any>undefined;
            this.dateofPresentAppointmentStr = _data["dateofPresentAppointmentStr"];
            this.dateOfAppointment = _data["dateOfAppointment"] ? new Date(_data["dateOfAppointment"].toString()) : <any>undefined;
            this.dateOfAppointmentStr = _data["dateOfAppointmentStr"];
            this.dateOfLastDeployment = _data["dateOfLastDeployment"] ? new Date(_data["dateOfLastDeployment"].toString()) : <any>undefined;
            this.dateOfLastDeploymentStr = _data["dateOfLastDeploymentStr"];
            this.dateOfConversion = _data["dateOfConversion"] ? new Date(_data["dateOfConversion"].toString()) : <any>undefined;
            this.dateOfConversionStr = _data["dateOfConversionStr"];
            this.dateOfConfirmation = _data["dateOfConfirmation"] ? new Date(_data["dateOfConfirmation"].toString()) : <any>undefined;
            this.dateOfConfirmationStr = _data["dateOfConfirmationStr"];
            this.dateDeployed = _data["dateDeployed"] ? new Date(_data["dateDeployed"].toString()) : <any>undefined;
            this.dateDeployedStr = _data["dateDeployedStr"];
            this.contractEndDateStr = _data["contractEndDateStr"];
            this.datePromotion = _data["datePromotion"] ? new Date(_data["datePromotion"].toString()) : <any>undefined;
            this.datePromotionStr = _data["datePromotionStr"];
            this.dateOfRetirement = _data["dateOfRetirement"] ? new Date(_data["dateOfRetirement"].toString()) : <any>undefined;
            this.dateOfRetirementStr = _data["dateOfRetirementStr"];
            this.totalEarnings = _data["totalEarnings"];
            this.totalDeductions = _data["totalDeductions"];
            this.netPayment = _data["netPayment"];
            this.isContractActive = _data["isContractActive"];
            this.isDefaultContract = _data["isDefaultContract"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.peopleGroupId = _data["peopleGroupId"];
            this.lastPromotionDate = _data["lastPromotionDate"] ? new Date(_data["lastPromotionDate"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.payRollTypeId = _data["payRollTypeId"];
            this.cadreId = _data["cadreId"];
            this.directorate_id = _data["directorate_id"];
            this.lcda_id = _data["lcda_id"];
            this.lga_id = _data["lga_id"];
        }
    }

    static fromJS(data: any): EmployeeContractAssignmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeContractAssignmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["supNumber"] = this.supNumber;
        data["assignmentNumber"] = this.assignmentNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherName"] = this.otherName;
        data["employeeId"] = this.employeeId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["contractEndDate"] = this.contractEndDate ? this.contractEndDate.toISOString() : <any>undefined;
        data["supervisorId"] = this.supervisorId;
        data["supervisorName"] = this.supervisorName;
        data["fullName"] = this.fullName;
        data["departmentId"] = this.departmentId;
        data["departmentName"] = this.departmentName;
        data["jobId"] = this.jobId;
        data["jobName"] = this.jobName;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["gradeStepId"] = this.gradeStepId;
        data["stepNo"] = this.stepNo;
        data["locationId"] = this.locationId;
        data["locationName"] = this.locationName;
        data["locationCode"] = this.locationCode;
        data["positionId"] = this.positionId;
        data["positionName"] = this.positionName;
        data["ministryId"] = this.ministryId;
        data["ministryName"] = this.ministryName;
        data["salaryScaleId"] = this.salaryScaleId;
        data["salaryScaleName"] = this.salaryScaleName;
        data["dateofPresentAppointment"] = this.dateofPresentAppointment ? this.dateofPresentAppointment.toISOString() : <any>undefined;
        data["dateofPresentAppointmentStr"] = this.dateofPresentAppointmentStr;
        data["dateOfAppointment"] = this.dateOfAppointment ? this.dateOfAppointment.toISOString() : <any>undefined;
        data["dateOfAppointmentStr"] = this.dateOfAppointmentStr;
        data["dateOfLastDeployment"] = this.dateOfLastDeployment ? this.dateOfLastDeployment.toISOString() : <any>undefined;
        data["dateOfLastDeploymentStr"] = this.dateOfLastDeploymentStr;
        data["dateOfConversion"] = this.dateOfConversion ? this.dateOfConversion.toISOString() : <any>undefined;
        data["dateOfConversionStr"] = this.dateOfConversionStr;
        data["dateOfConfirmation"] = this.dateOfConfirmation ? this.dateOfConfirmation.toISOString() : <any>undefined;
        data["dateOfConfirmationStr"] = this.dateOfConfirmationStr;
        data["dateDeployed"] = this.dateDeployed ? this.dateDeployed.toISOString() : <any>undefined;
        data["dateDeployedStr"] = this.dateDeployedStr;
        data["contractEndDateStr"] = this.contractEndDateStr;
        data["datePromotion"] = this.datePromotion ? this.datePromotion.toISOString() : <any>undefined;
        data["datePromotionStr"] = this.datePromotionStr;
        data["dateOfRetirement"] = this.dateOfRetirement ? this.dateOfRetirement.toISOString() : <any>undefined;
        data["dateOfRetirementStr"] = this.dateOfRetirementStr;
        data["totalEarnings"] = this.totalEarnings;
        data["totalDeductions"] = this.totalDeductions;
        data["netPayment"] = this.netPayment;
        data["isContractActive"] = this.isContractActive;
        data["isDefaultContract"] = this.isDefaultContract;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["peopleGroupId"] = this.peopleGroupId;
        data["lastPromotionDate"] = this.lastPromotionDate ? this.lastPromotionDate.toISOString() : <any>undefined;
        data["url"] = this.url;
        data["payRollTypeId"] = this.payRollTypeId;
        data["cadreId"] = this.cadreId;
        data["directorate_id"] = this.directorate_id;
        data["lcda_id"] = this.lcda_id;
        data["lga_id"] = this.lga_id;
        return data; 
    }

    clone(): EmployeeContractAssignmentDTO {
        const json = this.toJSON();
        let result = new EmployeeContractAssignmentDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeContractAssignmentDTO {
    id: number;
    companyID: number;
    subID: number;
    supNumber: string | undefined;
    assignmentNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    otherName: string | undefined;
    employeeId: number;
    employmentTypeId: number;
    contractEndDate: Date | undefined;
    supervisorId: number | undefined;
    supervisorName: string | undefined;
    fullName: string | undefined;
    departmentId: number | undefined;
    departmentName: string | undefined;
    jobId: number;
    jobName: string | undefined;
    gradeId: number | undefined;
    gradeName: string | undefined;
    gradeStepId: number | undefined;
    stepNo: string | undefined;
    locationId: number;
    locationName: string | undefined;
    locationCode: string | undefined;
    positionId: number | undefined;
    positionName: string | undefined;
    ministryId: number | undefined;
    ministryName: string | undefined;
    salaryScaleId: number | undefined;
    salaryScaleName: string | undefined;
    dateofPresentAppointment: Date;
    dateofPresentAppointmentStr: string | undefined;
    dateOfAppointment: Date;
    dateOfAppointmentStr: string | undefined;
    dateOfLastDeployment: Date | undefined;
    dateOfLastDeploymentStr: string | undefined;
    dateOfConversion: Date | undefined;
    dateOfConversionStr: string | undefined;
    dateOfConfirmation: Date | undefined;
    dateOfConfirmationStr: string | undefined;
    dateDeployed: Date | undefined;
    dateDeployedStr: string | undefined;
    contractEndDateStr: string | undefined;
    datePromotion: Date | undefined;
    datePromotionStr: string | undefined;
    dateOfRetirement: Date | undefined;
    dateOfRetirementStr: string | undefined;
    totalEarnings: number | undefined;
    totalDeductions: number | undefined;
    netPayment: number | undefined;
    isContractActive: boolean;
    isDefaultContract: boolean;
    noOfLeaveDays: number | undefined;
    peopleGroupId: number | undefined;
    lastPromotionDate: Date | undefined;
    url: string | undefined;
    payRollTypeId: number;
    cadreId: number;
    directorate_id: number;
    lcda_id: number;
    lga_id: number;
}

export class Pension implements IPension {
    pensionerFileNo!: string | undefined;
    pfaId!: number;
    pfa!: string | undefined;
    rsaNumber!: string | undefined;

    constructor(data?: IPension) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pensionerFileNo = _data["pensionerFileNo"];
            this.pfaId = _data["pfaId"];
            this.pfa = _data["pfa"];
            this.rsaNumber = _data["rsaNumber"];
        }
    }

    static fromJS(data: any): Pension {
        data = typeof data === 'object' ? data : {};
        let result = new Pension();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pensionerFileNo"] = this.pensionerFileNo;
        data["pfaId"] = this.pfaId;
        data["pfa"] = this.pfa;
        data["rsaNumber"] = this.rsaNumber;
        return data; 
    }

    clone(): Pension {
        const json = this.toJSON();
        let result = new Pension();
        result.init(json);
        return result;
    }
}

export interface IPension {
    pensionerFileNo: string | undefined;
    pfaId: number;
    pfa: string | undefined;
    rsaNumber: string | undefined;
}

export class EmployeeQualificationDTO implements IEmployeeQualificationDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    employeeId!: number;
    name!: string | undefined;
    qualificationId!: number;
    qualificationGradeId!: number;
    courseId!: number;
    institutionId!: number;
    institution!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    type!: string | undefined;
    typeId!: number;
    courseName!: string | undefined;
    grade!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeQualificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.employeeId = _data["employeeId"];
            this.name = _data["name"];
            this.qualificationId = _data["qualificationId"];
            this.qualificationGradeId = _data["qualificationGradeId"];
            this.courseId = _data["courseId"];
            this.institutionId = _data["institutionId"];
            this.institution = _data["institution"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.typeId = _data["typeId"];
            this.courseName = _data["courseName"];
            this.grade = _data["grade"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeQualificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeQualificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["employeeId"] = this.employeeId;
        data["name"] = this.name;
        data["qualificationId"] = this.qualificationId;
        data["qualificationGradeId"] = this.qualificationGradeId;
        data["courseId"] = this.courseId;
        data["institutionId"] = this.institutionId;
        data["institution"] = this.institution;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["typeId"] = this.typeId;
        data["courseName"] = this.courseName;
        data["grade"] = this.grade;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeQualificationDTO {
        const json = this.toJSON();
        let result = new EmployeeQualificationDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeQualificationDTO {
    id: number;
    companyID: number;
    subID: number;
    employeeId: number;
    name: string | undefined;
    qualificationId: number;
    qualificationGradeId: number;
    courseId: number;
    institutionId: number;
    institution: string | undefined;
    startDate: Date;
    endDate: Date;
    type: string | undefined;
    typeId: number;
    courseName: string | undefined;
    grade: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class AddressDTO implements IAddressDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    employee_id!: number;
    country_id!: number;
    country!: string | undefined;
    state_id!: number;
    state!: string | undefined;
    lga_id!: number;
    lga!: string | undefined;
    address1!: string | undefined;
    address2!: string | undefined;
    address_type!: number;
    address_type_name!: string | undefined;
    is_primary_address!: boolean;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IAddressDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.employee_id = _data["employee_id"];
            this.country_id = _data["country_id"];
            this.country = _data["country"];
            this.state_id = _data["state_id"];
            this.state = _data["state"];
            this.lga_id = _data["lga_id"];
            this.lga = _data["lga"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.address_type = _data["address_type"];
            this.address_type_name = _data["address_type_name"];
            this.is_primary_address = _data["is_primary_address"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): AddressDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["employee_id"] = this.employee_id;
        data["country_id"] = this.country_id;
        data["country"] = this.country;
        data["state_id"] = this.state_id;
        data["state"] = this.state;
        data["lga_id"] = this.lga_id;
        data["lga"] = this.lga;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["address_type"] = this.address_type;
        data["address_type_name"] = this.address_type_name;
        data["is_primary_address"] = this.is_primary_address;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): AddressDTO {
        const json = this.toJSON();
        let result = new AddressDTO();
        result.init(json);
        return result;
    }
}

export interface IAddressDTO {
    id: number;
    companyID: number;
    subID: number;
    employee_id: number;
    country_id: number;
    country: string | undefined;
    state_id: number;
    state: string | undefined;
    lga_id: number;
    lga: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    address_type: number;
    address_type_name: string | undefined;
    is_primary_address: boolean;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeBankDTO implements IEmployeeBankDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    employee_id!: number;
    bank_id!: number;
    bank_name!: string | undefined;
    bank_sort_code!: string | undefined;
    account_no!: string | undefined;
    account_name!: string | undefined;
    account_typeId!: number;
    account_type!: string | undefined;
    is_primary!: number | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeBankDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.employee_id = _data["employee_id"];
            this.bank_id = _data["bank_id"];
            this.bank_name = _data["bank_name"];
            this.bank_sort_code = _data["bank_sort_code"];
            this.account_no = _data["account_no"];
            this.account_name = _data["account_name"];
            this.account_typeId = _data["account_typeId"];
            this.account_type = _data["account_type"];
            this.is_primary = _data["is_primary"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeBankDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeBankDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["employee_id"] = this.employee_id;
        data["bank_id"] = this.bank_id;
        data["bank_name"] = this.bank_name;
        data["bank_sort_code"] = this.bank_sort_code;
        data["account_no"] = this.account_no;
        data["account_name"] = this.account_name;
        data["account_typeId"] = this.account_typeId;
        data["account_type"] = this.account_type;
        data["is_primary"] = this.is_primary;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeBankDTO {
        const json = this.toJSON();
        let result = new EmployeeBankDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeBankDTO {
    id: number;
    companyID: number;
    subID: number;
    employee_id: number;
    bank_id: number;
    bank_name: string | undefined;
    bank_sort_code: string | undefined;
    account_no: string | undefined;
    account_name: string | undefined;
    account_typeId: number;
    account_type: string | undefined;
    is_primary: number | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class NextOfKin implements INextOfKin {
    employee_id!: number;
    nok_first_name!: string;
    nok_last_name!: string;
    nok_address!: string;
    nok_email!: string | undefined;
    nok_phone!: string | undefined;
    nok_employer!: string | undefined;
    nok_work_address!: string | undefined;
    nok_relationship!: string;
    timestamp!: Date;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: INextOfKin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employee_id = _data["employee_id"];
            this.nok_first_name = _data["nok_first_name"];
            this.nok_last_name = _data["nok_last_name"];
            this.nok_address = _data["nok_address"];
            this.nok_email = _data["nok_email"];
            this.nok_phone = _data["nok_phone"];
            this.nok_employer = _data["nok_employer"];
            this.nok_work_address = _data["nok_work_address"];
            this.nok_relationship = _data["nok_relationship"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): NextOfKin {
        data = typeof data === 'object' ? data : {};
        let result = new NextOfKin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employee_id"] = this.employee_id;
        data["nok_first_name"] = this.nok_first_name;
        data["nok_last_name"] = this.nok_last_name;
        data["nok_address"] = this.nok_address;
        data["nok_email"] = this.nok_email;
        data["nok_phone"] = this.nok_phone;
        data["nok_employer"] = this.nok_employer;
        data["nok_work_address"] = this.nok_work_address;
        data["nok_relationship"] = this.nok_relationship;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): NextOfKin {
        const json = this.toJSON();
        let result = new NextOfKin();
        result.init(json);
        return result;
    }
}

export interface INextOfKin {
    employee_id: number;
    nok_first_name: string;
    nok_last_name: string;
    nok_address: string;
    nok_email: string | undefined;
    nok_phone: string | undefined;
    nok_employer: string | undefined;
    nok_work_address: string | undefined;
    nok_relationship: string;
    timestamp: Date;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeHistoryDTO implements IEmployeeHistoryDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    employeeID!: number | undefined;
    employerAddress!: string | undefined;
    jobTitleId!: number | undefined;
    jobTitle!: string | undefined;
    departmentId!: number | undefined;
    department!: string | undefined;
    startDate!: Date;
    endDate!: Date | undefined;
    designation!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.employeeID = _data["employeeID"];
            this.employerAddress = _data["employerAddress"];
            this.jobTitleId = _data["jobTitleId"];
            this.jobTitle = _data["jobTitle"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.designation = _data["designation"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["employeeID"] = this.employeeID;
        data["employerAddress"] = this.employerAddress;
        data["jobTitleId"] = this.jobTitleId;
        data["jobTitle"] = this.jobTitle;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["designation"] = this.designation;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeHistoryDTO {
        const json = this.toJSON();
        let result = new EmployeeHistoryDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeHistoryDTO {
    id: number;
    companyID: number;
    subID: number;
    employeeID: number | undefined;
    employerAddress: string | undefined;
    jobTitleId: number | undefined;
    jobTitle: string | undefined;
    departmentId: number | undefined;
    department: string | undefined;
    startDate: Date;
    endDate: Date | undefined;
    designation: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeCertificationDTO implements IEmployeeCertificationDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    employeeId!: number;
    certificationId!: number;
    certification!: string | undefined;
    professionalBodyId!: number;
    institution!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    comment!: string | undefined;
    numberOfExperienceInMonth!: number | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeCertificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.employeeId = _data["employeeId"];
            this.certificationId = _data["certificationId"];
            this.certification = _data["certification"];
            this.professionalBodyId = _data["professionalBodyId"];
            this.institution = _data["institution"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.numberOfExperienceInMonth = _data["numberOfExperienceInMonth"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeCertificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeCertificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["employeeId"] = this.employeeId;
        data["certificationId"] = this.certificationId;
        data["certification"] = this.certification;
        data["professionalBodyId"] = this.professionalBodyId;
        data["institution"] = this.institution;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["numberOfExperienceInMonth"] = this.numberOfExperienceInMonth;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeCertificationDTO {
        const json = this.toJSON();
        let result = new EmployeeCertificationDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeCertificationDTO {
    id: number;
    companyID: number;
    subID: number;
    employeeId: number;
    certificationId: number;
    certification: string | undefined;
    professionalBodyId: number;
    institution: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    comment: string | undefined;
    numberOfExperienceInMonth: number | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeSkillDTO implements IEmployeeSkillDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    employeeId!: number;
    skillId!: number;
    skillName!: string | undefined;
    categoryId!: number;
    categoryName!: string | undefined;
    startDate!: Date | undefined;
    numberOfExperienceInMonth!: number | undefined;
    point!: number | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;

    constructor(data?: IEmployeeSkillDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.employeeId = _data["employeeId"];
            this.skillId = _data["skillId"];
            this.skillName = _data["skillName"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.numberOfExperienceInMonth = _data["numberOfExperienceInMonth"];
            this.point = _data["point"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
        }
    }

    static fromJS(data: any): EmployeeSkillDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeSkillDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["employeeId"] = this.employeeId;
        data["skillId"] = this.skillId;
        data["skillName"] = this.skillName;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["numberOfExperienceInMonth"] = this.numberOfExperienceInMonth;
        data["point"] = this.point;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        return data; 
    }

    clone(): EmployeeSkillDTO {
        const json = this.toJSON();
        let result = new EmployeeSkillDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeSkillDTO {
    id: number;
    companyID: number;
    subID: number;
    employeeId: number;
    skillId: number;
    skillName: string | undefined;
    categoryId: number;
    categoryName: string | undefined;
    startDate: Date | undefined;
    numberOfExperienceInMonth: number | undefined;
    point: number | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
}

export class Document implements IDocument {
    employee_Id!: number;
    employeeNo!: string | undefined;
    name!: string;
    docUrl!: string | undefined;
    directory!: string | undefined;
    docType!: string | undefined;
    lastModifiedDate!: Date;
    comment!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employee_Id = _data["employee_Id"];
            this.employeeNo = _data["employeeNo"];
            this.name = _data["name"];
            this.docUrl = _data["docUrl"];
            this.directory = _data["directory"];
            this.docType = _data["docType"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employee_Id"] = this.employee_Id;
        data["employeeNo"] = this.employeeNo;
        data["name"] = this.name;
        data["docUrl"] = this.docUrl;
        data["directory"] = this.directory;
        data["docType"] = this.docType;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Document {
        const json = this.toJSON();
        let result = new Document();
        result.init(json);
        return result;
    }
}

export interface IDocument {
    employee_Id: number;
    employeeNo: string | undefined;
    name: string;
    docUrl: string | undefined;
    directory: string | undefined;
    docType: string | undefined;
    lastModifiedDate: Date;
    comment: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeDTO implements IEmployeeDTO {
    id!: number;
    employeeContractId!: number;
    companyId!: number;
    subID!: number;
    userId!: number;
    titleId!: number;
    religionId!: number | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    otherNames!: string | undefined;
    staffNo!: string | undefined;
    gradeId!: number;
    employeeNumber!: string | undefined;
    dateOfBirth!: Date | undefined;
    maritalStatusId!: number;
    genderId!: number;
    personalEmail!: string | undefined;
    workEmail!: string | undefined;
    fullName!: string | undefined;
    profilePic!: string | undefined;
    workMobile!: string | undefined;
    employmentStatusId!: number;
    bvn!: string | undefined;
    subjectSpecialization!: string | undefined;
    selfServiceStatus!: string | undefined;
    stateOfOrigin!: string | undefined;
    lgaOfOrigin!: string | undefined;
    originCountry!: number | undefined;
    originState!: number | undefined;
    residentialCountry!: number | undefined;
    residentialState!: number | undefined;
    residentialLga!: number | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    created_by!: string | undefined;
    contracts!: EmployeeContractAssignmentDTO[] | undefined;
    pension!: Pension;
    qualifications!: EmployeeQualificationDTO[] | undefined;
    addresses!: AddressDTO[] | undefined;
    banks!: EmployeeBankDTO[] | undefined;
    nexkOfKin!: NextOfKin;
    employmentHistories!: EmployeeHistoryDTO[] | undefined;
    certifications!: EmployeeCertificationDTO[] | undefined;
    skills!: EmployeeSkillDTO[] | undefined;
    documents!: Document[] | undefined;

    constructor(data?: IEmployeeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeContractId = _data["employeeContractId"];
            this.companyId = _data["companyId"];
            this.subID = _data["subID"];
            this.userId = _data["userId"];
            this.titleId = _data["titleId"];
            this.religionId = _data["religionId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherNames = _data["otherNames"];
            this.staffNo = _data["staffNo"];
            this.gradeId = _data["gradeId"];
            this.employeeNumber = _data["employeeNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.maritalStatusId = _data["maritalStatusId"];
            this.genderId = _data["genderId"];
            this.personalEmail = _data["personalEmail"];
            this.workEmail = _data["workEmail"];
            this.fullName = _data["fullName"];
            this.profilePic = _data["profilePic"];
            this.workMobile = _data["workMobile"];
            this.employmentStatusId = _data["employmentStatusId"];
            this.bvn = _data["bvn"];
            this.subjectSpecialization = _data["subjectSpecialization"];
            this.selfServiceStatus = _data["selfServiceStatus"];
            this.stateOfOrigin = _data["stateOfOrigin"];
            this.lgaOfOrigin = _data["lgaOfOrigin"];
            this.originCountry = _data["originCountry"];
            this.originState = _data["originState"];
            this.residentialCountry = _data["residentialCountry"];
            this.residentialState = _data["residentialState"];
            this.residentialLga = _data["residentialLga"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.created_by = _data["created_by"];
            if (Array.isArray(_data["contracts"])) {
                this.contracts = [] as any;
                for (let item of _data["contracts"])
                    this.contracts!.push(EmployeeContractAssignmentDTO.fromJS(item));
            }
            this.pension = _data["pension"] ? Pension.fromJS(_data["pension"]) : <any>undefined;
            if (Array.isArray(_data["qualifications"])) {
                this.qualifications = [] as any;
                for (let item of _data["qualifications"])
                    this.qualifications!.push(EmployeeQualificationDTO.fromJS(item));
            }
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(AddressDTO.fromJS(item));
            }
            if (Array.isArray(_data["banks"])) {
                this.banks = [] as any;
                for (let item of _data["banks"])
                    this.banks!.push(EmployeeBankDTO.fromJS(item));
            }
            this.nexkOfKin = _data["nexkOfKin"] ? NextOfKin.fromJS(_data["nexkOfKin"]) : <any>undefined;
            if (Array.isArray(_data["employmentHistories"])) {
                this.employmentHistories = [] as any;
                for (let item of _data["employmentHistories"])
                    this.employmentHistories!.push(EmployeeHistoryDTO.fromJS(item));
            }
            if (Array.isArray(_data["certifications"])) {
                this.certifications = [] as any;
                for (let item of _data["certifications"])
                    this.certifications!.push(EmployeeCertificationDTO.fromJS(item));
            }
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(EmployeeSkillDTO.fromJS(item));
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(Document.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmployeeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeContractId"] = this.employeeContractId;
        data["companyId"] = this.companyId;
        data["subID"] = this.subID;
        data["userId"] = this.userId;
        data["titleId"] = this.titleId;
        data["religionId"] = this.religionId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherNames"] = this.otherNames;
        data["staffNo"] = this.staffNo;
        data["gradeId"] = this.gradeId;
        data["employeeNumber"] = this.employeeNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["maritalStatusId"] = this.maritalStatusId;
        data["genderId"] = this.genderId;
        data["personalEmail"] = this.personalEmail;
        data["workEmail"] = this.workEmail;
        data["fullName"] = this.fullName;
        data["profilePic"] = this.profilePic;
        data["workMobile"] = this.workMobile;
        data["employmentStatusId"] = this.employmentStatusId;
        data["bvn"] = this.bvn;
        data["subjectSpecialization"] = this.subjectSpecialization;
        data["selfServiceStatus"] = this.selfServiceStatus;
        data["stateOfOrigin"] = this.stateOfOrigin;
        data["lgaOfOrigin"] = this.lgaOfOrigin;
        data["originCountry"] = this.originCountry;
        data["originState"] = this.originState;
        data["residentialCountry"] = this.residentialCountry;
        data["residentialState"] = this.residentialState;
        data["residentialLga"] = this.residentialLga;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["created_by"] = this.created_by;
        if (Array.isArray(this.contracts)) {
            data["contracts"] = [];
            for (let item of this.contracts)
                data["contracts"].push(item.toJSON());
        }
        data["pension"] = this.pension ? this.pension.toJSON() : <any>undefined;
        if (Array.isArray(this.qualifications)) {
            data["qualifications"] = [];
            for (let item of this.qualifications)
                data["qualifications"].push(item.toJSON());
        }
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.banks)) {
            data["banks"] = [];
            for (let item of this.banks)
                data["banks"].push(item.toJSON());
        }
        data["nexkOfKin"] = this.nexkOfKin ? this.nexkOfKin.toJSON() : <any>undefined;
        if (Array.isArray(this.employmentHistories)) {
            data["employmentHistories"] = [];
            for (let item of this.employmentHistories)
                data["employmentHistories"].push(item.toJSON());
        }
        if (Array.isArray(this.certifications)) {
            data["certifications"] = [];
            for (let item of this.certifications)
                data["certifications"].push(item.toJSON());
        }
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EmployeeDTO {
        const json = this.toJSON();
        let result = new EmployeeDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDTO {
    id: number;
    employeeContractId: number;
    companyId: number;
    subID: number;
    userId: number;
    titleId: number;
    religionId: number | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    otherNames: string | undefined;
    staffNo: string | undefined;
    gradeId: number;
    employeeNumber: string | undefined;
    dateOfBirth: Date | undefined;
    maritalStatusId: number;
    genderId: number;
    personalEmail: string | undefined;
    workEmail: string | undefined;
    fullName: string | undefined;
    profilePic: string | undefined;
    workMobile: string | undefined;
    employmentStatusId: number;
    bvn: string | undefined;
    subjectSpecialization: string | undefined;
    selfServiceStatus: string | undefined;
    stateOfOrigin: string | undefined;
    lgaOfOrigin: string | undefined;
    originCountry: number | undefined;
    originState: number | undefined;
    residentialCountry: number | undefined;
    residentialState: number | undefined;
    residentialLga: number | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    created_by: string | undefined;
    contracts: EmployeeContractAssignmentDTO[] | undefined;
    pension: Pension;
    qualifications: EmployeeQualificationDTO[] | undefined;
    addresses: AddressDTO[] | undefined;
    banks: EmployeeBankDTO[] | undefined;
    nexkOfKin: NextOfKin;
    employmentHistories: EmployeeHistoryDTO[] | undefined;
    certifications: EmployeeCertificationDTO[] | undefined;
    skills: EmployeeSkillDTO[] | undefined;
    documents: Document[] | undefined;
}

export class EmployeeDTOApiResult implements IEmployeeDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmployeeDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmployeeDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmployeeDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmployeeDTOApiResult {
        const json = this.toJSON();
        let result = new EmployeeDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeDTO;
    totalCount: number;
    totalRecord: number;
}

export class EmployeeDTOIListApiResult implements IEmployeeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmployeeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmployeeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmployeeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmployeeDTOIListApiResult {
        const json = this.toJSON();
        let result = new EmployeeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class EmployeeContractAssignmentDTOApiResult implements IEmployeeContractAssignmentDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeContractAssignmentDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmployeeContractAssignmentDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmployeeContractAssignmentDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmployeeContractAssignmentDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeContractAssignmentDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmployeeContractAssignmentDTOApiResult {
        const json = this.toJSON();
        let result = new EmployeeContractAssignmentDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeContractAssignmentDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeContractAssignmentDTO;
    totalCount: number;
    totalRecord: number;
}

export class ManageEventDTO implements IManageEventDTO {
    title!: string;
    eventTypeId!: number;
    id!: number;
    notify_Employee!: boolean;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    description!: string | undefined;

    constructor(data?: IManageEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.eventTypeId = _data["eventTypeId"];
            this.id = _data["id"];
            this.notify_Employee = _data["notify_Employee"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ManageEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["eventTypeId"] = this.eventTypeId;
        data["id"] = this.id;
        data["notify_Employee"] = this.notify_Employee;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data; 
    }

    clone(): ManageEventDTO {
        const json = this.toJSON();
        let result = new ManageEventDTO();
        result.init(json);
        return result;
    }
}

export interface IManageEventDTO {
    title: string;
    eventTypeId: number;
    id: number;
    notify_Employee: boolean;
    startDate: Date | undefined;
    endDate: Date | undefined;
    description: string | undefined;
}

export class EventDTO implements IEventDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    eventName!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    eventTypeID!: number;
    title!: string | undefined;
    isSystem!: boolean;
    notify_Employee!: boolean;
    file!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    description!: string | undefined;

    constructor(data?: IEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.eventName = _data["eventName"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.eventTypeID = _data["eventTypeID"];
            this.title = _data["title"];
            this.isSystem = _data["isSystem"];
            this.notify_Employee = _data["notify_Employee"];
            this.file = _data["file"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): EventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["eventName"] = this.eventName;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["eventTypeID"] = this.eventTypeID;
        data["title"] = this.title;
        data["isSystem"] = this.isSystem;
        data["notify_Employee"] = this.notify_Employee;
        data["file"] = this.file;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data; 
    }

    clone(): EventDTO {
        const json = this.toJSON();
        let result = new EventDTO();
        result.init(json);
        return result;
    }
}

export interface IEventDTO {
    id: number;
    companyID: number;
    subID: number;
    eventName: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    eventTypeID: number;
    title: string | undefined;
    isSystem: boolean;
    notify_Employee: boolean;
    file: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    description: string | undefined;
}

export class EventDTOListApiResult implements IEventDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EventDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEventDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EventDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EventDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EventDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EventDTOListApiResult {
        const json = this.toJSON();
        let result = new EventDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEventDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EventDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class EventDTOApiResult implements IEventDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EventDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEventDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EventDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EventDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EventDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EventDTOApiResult {
        const json = this.toJSON();
        let result = new EventDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEventDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EventDTO;
    totalCount: number;
    totalRecord: number;
}

export class ExpenseGroupDto implements IExpenseGroupDto {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    referenceId!: string | undefined;

    constructor(data?: IExpenseGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.referenceId = _data["referenceId"];
        }
    }

    static fromJS(data: any): ExpenseGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["referenceId"] = this.referenceId;
        return data; 
    }

    clone(): ExpenseGroupDto {
        const json = this.toJSON();
        let result = new ExpenseGroupDto();
        result.init(json);
        return result;
    }
}

export interface IExpenseGroupDto {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    referenceId: string | undefined;
}

export class ExpenseGroup implements IExpenseGroup {
    name!: string | undefined;
    referenceId!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.referenceId = _data["referenceId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseGroup {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["referenceId"] = this.referenceId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseGroup {
        const json = this.toJSON();
        let result = new ExpenseGroup();
        result.init(json);
        return result;
    }
}

export interface IExpenseGroup {
    name: string | undefined;
    referenceId: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseGroupIListApiResult implements IExpenseGroupIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ExpenseGroup[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IExpenseGroupIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ExpenseGroup.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ExpenseGroupIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseGroupIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ExpenseGroupIListApiResult {
        const json = this.toJSON();
        let result = new ExpenseGroupIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IExpenseGroupIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ExpenseGroup[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ExpenseProjectDto implements IExpenseProjectDto {
    id!: number;
    name!: string | undefined;
    companyID!: number;
    subID!: number;
    description!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    ban!: boolean;
    referenceId!: string | undefined;
    code!: string | undefined;
    isClosedEnded!: boolean;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    actionTitle!: string | undefined;
    readonly startDateString!: string | undefined;
    readonly endDateString!: string | undefined;
    status!: string | undefined;

    constructor(data?: IExpenseProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.ban = _data["ban"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isClosedEnded = _data["isClosedEnded"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.actionTitle = _data["actionTitle"];
            (<any>this).startDateString = _data["startDateString"];
            (<any>this).endDateString = _data["endDateString"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ExpenseProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ban"] = this.ban;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isClosedEnded"] = this.isClosedEnded;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["actionTitle"] = this.actionTitle;
        data["startDateString"] = this.startDateString;
        data["endDateString"] = this.endDateString;
        data["status"] = this.status;
        return data; 
    }

    clone(): ExpenseProjectDto {
        const json = this.toJSON();
        let result = new ExpenseProjectDto();
        result.init(json);
        return result;
    }
}

export interface IExpenseProjectDto {
    id: number;
    name: string | undefined;
    companyID: number;
    subID: number;
    description: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    ban: boolean;
    referenceId: string | undefined;
    code: string | undefined;
    isClosedEnded: boolean;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    actionTitle: string | undefined;
    startDateString: string | undefined;
    endDateString: string | undefined;
    status: string | undefined;
}

export class ExpenseDoc implements IExpenseDoc {
    expenseId!: number;
    path!: string | undefined;
    docType!: number;
    expense!: Expense;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseDoc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expenseId = _data["expenseId"];
            this.path = _data["path"];
            this.docType = _data["docType"];
            this.expense = _data["expense"] ? Expense.fromJS(_data["expense"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseDoc {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseDoc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expenseId"] = this.expenseId;
        data["path"] = this.path;
        data["docType"] = this.docType;
        data["expense"] = this.expense ? this.expense.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseDoc {
        const json = this.toJSON();
        let result = new ExpenseDoc();
        result.init(json);
        return result;
    }
}

export interface IExpenseDoc {
    expenseId: number;
    path: string | undefined;
    docType: number;
    expense: Expense;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseSubType implements IExpenseSubType {
    expenseTypeId!: number;
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    referenceId!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    approvalProcessId!: number | undefined;
    budgetedAmount!: number | undefined;
    currentAmount!: number | undefined;
    strBudgetedAmount!: string | undefined;
    strCurrentAmount!: string | undefined;
    expenses!: Expense[] | undefined;
    expenseType!: ExpenseType;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseSubType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expenseTypeId = _data["expenseTypeId"];
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.budgetedAmount = _data["budgetedAmount"];
            this.currentAmount = _data["currentAmount"];
            this.strBudgetedAmount = _data["strBudgetedAmount"];
            this.strCurrentAmount = _data["strCurrentAmount"];
            if (Array.isArray(_data["expenses"])) {
                this.expenses = [] as any;
                for (let item of _data["expenses"])
                    this.expenses!.push(Expense.fromJS(item));
            }
            this.expenseType = _data["expenseType"] ? ExpenseType.fromJS(_data["expenseType"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseSubType {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseSubType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expenseTypeId"] = this.expenseTypeId;
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["approvalProcessId"] = this.approvalProcessId;
        data["budgetedAmount"] = this.budgetedAmount;
        data["currentAmount"] = this.currentAmount;
        data["strBudgetedAmount"] = this.strBudgetedAmount;
        data["strCurrentAmount"] = this.strCurrentAmount;
        if (Array.isArray(this.expenses)) {
            data["expenses"] = [];
            for (let item of this.expenses)
                data["expenses"].push(item.toJSON());
        }
        data["expenseType"] = this.expenseType ? this.expenseType.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseSubType {
        const json = this.toJSON();
        let result = new ExpenseSubType();
        result.init(json);
        return result;
    }
}

export interface IExpenseSubType {
    expenseTypeId: number;
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    referenceId: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    approvalProcessId: number | undefined;
    budgetedAmount: number | undefined;
    currentAmount: number | undefined;
    strBudgetedAmount: string | undefined;
    strCurrentAmount: string | undefined;
    expenses: Expense[] | undefined;
    expenseType: ExpenseType;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseType implements IExpenseType {
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    referenceId!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    expenses!: Expense[] | undefined;
    expenseSubTypes!: ExpenseSubType[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["expenses"])) {
                this.expenses = [] as any;
                for (let item of _data["expenses"])
                    this.expenses!.push(Expense.fromJS(item));
            }
            if (Array.isArray(_data["expenseSubTypes"])) {
                this.expenseSubTypes = [] as any;
                for (let item of _data["expenseSubTypes"])
                    this.expenseSubTypes!.push(ExpenseSubType.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseType {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.expenses)) {
            data["expenses"] = [];
            for (let item of this.expenses)
                data["expenses"].push(item.toJSON());
        }
        if (Array.isArray(this.expenseSubTypes)) {
            data["expenseSubTypes"] = [];
            for (let item of this.expenseSubTypes)
                data["expenseSubTypes"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseType {
        const json = this.toJSON();
        let result = new ExpenseType();
        result.init(json);
        return result;
    }
}

export interface IExpenseType {
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    referenceId: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    expenses: Expense[] | undefined;
    expenseSubTypes: ExpenseSubType[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseProjectActivity implements IExpenseProjectActivity {
    expenseProjectId!: number;
    name!: string | undefined;
    description!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    closedEnded!: boolean | undefined;
    ban!: boolean;
    referenceId!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    expenses!: Expense[] | undefined;
    expenseProject!: ExpenseProject;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseProjectActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expenseProjectId = _data["expenseProjectId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.closedEnded = _data["closedEnded"];
            this.ban = _data["ban"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["expenses"])) {
                this.expenses = [] as any;
                for (let item of _data["expenses"])
                    this.expenses!.push(Expense.fromJS(item));
            }
            this.expenseProject = _data["expenseProject"] ? ExpenseProject.fromJS(_data["expenseProject"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseProjectActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseProjectActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expenseProjectId"] = this.expenseProjectId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["closedEnded"] = this.closedEnded;
        data["ban"] = this.ban;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.expenses)) {
            data["expenses"] = [];
            for (let item of this.expenses)
                data["expenses"].push(item.toJSON());
        }
        data["expenseProject"] = this.expenseProject ? this.expenseProject.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseProjectActivity {
        const json = this.toJSON();
        let result = new ExpenseProjectActivity();
        result.init(json);
        return result;
    }
}

export interface IExpenseProjectActivity {
    expenseProjectId: number;
    name: string | undefined;
    description: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    closedEnded: boolean | undefined;
    ban: boolean;
    referenceId: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    expenses: Expense[] | undefined;
    expenseProject: ExpenseProject;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Expense implements IExpense {
    refNo!: string | undefined;
    title!: string | undefined;
    description!: string | undefined;
    expenseSubTypeId!: number | undefined;
    expenseTypeId!: number;
    loggedByUserId!: number;
    loggedForEmployeeId!: number | undefined;
    expenseProjectActivityId!: number | undefined;
    expenseProjectId!: number;
    requestedAmount!: number;
    approvedAmount!: number;
    dateIncurred!: Date;
    dateReconciled!: Date | undefined;
    dateDisbursed!: Date | undefined;
    disburseComment!: string | undefined;
    dateApproved!: Date | undefined;
    reconciledStatus!: boolean;
    reconciledBy!: number | undefined;
    disbursedBy!: string | undefined;
    approvedBy!: number | undefined;
    departmentId!: number;
    declineReason!: string | undefined;
    disbursementType!: number | undefined;
    is_disbursed!: boolean;
    log_status!: number;
    approvalProcessId!: number;
    expenseGroupId!: number;
    expenseDocs!: ExpenseDoc[] | undefined;
    expenseType!: ExpenseType;
    expenseSubType!: ExpenseSubType;
    expenseProjectActivity!: ExpenseProjectActivity;
    expenseProject!: ExpenseProject;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpense) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refNo = _data["refNo"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.expenseSubTypeId = _data["expenseSubTypeId"];
            this.expenseTypeId = _data["expenseTypeId"];
            this.loggedByUserId = _data["loggedByUserId"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.expenseProjectActivityId = _data["expenseProjectActivityId"];
            this.expenseProjectId = _data["expenseProjectId"];
            this.requestedAmount = _data["requestedAmount"];
            this.approvedAmount = _data["approvedAmount"];
            this.dateIncurred = _data["dateIncurred"] ? new Date(_data["dateIncurred"].toString()) : <any>undefined;
            this.dateReconciled = _data["dateReconciled"] ? new Date(_data["dateReconciled"].toString()) : <any>undefined;
            this.dateDisbursed = _data["dateDisbursed"] ? new Date(_data["dateDisbursed"].toString()) : <any>undefined;
            this.disburseComment = _data["disburseComment"];
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.reconciledStatus = _data["reconciledStatus"];
            this.reconciledBy = _data["reconciledBy"];
            this.disbursedBy = _data["disbursedBy"];
            this.approvedBy = _data["approvedBy"];
            this.departmentId = _data["departmentId"];
            this.declineReason = _data["declineReason"];
            this.disbursementType = _data["disbursementType"];
            this.is_disbursed = _data["is_disbursed"];
            this.log_status = _data["log_status"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.expenseGroupId = _data["expenseGroupId"];
            if (Array.isArray(_data["expenseDocs"])) {
                this.expenseDocs = [] as any;
                for (let item of _data["expenseDocs"])
                    this.expenseDocs!.push(ExpenseDoc.fromJS(item));
            }
            this.expenseType = _data["expenseType"] ? ExpenseType.fromJS(_data["expenseType"]) : <any>undefined;
            this.expenseSubType = _data["expenseSubType"] ? ExpenseSubType.fromJS(_data["expenseSubType"]) : <any>undefined;
            this.expenseProjectActivity = _data["expenseProjectActivity"] ? ExpenseProjectActivity.fromJS(_data["expenseProjectActivity"]) : <any>undefined;
            this.expenseProject = _data["expenseProject"] ? ExpenseProject.fromJS(_data["expenseProject"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Expense {
        data = typeof data === 'object' ? data : {};
        let result = new Expense();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refNo"] = this.refNo;
        data["title"] = this.title;
        data["description"] = this.description;
        data["expenseSubTypeId"] = this.expenseSubTypeId;
        data["expenseTypeId"] = this.expenseTypeId;
        data["loggedByUserId"] = this.loggedByUserId;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["expenseProjectActivityId"] = this.expenseProjectActivityId;
        data["expenseProjectId"] = this.expenseProjectId;
        data["requestedAmount"] = this.requestedAmount;
        data["approvedAmount"] = this.approvedAmount;
        data["dateIncurred"] = this.dateIncurred ? this.dateIncurred.toISOString() : <any>undefined;
        data["dateReconciled"] = this.dateReconciled ? this.dateReconciled.toISOString() : <any>undefined;
        data["dateDisbursed"] = this.dateDisbursed ? this.dateDisbursed.toISOString() : <any>undefined;
        data["disburseComment"] = this.disburseComment;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["reconciledStatus"] = this.reconciledStatus;
        data["reconciledBy"] = this.reconciledBy;
        data["disbursedBy"] = this.disbursedBy;
        data["approvedBy"] = this.approvedBy;
        data["departmentId"] = this.departmentId;
        data["declineReason"] = this.declineReason;
        data["disbursementType"] = this.disbursementType;
        data["is_disbursed"] = this.is_disbursed;
        data["log_status"] = this.log_status;
        data["approvalProcessId"] = this.approvalProcessId;
        data["expenseGroupId"] = this.expenseGroupId;
        if (Array.isArray(this.expenseDocs)) {
            data["expenseDocs"] = [];
            for (let item of this.expenseDocs)
                data["expenseDocs"].push(item.toJSON());
        }
        data["expenseType"] = this.expenseType ? this.expenseType.toJSON() : <any>undefined;
        data["expenseSubType"] = this.expenseSubType ? this.expenseSubType.toJSON() : <any>undefined;
        data["expenseProjectActivity"] = this.expenseProjectActivity ? this.expenseProjectActivity.toJSON() : <any>undefined;
        data["expenseProject"] = this.expenseProject ? this.expenseProject.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Expense {
        const json = this.toJSON();
        let result = new Expense();
        result.init(json);
        return result;
    }
}

export interface IExpense {
    refNo: string | undefined;
    title: string | undefined;
    description: string | undefined;
    expenseSubTypeId: number | undefined;
    expenseTypeId: number;
    loggedByUserId: number;
    loggedForEmployeeId: number | undefined;
    expenseProjectActivityId: number | undefined;
    expenseProjectId: number;
    requestedAmount: number;
    approvedAmount: number;
    dateIncurred: Date;
    dateReconciled: Date | undefined;
    dateDisbursed: Date | undefined;
    disburseComment: string | undefined;
    dateApproved: Date | undefined;
    reconciledStatus: boolean;
    reconciledBy: number | undefined;
    disbursedBy: string | undefined;
    approvedBy: number | undefined;
    departmentId: number;
    declineReason: string | undefined;
    disbursementType: number | undefined;
    is_disbursed: boolean;
    log_status: number;
    approvalProcessId: number;
    expenseGroupId: number;
    expenseDocs: ExpenseDoc[] | undefined;
    expenseType: ExpenseType;
    expenseSubType: ExpenseSubType;
    expenseProjectActivity: ExpenseProjectActivity;
    expenseProject: ExpenseProject;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseProject implements IExpenseProject {
    name!: string | undefined;
    description!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    ban!: boolean;
    referenceId!: string | undefined;
    code!: string | undefined;
    isClosedEnded!: boolean;
    expenses!: Expense[] | undefined;
    expenseProjectActivities!: ExpenseProjectActivity[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.ban = _data["ban"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isClosedEnded = _data["isClosedEnded"];
            if (Array.isArray(_data["expenses"])) {
                this.expenses = [] as any;
                for (let item of _data["expenses"])
                    this.expenses!.push(Expense.fromJS(item));
            }
            if (Array.isArray(_data["expenseProjectActivities"])) {
                this.expenseProjectActivities = [] as any;
                for (let item of _data["expenseProjectActivities"])
                    this.expenseProjectActivities!.push(ExpenseProjectActivity.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseProject {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ban"] = this.ban;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isClosedEnded"] = this.isClosedEnded;
        if (Array.isArray(this.expenses)) {
            data["expenses"] = [];
            for (let item of this.expenses)
                data["expenses"].push(item.toJSON());
        }
        if (Array.isArray(this.expenseProjectActivities)) {
            data["expenseProjectActivities"] = [];
            for (let item of this.expenseProjectActivities)
                data["expenseProjectActivities"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseProject {
        const json = this.toJSON();
        let result = new ExpenseProject();
        result.init(json);
        return result;
    }
}

export interface IExpenseProject {
    name: string | undefined;
    description: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    ban: boolean;
    referenceId: string | undefined;
    code: string | undefined;
    isClosedEnded: boolean;
    expenses: Expense[] | undefined;
    expenseProjectActivities: ExpenseProjectActivity[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseProjectIListApiResult implements IExpenseProjectIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ExpenseProject[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IExpenseProjectIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ExpenseProject.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ExpenseProjectIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseProjectIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ExpenseProjectIListApiResult {
        const json = this.toJSON();
        let result = new ExpenseProjectIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IExpenseProjectIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ExpenseProject[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ExpenseProjectActivityDTO implements IExpenseProjectActivityDTO {
    id!: number;
    expenseProjectId!: number;
    companyID!: number;
    subID!: number;
    name!: string;
    description!: string;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    closedEnded!: boolean | undefined;
    ban!: boolean;
    referenceId!: string;
    code!: string | undefined;
    isDefault!: boolean;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    actionTitle!: string | undefined;
    readonly startDateString!: string | undefined;
    readonly endDateString!: string | undefined;
    readonly status!: string | undefined;

    constructor(data?: IExpenseProjectActivityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expenseProjectId = _data["expenseProjectId"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.closedEnded = _data["closedEnded"];
            this.ban = _data["ban"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.actionTitle = _data["actionTitle"];
            (<any>this).startDateString = _data["startDateString"];
            (<any>this).endDateString = _data["endDateString"];
            (<any>this).status = _data["status"];
        }
    }

    static fromJS(data: any): ExpenseProjectActivityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseProjectActivityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expenseProjectId"] = this.expenseProjectId;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["closedEnded"] = this.closedEnded;
        data["ban"] = this.ban;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["actionTitle"] = this.actionTitle;
        data["startDateString"] = this.startDateString;
        data["endDateString"] = this.endDateString;
        data["status"] = this.status;
        return data; 
    }

    clone(): ExpenseProjectActivityDTO {
        const json = this.toJSON();
        let result = new ExpenseProjectActivityDTO();
        result.init(json);
        return result;
    }
}

export interface IExpenseProjectActivityDTO {
    id: number;
    expenseProjectId: number;
    companyID: number;
    subID: number;
    name: string;
    description: string;
    startDate: Date | undefined;
    endDate: Date | undefined;
    closedEnded: boolean | undefined;
    ban: boolean;
    referenceId: string;
    code: string | undefined;
    isDefault: boolean;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    actionTitle: string | undefined;
    startDateString: string | undefined;
    endDateString: string | undefined;
    status: string | undefined;
}

export class ExpenseProjectActivityIListApiResult implements IExpenseProjectActivityIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ExpenseProjectActivity[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IExpenseProjectActivityIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ExpenseProjectActivity.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ExpenseProjectActivityIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseProjectActivityIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ExpenseProjectActivityIListApiResult {
        const json = this.toJSON();
        let result = new ExpenseProjectActivityIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IExpenseProjectActivityIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ExpenseProjectActivity[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ExpenseDTO implements IExpenseDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    approvalProcessId!: number;
    title!: string | undefined;
    description!: string | undefined;
    expenseSubTypeId!: number | undefined;
    expenseSubTypeName!: string | undefined;
    expenseTypeId!: number;
    expenseTypeName!: string | undefined;
    loggedByUserId!: number;
    loggedByUsername!: string | undefined;
    loggedForEmployeeId!: number | undefined;
    loggedForEmployeeName!: string | undefined;
    loggedForEmployeeNo!: string | undefined;
    expenseProjectActivityId!: number | undefined;
    expenseProjectActivityName!: string | undefined;
    expenseProjectId!: number;
    expenseProjectName!: string | undefined;
    requestedAmount!: number;
    approvedAmount!: number;
    dateIncurred!: Date | undefined;
    dateReconciled!: Date | undefined;
    dateDisbursed!: Date | undefined;
    disburseComment!: string | undefined;
    dateApproved!: Date | undefined;
    reconciledStatus!: boolean;
    reconciledBy!: number | undefined;
    reconciledByName!: string | undefined;
    disbursedBy!: string | undefined;
    disbursedByName!: string | undefined;
    approvedBy!: number | undefined;
    approvedByName!: string | undefined;
    refNo!: string | undefined;
    departmentId!: number;
    declineReason!: string | undefined;
    disbursementType!: number | undefined;
    is_disbursed!: boolean;
    log_status!: number;
    expenseGroupId!: number;
    expenseGroupName!: string | undefined;
    strRequestedAmount!: string | undefined;
    strApprovedAmount!: string | undefined;
    strDateIncurred!: string | undefined;
    _ServerDocURL!: string | undefined;
    tempRef!: string | undefined;
    departmentName!: string | undefined;
    locatioName!: string | undefined;

    constructor(data?: IExpenseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.expenseSubTypeId = _data["expenseSubTypeId"];
            this.expenseSubTypeName = _data["expenseSubTypeName"];
            this.expenseTypeId = _data["expenseTypeId"];
            this.expenseTypeName = _data["expenseTypeName"];
            this.loggedByUserId = _data["loggedByUserId"];
            this.loggedByUsername = _data["loggedByUsername"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.loggedForEmployeeName = _data["loggedForEmployeeName"];
            this.loggedForEmployeeNo = _data["loggedForEmployeeNo"];
            this.expenseProjectActivityId = _data["expenseProjectActivityId"];
            this.expenseProjectActivityName = _data["expenseProjectActivityName"];
            this.expenseProjectId = _data["expenseProjectId"];
            this.expenseProjectName = _data["expenseProjectName"];
            this.requestedAmount = _data["requestedAmount"];
            this.approvedAmount = _data["approvedAmount"];
            this.dateIncurred = _data["dateIncurred"] ? new Date(_data["dateIncurred"].toString()) : <any>undefined;
            this.dateReconciled = _data["dateReconciled"] ? new Date(_data["dateReconciled"].toString()) : <any>undefined;
            this.dateDisbursed = _data["dateDisbursed"] ? new Date(_data["dateDisbursed"].toString()) : <any>undefined;
            this.disburseComment = _data["disburseComment"];
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.reconciledStatus = _data["reconciledStatus"];
            this.reconciledBy = _data["reconciledBy"];
            this.reconciledByName = _data["reconciledByName"];
            this.disbursedBy = _data["disbursedBy"];
            this.disbursedByName = _data["disbursedByName"];
            this.approvedBy = _data["approvedBy"];
            this.approvedByName = _data["approvedByName"];
            this.refNo = _data["refNo"];
            this.departmentId = _data["departmentId"];
            this.declineReason = _data["declineReason"];
            this.disbursementType = _data["disbursementType"];
            this.is_disbursed = _data["is_disbursed"];
            this.log_status = _data["log_status"];
            this.expenseGroupId = _data["expenseGroupId"];
            this.expenseGroupName = _data["expenseGroupName"];
            this.strRequestedAmount = _data["strRequestedAmount"];
            this.strApprovedAmount = _data["strApprovedAmount"];
            this.strDateIncurred = _data["strDateIncurred"];
            this._ServerDocURL = _data["_ServerDocURL"];
            this.tempRef = _data["tempRef"];
            this.departmentName = _data["departmentName"];
            this.locatioName = _data["locatioName"];
        }
    }

    static fromJS(data: any): ExpenseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["approvalProcessId"] = this.approvalProcessId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["expenseSubTypeId"] = this.expenseSubTypeId;
        data["expenseSubTypeName"] = this.expenseSubTypeName;
        data["expenseTypeId"] = this.expenseTypeId;
        data["expenseTypeName"] = this.expenseTypeName;
        data["loggedByUserId"] = this.loggedByUserId;
        data["loggedByUsername"] = this.loggedByUsername;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["loggedForEmployeeName"] = this.loggedForEmployeeName;
        data["loggedForEmployeeNo"] = this.loggedForEmployeeNo;
        data["expenseProjectActivityId"] = this.expenseProjectActivityId;
        data["expenseProjectActivityName"] = this.expenseProjectActivityName;
        data["expenseProjectId"] = this.expenseProjectId;
        data["expenseProjectName"] = this.expenseProjectName;
        data["requestedAmount"] = this.requestedAmount;
        data["approvedAmount"] = this.approvedAmount;
        data["dateIncurred"] = this.dateIncurred ? this.dateIncurred.toISOString() : <any>undefined;
        data["dateReconciled"] = this.dateReconciled ? this.dateReconciled.toISOString() : <any>undefined;
        data["dateDisbursed"] = this.dateDisbursed ? this.dateDisbursed.toISOString() : <any>undefined;
        data["disburseComment"] = this.disburseComment;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["reconciledStatus"] = this.reconciledStatus;
        data["reconciledBy"] = this.reconciledBy;
        data["reconciledByName"] = this.reconciledByName;
        data["disbursedBy"] = this.disbursedBy;
        data["disbursedByName"] = this.disbursedByName;
        data["approvedBy"] = this.approvedBy;
        data["approvedByName"] = this.approvedByName;
        data["refNo"] = this.refNo;
        data["departmentId"] = this.departmentId;
        data["declineReason"] = this.declineReason;
        data["disbursementType"] = this.disbursementType;
        data["is_disbursed"] = this.is_disbursed;
        data["log_status"] = this.log_status;
        data["expenseGroupId"] = this.expenseGroupId;
        data["expenseGroupName"] = this.expenseGroupName;
        data["strRequestedAmount"] = this.strRequestedAmount;
        data["strApprovedAmount"] = this.strApprovedAmount;
        data["strDateIncurred"] = this.strDateIncurred;
        data["_ServerDocURL"] = this._ServerDocURL;
        data["tempRef"] = this.tempRef;
        data["departmentName"] = this.departmentName;
        data["locatioName"] = this.locatioName;
        return data; 
    }

    clone(): ExpenseDTO {
        const json = this.toJSON();
        let result = new ExpenseDTO();
        result.init(json);
        return result;
    }
}

export interface IExpenseDTO {
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    approvalProcessId: number;
    title: string | undefined;
    description: string | undefined;
    expenseSubTypeId: number | undefined;
    expenseSubTypeName: string | undefined;
    expenseTypeId: number;
    expenseTypeName: string | undefined;
    loggedByUserId: number;
    loggedByUsername: string | undefined;
    loggedForEmployeeId: number | undefined;
    loggedForEmployeeName: string | undefined;
    loggedForEmployeeNo: string | undefined;
    expenseProjectActivityId: number | undefined;
    expenseProjectActivityName: string | undefined;
    expenseProjectId: number;
    expenseProjectName: string | undefined;
    requestedAmount: number;
    approvedAmount: number;
    dateIncurred: Date | undefined;
    dateReconciled: Date | undefined;
    dateDisbursed: Date | undefined;
    disburseComment: string | undefined;
    dateApproved: Date | undefined;
    reconciledStatus: boolean;
    reconciledBy: number | undefined;
    reconciledByName: string | undefined;
    disbursedBy: string | undefined;
    disbursedByName: string | undefined;
    approvedBy: number | undefined;
    approvedByName: string | undefined;
    refNo: string | undefined;
    departmentId: number;
    declineReason: string | undefined;
    disbursementType: number | undefined;
    is_disbursed: boolean;
    log_status: number;
    expenseGroupId: number;
    expenseGroupName: string | undefined;
    strRequestedAmount: string | undefined;
    strApprovedAmount: string | undefined;
    strDateIncurred: string | undefined;
    _ServerDocURL: string | undefined;
    tempRef: string | undefined;
    departmentName: string | undefined;
    locatioName: string | undefined;
}

export class ExpenseDTOIListApiResult implements IExpenseDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ExpenseDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IExpenseDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ExpenseDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ExpenseDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ExpenseDTOIListApiResult {
        const json = this.toJSON();
        let result = new ExpenseDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IExpenseDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ExpenseDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ExpenseTypeDto implements IExpenseTypeDto {
    id!: number;
    companyID!: number;
    subID!: number;
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    referenceId!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IExpenseTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ExpenseTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ExpenseTypeDto {
        const json = this.toJSON();
        let result = new ExpenseTypeDto();
        result.init(json);
        return result;
    }
}

export interface IExpenseTypeDto {
    id: number;
    companyID: number;
    subID: number;
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    referenceId: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class ExpenseTypeIListApiResult implements IExpenseTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ExpenseType[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IExpenseTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ExpenseType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ExpenseTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ExpenseTypeIListApiResult {
        const json = this.toJSON();
        let result = new ExpenseTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IExpenseTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ExpenseType[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AzureDocs implements IAzureDocs {
    name!: string | undefined;
    directory!: string | undefined;
    lastModifiedDate!: string | undefined;
    url!: string | undefined;
    size!: string | undefined;

    constructor(data?: IAzureDocs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.directory = _data["directory"];
            this.lastModifiedDate = _data["lastModifiedDate"];
            this.url = _data["url"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): AzureDocs {
        data = typeof data === 'object' ? data : {};
        let result = new AzureDocs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["directory"] = this.directory;
        data["lastModifiedDate"] = this.lastModifiedDate;
        data["url"] = this.url;
        data["size"] = this.size;
        return data; 
    }

    clone(): AzureDocs {
        const json = this.toJSON();
        let result = new AzureDocs();
        result.init(json);
        return result;
    }
}

export interface IAzureDocs {
    name: string | undefined;
    directory: string | undefined;
    lastModifiedDate: string | undefined;
    url: string | undefined;
    size: string | undefined;
}

export class AzureDocsListApiResult implements IAzureDocsListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AzureDocs[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAzureDocsListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AzureDocs.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AzureDocsListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AzureDocsListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AzureDocsListApiResult {
        const json = this.toJSON();
        let result = new AzureDocsListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAzureDocsListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AzureDocs[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class StringApiResult implements IStringApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: string | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IStringApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"];
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): StringApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new StringApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): StringApiResult {
        const json = this.toJSON();
        let result = new StringApiResult();
        result.init(json);
        return result;
    }
}

export interface IStringApiResult {
    hasError: boolean;
    message: string | undefined;
    result: string | undefined;
    totalCount: number;
    totalRecord: number;
}

export class GradeLevelCreatePayload implements IGradeLevelCreatePayload {
    id!: number;
    name!: string;
    code!: string | undefined;
    created_by!: string | undefined;
    promotion_min_years!: number;
    promotion_min_in_days!: number | undefined;
    noOfLeaveDays!: number;

    constructor(data?: IGradeLevelCreatePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
        }
    }

    static fromJS(data: any): GradeLevelCreatePayload {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelCreatePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["promotion_min_years"] = this.promotion_min_years;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        return data; 
    }

    clone(): GradeLevelCreatePayload {
        const json = this.toJSON();
        let result = new GradeLevelCreatePayload();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelCreatePayload {
    id: number;
    name: string;
    code: string | undefined;
    created_by: string | undefined;
    promotion_min_years: number;
    promotion_min_in_days: number | undefined;
    noOfLeaveDays: number;
}

export class GradeLevelDTO implements IGradeLevelDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    promotion_min_years!: number | undefined;
    promotion_min_in_days!: number | undefined;
    noOfLeaveDays!: number | undefined;
    salaryScaleId!: number;

    constructor(data?: IGradeLevelDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.salaryScaleId = _data["salaryScaleId"];
        }
    }

    static fromJS(data: any): GradeLevelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["promotion_min_years"] = this.promotion_min_years;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["salaryScaleId"] = this.salaryScaleId;
        return data; 
    }

    clone(): GradeLevelDTO {
        const json = this.toJSON();
        let result = new GradeLevelDTO();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    promotion_min_years: number | undefined;
    promotion_min_in_days: number | undefined;
    noOfLeaveDays: number | undefined;
    salaryScaleId: number;
}

export class GradeLevelDTOListApiResult implements IGradeLevelDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: GradeLevelDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IGradeLevelDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GradeLevelDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): GradeLevelDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): GradeLevelDTOListApiResult {
        const json = this.toJSON();
        let result = new GradeLevelDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: GradeLevelDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ManageGradeLevelBenefitDTO implements IManageGradeLevelBenefitDTO {
    id!: number;
    benefitName!: string | undefined;
    gradeId!: number;
    gradeStepId!: number;
    amount!: number;
    salaryScaleId!: number;
    name!: string | undefined;
    promotion_min_years!: number | undefined;
    noOfLeaveDays!: number | undefined;
    benefitId!: number;
    gradeName!: string | undefined;

    constructor(data?: IManageGradeLevelBenefitDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.benefitName = _data["benefitName"];
            this.gradeId = _data["gradeId"];
            this.gradeStepId = _data["gradeStepId"];
            this.amount = _data["amount"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.name = _data["name"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.benefitId = _data["benefitId"];
            this.gradeName = _data["gradeName"];
        }
    }

    static fromJS(data: any): ManageGradeLevelBenefitDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageGradeLevelBenefitDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["benefitName"] = this.benefitName;
        data["gradeId"] = this.gradeId;
        data["gradeStepId"] = this.gradeStepId;
        data["amount"] = this.amount;
        data["salaryScaleId"] = this.salaryScaleId;
        data["name"] = this.name;
        data["promotion_min_years"] = this.promotion_min_years;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["benefitId"] = this.benefitId;
        data["gradeName"] = this.gradeName;
        return data; 
    }

    clone(): ManageGradeLevelBenefitDTO {
        const json = this.toJSON();
        let result = new ManageGradeLevelBenefitDTO();
        result.init(json);
        return result;
    }
}

export interface IManageGradeLevelBenefitDTO {
    id: number;
    benefitName: string | undefined;
    gradeId: number;
    gradeStepId: number;
    amount: number;
    salaryScaleId: number;
    name: string | undefined;
    promotion_min_years: number | undefined;
    noOfLeaveDays: number | undefined;
    benefitId: number;
    gradeName: string | undefined;
}

export class GradeLevelBenefitDTO implements IGradeLevelBenefitDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    salaryScaleId!: number;
    promotion_min_years!: number;
    promotion_min_in_days!: number | undefined;
    noOfLeaveDays!: number;
    gradeId!: number;
    gradeStepId!: number;
    salaryScaleName!: string | undefined;
    amount!: number;
    gradeName!: string | undefined;

    constructor(data?: IGradeLevelBenefitDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.gradeId = _data["gradeId"];
            this.gradeStepId = _data["gradeStepId"];
            this.salaryScaleName = _data["salaryScaleName"];
            this.amount = _data["amount"];
            this.gradeName = _data["gradeName"];
        }
    }

    static fromJS(data: any): GradeLevelBenefitDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelBenefitDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["salaryScaleId"] = this.salaryScaleId;
        data["promotion_min_years"] = this.promotion_min_years;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["gradeId"] = this.gradeId;
        data["gradeStepId"] = this.gradeStepId;
        data["salaryScaleName"] = this.salaryScaleName;
        data["amount"] = this.amount;
        data["gradeName"] = this.gradeName;
        return data; 
    }

    clone(): GradeLevelBenefitDTO {
        const json = this.toJSON();
        let result = new GradeLevelBenefitDTO();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelBenefitDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    salaryScaleId: number;
    promotion_min_years: number;
    promotion_min_in_days: number | undefined;
    noOfLeaveDays: number;
    gradeId: number;
    gradeStepId: number;
    salaryScaleName: string | undefined;
    amount: number;
    gradeName: string | undefined;
}

export class GradeLevelBenefitDTOApiResult implements IGradeLevelBenefitDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: GradeLevelBenefitDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IGradeLevelBenefitDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? GradeLevelBenefitDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): GradeLevelBenefitDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelBenefitDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): GradeLevelBenefitDTOApiResult {
        const json = this.toJSON();
        let result = new GradeLevelBenefitDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelBenefitDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: GradeLevelBenefitDTO;
    totalCount: number;
    totalRecord: number;
}

export class GradeLevelBenefitDTOListApiResult implements IGradeLevelBenefitDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: GradeLevelBenefitDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IGradeLevelBenefitDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GradeLevelBenefitDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): GradeLevelBenefitDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelBenefitDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): GradeLevelBenefitDTOListApiResult {
        const json = this.toJSON();
        let result = new GradeLevelBenefitDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeLevelBenefitDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: GradeLevelBenefitDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class GradestepCreatePayload implements IGradestepCreatePayload {
    id!: number;
    grade_id!: number;
    step_no!: number;
    gradeName!: string | undefined;
    stepName!: string | undefined;

    constructor(data?: IGradestepCreatePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.grade_id = _data["grade_id"];
            this.step_no = _data["step_no"];
            this.gradeName = _data["gradeName"];
            this.stepName = _data["stepName"];
        }
    }

    static fromJS(data: any): GradestepCreatePayload {
        data = typeof data === 'object' ? data : {};
        let result = new GradestepCreatePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["grade_id"] = this.grade_id;
        data["step_no"] = this.step_no;
        data["gradeName"] = this.gradeName;
        data["stepName"] = this.stepName;
        return data; 
    }

    clone(): GradestepCreatePayload {
        const json = this.toJSON();
        let result = new GradestepCreatePayload();
        result.init(json);
        return result;
    }
}

export interface IGradestepCreatePayload {
    id: number;
    grade_id: number;
    step_no: number;
    gradeName: string | undefined;
    stepName: string | undefined;
}

export class GradestepDTO implements IGradestepDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    grade_id!: number;
    step_no!: number;

    constructor(data?: IGradestepDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.grade_id = _data["grade_id"];
            this.step_no = _data["step_no"];
        }
    }

    static fromJS(data: any): GradestepDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradestepDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["grade_id"] = this.grade_id;
        data["step_no"] = this.step_no;
        return data; 
    }

    clone(): GradestepDTO {
        const json = this.toJSON();
        let result = new GradestepDTO();
        result.init(json);
        return result;
    }
}

export interface IGradestepDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    grade_id: number;
    step_no: number;
}

export class GradestepDTOListApiResult implements IGradestepDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: GradestepDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IGradestepDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GradestepDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): GradestepDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradestepDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): GradestepDTOListApiResult {
        const json = this.toJSON();
        let result = new GradestepDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradestepDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: GradestepDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class GradestepDTOApiResult implements IGradestepDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: GradestepDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IGradestepDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? GradestepDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): GradestepDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradestepDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): GradestepDTOApiResult {
        const json = this.toJSON();
        let result = new GradestepDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradestepDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: GradestepDTO;
    totalCount: number;
    totalRecord: number;
}

export class InstitutionListApiResult implements IInstitutionListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Institution[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IInstitutionListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Institution.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): InstitutionListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): InstitutionListApiResult {
        const json = this.toJSON();
        let result = new InstitutionListApiResult();
        result.init(json);
        return result;
    }
}

export interface IInstitutionListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Institution[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class InstitutionApiResult implements IInstitutionApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Institution;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IInstitutionApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? Institution.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): InstitutionApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): InstitutionApiResult {
        const json = this.toJSON();
        let result = new InstitutionApiResult();
        result.init(json);
        return result;
    }
}

export interface IInstitutionApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Institution;
    totalCount: number;
    totalRecord: number;
}

export class InterestRateDTO implements IInterestRateDTO {
    id!: number;
    rate!: number;
    description!: string | undefined;
    companyID!: number;
    subId!: number;

    constructor(data?: IInterestRateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rate = _data["rate"];
            this.description = _data["description"];
            this.companyID = _data["companyID"];
            this.subId = _data["subId"];
        }
    }

    static fromJS(data: any): InterestRateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InterestRateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rate"] = this.rate;
        data["description"] = this.description;
        data["companyID"] = this.companyID;
        data["subId"] = this.subId;
        return data; 
    }

    clone(): InterestRateDTO {
        const json = this.toJSON();
        let result = new InterestRateDTO();
        result.init(json);
        return result;
    }
}

export interface IInterestRateDTO {
    id: number;
    rate: number;
    description: string | undefined;
    companyID: number;
    subId: number;
}

export class InterestRate implements IInterestRate {
    rate!: number;
    description!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IInterestRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rate = _data["rate"];
            this.description = _data["description"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): InterestRate {
        data = typeof data === 'object' ? data : {};
        let result = new InterestRate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rate"] = this.rate;
        data["description"] = this.description;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): InterestRate {
        const json = this.toJSON();
        let result = new InterestRate();
        result.init(json);
        return result;
    }
}

export interface IInterestRate {
    rate: number;
    description: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class InterestRateIListApiResult implements IInterestRateIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: InterestRate[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IInterestRateIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(InterestRate.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): InterestRateIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new InterestRateIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): InterestRateIListApiResult {
        const json = this.toJSON();
        let result = new InterestRateIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IInterestRateIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: InterestRate[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ManageJobRoleDTO implements IManageJobRoleDTO {
    id!: number;
    name!: string;
    code!: string | undefined;
    salary!: number;
    parentJobRoleId!: number;

    constructor(data?: IManageJobRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.salary = _data["salary"];
            this.parentJobRoleId = _data["parentJobRoleId"];
        }
    }

    static fromJS(data: any): ManageJobRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageJobRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["salary"] = this.salary;
        data["parentJobRoleId"] = this.parentJobRoleId;
        return data; 
    }

    clone(): ManageJobRoleDTO {
        const json = this.toJSON();
        let result = new ManageJobRoleDTO();
        result.init(json);
        return result;
    }
}

export interface IManageJobRoleDTO {
    id: number;
    name: string;
    code: string | undefined;
    salary: number;
    parentJobRoleId: number;
}

export class JobRolesDTO implements IJobRolesDTO {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    parent_id!: number | undefined;
    parent_jobrole!: string | undefined;
    salary!: number;
    companyID!: number;
    subID!: number;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IJobRolesDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.parent_id = _data["parent_id"];
            this.parent_jobrole = _data["parent_jobrole"];
            this.salary = _data["salary"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): JobRolesDTO {
        data = typeof data === 'object' ? data : {};
        let result = new JobRolesDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["parent_id"] = this.parent_id;
        data["parent_jobrole"] = this.parent_jobrole;
        data["salary"] = this.salary;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): JobRolesDTO {
        const json = this.toJSON();
        let result = new JobRolesDTO();
        result.init(json);
        return result;
    }
}

export interface IJobRolesDTO {
    id: number;
    name: string | undefined;
    code: string | undefined;
    parent_id: number | undefined;
    parent_jobrole: string | undefined;
    salary: number;
    companyID: number;
    subID: number;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class JobRolesDTOListApiResult implements IJobRolesDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: JobRolesDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IJobRolesDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(JobRolesDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): JobRolesDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobRolesDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): JobRolesDTOListApiResult {
        const json = this.toJSON();
        let result = new JobRolesDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IJobRolesDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: JobRolesDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class JobRolesDTOApiResult implements IJobRolesDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: JobRolesDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IJobRolesDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? JobRolesDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): JobRolesDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobRolesDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): JobRolesDTOApiResult {
        const json = this.toJSON();
        let result = new JobRolesDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IJobRolesDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: JobRolesDTO;
    totalCount: number;
    totalRecord: number;
}

export class SectionDTO implements ISectionDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    section_name!: string | undefined;
    isMarkObtainable!: boolean;
    maximum_score_obtainable!: number;
    weight!: number;
    description!: string | undefined;
    instructions!: string | undefined;
    is_notified_employees!: boolean;
    order!: number;
    no_of_kpis!: number;
    kpi_rating_type_id!: number;
    strategyCategoryId!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    readonly strategyCategory!: string | undefined;
    readonly ratingType!: string | undefined;

    constructor(data?: ISectionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.section_name = _data["section_name"];
            this.isMarkObtainable = _data["isMarkObtainable"];
            this.maximum_score_obtainable = _data["maximum_score_obtainable"];
            this.weight = _data["weight"];
            this.description = _data["description"];
            this.instructions = _data["instructions"];
            this.is_notified_employees = _data["is_notified_employees"];
            this.order = _data["order"];
            this.no_of_kpis = _data["no_of_kpis"];
            this.kpi_rating_type_id = _data["kpi_rating_type_id"];
            this.strategyCategoryId = _data["strategyCategoryId"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            (<any>this).strategyCategory = _data["strategyCategory"];
            (<any>this).ratingType = _data["ratingType"];
        }
    }

    static fromJS(data: any): SectionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SectionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["section_name"] = this.section_name;
        data["isMarkObtainable"] = this.isMarkObtainable;
        data["maximum_score_obtainable"] = this.maximum_score_obtainable;
        data["weight"] = this.weight;
        data["description"] = this.description;
        data["instructions"] = this.instructions;
        data["is_notified_employees"] = this.is_notified_employees;
        data["order"] = this.order;
        data["no_of_kpis"] = this.no_of_kpis;
        data["kpi_rating_type_id"] = this.kpi_rating_type_id;
        data["strategyCategoryId"] = this.strategyCategoryId;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["strategyCategory"] = this.strategyCategory;
        data["ratingType"] = this.ratingType;
        return data; 
    }

    clone(): SectionDTO {
        const json = this.toJSON();
        let result = new SectionDTO();
        result.init(json);
        return result;
    }
}

export interface ISectionDTO {
    id: number;
    companyID: number;
    subID: number;
    section_name: string | undefined;
    isMarkObtainable: boolean;
    maximum_score_obtainable: number;
    weight: number;
    description: string | undefined;
    instructions: string | undefined;
    is_notified_employees: boolean;
    order: number;
    no_of_kpis: number;
    kpi_rating_type_id: number;
    strategyCategoryId: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    strategyCategory: string | undefined;
    ratingType: string | undefined;
}

export class SectionDTOIListApiResult implements ISectionDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SectionDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISectionDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SectionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SectionDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SectionDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SectionDTOIListApiResult {
        const json = this.toJSON();
        let result = new SectionDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISectionDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SectionDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class KPI implements IKPI {
    kpi_section_id!: number;
    title!: string | undefined;
    unit_of_measurement_id!: number;
    canComment!: boolean;
    instruction!: string | undefined;
    description!: string | undefined;
    is_compulsory!: boolean;
    order!: number;
    is_closed_ended!: boolean;
    score!: number | undefined;
    sendToEmployee!: boolean;
    is_employee_entry!: boolean | undefined;
    contract_id!: number | undefined;
    kpiSection!: KPISection;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IKPI) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kpi_section_id = _data["kpi_section_id"];
            this.title = _data["title"];
            this.unit_of_measurement_id = _data["unit_of_measurement_id"];
            this.canComment = _data["canComment"];
            this.instruction = _data["instruction"];
            this.description = _data["description"];
            this.is_compulsory = _data["is_compulsory"];
            this.order = _data["order"];
            this.is_closed_ended = _data["is_closed_ended"];
            this.score = _data["score"];
            this.sendToEmployee = _data["sendToEmployee"];
            this.is_employee_entry = _data["is_employee_entry"];
            this.contract_id = _data["contract_id"];
            this.kpiSection = _data["kpiSection"] ? KPISection.fromJS(_data["kpiSection"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): KPI {
        data = typeof data === 'object' ? data : {};
        let result = new KPI();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kpi_section_id"] = this.kpi_section_id;
        data["title"] = this.title;
        data["unit_of_measurement_id"] = this.unit_of_measurement_id;
        data["canComment"] = this.canComment;
        data["instruction"] = this.instruction;
        data["description"] = this.description;
        data["is_compulsory"] = this.is_compulsory;
        data["order"] = this.order;
        data["is_closed_ended"] = this.is_closed_ended;
        data["score"] = this.score;
        data["sendToEmployee"] = this.sendToEmployee;
        data["is_employee_entry"] = this.is_employee_entry;
        data["contract_id"] = this.contract_id;
        data["kpiSection"] = this.kpiSection ? this.kpiSection.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): KPI {
        const json = this.toJSON();
        let result = new KPI();
        result.init(json);
        return result;
    }
}

export interface IKPI {
    kpi_section_id: number;
    title: string | undefined;
    unit_of_measurement_id: number;
    canComment: boolean;
    instruction: string | undefined;
    description: string | undefined;
    is_compulsory: boolean;
    order: number;
    is_closed_ended: boolean;
    score: number | undefined;
    sendToEmployee: boolean;
    is_employee_entry: boolean | undefined;
    contract_id: number | undefined;
    kpiSection: KPISection;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class KPISection implements IKPISection {
    section_name!: string;
    isMarkObtainable!: boolean;
    maximum_score_obtainable!: number;
    description!: string | undefined;
    instructions!: string | undefined;
    is_notified_employees!: boolean;
    order!: number;
    kpi_rating_type_id!: number;
    category_id!: number;
    weight!: number;
    kpis!: KPI[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IKPISection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.section_name = _data["section_name"];
            this.isMarkObtainable = _data["isMarkObtainable"];
            this.maximum_score_obtainable = _data["maximum_score_obtainable"];
            this.description = _data["description"];
            this.instructions = _data["instructions"];
            this.is_notified_employees = _data["is_notified_employees"];
            this.order = _data["order"];
            this.kpi_rating_type_id = _data["kpi_rating_type_id"];
            this.category_id = _data["category_id"];
            this.weight = _data["weight"];
            if (Array.isArray(_data["kpis"])) {
                this.kpis = [] as any;
                for (let item of _data["kpis"])
                    this.kpis!.push(KPI.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): KPISection {
        data = typeof data === 'object' ? data : {};
        let result = new KPISection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["section_name"] = this.section_name;
        data["isMarkObtainable"] = this.isMarkObtainable;
        data["maximum_score_obtainable"] = this.maximum_score_obtainable;
        data["description"] = this.description;
        data["instructions"] = this.instructions;
        data["is_notified_employees"] = this.is_notified_employees;
        data["order"] = this.order;
        data["kpi_rating_type_id"] = this.kpi_rating_type_id;
        data["category_id"] = this.category_id;
        data["weight"] = this.weight;
        if (Array.isArray(this.kpis)) {
            data["kpis"] = [];
            for (let item of this.kpis)
                data["kpis"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): KPISection {
        const json = this.toJSON();
        let result = new KPISection();
        result.init(json);
        return result;
    }
}

export interface IKPISection {
    section_name: string;
    isMarkObtainable: boolean;
    maximum_score_obtainable: number;
    description: string | undefined;
    instructions: string | undefined;
    is_notified_employees: boolean;
    order: number;
    kpi_rating_type_id: number;
    category_id: number;
    weight: number;
    kpis: KPI[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class KPISectionIListApiResult implements IKPISectionIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: KPISection[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IKPISectionIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(KPISection.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): KPISectionIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new KPISectionIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): KPISectionIListApiResult {
        const json = this.toJSON();
        let result = new KPISectionIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IKPISectionIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: KPISection[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class SectionDTOApiResult implements ISectionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SectionDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISectionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? SectionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SectionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SectionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SectionDTOApiResult {
        const json = this.toJSON();
        let result = new SectionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ISectionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SectionDTO;
    totalCount: number;
    totalRecord: number;
}

export class ManageSectionDTO implements IManageSectionDTO {
    id!: number;
    name!: string;
    score!: number;
    weight!: number;
    strategyCategoryId!: number;
    order!: number;
    description!: string | undefined;
    instructions!: string | undefined;
    ratingTypeId!: number;

    constructor(data?: IManageSectionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.score = _data["score"];
            this.weight = _data["weight"];
            this.strategyCategoryId = _data["strategyCategoryId"];
            this.order = _data["order"];
            this.description = _data["description"];
            this.instructions = _data["instructions"];
            this.ratingTypeId = _data["ratingTypeId"];
        }
    }

    static fromJS(data: any): ManageSectionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageSectionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["score"] = this.score;
        data["weight"] = this.weight;
        data["strategyCategoryId"] = this.strategyCategoryId;
        data["order"] = this.order;
        data["description"] = this.description;
        data["instructions"] = this.instructions;
        data["ratingTypeId"] = this.ratingTypeId;
        return data; 
    }

    clone(): ManageSectionDTO {
        const json = this.toJSON();
        let result = new ManageSectionDTO();
        result.init(json);
        return result;
    }
}

export interface IManageSectionDTO {
    id: number;
    name: string;
    score: number;
    weight: number;
    strategyCategoryId: number;
    order: number;
    description: string | undefined;
    instructions: string | undefined;
    ratingTypeId: number;
}

export class AssignKraDto implements IAssignKraDto {
    cycleId!: number;
    krAs!: string;
    reviewerId!: number;
    employeeContractIds!: string;

    constructor(data?: IAssignKraDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cycleId = _data["cycleId"];
            this.krAs = _data["krAs"];
            this.reviewerId = _data["reviewerId"];
            this.employeeContractIds = _data["employeeContractIds"];
        }
    }

    static fromJS(data: any): AssignKraDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssignKraDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cycleId"] = this.cycleId;
        data["krAs"] = this.krAs;
        data["reviewerId"] = this.reviewerId;
        data["employeeContractIds"] = this.employeeContractIds;
        return data; 
    }

    clone(): AssignKraDto {
        const json = this.toJSON();
        let result = new AssignKraDto();
        result.init(json);
        return result;
    }
}

export interface IAssignKraDto {
    cycleId: number;
    krAs: string;
    reviewerId: number;
    employeeContractIds: string;
}

export class ManageKpiDTO implements IManageKpiDTO {
    id!: number;
    title!: string;
    description!: string | undefined;
    kra_id!: number;
    score!: number;
    unit_of_measurement_id!: number;
    canComment!: boolean;

    constructor(data?: IManageKpiDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.kra_id = _data["kra_id"];
            this.score = _data["score"];
            this.unit_of_measurement_id = _data["unit_of_measurement_id"];
            this.canComment = _data["canComment"];
        }
    }

    static fromJS(data: any): ManageKpiDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageKpiDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["kra_id"] = this.kra_id;
        data["score"] = this.score;
        data["unit_of_measurement_id"] = this.unit_of_measurement_id;
        data["canComment"] = this.canComment;
        return data; 
    }

    clone(): ManageKpiDTO {
        const json = this.toJSON();
        let result = new ManageKpiDTO();
        result.init(json);
        return result;
    }
}

export interface IManageKpiDTO {
    id: number;
    title: string;
    description: string | undefined;
    kra_id: number;
    score: number;
    unit_of_measurement_id: number;
    canComment: boolean;
}

export class KpiDTO implements IKpiDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    title!: string;
    kpi_section_id!: number;
    unit_of_measurement_id!: number;
    canComment!: boolean;
    is_closed_ended!: boolean;
    section_name!: string | undefined;
    sectionTotalScore!: number;
    instruction!: string | undefined;
    description!: string | undefined;
    is_compulsory!: boolean;
    order!: number;
    order_count!: number;
    kpi_score!: number | undefined;
    employee_score!: number | undefined;
    supervisor_score!: number | undefined;
    score!: number | undefined;
    is_employee_entry!: boolean | undefined;
    sendToEmployee!: boolean;
    contract_id!: number | undefined;
    response!: string | undefined;
    supervisorResponse!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    readonly unitOfMeasurement!: string | undefined;

    constructor(data?: IKpiDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.title = _data["title"];
            this.kpi_section_id = _data["kpi_section_id"];
            this.unit_of_measurement_id = _data["unit_of_measurement_id"];
            this.canComment = _data["canComment"];
            this.is_closed_ended = _data["is_closed_ended"];
            this.section_name = _data["section_name"];
            this.sectionTotalScore = _data["sectionTotalScore"];
            this.instruction = _data["instruction"];
            this.description = _data["description"];
            this.is_compulsory = _data["is_compulsory"];
            this.order = _data["order"];
            this.order_count = _data["order_count"];
            this.kpi_score = _data["kpi_score"];
            this.employee_score = _data["employee_score"];
            this.supervisor_score = _data["supervisor_score"];
            this.score = _data["score"];
            this.is_employee_entry = _data["is_employee_entry"];
            this.sendToEmployee = _data["sendToEmployee"];
            this.contract_id = _data["contract_id"];
            this.response = _data["response"];
            this.supervisorResponse = _data["supervisorResponse"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            (<any>this).unitOfMeasurement = _data["unitOfMeasurement"];
        }
    }

    static fromJS(data: any): KpiDTO {
        data = typeof data === 'object' ? data : {};
        let result = new KpiDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["title"] = this.title;
        data["kpi_section_id"] = this.kpi_section_id;
        data["unit_of_measurement_id"] = this.unit_of_measurement_id;
        data["canComment"] = this.canComment;
        data["is_closed_ended"] = this.is_closed_ended;
        data["section_name"] = this.section_name;
        data["sectionTotalScore"] = this.sectionTotalScore;
        data["instruction"] = this.instruction;
        data["description"] = this.description;
        data["is_compulsory"] = this.is_compulsory;
        data["order"] = this.order;
        data["order_count"] = this.order_count;
        data["kpi_score"] = this.kpi_score;
        data["employee_score"] = this.employee_score;
        data["supervisor_score"] = this.supervisor_score;
        data["score"] = this.score;
        data["is_employee_entry"] = this.is_employee_entry;
        data["sendToEmployee"] = this.sendToEmployee;
        data["contract_id"] = this.contract_id;
        data["response"] = this.response;
        data["supervisorResponse"] = this.supervisorResponse;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        return data; 
    }

    clone(): KpiDTO {
        const json = this.toJSON();
        let result = new KpiDTO();
        result.init(json);
        return result;
    }
}

export interface IKpiDTO {
    id: number;
    companyID: number;
    subID: number;
    title: string;
    kpi_section_id: number;
    unit_of_measurement_id: number;
    canComment: boolean;
    is_closed_ended: boolean;
    section_name: string | undefined;
    sectionTotalScore: number;
    instruction: string | undefined;
    description: string | undefined;
    is_compulsory: boolean;
    order: number;
    order_count: number;
    kpi_score: number | undefined;
    employee_score: number | undefined;
    supervisor_score: number | undefined;
    score: number | undefined;
    is_employee_entry: boolean | undefined;
    sendToEmployee: boolean;
    contract_id: number | undefined;
    response: string | undefined;
    supervisorResponse: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    unitOfMeasurement: string | undefined;
}

export class KpiDTOIListApiResult implements IKpiDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: KpiDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IKpiDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(KpiDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): KpiDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new KpiDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): KpiDTOIListApiResult {
        const json = this.toJSON();
        let result = new KpiDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IKpiDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: KpiDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class KpiDTOApiResult implements IKpiDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: KpiDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IKpiDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? KpiDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): KpiDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new KpiDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): KpiDTOApiResult {
        const json = this.toJSON();
        let result = new KpiDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IKpiDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: KpiDTO;
    totalCount: number;
    totalRecord: number;
}

export class LeaveEntitlementResource implements ILeaveEntitlementResource {
    id!: number;
    companyID!: number;
    subID!: number;
    gradeID!: number;
    leaveTypeID!: number;
    entitlement!: number;
    daysUsed!: number;
    daysRemaining!: number;
    leaveType!: string | undefined;
    grade!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveEntitlementResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.gradeID = _data["gradeID"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.entitlement = _data["entitlement"];
            this.daysUsed = _data["daysUsed"];
            this.daysRemaining = _data["daysRemaining"];
            this.leaveType = _data["leaveType"];
            this.grade = _data["grade"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveEntitlementResource {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["gradeID"] = this.gradeID;
        data["leaveTypeID"] = this.leaveTypeID;
        data["entitlement"] = this.entitlement;
        data["daysUsed"] = this.daysUsed;
        data["daysRemaining"] = this.daysRemaining;
        data["leaveType"] = this.leaveType;
        data["grade"] = this.grade;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveEntitlementResource {
        const json = this.toJSON();
        let result = new LeaveEntitlementResource();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementResource {
    id: number;
    companyID: number;
    subID: number;
    gradeID: number;
    leaveTypeID: number;
    entitlement: number;
    daysUsed: number;
    daysRemaining: number;
    leaveType: string | undefined;
    grade: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveEntitlementResourceListApiResult implements ILeaveEntitlementResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveEntitlementResource[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILeaveEntitlementResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveEntitlementResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LeaveEntitlementResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LeaveEntitlementResourceListApiResult {
        const json = this.toJSON();
        let result = new LeaveEntitlementResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveEntitlementResource[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class LeaveEntitlementResourceApiResult implements ILeaveEntitlementResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveEntitlementResource;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILeaveEntitlementResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveEntitlementResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LeaveEntitlementResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LeaveEntitlementResourceApiResult {
        const json = this.toJSON();
        let result = new LeaveEntitlementResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveEntitlementResource;
    totalCount: number;
    totalRecord: number;
}

export class LeaveEntitlementPayload implements ILeaveEntitlementPayload {
    gradeID!: number;
    leaveTypeID!: number;
    entitlement!: number;
    id!: number;

    constructor(data?: ILeaveEntitlementPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeID = _data["gradeID"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.entitlement = _data["entitlement"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LeaveEntitlementPayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeID"] = this.gradeID;
        data["leaveTypeID"] = this.leaveTypeID;
        data["entitlement"] = this.entitlement;
        data["id"] = this.id;
        return data; 
    }

    clone(): LeaveEntitlementPayload {
        const json = this.toJSON();
        let result = new LeaveEntitlementPayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementPayload {
    gradeID: number;
    leaveTypeID: number;
    entitlement: number;
    id: number;
}

export class GradeListApiResult implements IGradeListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Grade[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IGradeListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Grade.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): GradeListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): GradeListApiResult {
        const json = this.toJSON();
        let result = new GradeListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Grade[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ManageLeaveHolidayDTO implements IManageLeaveHolidayDTO {
    id!: number;
    holidayDate!: Date;
    description!: string | undefined;
    leaveYearId!: number;

    constructor(data?: IManageLeaveHolidayDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.holidayDate = _data["holidayDate"] ? new Date(_data["holidayDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.leaveYearId = _data["leaveYearId"];
        }
    }

    static fromJS(data: any): ManageLeaveHolidayDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageLeaveHolidayDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["holidayDate"] = this.holidayDate ? this.holidayDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["leaveYearId"] = this.leaveYearId;
        return data; 
    }

    clone(): ManageLeaveHolidayDTO {
        const json = this.toJSON();
        let result = new ManageLeaveHolidayDTO();
        result.init(json);
        return result;
    }
}

export interface IManageLeaveHolidayDTO {
    id: number;
    holidayDate: Date;
    description: string | undefined;
    leaveYearId: number;
}

export class LeaveHolidayDTO implements ILeaveHolidayDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    holidayDate!: Date;
    description!: string | undefined;
    leaveYearId!: number;
    leaveYear!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveHolidayDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.holidayDate = _data["holidayDate"] ? new Date(_data["holidayDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.leaveYearId = _data["leaveYearId"];
            this.leaveYear = _data["leaveYear"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveHolidayDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveHolidayDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["holidayDate"] = this.holidayDate ? this.holidayDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["leaveYearId"] = this.leaveYearId;
        data["leaveYear"] = this.leaveYear;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveHolidayDTO {
        const json = this.toJSON();
        let result = new LeaveHolidayDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveHolidayDTO {
    id: number;
    companyID: number;
    subID: number;
    holidayDate: Date;
    description: string | undefined;
    leaveYearId: number;
    leaveYear: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveHolidayDTOListApiResult implements ILeaveHolidayDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveHolidayDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILeaveHolidayDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveHolidayDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LeaveHolidayDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveHolidayDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LeaveHolidayDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveHolidayDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveHolidayDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveHolidayDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class LeaveHolidayDTOApiResult implements ILeaveHolidayDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveHolidayDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILeaveHolidayDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveHolidayDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LeaveHolidayDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveHolidayDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LeaveHolidayDTOApiResult {
        const json = this.toJSON();
        let result = new LeaveHolidayDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveHolidayDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveHolidayDTO;
    totalCount: number;
    totalRecord: number;
}

export class LeavePlanDTO implements ILeavePlanDTO {
    employeeContractId!: number;
    leaveTypeId!: number;
    leaveYearId!: number;
    comment!: string;
    startDate!: Date;
    endDate!: Date;
    noOfDays!: number;
    locationId!: number;

    constructor(data?: ILeavePlanDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeContractId = _data["employeeContractId"];
            this.leaveTypeId = _data["leaveTypeId"];
            this.leaveYearId = _data["leaveYearId"];
            this.comment = _data["comment"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.locationId = _data["locationId"];
        }
    }

    static fromJS(data: any): LeavePlanDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePlanDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeContractId"] = this.employeeContractId;
        data["leaveTypeId"] = this.leaveTypeId;
        data["leaveYearId"] = this.leaveYearId;
        data["comment"] = this.comment;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["locationId"] = this.locationId;
        return data; 
    }

    clone(): LeavePlanDTO {
        const json = this.toJSON();
        let result = new LeavePlanDTO();
        result.init(json);
        return result;
    }
}

export interface ILeavePlanDTO {
    employeeContractId: number;
    leaveTypeId: number;
    leaveYearId: number;
    comment: string;
    startDate: Date;
    endDate: Date;
    noOfDays: number;
    locationId: number;
}

export class LeavePlanResource implements ILeavePlanResource {
    strApprovalStatus!: string | undefined;
    isApproved!: number;
    dateCreated!: Date;
    id!: number;
    employeeContractId!: number;
    leaveTypeId!: number;
    leaveYearId!: number;
    comment!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    noOfDays!: number;
    locationName!: string | undefined;
    locationId!: number;
    employeeNo!: string | undefined;
    fullName!: string | undefined;
    leaveType!: string | undefined;
    leaveYear!: string | undefined;
    companyId!: number;
    subId!: number;

    constructor(data?: ILeavePlanResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.strApprovalStatus = _data["strApprovalStatus"];
            this.isApproved = _data["isApproved"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.employeeContractId = _data["employeeContractId"];
            this.leaveTypeId = _data["leaveTypeId"];
            this.leaveYearId = _data["leaveYearId"];
            this.comment = _data["comment"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.locationName = _data["locationName"];
            this.locationId = _data["locationId"];
            this.employeeNo = _data["employeeNo"];
            this.fullName = _data["fullName"];
            this.leaveType = _data["leaveType"];
            this.leaveYear = _data["leaveYear"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
        }
    }

    static fromJS(data: any): LeavePlanResource {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePlanResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["strApprovalStatus"] = this.strApprovalStatus;
        data["isApproved"] = this.isApproved;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["employeeContractId"] = this.employeeContractId;
        data["leaveTypeId"] = this.leaveTypeId;
        data["leaveYearId"] = this.leaveYearId;
        data["comment"] = this.comment;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["locationName"] = this.locationName;
        data["locationId"] = this.locationId;
        data["employeeNo"] = this.employeeNo;
        data["fullName"] = this.fullName;
        data["leaveType"] = this.leaveType;
        data["leaveYear"] = this.leaveYear;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        return data; 
    }

    clone(): LeavePlanResource {
        const json = this.toJSON();
        let result = new LeavePlanResource();
        result.init(json);
        return result;
    }
}

export interface ILeavePlanResource {
    strApprovalStatus: string | undefined;
    isApproved: number;
    dateCreated: Date;
    id: number;
    employeeContractId: number;
    leaveTypeId: number;
    leaveYearId: number;
    comment: string | undefined;
    startDate: Date;
    endDate: Date;
    noOfDays: number;
    locationName: string | undefined;
    locationId: number;
    employeeNo: string | undefined;
    fullName: string | undefined;
    leaveType: string | undefined;
    leaveYear: string | undefined;
    companyId: number;
    subId: number;
}

export class LeavePlanResourceListApiResult implements ILeavePlanResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeavePlanResource[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILeavePlanResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeavePlanResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LeavePlanResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePlanResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LeavePlanResourceListApiResult {
        const json = this.toJSON();
        let result = new LeavePlanResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeavePlanResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeavePlanResource[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export enum LeavePlaneStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ApproveOrRejectPayload implements IApproveOrRejectPayload {
    id!: number;
    companyId!: number | undefined;
    leavePlaneStatus!: LeavePlaneStatus;

    constructor(data?: IApproveOrRejectPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.leavePlaneStatus = _data["leavePlaneStatus"];
        }
    }

    static fromJS(data: any): ApproveOrRejectPayload {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveOrRejectPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["leavePlaneStatus"] = this.leavePlaneStatus;
        return data; 
    }

    clone(): ApproveOrRejectPayload {
        const json = this.toJSON();
        let result = new ApproveOrRejectPayload();
        result.init(json);
        return result;
    }
}

export interface IApproveOrRejectPayload {
    id: number;
    companyId: number | undefined;
    leavePlaneStatus: LeavePlaneStatus;
}

export class ManageLeaveRequestDTO implements IManageLeaveRequestDTO {
    id!: number;
    employeeNumber!: string | undefined;
    leaveTypeID!: number;
    leaveYearID!: number;
    startDate!: Date;
    noOfDays!: number;
    contactInfoOnLeave!: string;
    reliefOfficerStaffNo!: string;
    tempRef!: string | undefined;
    file!: string | undefined;

    constructor(data?: IManageLeaveRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeNumber = _data["employeeNumber"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.leaveYearID = _data["leaveYearID"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.contactInfoOnLeave = _data["contactInfoOnLeave"];
            this.reliefOfficerStaffNo = _data["reliefOfficerStaffNo"];
            this.tempRef = _data["tempRef"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): ManageLeaveRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageLeaveRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeNumber"] = this.employeeNumber;
        data["leaveTypeID"] = this.leaveTypeID;
        data["leaveYearID"] = this.leaveYearID;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["contactInfoOnLeave"] = this.contactInfoOnLeave;
        data["reliefOfficerStaffNo"] = this.reliefOfficerStaffNo;
        data["tempRef"] = this.tempRef;
        data["file"] = this.file;
        return data; 
    }

    clone(): ManageLeaveRequestDTO {
        const json = this.toJSON();
        let result = new ManageLeaveRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IManageLeaveRequestDTO {
    id: number;
    employeeNumber: string | undefined;
    leaveTypeID: number;
    leaveYearID: number;
    startDate: Date;
    noOfDays: number;
    contactInfoOnLeave: string;
    reliefOfficerStaffNo: string;
    tempRef: string | undefined;
    file: string | undefined;
}

export class LeaveReportListDTO implements ILeaveReportListDTO {
    leaveRequestId!: number;
    leaveTypeId!: number;
    leaveYearId!: number;
    leaveType!: string | undefined;
    yearName!: string | undefined;
    employeeNumber!: string | undefined;
    fullName!: string | undefined;
    employeeID!: number | undefined;
    employeeContractID!: number | undefined;
    startDate!: Date;
    enddate!: Date;
    resumptionDate!: Date;
    entitlement!: number;
    daysRem!: number;
    noOfDays!: number;
    position!: string | undefined;
    approvalStatus!: string | undefined;

    constructor(data?: ILeaveReportListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leaveRequestId = _data["leaveRequestId"];
            this.leaveTypeId = _data["leaveTypeId"];
            this.leaveYearId = _data["leaveYearId"];
            this.leaveType = _data["leaveType"];
            this.yearName = _data["yearName"];
            this.employeeNumber = _data["employeeNumber"];
            this.fullName = _data["fullName"];
            this.employeeID = _data["employeeID"];
            this.employeeContractID = _data["employeeContractID"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.enddate = _data["enddate"] ? new Date(_data["enddate"].toString()) : <any>undefined;
            this.resumptionDate = _data["resumptionDate"] ? new Date(_data["resumptionDate"].toString()) : <any>undefined;
            this.entitlement = _data["entitlement"];
            this.daysRem = _data["daysRem"];
            this.noOfDays = _data["noOfDays"];
            this.position = _data["position"];
            this.approvalStatus = _data["approvalStatus"];
        }
    }

    static fromJS(data: any): LeaveReportListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveReportListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaveRequestId"] = this.leaveRequestId;
        data["leaveTypeId"] = this.leaveTypeId;
        data["leaveYearId"] = this.leaveYearId;
        data["leaveType"] = this.leaveType;
        data["yearName"] = this.yearName;
        data["employeeNumber"] = this.employeeNumber;
        data["fullName"] = this.fullName;
        data["employeeID"] = this.employeeID;
        data["employeeContractID"] = this.employeeContractID;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["enddate"] = this.enddate ? this.enddate.toISOString() : <any>undefined;
        data["resumptionDate"] = this.resumptionDate ? this.resumptionDate.toISOString() : <any>undefined;
        data["entitlement"] = this.entitlement;
        data["daysRem"] = this.daysRem;
        data["noOfDays"] = this.noOfDays;
        data["position"] = this.position;
        data["approvalStatus"] = this.approvalStatus;
        return data; 
    }

    clone(): LeaveReportListDTO {
        const json = this.toJSON();
        let result = new LeaveReportListDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveReportListDTO {
    leaveRequestId: number;
    leaveTypeId: number;
    leaveYearId: number;
    leaveType: string | undefined;
    yearName: string | undefined;
    employeeNumber: string | undefined;
    fullName: string | undefined;
    employeeID: number | undefined;
    employeeContractID: number | undefined;
    startDate: Date;
    enddate: Date;
    resumptionDate: Date;
    entitlement: number;
    daysRem: number;
    noOfDays: number;
    position: string | undefined;
    approvalStatus: string | undefined;
}

export class LeaveReportListDTOListApiResult implements ILeaveReportListDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveReportListDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILeaveReportListDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveReportListDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LeaveReportListDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveReportListDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LeaveReportListDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveReportListDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveReportListDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveReportListDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class LeaveYear implements ILeaveYear {
    yearName!: string;
    isActiveYear!: boolean;
    yearStartDate!: Date;
    yearEndDate!: Date;
    yearEndDateString!: string | undefined;
    yearStartDateString!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveYear) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.yearName = _data["yearName"];
            this.isActiveYear = _data["isActiveYear"];
            this.yearStartDate = _data["yearStartDate"] ? new Date(_data["yearStartDate"].toString()) : <any>undefined;
            this.yearEndDate = _data["yearEndDate"] ? new Date(_data["yearEndDate"].toString()) : <any>undefined;
            this.yearEndDateString = _data["yearEndDateString"];
            this.yearStartDateString = _data["yearStartDateString"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveYear {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYear();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yearName"] = this.yearName;
        data["isActiveYear"] = this.isActiveYear;
        data["yearStartDate"] = this.yearStartDate ? this.yearStartDate.toISOString() : <any>undefined;
        data["yearEndDate"] = this.yearEndDate ? this.yearEndDate.toISOString() : <any>undefined;
        data["yearEndDateString"] = this.yearEndDateString;
        data["yearStartDateString"] = this.yearStartDateString;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveYear {
        const json = this.toJSON();
        let result = new LeaveYear();
        result.init(json);
        return result;
    }
}

export interface ILeaveYear {
    yearName: string;
    isActiveYear: boolean;
    yearStartDate: Date;
    yearEndDate: Date;
    yearEndDateString: string | undefined;
    yearStartDateString: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveType implements ILeaveType {
    description!: string;
    isDeductableFromAnualLeave!: boolean;
    excludeWeekendInCalculation!: boolean;
    isOnlyAvailableToAdmin!: boolean;
    isAnnualLeave!: boolean;
    allowedGender!: number;
    maxDays!: number;
    minDays!: number;
    isSystemDefault!: boolean;
    maxNoofPossibleApplication!: number;
    maxNoofYearlyApplication!: number;
    isGradeDependent!: boolean;
    pro_rateLeaveDays!: boolean;
    onlyForConfirmStaff!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.maxDays = 0;
            this.minDays = 0;
            this.maxNoofPossibleApplication = 0;
            this.maxNoofYearlyApplication = 0;
            this.isGradeDependent = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.isDeductableFromAnualLeave = _data["isDeductableFromAnualLeave"];
            this.excludeWeekendInCalculation = _data["excludeWeekendInCalculation"];
            this.isOnlyAvailableToAdmin = _data["isOnlyAvailableToAdmin"];
            this.isAnnualLeave = _data["isAnnualLeave"];
            this.allowedGender = _data["allowedGender"];
            this.maxDays = _data["maxDays"] !== undefined ? _data["maxDays"] : 0;
            this.minDays = _data["minDays"] !== undefined ? _data["minDays"] : 0;
            this.isSystemDefault = _data["isSystemDefault"];
            this.maxNoofPossibleApplication = _data["maxNoofPossibleApplication"] !== undefined ? _data["maxNoofPossibleApplication"] : 0;
            this.maxNoofYearlyApplication = _data["maxNoofYearlyApplication"] !== undefined ? _data["maxNoofYearlyApplication"] : 0;
            this.isGradeDependent = _data["isGradeDependent"] !== undefined ? _data["isGradeDependent"] : false;
            this.pro_rateLeaveDays = _data["pro_rateLeaveDays"];
            this.onlyForConfirmStaff = _data["onlyForConfirmStaff"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveType {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["isDeductableFromAnualLeave"] = this.isDeductableFromAnualLeave;
        data["excludeWeekendInCalculation"] = this.excludeWeekendInCalculation;
        data["isOnlyAvailableToAdmin"] = this.isOnlyAvailableToAdmin;
        data["isAnnualLeave"] = this.isAnnualLeave;
        data["allowedGender"] = this.allowedGender;
        data["maxDays"] = this.maxDays;
        data["minDays"] = this.minDays;
        data["isSystemDefault"] = this.isSystemDefault;
        data["maxNoofPossibleApplication"] = this.maxNoofPossibleApplication;
        data["maxNoofYearlyApplication"] = this.maxNoofYearlyApplication;
        data["isGradeDependent"] = this.isGradeDependent;
        data["pro_rateLeaveDays"] = this.pro_rateLeaveDays;
        data["onlyForConfirmStaff"] = this.onlyForConfirmStaff;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveType {
        const json = this.toJSON();
        let result = new LeaveType();
        result.init(json);
        return result;
    }
}

export interface ILeaveType {
    description: string;
    isDeductableFromAnualLeave: boolean;
    excludeWeekendInCalculation: boolean;
    isOnlyAvailableToAdmin: boolean;
    isAnnualLeave: boolean;
    allowedGender: number;
    maxDays: number;
    minDays: number;
    isSystemDefault: boolean;
    maxNoofPossibleApplication: number;
    maxNoofYearlyApplication: number;
    isGradeDependent: boolean;
    pro_rateLeaveDays: boolean;
    onlyForConfirmStaff: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveEntitlement implements ILeaveEntitlement {
    gradeID!: number;
    leaveTypeID!: number;
    entitlement!: number;
    daysUsed!: number;
    daysRemaining!: number;
    leaveType!: LeaveType;
    grades!: Grade;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveEntitlement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeID = _data["gradeID"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.entitlement = _data["entitlement"];
            this.daysUsed = _data["daysUsed"];
            this.daysRemaining = _data["daysRemaining"];
            this.leaveType = _data["leaveType"] ? LeaveType.fromJS(_data["leaveType"]) : <any>undefined;
            this.grades = _data["grades"] ? Grade.fromJS(_data["grades"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveEntitlement {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeID"] = this.gradeID;
        data["leaveTypeID"] = this.leaveTypeID;
        data["entitlement"] = this.entitlement;
        data["daysUsed"] = this.daysUsed;
        data["daysRemaining"] = this.daysRemaining;
        data["leaveType"] = this.leaveType ? this.leaveType.toJSON() : <any>undefined;
        data["grades"] = this.grades ? this.grades.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveEntitlement {
        const json = this.toJSON();
        let result = new LeaveEntitlement();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlement {
    gradeID: number;
    leaveTypeID: number;
    entitlement: number;
    daysUsed: number;
    daysRemaining: number;
    leaveType: LeaveType;
    grades: Grade;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveRequest implements ILeaveRequest {
    leaveTypeID!: number;
    employeeID!: number;
    employeeContractID!: number | undefined;
    employeeNumber!: string | undefined;
    leaveYearID!: number;
    leaveCalendarID!: number;
    initiatorComment!: string | undefined;
    contactInfoOnLeave!: string;
    reliefOfficer!: string;
    reliefOfficerId!: number;
    startDate!: Date;
    startDateString!: string | undefined;
    enddate!: Date;
    noOfDays!: number;
    resumptionDate!: Date;
    dateApplied!: Date;
    gradeID!: number;
    dateApproved!: Date | undefined;
    rejectedBy!: string | undefined;
    employee!: Employee;
    leaveYear!: LeaveYear;
    leaveType!: LeaveType;
    grade!: Grade;
    file!: string | undefined;
    leaveHistory!: LeaveRequest[] | undefined;
    leaveEntitlement!: LeaveEntitlement[] | undefined;
    approvalDecision!: string | undefined;
    approvalStatus!: string | undefined;
    log_status!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leaveTypeID = _data["leaveTypeID"];
            this.employeeID = _data["employeeID"];
            this.employeeContractID = _data["employeeContractID"];
            this.employeeNumber = _data["employeeNumber"];
            this.leaveYearID = _data["leaveYearID"];
            this.leaveCalendarID = _data["leaveCalendarID"];
            this.initiatorComment = _data["initiatorComment"];
            this.contactInfoOnLeave = _data["contactInfoOnLeave"];
            this.reliefOfficer = _data["reliefOfficer"];
            this.reliefOfficerId = _data["reliefOfficerId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.startDateString = _data["startDateString"];
            this.enddate = _data["enddate"] ? new Date(_data["enddate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.resumptionDate = _data["resumptionDate"] ? new Date(_data["resumptionDate"].toString()) : <any>undefined;
            this.dateApplied = _data["dateApplied"] ? new Date(_data["dateApplied"].toString()) : <any>undefined;
            this.gradeID = _data["gradeID"];
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.rejectedBy = _data["rejectedBy"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.leaveYear = _data["leaveYear"] ? LeaveYear.fromJS(_data["leaveYear"]) : <any>undefined;
            this.leaveType = _data["leaveType"] ? LeaveType.fromJS(_data["leaveType"]) : <any>undefined;
            this.grade = _data["grade"] ? Grade.fromJS(_data["grade"]) : <any>undefined;
            this.file = _data["file"];
            if (Array.isArray(_data["leaveHistory"])) {
                this.leaveHistory = [] as any;
                for (let item of _data["leaveHistory"])
                    this.leaveHistory!.push(LeaveRequest.fromJS(item));
            }
            if (Array.isArray(_data["leaveEntitlement"])) {
                this.leaveEntitlement = [] as any;
                for (let item of _data["leaveEntitlement"])
                    this.leaveEntitlement!.push(LeaveEntitlement.fromJS(item));
            }
            this.approvalDecision = _data["approvalDecision"];
            this.approvalStatus = _data["approvalStatus"];
            this.log_status = _data["log_status"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaveTypeID"] = this.leaveTypeID;
        data["employeeID"] = this.employeeID;
        data["employeeContractID"] = this.employeeContractID;
        data["employeeNumber"] = this.employeeNumber;
        data["leaveYearID"] = this.leaveYearID;
        data["leaveCalendarID"] = this.leaveCalendarID;
        data["initiatorComment"] = this.initiatorComment;
        data["contactInfoOnLeave"] = this.contactInfoOnLeave;
        data["reliefOfficer"] = this.reliefOfficer;
        data["reliefOfficerId"] = this.reliefOfficerId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["startDateString"] = this.startDateString;
        data["enddate"] = this.enddate ? this.enddate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["resumptionDate"] = this.resumptionDate ? this.resumptionDate.toISOString() : <any>undefined;
        data["dateApplied"] = this.dateApplied ? this.dateApplied.toISOString() : <any>undefined;
        data["gradeID"] = this.gradeID;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["rejectedBy"] = this.rejectedBy;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["leaveYear"] = this.leaveYear ? this.leaveYear.toJSON() : <any>undefined;
        data["leaveType"] = this.leaveType ? this.leaveType.toJSON() : <any>undefined;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        data["file"] = this.file;
        if (Array.isArray(this.leaveHistory)) {
            data["leaveHistory"] = [];
            for (let item of this.leaveHistory)
                data["leaveHistory"].push(item.toJSON());
        }
        if (Array.isArray(this.leaveEntitlement)) {
            data["leaveEntitlement"] = [];
            for (let item of this.leaveEntitlement)
                data["leaveEntitlement"].push(item.toJSON());
        }
        data["approvalDecision"] = this.approvalDecision;
        data["approvalStatus"] = this.approvalStatus;
        data["log_status"] = this.log_status;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveRequest {
        const json = this.toJSON();
        let result = new LeaveRequest();
        result.init(json);
        return result;
    }
}

export interface ILeaveRequest {
    leaveTypeID: number;
    employeeID: number;
    employeeContractID: number | undefined;
    employeeNumber: string | undefined;
    leaveYearID: number;
    leaveCalendarID: number;
    initiatorComment: string | undefined;
    contactInfoOnLeave: string;
    reliefOfficer: string;
    reliefOfficerId: number;
    startDate: Date;
    startDateString: string | undefined;
    enddate: Date;
    noOfDays: number;
    resumptionDate: Date;
    dateApplied: Date;
    gradeID: number;
    dateApproved: Date | undefined;
    rejectedBy: string | undefined;
    employee: Employee;
    leaveYear: LeaveYear;
    leaveType: LeaveType;
    grade: Grade;
    file: string | undefined;
    leaveHistory: LeaveRequest[] | undefined;
    leaveEntitlement: LeaveEntitlement[] | undefined;
    approvalDecision: string | undefined;
    approvalStatus: string | undefined;
    log_status: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveRequestApiResult implements ILeaveRequestApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveRequest;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILeaveRequestApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveRequest.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LeaveRequestApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveRequestApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LeaveRequestApiResult {
        const json = this.toJSON();
        let result = new LeaveRequestApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveRequestApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveRequest;
    totalCount: number;
    totalRecord: number;
}

export class LeaveTypeDTO implements ILeaveTypeDTO {
    id!: number;
    name!: string | undefined;
    companyID!: number;
    subID!: number;
    isDeductableFromAnualLeave!: boolean;
    excludeWeekendInCalculation!: boolean;
    isOnlyAvailableToAdmin!: boolean;
    isAnnualLeave!: boolean;
    allowedGender!: number;
    maxDays!: number;
    minDays!: number;
    isSystemDefault!: boolean;
    maxNoofPossibleApplication!: number;
    maxNoofYearlyApplication!: number;
    isGradeDependent!: boolean;
    pro_rateLeaveDays!: boolean;
    onlyForConfirmStaff!: boolean;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isDeductableFromAnualLeave = _data["isDeductableFromAnualLeave"];
            this.excludeWeekendInCalculation = _data["excludeWeekendInCalculation"];
            this.isOnlyAvailableToAdmin = _data["isOnlyAvailableToAdmin"];
            this.isAnnualLeave = _data["isAnnualLeave"];
            this.allowedGender = _data["allowedGender"];
            this.maxDays = _data["maxDays"];
            this.minDays = _data["minDays"];
            this.isSystemDefault = _data["isSystemDefault"];
            this.maxNoofPossibleApplication = _data["maxNoofPossibleApplication"];
            this.maxNoofYearlyApplication = _data["maxNoofYearlyApplication"];
            this.isGradeDependent = _data["isGradeDependent"];
            this.pro_rateLeaveDays = _data["pro_rateLeaveDays"];
            this.onlyForConfirmStaff = _data["onlyForConfirmStaff"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isDeductableFromAnualLeave"] = this.isDeductableFromAnualLeave;
        data["excludeWeekendInCalculation"] = this.excludeWeekendInCalculation;
        data["isOnlyAvailableToAdmin"] = this.isOnlyAvailableToAdmin;
        data["isAnnualLeave"] = this.isAnnualLeave;
        data["allowedGender"] = this.allowedGender;
        data["maxDays"] = this.maxDays;
        data["minDays"] = this.minDays;
        data["isSystemDefault"] = this.isSystemDefault;
        data["maxNoofPossibleApplication"] = this.maxNoofPossibleApplication;
        data["maxNoofYearlyApplication"] = this.maxNoofYearlyApplication;
        data["isGradeDependent"] = this.isGradeDependent;
        data["pro_rateLeaveDays"] = this.pro_rateLeaveDays;
        data["onlyForConfirmStaff"] = this.onlyForConfirmStaff;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveTypeDTO {
        const json = this.toJSON();
        let result = new LeaveTypeDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeDTO {
    id: number;
    name: string | undefined;
    companyID: number;
    subID: number;
    isDeductableFromAnualLeave: boolean;
    excludeWeekendInCalculation: boolean;
    isOnlyAvailableToAdmin: boolean;
    isAnnualLeave: boolean;
    allowedGender: number;
    maxDays: number;
    minDays: number;
    isSystemDefault: boolean;
    maxNoofPossibleApplication: number;
    maxNoofYearlyApplication: number;
    isGradeDependent: boolean;
    pro_rateLeaveDays: boolean;
    onlyForConfirmStaff: boolean;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveTypeDTOListApiResult implements ILeaveTypeDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveTypeDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILeaveTypeDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LeaveTypeDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LeaveTypeDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveTypeDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveTypeDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class LeaveTypeCreatePayload implements ILeaveTypeCreatePayload {
    id!: number;
    name!: string;
    allowedGender!: number;
    maxDays!: number;
    minDays!: number;
    maxNoofPossibleApplication!: number;
    maxNoofYearlyApplication!: number;

    constructor(data?: ILeaveTypeCreatePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.allowedGender = _data["allowedGender"];
            this.maxDays = _data["maxDays"];
            this.minDays = _data["minDays"];
            this.maxNoofPossibleApplication = _data["maxNoofPossibleApplication"];
            this.maxNoofYearlyApplication = _data["maxNoofYearlyApplication"];
        }
    }

    static fromJS(data: any): LeaveTypeCreatePayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeCreatePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["allowedGender"] = this.allowedGender;
        data["maxDays"] = this.maxDays;
        data["minDays"] = this.minDays;
        data["maxNoofPossibleApplication"] = this.maxNoofPossibleApplication;
        data["maxNoofYearlyApplication"] = this.maxNoofYearlyApplication;
        return data; 
    }

    clone(): LeaveTypeCreatePayload {
        const json = this.toJSON();
        let result = new LeaveTypeCreatePayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeCreatePayload {
    id: number;
    name: string;
    allowedGender: number;
    maxDays: number;
    minDays: number;
    maxNoofPossibleApplication: number;
    maxNoofYearlyApplication: number;
}

export class LeaveTypeDTOApiResult implements ILeaveTypeDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveTypeDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILeaveTypeDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveTypeDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LeaveTypeDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LeaveTypeDTOApiResult {
        const json = this.toJSON();
        let result = new LeaveTypeDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveTypeDTO;
    totalCount: number;
    totalRecord: number;
}

export class LeaveWorkFlow implements ILeaveWorkFlow {
    departmentID!: number;
    workFlowName!: string | undefined;
    workFlowItems!: LeaveWorkFlowItem[] | undefined;
    department!: Department;
    workFlowString!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveWorkFlow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentID = _data["departmentID"];
            this.workFlowName = _data["workFlowName"];
            if (Array.isArray(_data["workFlowItems"])) {
                this.workFlowItems = [] as any;
                for (let item of _data["workFlowItems"])
                    this.workFlowItems!.push(LeaveWorkFlowItem.fromJS(item));
            }
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.workFlowString = _data["workFlowString"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveWorkFlow {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentID"] = this.departmentID;
        data["workFlowName"] = this.workFlowName;
        if (Array.isArray(this.workFlowItems)) {
            data["workFlowItems"] = [];
            for (let item of this.workFlowItems)
                data["workFlowItems"].push(item.toJSON());
        }
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["workFlowString"] = this.workFlowString;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveWorkFlow {
        const json = this.toJSON();
        let result = new LeaveWorkFlow();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlow {
    departmentID: number;
    workFlowName: string | undefined;
    workFlowItems: LeaveWorkFlowItem[] | undefined;
    department: Department;
    workFlowString: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveWorkFlowItem implements ILeaveWorkFlowItem {
    stepName!: string | undefined;
    jobRoleID!: number;
    leaveWorkFlowID!: number;
    rank!: number;
    isFinalApproval!: boolean;
    recipientName!: string | undefined;
    jobRole!: JobRole;
    leaveWorkFlow!: LeaveWorkFlow;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveWorkFlowItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stepName = _data["stepName"];
            this.jobRoleID = _data["jobRoleID"];
            this.leaveWorkFlowID = _data["leaveWorkFlowID"];
            this.rank = _data["rank"];
            this.isFinalApproval = _data["isFinalApproval"];
            this.recipientName = _data["recipientName"];
            this.jobRole = _data["jobRole"] ? JobRole.fromJS(_data["jobRole"]) : <any>undefined;
            this.leaveWorkFlow = _data["leaveWorkFlow"] ? LeaveWorkFlow.fromJS(_data["leaveWorkFlow"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowItem {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stepName"] = this.stepName;
        data["jobRoleID"] = this.jobRoleID;
        data["leaveWorkFlowID"] = this.leaveWorkFlowID;
        data["rank"] = this.rank;
        data["isFinalApproval"] = this.isFinalApproval;
        data["recipientName"] = this.recipientName;
        data["jobRole"] = this.jobRole ? this.jobRole.toJSON() : <any>undefined;
        data["leaveWorkFlow"] = this.leaveWorkFlow ? this.leaveWorkFlow.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveWorkFlowItem {
        const json = this.toJSON();
        let result = new LeaveWorkFlowItem();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowItem {
    stepName: string | undefined;
    jobRoleID: number;
    leaveWorkFlowID: number;
    rank: number;
    isFinalApproval: boolean;
    recipientName: string | undefined;
    jobRole: JobRole;
    leaveWorkFlow: LeaveWorkFlow;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveWorkFlowResource implements ILeaveWorkFlowResource {
    departmentID!: number;
    workFlowName!: string | undefined;
    workFlowItems!: LeaveWorkFlowItem[] | undefined;
    department!: Department;
    workFlowString!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;

    constructor(data?: ILeaveWorkFlowResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentID = _data["departmentID"];
            this.workFlowName = _data["workFlowName"];
            if (Array.isArray(_data["workFlowItems"])) {
                this.workFlowItems = [] as any;
                for (let item of _data["workFlowItems"])
                    this.workFlowItems!.push(LeaveWorkFlowItem.fromJS(item));
            }
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.workFlowString = _data["workFlowString"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowResource {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentID"] = this.departmentID;
        data["workFlowName"] = this.workFlowName;
        if (Array.isArray(this.workFlowItems)) {
            data["workFlowItems"] = [];
            for (let item of this.workFlowItems)
                data["workFlowItems"].push(item.toJSON());
        }
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["workFlowString"] = this.workFlowString;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        return data; 
    }

    clone(): LeaveWorkFlowResource {
        const json = this.toJSON();
        let result = new LeaveWorkFlowResource();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowResource {
    departmentID: number;
    workFlowName: string | undefined;
    workFlowItems: LeaveWorkFlowItem[] | undefined;
    department: Department;
    workFlowString: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
}

export class LeaveWorkFlowResourceListApiResult implements ILeaveWorkFlowResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveWorkFlowResource[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILeaveWorkFlowResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveWorkFlowResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LeaveWorkFlowResourceListApiResult {
        const json = this.toJSON();
        let result = new LeaveWorkFlowResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveWorkFlowResource[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class LeaveWorkFlowResourceApiResult implements ILeaveWorkFlowResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveWorkFlowResource;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILeaveWorkFlowResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveWorkFlowResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LeaveWorkFlowResourceApiResult {
        const json = this.toJSON();
        let result = new LeaveWorkFlowResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveWorkFlowResource;
    totalCount: number;
    totalRecord: number;
}

export class LeaveworkFlowPayload implements ILeaveworkFlowPayload {
    leaveWorkFlowID!: number;
    departmentID!: number;
    workFlowName!: string;
    workFlowString!: string;

    constructor(data?: ILeaveworkFlowPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leaveWorkFlowID = _data["leaveWorkFlowID"];
            this.departmentID = _data["departmentID"];
            this.workFlowName = _data["workFlowName"];
            this.workFlowString = _data["workFlowString"];
        }
    }

    static fromJS(data: any): LeaveworkFlowPayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveworkFlowPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaveWorkFlowID"] = this.leaveWorkFlowID;
        data["departmentID"] = this.departmentID;
        data["workFlowName"] = this.workFlowName;
        data["workFlowString"] = this.workFlowString;
        return data; 
    }

    clone(): LeaveworkFlowPayload {
        const json = this.toJSON();
        let result = new LeaveworkFlowPayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveworkFlowPayload {
    leaveWorkFlowID: number;
    departmentID: number;
    workFlowName: string;
    workFlowString: string;
}

export class LeaveYearDTO implements ILeaveYearDTO {
    yearName!: string | undefined;
    isActiveYear!: boolean;
    yearStartDate!: Date;
    yearEndDate!: Date;
    log_status!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    create_contextyId!: number;
    dateModified!: Date | undefined;
    modifie_contextyId!: number | undefined;

    constructor(data?: ILeaveYearDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.yearName = _data["yearName"];
            this.isActiveYear = _data["isActiveYear"];
            this.yearStartDate = _data["yearStartDate"] ? new Date(_data["yearStartDate"].toString()) : <any>undefined;
            this.yearEndDate = _data["yearEndDate"] ? new Date(_data["yearEndDate"].toString()) : <any>undefined;
            this.log_status = _data["log_status"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.create_contextyId = _data["create_contextyId"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifie_contextyId = _data["modifie_contextyId"];
        }
    }

    static fromJS(data: any): LeaveYearDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yearName"] = this.yearName;
        data["isActiveYear"] = this.isActiveYear;
        data["yearStartDate"] = this.yearStartDate ? this.yearStartDate.toISOString() : <any>undefined;
        data["yearEndDate"] = this.yearEndDate ? this.yearEndDate.toISOString() : <any>undefined;
        data["log_status"] = this.log_status;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["create_contextyId"] = this.create_contextyId;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifie_contextyId"] = this.modifie_contextyId;
        return data; 
    }

    clone(): LeaveYearDTO {
        const json = this.toJSON();
        let result = new LeaveYearDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearDTO {
    yearName: string | undefined;
    isActiveYear: boolean;
    yearStartDate: Date;
    yearEndDate: Date;
    log_status: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    create_contextyId: number;
    dateModified: Date | undefined;
    modifie_contextyId: number | undefined;
}

export class LeaveYearDTOListApiResult implements ILeaveYearDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveYearDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILeaveYearDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveYearDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LeaveYearDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LeaveYearDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveYearDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveYearDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class LeaveYearCreatePayload implements ILeaveYearCreatePayload {
    id!: number;
    yearName!: string;
    isActiveYear!: boolean;
    yearStartDate!: Date;
    yearEndDate!: Date;

    constructor(data?: ILeaveYearCreatePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.yearName = _data["yearName"];
            this.isActiveYear = _data["isActiveYear"];
            this.yearStartDate = _data["yearStartDate"] ? new Date(_data["yearStartDate"].toString()) : <any>undefined;
            this.yearEndDate = _data["yearEndDate"] ? new Date(_data["yearEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LeaveYearCreatePayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearCreatePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["yearName"] = this.yearName;
        data["isActiveYear"] = this.isActiveYear;
        data["yearStartDate"] = this.yearStartDate ? this.yearStartDate.toISOString() : <any>undefined;
        data["yearEndDate"] = this.yearEndDate ? this.yearEndDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): LeaveYearCreatePayload {
        const json = this.toJSON();
        let result = new LeaveYearCreatePayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearCreatePayload {
    id: number;
    yearName: string;
    isActiveYear: boolean;
    yearStartDate: Date;
    yearEndDate: Date;
}

export class LeaveYearDTOApiResult implements ILeaveYearDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveYearDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILeaveYearDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveYearDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LeaveYearDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LeaveYearDTOApiResult {
        const json = this.toJSON();
        let result = new LeaveYearDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveYearDTO;
    totalCount: number;
    totalRecord: number;
}

export class NewLoanRequestDTO implements INewLoanRequestDTO {
    id!: number;
    loanTypeId!: number;
    refNo!: string | undefined;
    employeeNo!: string | undefined;
    employeeName!: string | undefined;
    loanTypeName!: string | undefined;
    employeeId!: number;
    log_status!: number;
    is_disbursed!: boolean;
    is_active!: boolean;
    amount!: number;
    tenor!: number;
    totalPrincipalRepaid!: number;
    approvalProcessId!: number;
    requestedTenor!: number;
    tempRef!: string | undefined;
    strRequestedAmount!: string | undefined;
    strEffectiveDate!: string | undefined;
    strGuarantorIds!: string | undefined;
    effectiveDate!: Date | undefined;
    requestedAmount!: number;
    autoDeduction!: boolean;
    customAnswer!: string | undefined;
    loggedForEmployeeId!: string | undefined;
    justification!: string | undefined;
    submittedByUserId!: number;

    constructor(data?: INewLoanRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.loanTypeId = _data["loanTypeId"];
            this.refNo = _data["refNo"];
            this.employeeNo = _data["employeeNo"];
            this.employeeName = _data["employeeName"];
            this.loanTypeName = _data["loanTypeName"];
            this.employeeId = _data["employeeId"];
            this.log_status = _data["log_status"];
            this.is_disbursed = _data["is_disbursed"];
            this.is_active = _data["is_active"];
            this.amount = _data["amount"];
            this.tenor = _data["tenor"];
            this.totalPrincipalRepaid = _data["totalPrincipalRepaid"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.requestedTenor = _data["requestedTenor"];
            this.tempRef = _data["tempRef"];
            this.strRequestedAmount = _data["strRequestedAmount"];
            this.strEffectiveDate = _data["strEffectiveDate"];
            this.strGuarantorIds = _data["strGuarantorIds"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.requestedAmount = _data["requestedAmount"];
            this.autoDeduction = _data["autoDeduction"];
            this.customAnswer = _data["customAnswer"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.justification = _data["justification"];
            this.submittedByUserId = _data["submittedByUserId"];
        }
    }

    static fromJS(data: any): NewLoanRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NewLoanRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["loanTypeId"] = this.loanTypeId;
        data["refNo"] = this.refNo;
        data["employeeNo"] = this.employeeNo;
        data["employeeName"] = this.employeeName;
        data["loanTypeName"] = this.loanTypeName;
        data["employeeId"] = this.employeeId;
        data["log_status"] = this.log_status;
        data["is_disbursed"] = this.is_disbursed;
        data["is_active"] = this.is_active;
        data["amount"] = this.amount;
        data["tenor"] = this.tenor;
        data["totalPrincipalRepaid"] = this.totalPrincipalRepaid;
        data["approvalProcessId"] = this.approvalProcessId;
        data["requestedTenor"] = this.requestedTenor;
        data["tempRef"] = this.tempRef;
        data["strRequestedAmount"] = this.strRequestedAmount;
        data["strEffectiveDate"] = this.strEffectiveDate;
        data["strGuarantorIds"] = this.strGuarantorIds;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["requestedAmount"] = this.requestedAmount;
        data["autoDeduction"] = this.autoDeduction;
        data["customAnswer"] = this.customAnswer;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["justification"] = this.justification;
        data["submittedByUserId"] = this.submittedByUserId;
        return data; 
    }

    clone(): NewLoanRequestDTO {
        const json = this.toJSON();
        let result = new NewLoanRequestDTO();
        result.init(json);
        return result;
    }
}

export interface INewLoanRequestDTO {
    id: number;
    loanTypeId: number;
    refNo: string | undefined;
    employeeNo: string | undefined;
    employeeName: string | undefined;
    loanTypeName: string | undefined;
    employeeId: number;
    log_status: number;
    is_disbursed: boolean;
    is_active: boolean;
    amount: number;
    tenor: number;
    totalPrincipalRepaid: number;
    approvalProcessId: number;
    requestedTenor: number;
    tempRef: string | undefined;
    strRequestedAmount: string | undefined;
    strEffectiveDate: string | undefined;
    strGuarantorIds: string | undefined;
    effectiveDate: Date | undefined;
    requestedAmount: number;
    autoDeduction: boolean;
    customAnswer: string | undefined;
    loggedForEmployeeId: string | undefined;
    justification: string | undefined;
    submittedByUserId: number;
}

export class PostLoanDto implements IPostLoanDto {
    loan_id!: number;
    repaymentcomment!: string | undefined;
    repaymenttotalamt!: string | undefined;
    repaymenttype!: string | undefined;
    partamt!: string | undefined;
    repytdate!: string | undefined;

    constructor(data?: IPostLoanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loan_id = _data["loan_id"];
            this.repaymentcomment = _data["repaymentcomment"];
            this.repaymenttotalamt = _data["repaymenttotalamt"];
            this.repaymenttype = _data["repaymenttype"];
            this.partamt = _data["partamt"];
            this.repytdate = _data["repytdate"];
        }
    }

    static fromJS(data: any): PostLoanDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostLoanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loan_id"] = this.loan_id;
        data["repaymentcomment"] = this.repaymentcomment;
        data["repaymenttotalamt"] = this.repaymenttotalamt;
        data["repaymenttype"] = this.repaymenttype;
        data["partamt"] = this.partamt;
        data["repytdate"] = this.repytdate;
        return data; 
    }

    clone(): PostLoanDto {
        const json = this.toJSON();
        let result = new PostLoanDto();
        result.init(json);
        return result;
    }
}

export interface IPostLoanDto {
    loan_id: number;
    repaymentcomment: string | undefined;
    repaymenttotalamt: string | undefined;
    repaymenttype: string | undefined;
    partamt: string | undefined;
    repytdate: string | undefined;
}

export class LoanRepaymentLog implements ILoanRepaymentLog {
    id!: number;
    loanRequestId!: number;
    amountRepaid!: number;
    principalRepayment!: number;
    interestRepayment!: number;
    repaymentDate!: Date;
    repaymentType!: string | undefined;
    comment!: string | undefined;
    isSchedule!: boolean;
    strRepaymentDate!: string | undefined;

    constructor(data?: ILoanRepaymentLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.loanRequestId = _data["loanRequestId"];
            this.amountRepaid = _data["amountRepaid"];
            this.principalRepayment = _data["principalRepayment"];
            this.interestRepayment = _data["interestRepayment"];
            this.repaymentDate = _data["repaymentDate"] ? new Date(_data["repaymentDate"].toString()) : <any>undefined;
            this.repaymentType = _data["repaymentType"];
            this.comment = _data["comment"];
            this.isSchedule = _data["isSchedule"];
            this.strRepaymentDate = _data["strRepaymentDate"];
        }
    }

    static fromJS(data: any): LoanRepaymentLog {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRepaymentLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["loanRequestId"] = this.loanRequestId;
        data["amountRepaid"] = this.amountRepaid;
        data["principalRepayment"] = this.principalRepayment;
        data["interestRepayment"] = this.interestRepayment;
        data["repaymentDate"] = this.repaymentDate ? this.repaymentDate.toISOString() : <any>undefined;
        data["repaymentType"] = this.repaymentType;
        data["comment"] = this.comment;
        data["isSchedule"] = this.isSchedule;
        data["strRepaymentDate"] = this.strRepaymentDate;
        return data; 
    }

    clone(): LoanRepaymentLog {
        const json = this.toJSON();
        let result = new LoanRepaymentLog();
        result.init(json);
        return result;
    }
}

export interface ILoanRepaymentLog {
    id: number;
    loanRequestId: number;
    amountRepaid: number;
    principalRepayment: number;
    interestRepayment: number;
    repaymentDate: Date;
    repaymentType: string | undefined;
    comment: string | undefined;
    isSchedule: boolean;
    strRepaymentDate: string | undefined;
}

export class LoanRepaymentLogIListApiResult implements ILoanRepaymentLogIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanRepaymentLog[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILoanRepaymentLogIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LoanRepaymentLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LoanRepaymentLogIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRepaymentLogIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LoanRepaymentLogIListApiResult {
        const json = this.toJSON();
        let result = new LoanRepaymentLogIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanRepaymentLogIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanRepaymentLog[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class LoanRequestDTO implements ILoanRequestDTO {
    id!: number;
    loanTypeId!: number;
    refNo!: string | undefined;
    employeeNo!: string | undefined;
    employeeName!: string | undefined;
    loanTypeName!: string | undefined;
    employeeId!: number;
    log_status!: number;
    is_disbursed!: boolean;
    is_active!: boolean;
    amount!: number;
    tenor!: number;
    totalPrincipalRepaid!: number;
    approvalProcessId!: number;
    requestedTenor!: number;
    approvedTenor!: number;
    strRequestedAmount!: string | undefined;
    strEffectiveDate!: string | undefined;
    tempRef!: string | undefined;
    strApprovedAmount!: string | undefined;
    strMaturityDate!: string | undefined;
    _ServerDocURL!: string | undefined;
    strGuarantorIds!: string | undefined;
    effectiveDate!: Date | undefined;
    outstandingPrincipal!: number;
    outstandingInterest!: number;
    requestedAmount!: number;
    approvedAmount!: number;
    autoDeduction!: boolean;
    customAnswer!: string | undefined;
    loggedForEmployeeId!: string | undefined;
    justification!: string | undefined;
    submittedByUserId!: number;

    constructor(data?: ILoanRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.loanTypeId = _data["loanTypeId"];
            this.refNo = _data["refNo"];
            this.employeeNo = _data["employeeNo"];
            this.employeeName = _data["employeeName"];
            this.loanTypeName = _data["loanTypeName"];
            this.employeeId = _data["employeeId"];
            this.log_status = _data["log_status"];
            this.is_disbursed = _data["is_disbursed"];
            this.is_active = _data["is_active"];
            this.amount = _data["amount"];
            this.tenor = _data["tenor"];
            this.totalPrincipalRepaid = _data["totalPrincipalRepaid"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.requestedTenor = _data["requestedTenor"];
            this.approvedTenor = _data["approvedTenor"];
            this.strRequestedAmount = _data["strRequestedAmount"];
            this.strEffectiveDate = _data["strEffectiveDate"];
            this.tempRef = _data["tempRef"];
            this.strApprovedAmount = _data["strApprovedAmount"];
            this.strMaturityDate = _data["strMaturityDate"];
            this._ServerDocURL = _data["_ServerDocURL"];
            this.strGuarantorIds = _data["strGuarantorIds"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.outstandingPrincipal = _data["outstandingPrincipal"];
            this.outstandingInterest = _data["outstandingInterest"];
            this.requestedAmount = _data["requestedAmount"];
            this.approvedAmount = _data["approvedAmount"];
            this.autoDeduction = _data["autoDeduction"];
            this.customAnswer = _data["customAnswer"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.justification = _data["justification"];
            this.submittedByUserId = _data["submittedByUserId"];
        }
    }

    static fromJS(data: any): LoanRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["loanTypeId"] = this.loanTypeId;
        data["refNo"] = this.refNo;
        data["employeeNo"] = this.employeeNo;
        data["employeeName"] = this.employeeName;
        data["loanTypeName"] = this.loanTypeName;
        data["employeeId"] = this.employeeId;
        data["log_status"] = this.log_status;
        data["is_disbursed"] = this.is_disbursed;
        data["is_active"] = this.is_active;
        data["amount"] = this.amount;
        data["tenor"] = this.tenor;
        data["totalPrincipalRepaid"] = this.totalPrincipalRepaid;
        data["approvalProcessId"] = this.approvalProcessId;
        data["requestedTenor"] = this.requestedTenor;
        data["approvedTenor"] = this.approvedTenor;
        data["strRequestedAmount"] = this.strRequestedAmount;
        data["strEffectiveDate"] = this.strEffectiveDate;
        data["tempRef"] = this.tempRef;
        data["strApprovedAmount"] = this.strApprovedAmount;
        data["strMaturityDate"] = this.strMaturityDate;
        data["_ServerDocURL"] = this._ServerDocURL;
        data["strGuarantorIds"] = this.strGuarantorIds;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["outstandingPrincipal"] = this.outstandingPrincipal;
        data["outstandingInterest"] = this.outstandingInterest;
        data["requestedAmount"] = this.requestedAmount;
        data["approvedAmount"] = this.approvedAmount;
        data["autoDeduction"] = this.autoDeduction;
        data["customAnswer"] = this.customAnswer;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["justification"] = this.justification;
        data["submittedByUserId"] = this.submittedByUserId;
        return data; 
    }

    clone(): LoanRequestDTO {
        const json = this.toJSON();
        let result = new LoanRequestDTO();
        result.init(json);
        return result;
    }
}

export interface ILoanRequestDTO {
    id: number;
    loanTypeId: number;
    refNo: string | undefined;
    employeeNo: string | undefined;
    employeeName: string | undefined;
    loanTypeName: string | undefined;
    employeeId: number;
    log_status: number;
    is_disbursed: boolean;
    is_active: boolean;
    amount: number;
    tenor: number;
    totalPrincipalRepaid: number;
    approvalProcessId: number;
    requestedTenor: number;
    approvedTenor: number;
    strRequestedAmount: string | undefined;
    strEffectiveDate: string | undefined;
    tempRef: string | undefined;
    strApprovedAmount: string | undefined;
    strMaturityDate: string | undefined;
    _ServerDocURL: string | undefined;
    strGuarantorIds: string | undefined;
    effectiveDate: Date | undefined;
    outstandingPrincipal: number;
    outstandingInterest: number;
    requestedAmount: number;
    approvedAmount: number;
    autoDeduction: boolean;
    customAnswer: string | undefined;
    loggedForEmployeeId: string | undefined;
    justification: string | undefined;
    submittedByUserId: number;
}

export class LoanRequestDTOIListApiResult implements ILoanRequestDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanRequestDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILoanRequestDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LoanRequestDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LoanRequestDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequestDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LoanRequestDTOIListApiResult {
        const json = this.toJSON();
        let result = new LoanRequestDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanRequestDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanRequestDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class IdNameObjIListApiResult implements IIdNameObjIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: IdNameObj[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IIdNameObjIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(IdNameObj.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): IdNameObjIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameObjIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): IdNameObjIListApiResult {
        const json = this.toJSON();
        let result = new IdNameObjIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IIdNameObjIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: IdNameObj[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class UpdateLoadRequestDTO implements IUpdateLoadRequestDTO {
    effective_date!: string | undefined;
    loan_id!: number;
    approved_tenor!: number;
    approved_amt!: string | undefined;

    constructor(data?: IUpdateLoadRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.effective_date = _data["effective_date"];
            this.loan_id = _data["loan_id"];
            this.approved_tenor = _data["approved_tenor"];
            this.approved_amt = _data["approved_amt"];
        }
    }

    static fromJS(data: any): UpdateLoadRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLoadRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["effective_date"] = this.effective_date;
        data["loan_id"] = this.loan_id;
        data["approved_tenor"] = this.approved_tenor;
        data["approved_amt"] = this.approved_amt;
        return data; 
    }

    clone(): UpdateLoadRequestDTO {
        const json = this.toJSON();
        let result = new UpdateLoadRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IUpdateLoadRequestDTO {
    effective_date: string | undefined;
    loan_id: number;
    approved_tenor: number;
    approved_amt: string | undefined;
}

export class LoanRequest implements ILoanRequest {
    loanTypeId!: number;
    submittedByUserId!: number;
    loggedForEmployeeId!: number;
    refNo!: string | undefined;
    interestRate!: number;
    requestedAmount!: number;
    approvalProcessId!: number;
    interestType!: number;
    requestedTenor!: number;
    approvedTenor!: number;
    approvedAmount!: number;
    totalPrincipalRepaid!: number;
    totalInterestRepaid!: number;
    totalAmountRepaid!: number;
    lastRepaymentDate!: Date | undefined;
    effectiveDate!: Date | undefined;
    dateApproved!: Date | undefined;
    customAnswer!: string | undefined;
    justification!: string | undefined;
    log_status!: number;
    is_disbursed!: boolean;
    date_disbursed!: Date | undefined;
    autoDeduction!: boolean;
    maxLoanRepaytPercent!: number;
    maxLoanRepaytAmount!: number;
    is_repaid!: boolean;
    disbursementdetails!: string | undefined;
    disburseby!: string | undefined;
    disbursementType!: number | undefined;
    employeeNo!: string | undefined;
    employeeName!: string | undefined;
    loanTypeName!: string | undefined;
    strRequestedAmount!: string | undefined;
    strEffectiveDate!: string | undefined;
    tempRef!: string | undefined;
    strApprovedAmount!: string | undefined;
    strMaturityDate!: string | undefined;
    _ServerDocURL!: string | undefined;
    strGuarantorIds!: string | undefined;
    outstandingPrincipal!: number;
    outstandingInterest!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILoanRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loanTypeId = _data["loanTypeId"];
            this.submittedByUserId = _data["submittedByUserId"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.refNo = _data["refNo"];
            this.interestRate = _data["interestRate"];
            this.requestedAmount = _data["requestedAmount"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.interestType = _data["interestType"];
            this.requestedTenor = _data["requestedTenor"];
            this.approvedTenor = _data["approvedTenor"];
            this.approvedAmount = _data["approvedAmount"];
            this.totalPrincipalRepaid = _data["totalPrincipalRepaid"];
            this.totalInterestRepaid = _data["totalInterestRepaid"];
            this.totalAmountRepaid = _data["totalAmountRepaid"];
            this.lastRepaymentDate = _data["lastRepaymentDate"] ? new Date(_data["lastRepaymentDate"].toString()) : <any>undefined;
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.customAnswer = _data["customAnswer"];
            this.justification = _data["justification"];
            this.log_status = _data["log_status"];
            this.is_disbursed = _data["is_disbursed"];
            this.date_disbursed = _data["date_disbursed"] ? new Date(_data["date_disbursed"].toString()) : <any>undefined;
            this.autoDeduction = _data["autoDeduction"];
            this.maxLoanRepaytPercent = _data["maxLoanRepaytPercent"];
            this.maxLoanRepaytAmount = _data["maxLoanRepaytAmount"];
            this.is_repaid = _data["is_repaid"];
            this.disbursementdetails = _data["disbursementdetails"];
            this.disburseby = _data["disburseby"];
            this.disbursementType = _data["disbursementType"];
            this.employeeNo = _data["employeeNo"];
            this.employeeName = _data["employeeName"];
            this.loanTypeName = _data["loanTypeName"];
            this.strRequestedAmount = _data["strRequestedAmount"];
            this.strEffectiveDate = _data["strEffectiveDate"];
            this.tempRef = _data["tempRef"];
            this.strApprovedAmount = _data["strApprovedAmount"];
            this.strMaturityDate = _data["strMaturityDate"];
            this._ServerDocURL = _data["_ServerDocURL"];
            this.strGuarantorIds = _data["strGuarantorIds"];
            this.outstandingPrincipal = _data["outstandingPrincipal"];
            this.outstandingInterest = _data["outstandingInterest"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LoanRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loanTypeId"] = this.loanTypeId;
        data["submittedByUserId"] = this.submittedByUserId;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["refNo"] = this.refNo;
        data["interestRate"] = this.interestRate;
        data["requestedAmount"] = this.requestedAmount;
        data["approvalProcessId"] = this.approvalProcessId;
        data["interestType"] = this.interestType;
        data["requestedTenor"] = this.requestedTenor;
        data["approvedTenor"] = this.approvedTenor;
        data["approvedAmount"] = this.approvedAmount;
        data["totalPrincipalRepaid"] = this.totalPrincipalRepaid;
        data["totalInterestRepaid"] = this.totalInterestRepaid;
        data["totalAmountRepaid"] = this.totalAmountRepaid;
        data["lastRepaymentDate"] = this.lastRepaymentDate ? this.lastRepaymentDate.toISOString() : <any>undefined;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["customAnswer"] = this.customAnswer;
        data["justification"] = this.justification;
        data["log_status"] = this.log_status;
        data["is_disbursed"] = this.is_disbursed;
        data["date_disbursed"] = this.date_disbursed ? this.date_disbursed.toISOString() : <any>undefined;
        data["autoDeduction"] = this.autoDeduction;
        data["maxLoanRepaytPercent"] = this.maxLoanRepaytPercent;
        data["maxLoanRepaytAmount"] = this.maxLoanRepaytAmount;
        data["is_repaid"] = this.is_repaid;
        data["disbursementdetails"] = this.disbursementdetails;
        data["disburseby"] = this.disburseby;
        data["disbursementType"] = this.disbursementType;
        data["employeeNo"] = this.employeeNo;
        data["employeeName"] = this.employeeName;
        data["loanTypeName"] = this.loanTypeName;
        data["strRequestedAmount"] = this.strRequestedAmount;
        data["strEffectiveDate"] = this.strEffectiveDate;
        data["tempRef"] = this.tempRef;
        data["strApprovedAmount"] = this.strApprovedAmount;
        data["strMaturityDate"] = this.strMaturityDate;
        data["_ServerDocURL"] = this._ServerDocURL;
        data["strGuarantorIds"] = this.strGuarantorIds;
        data["outstandingPrincipal"] = this.outstandingPrincipal;
        data["outstandingInterest"] = this.outstandingInterest;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LoanRequest {
        const json = this.toJSON();
        let result = new LoanRequest();
        result.init(json);
        return result;
    }
}

export interface ILoanRequest {
    loanTypeId: number;
    submittedByUserId: number;
    loggedForEmployeeId: number;
    refNo: string | undefined;
    interestRate: number;
    requestedAmount: number;
    approvalProcessId: number;
    interestType: number;
    requestedTenor: number;
    approvedTenor: number;
    approvedAmount: number;
    totalPrincipalRepaid: number;
    totalInterestRepaid: number;
    totalAmountRepaid: number;
    lastRepaymentDate: Date | undefined;
    effectiveDate: Date | undefined;
    dateApproved: Date | undefined;
    customAnswer: string | undefined;
    justification: string | undefined;
    log_status: number;
    is_disbursed: boolean;
    date_disbursed: Date | undefined;
    autoDeduction: boolean;
    maxLoanRepaytPercent: number;
    maxLoanRepaytAmount: number;
    is_repaid: boolean;
    disbursementdetails: string | undefined;
    disburseby: string | undefined;
    disbursementType: number | undefined;
    employeeNo: string | undefined;
    employeeName: string | undefined;
    loanTypeName: string | undefined;
    strRequestedAmount: string | undefined;
    strEffectiveDate: string | undefined;
    tempRef: string | undefined;
    strApprovedAmount: string | undefined;
    strMaturityDate: string | undefined;
    _ServerDocURL: string | undefined;
    strGuarantorIds: string | undefined;
    outstandingPrincipal: number;
    outstandingInterest: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LoanRequestApiResult implements ILoanRequestApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanRequest;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILoanRequestApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LoanRequest.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LoanRequestApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequestApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LoanRequestApiResult {
        const json = this.toJSON();
        let result = new LoanRequestApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanRequestApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanRequest;
    totalCount: number;
    totalRecord: number;
}

export class ManageLoanTypeDTO implements IManageLoanTypeDTO {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    requiresGuarantor!: boolean;
    requiredNoOfGuarantors!: number;
    eligibleGrades!: string | undefined;
    ledgerNo!: string | undefined;
    approvalProcessId!: number;
    interestRate!: number;
    minTenor!: number;
    maxTenor!: number;
    minAmount!: number;
    maxAmount!: number;
    interestType!: number;
    eligibleEmploymentStatus!: number;
    customQuestion!: string | undefined;
    maxLoanRepaytPercent!: number;

    constructor(data?: IManageLoanTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.requiresGuarantor = _data["requiresGuarantor"];
            this.requiredNoOfGuarantors = _data["requiredNoOfGuarantors"];
            this.eligibleGrades = _data["eligibleGrades"];
            this.ledgerNo = _data["ledgerNo"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.interestRate = _data["interestRate"];
            this.minTenor = _data["minTenor"];
            this.maxTenor = _data["maxTenor"];
            this.minAmount = _data["minAmount"];
            this.maxAmount = _data["maxAmount"];
            this.interestType = _data["interestType"];
            this.eligibleEmploymentStatus = _data["eligibleEmploymentStatus"];
            this.customQuestion = _data["customQuestion"];
            this.maxLoanRepaytPercent = _data["maxLoanRepaytPercent"];
        }
    }

    static fromJS(data: any): ManageLoanTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageLoanTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["requiresGuarantor"] = this.requiresGuarantor;
        data["requiredNoOfGuarantors"] = this.requiredNoOfGuarantors;
        data["eligibleGrades"] = this.eligibleGrades;
        data["ledgerNo"] = this.ledgerNo;
        data["approvalProcessId"] = this.approvalProcessId;
        data["interestRate"] = this.interestRate;
        data["minTenor"] = this.minTenor;
        data["maxTenor"] = this.maxTenor;
        data["minAmount"] = this.minAmount;
        data["maxAmount"] = this.maxAmount;
        data["interestType"] = this.interestType;
        data["eligibleEmploymentStatus"] = this.eligibleEmploymentStatus;
        data["customQuestion"] = this.customQuestion;
        data["maxLoanRepaytPercent"] = this.maxLoanRepaytPercent;
        return data; 
    }

    clone(): ManageLoanTypeDTO {
        const json = this.toJSON();
        let result = new ManageLoanTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IManageLoanTypeDTO {
    id: number;
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    requiresGuarantor: boolean;
    requiredNoOfGuarantors: number;
    eligibleGrades: string | undefined;
    ledgerNo: string | undefined;
    approvalProcessId: number;
    interestRate: number;
    minTenor: number;
    maxTenor: number;
    minAmount: number;
    maxAmount: number;
    interestType: number;
    eligibleEmploymentStatus: number;
    customQuestion: string | undefined;
    maxLoanRepaytPercent: number;
}

export class EligibleGradeDTO implements IEligibleGradeDTO {
    loanTypeID!: number;
    gradeID!: number;
    gradeName!: string | undefined;

    constructor(data?: IEligibleGradeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loanTypeID = _data["loanTypeID"];
            this.gradeID = _data["gradeID"];
            this.gradeName = _data["gradeName"];
        }
    }

    static fromJS(data: any): EligibleGradeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EligibleGradeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loanTypeID"] = this.loanTypeID;
        data["gradeID"] = this.gradeID;
        data["gradeName"] = this.gradeName;
        return data; 
    }

    clone(): EligibleGradeDTO {
        const json = this.toJSON();
        let result = new EligibleGradeDTO();
        result.init(json);
        return result;
    }
}

export interface IEligibleGradeDTO {
    loanTypeID: number;
    gradeID: number;
    gradeName: string | undefined;
}

export class LoanTypeDTO implements ILoanTypeDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    code!: string | undefined;
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    approvalProcessId!: number;
    interestRate!: number;
    minTenor!: number;
    maxTenor!: number;
    minAmount!: number;
    maxAmount!: number;
    interestType!: number;
    requiresGuarantor!: boolean;
    requiredNoOfGuarantors!: number;
    eligibleGrades!: string | undefined;
    eligibleEmploymentStatus!: number;
    customQuestion!: string | undefined;
    maxLoanRepaytPercent!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    readonly eligibleEmployeeStatus!: string | undefined;
    readonly interestTypeName!: string | undefined;
    eligibleGradeList!: EligibleGradeDTO[] | undefined;

    constructor(data?: ILoanTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.code = _data["code"];
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.interestRate = _data["interestRate"];
            this.minTenor = _data["minTenor"];
            this.maxTenor = _data["maxTenor"];
            this.minAmount = _data["minAmount"];
            this.maxAmount = _data["maxAmount"];
            this.interestType = _data["interestType"];
            this.requiresGuarantor = _data["requiresGuarantor"];
            this.requiredNoOfGuarantors = _data["requiredNoOfGuarantors"];
            this.eligibleGrades = _data["eligibleGrades"];
            this.eligibleEmploymentStatus = _data["eligibleEmploymentStatus"];
            this.customQuestion = _data["customQuestion"];
            this.maxLoanRepaytPercent = _data["maxLoanRepaytPercent"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            (<any>this).eligibleEmployeeStatus = _data["eligibleEmployeeStatus"];
            (<any>this).interestTypeName = _data["interestTypeName"];
            if (Array.isArray(_data["eligibleGradeList"])) {
                this.eligibleGradeList = [] as any;
                for (let item of _data["eligibleGradeList"])
                    this.eligibleGradeList!.push(EligibleGradeDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LoanTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoanTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["code"] = this.code;
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["approvalProcessId"] = this.approvalProcessId;
        data["interestRate"] = this.interestRate;
        data["minTenor"] = this.minTenor;
        data["maxTenor"] = this.maxTenor;
        data["minAmount"] = this.minAmount;
        data["maxAmount"] = this.maxAmount;
        data["interestType"] = this.interestType;
        data["requiresGuarantor"] = this.requiresGuarantor;
        data["requiredNoOfGuarantors"] = this.requiredNoOfGuarantors;
        data["eligibleGrades"] = this.eligibleGrades;
        data["eligibleEmploymentStatus"] = this.eligibleEmploymentStatus;
        data["customQuestion"] = this.customQuestion;
        data["maxLoanRepaytPercent"] = this.maxLoanRepaytPercent;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["eligibleEmployeeStatus"] = this.eligibleEmployeeStatus;
        data["interestTypeName"] = this.interestTypeName;
        if (Array.isArray(this.eligibleGradeList)) {
            data["eligibleGradeList"] = [];
            for (let item of this.eligibleGradeList)
                data["eligibleGradeList"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LoanTypeDTO {
        const json = this.toJSON();
        let result = new LoanTypeDTO();
        result.init(json);
        return result;
    }
}

export interface ILoanTypeDTO {
    id: number;
    companyID: number;
    subID: number;
    code: string | undefined;
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    approvalProcessId: number;
    interestRate: number;
    minTenor: number;
    maxTenor: number;
    minAmount: number;
    maxAmount: number;
    interestType: number;
    requiresGuarantor: boolean;
    requiredNoOfGuarantors: number;
    eligibleGrades: string | undefined;
    eligibleEmploymentStatus: number;
    customQuestion: string | undefined;
    maxLoanRepaytPercent: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    eligibleEmployeeStatus: string | undefined;
    interestTypeName: string | undefined;
    eligibleGradeList: EligibleGradeDTO[] | undefined;
}

export class LoanTypeDTOIListApiResult implements ILoanTypeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanTypeDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILoanTypeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LoanTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LoanTypeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanTypeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LoanTypeDTOIListApiResult {
        const json = this.toJSON();
        let result = new LoanTypeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanTypeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanTypeDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class LoanType implements ILoanType {
    code!: string | undefined;
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    approvalProcessId!: number;
    interestRate!: number;
    minTenor!: number;
    maxTenor!: number;
    minAmount!: number;
    maxAmount!: number;
    interestType!: number;
    requiresGuarantor!: boolean;
    requiredNoOfGuarantors!: number;
    eligibleGrades!: string | undefined;
    eligibleEmploymentStatus!: number;
    customQuestion!: string | undefined;
    maxLoanRepaytPercent!: number;
    strMinAmount!: string | undefined;
    strMaxAmount!: string | undefined;
    strRequiresGuarantor!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILoanType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.interestRate = _data["interestRate"];
            this.minTenor = _data["minTenor"];
            this.maxTenor = _data["maxTenor"];
            this.minAmount = _data["minAmount"];
            this.maxAmount = _data["maxAmount"];
            this.interestType = _data["interestType"];
            this.requiresGuarantor = _data["requiresGuarantor"];
            this.requiredNoOfGuarantors = _data["requiredNoOfGuarantors"];
            this.eligibleGrades = _data["eligibleGrades"];
            this.eligibleEmploymentStatus = _data["eligibleEmploymentStatus"];
            this.customQuestion = _data["customQuestion"];
            this.maxLoanRepaytPercent = _data["maxLoanRepaytPercent"];
            this.strMinAmount = _data["strMinAmount"];
            this.strMaxAmount = _data["strMaxAmount"];
            this.strRequiresGuarantor = _data["strRequiresGuarantor"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LoanType {
        data = typeof data === 'object' ? data : {};
        let result = new LoanType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["approvalProcessId"] = this.approvalProcessId;
        data["interestRate"] = this.interestRate;
        data["minTenor"] = this.minTenor;
        data["maxTenor"] = this.maxTenor;
        data["minAmount"] = this.minAmount;
        data["maxAmount"] = this.maxAmount;
        data["interestType"] = this.interestType;
        data["requiresGuarantor"] = this.requiresGuarantor;
        data["requiredNoOfGuarantors"] = this.requiredNoOfGuarantors;
        data["eligibleGrades"] = this.eligibleGrades;
        data["eligibleEmploymentStatus"] = this.eligibleEmploymentStatus;
        data["customQuestion"] = this.customQuestion;
        data["maxLoanRepaytPercent"] = this.maxLoanRepaytPercent;
        data["strMinAmount"] = this.strMinAmount;
        data["strMaxAmount"] = this.strMaxAmount;
        data["strRequiresGuarantor"] = this.strRequiresGuarantor;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LoanType {
        const json = this.toJSON();
        let result = new LoanType();
        result.init(json);
        return result;
    }
}

export interface ILoanType {
    code: string | undefined;
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    approvalProcessId: number;
    interestRate: number;
    minTenor: number;
    maxTenor: number;
    minAmount: number;
    maxAmount: number;
    interestType: number;
    requiresGuarantor: boolean;
    requiredNoOfGuarantors: number;
    eligibleGrades: string | undefined;
    eligibleEmploymentStatus: number;
    customQuestion: string | undefined;
    maxLoanRepaytPercent: number;
    strMinAmount: string | undefined;
    strMaxAmount: string | undefined;
    strRequiresGuarantor: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LoanTypeIListApiResult implements ILoanTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanType[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILoanTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LoanType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LoanTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LoanTypeIListApiResult {
        const json = this.toJSON();
        let result = new LoanTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanType[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ManageLocationDTO implements IManageLocationDTO {
    id!: number;
    location_name!: string;
    state_id!: number;
    lga_id!: number;
    is_enabled!: boolean;

    constructor(data?: IManageLocationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.location_name = _data["location_name"];
            this.state_id = _data["state_id"];
            this.lga_id = _data["lga_id"];
            this.is_enabled = _data["is_enabled"];
        }
    }

    static fromJS(data: any): ManageLocationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageLocationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["location_name"] = this.location_name;
        data["state_id"] = this.state_id;
        data["lga_id"] = this.lga_id;
        data["is_enabled"] = this.is_enabled;
        return data; 
    }

    clone(): ManageLocationDTO {
        const json = this.toJSON();
        let result = new ManageLocationDTO();
        result.init(json);
        return result;
    }
}

export interface IManageLocationDTO {
    id: number;
    location_name: string;
    state_id: number;
    lga_id: number;
    is_enabled: boolean;
}

export class LocationDTO implements ILocationDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    location_name!: string | undefined;
    lga_id!: number | undefined;
    state_id!: number | undefined;
    lga!: string | undefined;
    state!: string | undefined;
    is_enabled!: boolean;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILocationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.location_name = _data["location_name"];
            this.lga_id = _data["lga_id"];
            this.state_id = _data["state_id"];
            this.lga = _data["lga"];
            this.state = _data["state"];
            this.is_enabled = _data["is_enabled"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LocationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["location_name"] = this.location_name;
        data["lga_id"] = this.lga_id;
        data["state_id"] = this.state_id;
        data["lga"] = this.lga;
        data["state"] = this.state;
        data["is_enabled"] = this.is_enabled;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LocationDTO {
        const json = this.toJSON();
        let result = new LocationDTO();
        result.init(json);
        return result;
    }
}

export interface ILocationDTO {
    id: number;
    companyID: number;
    subID: number;
    location_name: string | undefined;
    lga_id: number | undefined;
    state_id: number | undefined;
    lga: string | undefined;
    state: string | undefined;
    is_enabled: boolean;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LocationDTOListApiResult implements ILocationDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LocationDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILocationDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LocationDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LocationDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LocationDTOListApiResult {
        const json = this.toJSON();
        let result = new LocationDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILocationDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LocationDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class LocationDTOApiResult implements ILocationDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LocationDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ILocationDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LocationDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): LocationDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): LocationDTOApiResult {
        const json = this.toJSON();
        let result = new LocationDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ILocationDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LocationDTO;
    totalCount: number;
    totalRecord: number;
}

export class DepartmentManPowerActivityDTO implements IDepartmentManPowerActivityDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    departmentActivityId!: number;
    activityTypeId!: number;
    activityApprovedBy!: number | undefined;
    activityApprovedByName!: string | undefined;
    activityApprovedByDate!: Date | undefined;
    headofDepartmentName!: string | undefined;
    departmentId!: number;
    jobCategoryName!: string | undefined;
    departmentName!: string | undefined;
    activityName!: string | undefined;
    jobRoleId!: number | undefined;
    jobRoleName!: string | undefined;
    postionId!: number | undefined;
    positionName!: string | undefined;
    gradeId!: number | undefined;
    gradeName!: string | undefined;
    numberOfResource!: number;
    approvedResource!: number;
    costPerResource!: number;
    hrComment!: string | undefined;
    decision!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    status!: number;
    loggedByUserId!: number;
    loggedByUserName!: string | undefined;
    approvedBy!: number | undefined;
    approvedByName!: string | undefined;
    requirment!: string | undefined;
    apporvedDate!: Date | undefined;
    readonly statusName!: string | undefined;
    readonly activityTypeName!: string | undefined;

    constructor(data?: IDepartmentManPowerActivityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.departmentActivityId = _data["departmentActivityId"];
            this.activityTypeId = _data["activityTypeId"];
            this.activityApprovedBy = _data["activityApprovedBy"];
            this.activityApprovedByName = _data["activityApprovedByName"];
            this.activityApprovedByDate = _data["activityApprovedByDate"] ? new Date(_data["activityApprovedByDate"].toString()) : <any>undefined;
            this.headofDepartmentName = _data["headofDepartmentName"];
            this.departmentId = _data["departmentId"];
            this.jobCategoryName = _data["jobCategoryName"];
            this.departmentName = _data["departmentName"];
            this.activityName = _data["activityName"];
            this.jobRoleId = _data["jobRoleId"];
            this.jobRoleName = _data["jobRoleName"];
            this.postionId = _data["postionId"];
            this.positionName = _data["positionName"];
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.numberOfResource = _data["numberOfResource"];
            this.approvedResource = _data["approvedResource"];
            this.costPerResource = _data["costPerResource"];
            this.hrComment = _data["hrComment"];
            this.decision = _data["decision"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.status = _data["status"];
            this.loggedByUserId = _data["loggedByUserId"];
            this.loggedByUserName = _data["loggedByUserName"];
            this.approvedBy = _data["approvedBy"];
            this.approvedByName = _data["approvedByName"];
            this.requirment = _data["requirment"];
            this.apporvedDate = _data["apporvedDate"] ? new Date(_data["apporvedDate"].toString()) : <any>undefined;
            (<any>this).statusName = _data["statusName"];
            (<any>this).activityTypeName = _data["activityTypeName"];
        }
    }

    static fromJS(data: any): DepartmentManPowerActivityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentManPowerActivityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["departmentActivityId"] = this.departmentActivityId;
        data["activityTypeId"] = this.activityTypeId;
        data["activityApprovedBy"] = this.activityApprovedBy;
        data["activityApprovedByName"] = this.activityApprovedByName;
        data["activityApprovedByDate"] = this.activityApprovedByDate ? this.activityApprovedByDate.toISOString() : <any>undefined;
        data["headofDepartmentName"] = this.headofDepartmentName;
        data["departmentId"] = this.departmentId;
        data["jobCategoryName"] = this.jobCategoryName;
        data["departmentName"] = this.departmentName;
        data["activityName"] = this.activityName;
        data["jobRoleId"] = this.jobRoleId;
        data["jobRoleName"] = this.jobRoleName;
        data["postionId"] = this.postionId;
        data["positionName"] = this.positionName;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["numberOfResource"] = this.numberOfResource;
        data["approvedResource"] = this.approvedResource;
        data["costPerResource"] = this.costPerResource;
        data["hrComment"] = this.hrComment;
        data["decision"] = this.decision;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["status"] = this.status;
        data["loggedByUserId"] = this.loggedByUserId;
        data["loggedByUserName"] = this.loggedByUserName;
        data["approvedBy"] = this.approvedBy;
        data["approvedByName"] = this.approvedByName;
        data["requirment"] = this.requirment;
        data["apporvedDate"] = this.apporvedDate ? this.apporvedDate.toISOString() : <any>undefined;
        data["statusName"] = this.statusName;
        data["activityTypeName"] = this.activityTypeName;
        return data; 
    }

    clone(): DepartmentManPowerActivityDTO {
        const json = this.toJSON();
        let result = new DepartmentManPowerActivityDTO();
        result.init(json);
        return result;
    }
}

export interface IDepartmentManPowerActivityDTO {
    id: number;
    companyID: number;
    subID: number;
    departmentActivityId: number;
    activityTypeId: number;
    activityApprovedBy: number | undefined;
    activityApprovedByName: string | undefined;
    activityApprovedByDate: Date | undefined;
    headofDepartmentName: string | undefined;
    departmentId: number;
    jobCategoryName: string | undefined;
    departmentName: string | undefined;
    activityName: string | undefined;
    jobRoleId: number | undefined;
    jobRoleName: string | undefined;
    postionId: number | undefined;
    positionName: string | undefined;
    gradeId: number | undefined;
    gradeName: string | undefined;
    numberOfResource: number;
    approvedResource: number;
    costPerResource: number;
    hrComment: string | undefined;
    decision: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    status: number;
    loggedByUserId: number;
    loggedByUserName: string | undefined;
    approvedBy: number | undefined;
    approvedByName: string | undefined;
    requirment: string | undefined;
    apporvedDate: Date | undefined;
    statusName: string | undefined;
    activityTypeName: string | undefined;
}

export class DepartmentActivityDTO implements IDepartmentActivityDTO {
    id!: number;
    companyID!: number;
    activityTypeId!: number;
    departmentId!: number;
    departmentName!: string | undefined;
    activityName!: string;
    description!: string;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    year!: number;
    baseYear!: number;
    projectYear!: number;
    totalResourceRequested!: number;
    totalReviewResource!: number;
    hrComment!: string | undefined;
    decision!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    status!: number;
    loggedByUserId!: number;
    loggedByUserName!: string | undefined;
    approvedBy!: number | undefined;
    approvedByName!: string | undefined;
    apporvedDate!: Date | undefined;
    readonly statusName!: string | undefined;
    readonly activityTypeName!: string | undefined;
    stringDepartmentManPowerActivity!: string | undefined;
    requirements!: DepartmentManPowerActivityDTO[] | undefined;

    constructor(data?: IDepartmentActivityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.activityTypeId = _data["activityTypeId"];
            this.departmentId = _data["departmentId"];
            this.departmentName = _data["departmentName"];
            this.activityName = _data["activityName"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.year = _data["year"];
            this.baseYear = _data["baseYear"];
            this.projectYear = _data["projectYear"];
            this.totalResourceRequested = _data["totalResourceRequested"];
            this.totalReviewResource = _data["totalReviewResource"];
            this.hrComment = _data["hrComment"];
            this.decision = _data["decision"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.status = _data["status"];
            this.loggedByUserId = _data["loggedByUserId"];
            this.loggedByUserName = _data["loggedByUserName"];
            this.approvedBy = _data["approvedBy"];
            this.approvedByName = _data["approvedByName"];
            this.apporvedDate = _data["apporvedDate"] ? new Date(_data["apporvedDate"].toString()) : <any>undefined;
            (<any>this).statusName = _data["statusName"];
            (<any>this).activityTypeName = _data["activityTypeName"];
            this.stringDepartmentManPowerActivity = _data["stringDepartmentManPowerActivity"];
            if (Array.isArray(_data["requirements"])) {
                this.requirements = [] as any;
                for (let item of _data["requirements"])
                    this.requirements!.push(DepartmentManPowerActivityDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DepartmentActivityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentActivityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["activityTypeId"] = this.activityTypeId;
        data["departmentId"] = this.departmentId;
        data["departmentName"] = this.departmentName;
        data["activityName"] = this.activityName;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["year"] = this.year;
        data["baseYear"] = this.baseYear;
        data["projectYear"] = this.projectYear;
        data["totalResourceRequested"] = this.totalResourceRequested;
        data["totalReviewResource"] = this.totalReviewResource;
        data["hrComment"] = this.hrComment;
        data["decision"] = this.decision;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["status"] = this.status;
        data["loggedByUserId"] = this.loggedByUserId;
        data["loggedByUserName"] = this.loggedByUserName;
        data["approvedBy"] = this.approvedBy;
        data["approvedByName"] = this.approvedByName;
        data["apporvedDate"] = this.apporvedDate ? this.apporvedDate.toISOString() : <any>undefined;
        data["statusName"] = this.statusName;
        data["activityTypeName"] = this.activityTypeName;
        data["stringDepartmentManPowerActivity"] = this.stringDepartmentManPowerActivity;
        if (Array.isArray(this.requirements)) {
            data["requirements"] = [];
            for (let item of this.requirements)
                data["requirements"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DepartmentActivityDTO {
        const json = this.toJSON();
        let result = new DepartmentActivityDTO();
        result.init(json);
        return result;
    }
}

export interface IDepartmentActivityDTO {
    id: number;
    companyID: number;
    activityTypeId: number;
    departmentId: number;
    departmentName: string | undefined;
    activityName: string;
    description: string;
    startDate: Date | undefined;
    endDate: Date | undefined;
    year: number;
    baseYear: number;
    projectYear: number;
    totalResourceRequested: number;
    totalReviewResource: number;
    hrComment: string | undefined;
    decision: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    status: number;
    loggedByUserId: number;
    loggedByUserName: string | undefined;
    approvedBy: number | undefined;
    approvedByName: string | undefined;
    apporvedDate: Date | undefined;
    statusName: string | undefined;
    activityTypeName: string | undefined;
    stringDepartmentManPowerActivity: string | undefined;
    requirements: DepartmentManPowerActivityDTO[] | undefined;
}

export class DepartmentManPowerActivityDTOListApiResult implements IDepartmentManPowerActivityDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DepartmentManPowerActivityDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDepartmentManPowerActivityDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DepartmentManPowerActivityDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DepartmentManPowerActivityDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentManPowerActivityDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DepartmentManPowerActivityDTOListApiResult {
        const json = this.toJSON();
        let result = new DepartmentManPowerActivityDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDepartmentManPowerActivityDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DepartmentManPowerActivityDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class BaseYearJobRoleDTO implements IBaseYearJobRoleDTO {
    roleId!: number;
    roleName!: string | undefined;
    roleCount!: number;
    roleCost!: number;

    constructor(data?: IBaseYearJobRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleCount = _data["roleCount"];
            this.roleCost = _data["roleCost"];
        }
    }

    static fromJS(data: any): BaseYearJobRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BaseYearJobRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleCount"] = this.roleCount;
        data["roleCost"] = this.roleCost;
        return data; 
    }

    clone(): BaseYearJobRoleDTO {
        const json = this.toJSON();
        let result = new BaseYearJobRoleDTO();
        result.init(json);
        return result;
    }
}

export interface IBaseYearJobRoleDTO {
    roleId: number;
    roleName: string | undefined;
    roleCount: number;
    roleCost: number;
}

export class BaseYearPositionDTO implements IBaseYearPositionDTO {
    positionId!: number;
    positionName!: string | undefined;
    positionCount!: number;
    positionCost!: number;

    constructor(data?: IBaseYearPositionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.positionId = _data["positionId"];
            this.positionName = _data["positionName"];
            this.positionCount = _data["positionCount"];
            this.positionCost = _data["positionCost"];
        }
    }

    static fromJS(data: any): BaseYearPositionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BaseYearPositionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["positionId"] = this.positionId;
        data["positionName"] = this.positionName;
        data["positionCount"] = this.positionCount;
        data["positionCost"] = this.positionCost;
        return data; 
    }

    clone(): BaseYearPositionDTO {
        const json = this.toJSON();
        let result = new BaseYearPositionDTO();
        result.init(json);
        return result;
    }
}

export interface IBaseYearPositionDTO {
    positionId: number;
    positionName: string | undefined;
    positionCount: number;
    positionCost: number;
}

export class BaseYearGradeDTO implements IBaseYearGradeDTO {
    gradeId!: number;
    gradeName!: string | undefined;
    gradeCount!: number;
    gradeCost!: number;

    constructor(data?: IBaseYearGradeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.gradeCount = _data["gradeCount"];
            this.gradeCost = _data["gradeCost"];
        }
    }

    static fromJS(data: any): BaseYearGradeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BaseYearGradeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["gradeCount"] = this.gradeCount;
        data["gradeCost"] = this.gradeCost;
        return data; 
    }

    clone(): BaseYearGradeDTO {
        const json = this.toJSON();
        let result = new BaseYearGradeDTO();
        result.init(json);
        return result;
    }
}

export interface IBaseYearGradeDTO {
    gradeId: number;
    gradeName: string | undefined;
    gradeCount: number;
    gradeCost: number;
}

export class BaseYearDTO implements IBaseYearDTO {
    baseYear!: number;
    jobRole!: BaseYearJobRoleDTO[] | undefined;
    position!: BaseYearPositionDTO[] | undefined;
    grade!: BaseYearGradeDTO[] | undefined;

    constructor(data?: IBaseYearDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseYear = _data["baseYear"];
            if (Array.isArray(_data["jobRole"])) {
                this.jobRole = [] as any;
                for (let item of _data["jobRole"])
                    this.jobRole!.push(BaseYearJobRoleDTO.fromJS(item));
            }
            if (Array.isArray(_data["position"])) {
                this.position = [] as any;
                for (let item of _data["position"])
                    this.position!.push(BaseYearPositionDTO.fromJS(item));
            }
            if (Array.isArray(_data["grade"])) {
                this.grade = [] as any;
                for (let item of _data["grade"])
                    this.grade!.push(BaseYearGradeDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaseYearDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BaseYearDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseYear"] = this.baseYear;
        if (Array.isArray(this.jobRole)) {
            data["jobRole"] = [];
            for (let item of this.jobRole)
                data["jobRole"].push(item.toJSON());
        }
        if (Array.isArray(this.position)) {
            data["position"] = [];
            for (let item of this.position)
                data["position"].push(item.toJSON());
        }
        if (Array.isArray(this.grade)) {
            data["grade"] = [];
            for (let item of this.grade)
                data["grade"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BaseYearDTO {
        const json = this.toJSON();
        let result = new BaseYearDTO();
        result.init(json);
        return result;
    }
}

export interface IBaseYearDTO {
    baseYear: number;
    jobRole: BaseYearJobRoleDTO[] | undefined;
    position: BaseYearPositionDTO[] | undefined;
    grade: BaseYearGradeDTO[] | undefined;
}

export class BaseYearDTOListApiResult implements IBaseYearDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: BaseYearDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IBaseYearDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(BaseYearDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): BaseYearDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BaseYearDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): BaseYearDTOListApiResult {
        const json = this.toJSON();
        let result = new BaseYearDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IBaseYearDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: BaseYearDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class DepartmentActivityDTOListApiResult implements IDepartmentActivityDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DepartmentActivityDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDepartmentActivityDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DepartmentActivityDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DepartmentActivityDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentActivityDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DepartmentActivityDTOListApiResult {
        const json = this.toJSON();
        let result = new DepartmentActivityDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDepartmentActivityDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DepartmentActivityDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class DepartmentManPowerActivityDTOIListApiResult implements IDepartmentManPowerActivityDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DepartmentManPowerActivityDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDepartmentManPowerActivityDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DepartmentManPowerActivityDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DepartmentManPowerActivityDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentManPowerActivityDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DepartmentManPowerActivityDTOIListApiResult {
        const json = this.toJSON();
        let result = new DepartmentManPowerActivityDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDepartmentManPowerActivityDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DepartmentManPowerActivityDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class DepartmentActivityDTOIListApiResult implements IDepartmentActivityDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DepartmentActivityDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDepartmentActivityDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DepartmentActivityDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DepartmentActivityDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentActivityDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DepartmentActivityDTOIListApiResult {
        const json = this.toJSON();
        let result = new DepartmentActivityDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDepartmentActivityDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DepartmentActivityDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class OfferLetterTemplateDTO implements IOfferLetterTemplateDTO {
    id!: number;
    offerTitle!: string | undefined;
    offerContent!: string | undefined;
    signatoryName!: string | undefined;
    signatoryTitle!: string | undefined;
    signatureFileName!: string | undefined;

    constructor(data?: IOfferLetterTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.offerTitle = _data["offerTitle"];
            this.offerContent = _data["offerContent"];
            this.signatoryName = _data["signatoryName"];
            this.signatoryTitle = _data["signatoryTitle"];
            this.signatureFileName = _data["signatureFileName"];
        }
    }

    static fromJS(data: any): OfferLetterTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OfferLetterTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["offerTitle"] = this.offerTitle;
        data["offerContent"] = this.offerContent;
        data["signatoryName"] = this.signatoryName;
        data["signatoryTitle"] = this.signatoryTitle;
        data["signatureFileName"] = this.signatureFileName;
        return data; 
    }

    clone(): OfferLetterTemplateDTO {
        const json = this.toJSON();
        let result = new OfferLetterTemplateDTO();
        result.init(json);
        return result;
    }
}

export interface IOfferLetterTemplateDTO {
    id: number;
    offerTitle: string | undefined;
    offerContent: string | undefined;
    signatoryName: string | undefined;
    signatoryTitle: string | undefined;
    signatureFileName: string | undefined;
}

export class PrepareOfferLetterDTO implements IPrepareOfferLetterDTO {
    messageContent!: string | undefined;
    receiverEmail!: string | undefined;
    fullName!: string | undefined;
    message!: string | undefined;
    isSuccessful!: boolean;
    firstName!: string | undefined;
    lastName!: string | undefined;
    hireDate!: Date;
    reportingTo!: string | undefined;
    expiredDate!: Date;
    companyName!: string | undefined;
    signatureFilePath!: string | undefined;
    signatureName!: string | undefined;
    offerTitle!: string | undefined;
    emailSubject!: string | undefined;
    offerLetterContent!: string | undefined;
    signatureFileName!: string | undefined;
    offerLetterId!: number;
    expireDate!: Date | undefined;

    constructor(data?: IPrepareOfferLetterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.messageContent = _data["messageContent"];
            this.receiverEmail = _data["receiverEmail"];
            this.fullName = _data["fullName"];
            this.message = _data["message"];
            this.isSuccessful = _data["isSuccessful"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.hireDate = _data["hireDate"] ? new Date(_data["hireDate"].toString()) : <any>undefined;
            this.reportingTo = _data["reportingTo"];
            this.expiredDate = _data["expiredDate"] ? new Date(_data["expiredDate"].toString()) : <any>undefined;
            this.companyName = _data["companyName"];
            this.signatureFilePath = _data["signatureFilePath"];
            this.signatureName = _data["signatureName"];
            this.offerTitle = _data["offerTitle"];
            this.emailSubject = _data["emailSubject"];
            this.offerLetterContent = _data["offerLetterContent"];
            this.signatureFileName = _data["signatureFileName"];
            this.offerLetterId = _data["offerLetterId"];
            this.expireDate = _data["expireDate"] ? new Date(_data["expireDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PrepareOfferLetterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PrepareOfferLetterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageContent"] = this.messageContent;
        data["receiverEmail"] = this.receiverEmail;
        data["fullName"] = this.fullName;
        data["message"] = this.message;
        data["isSuccessful"] = this.isSuccessful;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["hireDate"] = this.hireDate ? this.hireDate.toISOString() : <any>undefined;
        data["reportingTo"] = this.reportingTo;
        data["expiredDate"] = this.expiredDate ? this.expiredDate.toISOString() : <any>undefined;
        data["companyName"] = this.companyName;
        data["signatureFilePath"] = this.signatureFilePath;
        data["signatureName"] = this.signatureName;
        data["offerTitle"] = this.offerTitle;
        data["emailSubject"] = this.emailSubject;
        data["offerLetterContent"] = this.offerLetterContent;
        data["signatureFileName"] = this.signatureFileName;
        data["offerLetterId"] = this.offerLetterId;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): PrepareOfferLetterDTO {
        const json = this.toJSON();
        let result = new PrepareOfferLetterDTO();
        result.init(json);
        return result;
    }
}

export interface IPrepareOfferLetterDTO {
    messageContent: string | undefined;
    receiverEmail: string | undefined;
    fullName: string | undefined;
    message: string | undefined;
    isSuccessful: boolean;
    firstName: string | undefined;
    lastName: string | undefined;
    hireDate: Date;
    reportingTo: string | undefined;
    expiredDate: Date;
    companyName: string | undefined;
    signatureFilePath: string | undefined;
    signatureName: string | undefined;
    offerTitle: string | undefined;
    emailSubject: string | undefined;
    offerLetterContent: string | undefined;
    signatureFileName: string | undefined;
    offerLetterId: number;
    expireDate: Date | undefined;
}

export class PrepareOfferLetterDTOApiResult implements IPrepareOfferLetterDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PrepareOfferLetterDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPrepareOfferLetterDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? PrepareOfferLetterDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PrepareOfferLetterDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PrepareOfferLetterDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PrepareOfferLetterDTOApiResult {
        const json = this.toJSON();
        let result = new PrepareOfferLetterDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IPrepareOfferLetterDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PrepareOfferLetterDTO;
    totalCount: number;
    totalRecord: number;
}

export class OnboardingPersonalDTO implements IOnboardingPersonalDTO {
    id!: number;
    companyId!: number;
    subID!: number;
    titleId!: number;
    firstName!: string;
    lastName!: string;
    otherNames!: string | undefined;
    phoneNumber!: string | undefined;
    dateOfBirth!: Date;
    maritalStatusId!: number;
    genderId!: number;
    residentialAddress!: string | undefined;
    personalEmail!: string;
    defaultMobile!: string;
    religionId!: number;
    martialStatusId!: number | undefined;
    fieldOfStudy!: string;
    degree!: string;
    dateofCompletion!: Date;
    cgpa!: string | undefined;
    institutionId!: number | undefined;
    nextOfKinFullName!: string | undefined;
    netofKinRelationship!: string | undefined;
    nextofKinPhoneNumber!: string | undefined;
    nextofKinAddress!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    userId!: number;
    created_by!: string | undefined;
    countryId!: number;
    stateId!: number;
    regionId!: number;

    constructor(data?: IOnboardingPersonalDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.subID = _data["subID"];
            this.titleId = _data["titleId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherNames = _data["otherNames"];
            this.phoneNumber = _data["phoneNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.maritalStatusId = _data["maritalStatusId"];
            this.genderId = _data["genderId"];
            this.residentialAddress = _data["residentialAddress"];
            this.personalEmail = _data["personalEmail"];
            this.defaultMobile = _data["defaultMobile"];
            this.religionId = _data["religionId"];
            this.martialStatusId = _data["martialStatusId"];
            this.fieldOfStudy = _data["fieldOfStudy"];
            this.degree = _data["degree"];
            this.dateofCompletion = _data["dateofCompletion"] ? new Date(_data["dateofCompletion"].toString()) : <any>undefined;
            this.cgpa = _data["cgpa"];
            this.institutionId = _data["institutionId"];
            this.nextOfKinFullName = _data["nextOfKinFullName"];
            this.netofKinRelationship = _data["netofKinRelationship"];
            this.nextofKinPhoneNumber = _data["nextofKinPhoneNumber"];
            this.nextofKinAddress = _data["nextofKinAddress"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.userId = _data["userId"];
            this.created_by = _data["created_by"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.regionId = _data["regionId"];
        }
    }

    static fromJS(data: any): OnboardingPersonalDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingPersonalDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["subID"] = this.subID;
        data["titleId"] = this.titleId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherNames"] = this.otherNames;
        data["phoneNumber"] = this.phoneNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["maritalStatusId"] = this.maritalStatusId;
        data["genderId"] = this.genderId;
        data["residentialAddress"] = this.residentialAddress;
        data["personalEmail"] = this.personalEmail;
        data["defaultMobile"] = this.defaultMobile;
        data["religionId"] = this.religionId;
        data["martialStatusId"] = this.martialStatusId;
        data["fieldOfStudy"] = this.fieldOfStudy;
        data["degree"] = this.degree;
        data["dateofCompletion"] = this.dateofCompletion ? this.dateofCompletion.toISOString() : <any>undefined;
        data["cgpa"] = this.cgpa;
        data["institutionId"] = this.institutionId;
        data["nextOfKinFullName"] = this.nextOfKinFullName;
        data["netofKinRelationship"] = this.netofKinRelationship;
        data["nextofKinPhoneNumber"] = this.nextofKinPhoneNumber;
        data["nextofKinAddress"] = this.nextofKinAddress;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["userId"] = this.userId;
        data["created_by"] = this.created_by;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["regionId"] = this.regionId;
        return data; 
    }

    clone(): OnboardingPersonalDTO {
        const json = this.toJSON();
        let result = new OnboardingPersonalDTO();
        result.init(json);
        return result;
    }
}

export interface IOnboardingPersonalDTO {
    id: number;
    companyId: number;
    subID: number;
    titleId: number;
    firstName: string;
    lastName: string;
    otherNames: string | undefined;
    phoneNumber: string | undefined;
    dateOfBirth: Date;
    maritalStatusId: number;
    genderId: number;
    residentialAddress: string | undefined;
    personalEmail: string;
    defaultMobile: string;
    religionId: number;
    martialStatusId: number | undefined;
    fieldOfStudy: string;
    degree: string;
    dateofCompletion: Date;
    cgpa: string | undefined;
    institutionId: number | undefined;
    nextOfKinFullName: string | undefined;
    netofKinRelationship: string | undefined;
    nextofKinPhoneNumber: string | undefined;
    nextofKinAddress: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    userId: number;
    created_by: string | undefined;
    countryId: number;
    stateId: number;
    regionId: number;
}

export class OnboardingBankDTO implements IOnboardingBankDTO {
    id!: number;
    companyId!: number;
    subID!: number;
    onboardingId!: number;
    bankNameId!: number;
    accountName!: string;
    accountNumber!: string;
    accountTypeId!: number;
    paymentMethodId!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    userId!: number;
    bvn!: string | undefined;
    fullName!: string | undefined;
    dialingCode!: string | undefined;
    created_by!: string | undefined;

    constructor(data?: IOnboardingBankDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.subID = _data["subID"];
            this.onboardingId = _data["onboardingId"];
            this.bankNameId = _data["bankNameId"];
            this.accountName = _data["accountName"];
            this.accountNumber = _data["accountNumber"];
            this.accountTypeId = _data["accountTypeId"];
            this.paymentMethodId = _data["paymentMethodId"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.userId = _data["userId"];
            this.bvn = _data["bvn"];
            this.fullName = _data["fullName"];
            this.dialingCode = _data["dialingCode"];
            this.created_by = _data["created_by"];
        }
    }

    static fromJS(data: any): OnboardingBankDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingBankDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["subID"] = this.subID;
        data["onboardingId"] = this.onboardingId;
        data["bankNameId"] = this.bankNameId;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["accountTypeId"] = this.accountTypeId;
        data["paymentMethodId"] = this.paymentMethodId;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["userId"] = this.userId;
        data["bvn"] = this.bvn;
        data["fullName"] = this.fullName;
        data["dialingCode"] = this.dialingCode;
        data["created_by"] = this.created_by;
        return data; 
    }

    clone(): OnboardingBankDTO {
        const json = this.toJSON();
        let result = new OnboardingBankDTO();
        result.init(json);
        return result;
    }
}

export interface IOnboardingBankDTO {
    id: number;
    companyId: number;
    subID: number;
    onboardingId: number;
    bankNameId: number;
    accountName: string;
    accountNumber: string;
    accountTypeId: number;
    paymentMethodId: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    userId: number;
    bvn: string | undefined;
    fullName: string | undefined;
    dialingCode: string | undefined;
    created_by: string | undefined;
}

export class OnboardingWorkDTO implements IOnboardingWorkDTO {
    id!: number;
    companyId!: number;
    subID!: number;
    onboardingId!: number;
    hireDate!: Date;
    dateofJoining!: Date;
    salaryPerAnnum!: number;
    desginationId!: number;
    employeeTypeId!: number;
    departmentId!: number;
    reportingManagerId!: number;
    location!: string | undefined;
    workEmail!: string;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    userId!: number;
    created_by!: string | undefined;
    linkExpireDate!: Date;

    constructor(data?: IOnboardingWorkDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.subID = _data["subID"];
            this.onboardingId = _data["onboardingId"];
            this.hireDate = _data["hireDate"] ? new Date(_data["hireDate"].toString()) : <any>undefined;
            this.dateofJoining = _data["dateofJoining"] ? new Date(_data["dateofJoining"].toString()) : <any>undefined;
            this.salaryPerAnnum = _data["salaryPerAnnum"];
            this.desginationId = _data["desginationId"];
            this.employeeTypeId = _data["employeeTypeId"];
            this.departmentId = _data["departmentId"];
            this.reportingManagerId = _data["reportingManagerId"];
            this.location = _data["location"];
            this.workEmail = _data["workEmail"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.userId = _data["userId"];
            this.created_by = _data["created_by"];
            this.linkExpireDate = _data["linkExpireDate"] ? new Date(_data["linkExpireDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OnboardingWorkDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingWorkDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["subID"] = this.subID;
        data["onboardingId"] = this.onboardingId;
        data["hireDate"] = this.hireDate ? this.hireDate.toISOString() : <any>undefined;
        data["dateofJoining"] = this.dateofJoining ? this.dateofJoining.toISOString() : <any>undefined;
        data["salaryPerAnnum"] = this.salaryPerAnnum;
        data["desginationId"] = this.desginationId;
        data["employeeTypeId"] = this.employeeTypeId;
        data["departmentId"] = this.departmentId;
        data["reportingManagerId"] = this.reportingManagerId;
        data["location"] = this.location;
        data["workEmail"] = this.workEmail;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["userId"] = this.userId;
        data["created_by"] = this.created_by;
        data["linkExpireDate"] = this.linkExpireDate ? this.linkExpireDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): OnboardingWorkDTO {
        const json = this.toJSON();
        let result = new OnboardingWorkDTO();
        result.init(json);
        return result;
    }
}

export interface IOnboardingWorkDTO {
    id: number;
    companyId: number;
    subID: number;
    onboardingId: number;
    hireDate: Date;
    dateofJoining: Date;
    salaryPerAnnum: number;
    desginationId: number;
    employeeTypeId: number;
    departmentId: number;
    reportingManagerId: number;
    location: string | undefined;
    workEmail: string;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    userId: number;
    created_by: string | undefined;
    linkExpireDate: Date;
}

export class OnboardingTaxDTO implements IOnboardingTaxDTO {
    id!: number;
    companyId!: number;
    subID!: number;
    onboardingId!: number;
    taxId!: string;
    nationality_Nigeria!: boolean;
    passportNumber!: string | undefined;
    passportExpiryDate!: Date;
    countryId!: number;
    visaTypeId!: number;
    visaExpiryDate!: Date;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dialingCode!: string | undefined;
    created_by!: string | undefined;

    constructor(data?: IOnboardingTaxDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.subID = _data["subID"];
            this.onboardingId = _data["onboardingId"];
            this.taxId = _data["taxId"];
            this.nationality_Nigeria = _data["nationality_Nigeria"];
            this.passportNumber = _data["passportNumber"];
            this.passportExpiryDate = _data["passportExpiryDate"] ? new Date(_data["passportExpiryDate"].toString()) : <any>undefined;
            this.countryId = _data["countryId"];
            this.visaTypeId = _data["visaTypeId"];
            this.visaExpiryDate = _data["visaExpiryDate"] ? new Date(_data["visaExpiryDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dialingCode = _data["dialingCode"];
            this.created_by = _data["created_by"];
        }
    }

    static fromJS(data: any): OnboardingTaxDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingTaxDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["subID"] = this.subID;
        data["onboardingId"] = this.onboardingId;
        data["taxId"] = this.taxId;
        data["nationality_Nigeria"] = this.nationality_Nigeria;
        data["passportNumber"] = this.passportNumber;
        data["passportExpiryDate"] = this.passportExpiryDate ? this.passportExpiryDate.toISOString() : <any>undefined;
        data["countryId"] = this.countryId;
        data["visaTypeId"] = this.visaTypeId;
        data["visaExpiryDate"] = this.visaExpiryDate ? this.visaExpiryDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dialingCode"] = this.dialingCode;
        data["created_by"] = this.created_by;
        return data; 
    }

    clone(): OnboardingTaxDTO {
        const json = this.toJSON();
        let result = new OnboardingTaxDTO();
        result.init(json);
        return result;
    }
}

export interface IOnboardingTaxDTO {
    id: number;
    companyId: number;
    subID: number;
    onboardingId: number;
    taxId: string;
    nationality_Nigeria: boolean;
    passportNumber: string | undefined;
    passportExpiryDate: Date;
    countryId: number;
    visaTypeId: number;
    visaExpiryDate: Date;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dialingCode: string | undefined;
    created_by: string | undefined;
}

export class OnboardingMedicalDisclosureDTO implements IOnboardingMedicalDisclosureDTO {
    id!: number;
    companyId!: number;
    subID!: number;
    onboardingId!: number;
    genotype!: string;
    bloodGroup!: string;
    anyPreInjury!: boolean;
    statePreInjury!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    userId!: number;
    created_by!: string | undefined;

    constructor(data?: IOnboardingMedicalDisclosureDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.subID = _data["subID"];
            this.onboardingId = _data["onboardingId"];
            this.genotype = _data["genotype"];
            this.bloodGroup = _data["bloodGroup"];
            this.anyPreInjury = _data["anyPreInjury"];
            this.statePreInjury = _data["statePreInjury"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.userId = _data["userId"];
            this.created_by = _data["created_by"];
        }
    }

    static fromJS(data: any): OnboardingMedicalDisclosureDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingMedicalDisclosureDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["subID"] = this.subID;
        data["onboardingId"] = this.onboardingId;
        data["genotype"] = this.genotype;
        data["bloodGroup"] = this.bloodGroup;
        data["anyPreInjury"] = this.anyPreInjury;
        data["statePreInjury"] = this.statePreInjury;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["userId"] = this.userId;
        data["created_by"] = this.created_by;
        return data; 
    }

    clone(): OnboardingMedicalDisclosureDTO {
        const json = this.toJSON();
        let result = new OnboardingMedicalDisclosureDTO();
        result.init(json);
        return result;
    }
}

export interface IOnboardingMedicalDisclosureDTO {
    id: number;
    companyId: number;
    subID: number;
    onboardingId: number;
    genotype: string;
    bloodGroup: string;
    anyPreInjury: boolean;
    statePreInjury: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    userId: number;
    created_by: string | undefined;
}

export class OnboardingPersonalInfo implements IOnboardingPersonalInfo {
    userId!: number;
    titleId!: number;
    firstName!: string | undefined;
    lastName!: string | undefined;
    phoneNumber!: string | undefined;
    dateofBirth!: Date | undefined;
    martialStatus!: number;
    genderId!: number;
    residentialAddress!: string | undefined;
    fieldofStudy!: string | undefined;
    degree!: string | undefined;
    defaultMobile!: string | undefined;
    personalEmail!: string | undefined;
    dateofCompletion!: Date | undefined;
    cgpa!: string | undefined;
    institutionId!: number;
    nextOfKinFullName!: string | undefined;
    netofKinRelationship!: string | undefined;
    nextofKinPhoneNumber!: string | undefined;
    nextofKinAddress!: string | undefined;
    martialStatusId!: number;
    countryId!: number;
    stateId!: number;
    regionId!: number;
    completedOnboarding!: boolean;
    offerId!: number | undefined;
    offerStatus!: boolean;
    replyOfferDate!: Date | undefined;
    offerSentDate!: Date | undefined;
    offerSentBy!: number | undefined;
    country!: Country;
    state!: State;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IOnboardingPersonalInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.titleId = _data["titleId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.dateofBirth = _data["dateofBirth"] ? new Date(_data["dateofBirth"].toString()) : <any>undefined;
            this.martialStatus = _data["martialStatus"];
            this.genderId = _data["genderId"];
            this.residentialAddress = _data["residentialAddress"];
            this.fieldofStudy = _data["fieldofStudy"];
            this.degree = _data["degree"];
            this.defaultMobile = _data["defaultMobile"];
            this.personalEmail = _data["personalEmail"];
            this.dateofCompletion = _data["dateofCompletion"] ? new Date(_data["dateofCompletion"].toString()) : <any>undefined;
            this.cgpa = _data["cgpa"];
            this.institutionId = _data["institutionId"];
            this.nextOfKinFullName = _data["nextOfKinFullName"];
            this.netofKinRelationship = _data["netofKinRelationship"];
            this.nextofKinPhoneNumber = _data["nextofKinPhoneNumber"];
            this.nextofKinAddress = _data["nextofKinAddress"];
            this.martialStatusId = _data["martialStatusId"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.regionId = _data["regionId"];
            this.completedOnboarding = _data["completedOnboarding"];
            this.offerId = _data["offerId"];
            this.offerStatus = _data["offerStatus"];
            this.replyOfferDate = _data["replyOfferDate"] ? new Date(_data["replyOfferDate"].toString()) : <any>undefined;
            this.offerSentDate = _data["offerSentDate"] ? new Date(_data["offerSentDate"].toString()) : <any>undefined;
            this.offerSentBy = _data["offerSentBy"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : <any>undefined;
            this.state = _data["state"] ? State.fromJS(_data["state"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): OnboardingPersonalInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingPersonalInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["titleId"] = this.titleId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["martialStatus"] = this.martialStatus;
        data["genderId"] = this.genderId;
        data["residentialAddress"] = this.residentialAddress;
        data["fieldofStudy"] = this.fieldofStudy;
        data["degree"] = this.degree;
        data["defaultMobile"] = this.defaultMobile;
        data["personalEmail"] = this.personalEmail;
        data["dateofCompletion"] = this.dateofCompletion ? this.dateofCompletion.toISOString() : <any>undefined;
        data["cgpa"] = this.cgpa;
        data["institutionId"] = this.institutionId;
        data["nextOfKinFullName"] = this.nextOfKinFullName;
        data["netofKinRelationship"] = this.netofKinRelationship;
        data["nextofKinPhoneNumber"] = this.nextofKinPhoneNumber;
        data["nextofKinAddress"] = this.nextofKinAddress;
        data["martialStatusId"] = this.martialStatusId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["regionId"] = this.regionId;
        data["completedOnboarding"] = this.completedOnboarding;
        data["offerId"] = this.offerId;
        data["offerStatus"] = this.offerStatus;
        data["replyOfferDate"] = this.replyOfferDate ? this.replyOfferDate.toISOString() : <any>undefined;
        data["offerSentDate"] = this.offerSentDate ? this.offerSentDate.toISOString() : <any>undefined;
        data["offerSentBy"] = this.offerSentBy;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): OnboardingPersonalInfo {
        const json = this.toJSON();
        let result = new OnboardingPersonalInfo();
        result.init(json);
        return result;
    }
}

export interface IOnboardingPersonalInfo {
    userId: number;
    titleId: number;
    firstName: string | undefined;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    dateofBirth: Date | undefined;
    martialStatus: number;
    genderId: number;
    residentialAddress: string | undefined;
    fieldofStudy: string | undefined;
    degree: string | undefined;
    defaultMobile: string | undefined;
    personalEmail: string | undefined;
    dateofCompletion: Date | undefined;
    cgpa: string | undefined;
    institutionId: number;
    nextOfKinFullName: string | undefined;
    netofKinRelationship: string | undefined;
    nextofKinPhoneNumber: string | undefined;
    nextofKinAddress: string | undefined;
    martialStatusId: number;
    countryId: number;
    stateId: number;
    regionId: number;
    completedOnboarding: boolean;
    offerId: number | undefined;
    offerStatus: boolean;
    replyOfferDate: Date | undefined;
    offerSentDate: Date | undefined;
    offerSentBy: number | undefined;
    country: Country;
    state: State;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class OnboardingPersonalInfoApiResult implements IOnboardingPersonalInfoApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: OnboardingPersonalInfo;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IOnboardingPersonalInfoApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? OnboardingPersonalInfo.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): OnboardingPersonalInfoApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingPersonalInfoApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): OnboardingPersonalInfoApiResult {
        const json = this.toJSON();
        let result = new OnboardingPersonalInfoApiResult();
        result.init(json);
        return result;
    }
}

export interface IOnboardingPersonalInfoApiResult {
    hasError: boolean;
    message: string | undefined;
    result: OnboardingPersonalInfo;
    totalCount: number;
    totalRecord: number;
}

export class OnboardingDocumentInfo implements IOnboardingDocumentInfo {
    onboardingId!: number;
    nyscCertificate!: string | undefined;
    birthCertificate!: string | undefined;
    driverLicense!: string | undefined;
    addtionalDocument!: string | undefined;
    passport!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IOnboardingDocumentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onboardingId = _data["onboardingId"];
            this.nyscCertificate = _data["nyscCertificate"];
            this.birthCertificate = _data["birthCertificate"];
            this.driverLicense = _data["driverLicense"];
            this.addtionalDocument = _data["addtionalDocument"];
            this.passport = _data["passport"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): OnboardingDocumentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingDocumentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onboardingId"] = this.onboardingId;
        data["nyscCertificate"] = this.nyscCertificate;
        data["birthCertificate"] = this.birthCertificate;
        data["driverLicense"] = this.driverLicense;
        data["addtionalDocument"] = this.addtionalDocument;
        data["passport"] = this.passport;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): OnboardingDocumentInfo {
        const json = this.toJSON();
        let result = new OnboardingDocumentInfo();
        result.init(json);
        return result;
    }
}

export interface IOnboardingDocumentInfo {
    onboardingId: number;
    nyscCertificate: string | undefined;
    birthCertificate: string | undefined;
    driverLicense: string | undefined;
    addtionalDocument: string | undefined;
    passport: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class OnboardingDocumentInfoApiResult implements IOnboardingDocumentInfoApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: OnboardingDocumentInfo;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IOnboardingDocumentInfoApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? OnboardingDocumentInfo.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): OnboardingDocumentInfoApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingDocumentInfoApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): OnboardingDocumentInfoApiResult {
        const json = this.toJSON();
        let result = new OnboardingDocumentInfoApiResult();
        result.init(json);
        return result;
    }
}

export interface IOnboardingDocumentInfoApiResult {
    hasError: boolean;
    message: string | undefined;
    result: OnboardingDocumentInfo;
    totalCount: number;
    totalRecord: number;
}

export class OnboardingMedicalDisclosureInfo implements IOnboardingMedicalDisclosureInfo {
    onboardingId!: number;
    genotype!: string | undefined;
    bloodGroup!: string | undefined;
    anyPreInjury!: boolean;
    statePreInjury!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IOnboardingMedicalDisclosureInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onboardingId = _data["onboardingId"];
            this.genotype = _data["genotype"];
            this.bloodGroup = _data["bloodGroup"];
            this.anyPreInjury = _data["anyPreInjury"];
            this.statePreInjury = _data["statePreInjury"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): OnboardingMedicalDisclosureInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingMedicalDisclosureInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onboardingId"] = this.onboardingId;
        data["genotype"] = this.genotype;
        data["bloodGroup"] = this.bloodGroup;
        data["anyPreInjury"] = this.anyPreInjury;
        data["statePreInjury"] = this.statePreInjury;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): OnboardingMedicalDisclosureInfo {
        const json = this.toJSON();
        let result = new OnboardingMedicalDisclosureInfo();
        result.init(json);
        return result;
    }
}

export interface IOnboardingMedicalDisclosureInfo {
    onboardingId: number;
    genotype: string | undefined;
    bloodGroup: string | undefined;
    anyPreInjury: boolean;
    statePreInjury: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class OnboardingMedicalDisclosureInfoApiResult implements IOnboardingMedicalDisclosureInfoApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: OnboardingMedicalDisclosureInfo;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IOnboardingMedicalDisclosureInfoApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? OnboardingMedicalDisclosureInfo.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): OnboardingMedicalDisclosureInfoApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingMedicalDisclosureInfoApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): OnboardingMedicalDisclosureInfoApiResult {
        const json = this.toJSON();
        let result = new OnboardingMedicalDisclosureInfoApiResult();
        result.init(json);
        return result;
    }
}

export interface IOnboardingMedicalDisclosureInfoApiResult {
    hasError: boolean;
    message: string | undefined;
    result: OnboardingMedicalDisclosureInfo;
    totalCount: number;
    totalRecord: number;
}

export class OnboardingTaxInfo implements IOnboardingTaxInfo {
    onboardingId!: number;
    taxId!: string | undefined;
    nationality_Nigeria!: boolean;
    passportNumber!: string | undefined;
    passportExpiryDate!: Date;
    countryId!: number;
    visaTypeId!: number;
    visaExpiryDate!: Date;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IOnboardingTaxInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onboardingId = _data["onboardingId"];
            this.taxId = _data["taxId"];
            this.nationality_Nigeria = _data["nationality_Nigeria"];
            this.passportNumber = _data["passportNumber"];
            this.passportExpiryDate = _data["passportExpiryDate"] ? new Date(_data["passportExpiryDate"].toString()) : <any>undefined;
            this.countryId = _data["countryId"];
            this.visaTypeId = _data["visaTypeId"];
            this.visaExpiryDate = _data["visaExpiryDate"] ? new Date(_data["visaExpiryDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): OnboardingTaxInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingTaxInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onboardingId"] = this.onboardingId;
        data["taxId"] = this.taxId;
        data["nationality_Nigeria"] = this.nationality_Nigeria;
        data["passportNumber"] = this.passportNumber;
        data["passportExpiryDate"] = this.passportExpiryDate ? this.passportExpiryDate.toISOString() : <any>undefined;
        data["countryId"] = this.countryId;
        data["visaTypeId"] = this.visaTypeId;
        data["visaExpiryDate"] = this.visaExpiryDate ? this.visaExpiryDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): OnboardingTaxInfo {
        const json = this.toJSON();
        let result = new OnboardingTaxInfo();
        result.init(json);
        return result;
    }
}

export interface IOnboardingTaxInfo {
    onboardingId: number;
    taxId: string | undefined;
    nationality_Nigeria: boolean;
    passportNumber: string | undefined;
    passportExpiryDate: Date;
    countryId: number;
    visaTypeId: number;
    visaExpiryDate: Date;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class OnboardingTaxInfoApiResult implements IOnboardingTaxInfoApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: OnboardingTaxInfo;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IOnboardingTaxInfoApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? OnboardingTaxInfo.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): OnboardingTaxInfoApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingTaxInfoApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): OnboardingTaxInfoApiResult {
        const json = this.toJSON();
        let result = new OnboardingTaxInfoApiResult();
        result.init(json);
        return result;
    }
}

export interface IOnboardingTaxInfoApiResult {
    hasError: boolean;
    message: string | undefined;
    result: OnboardingTaxInfo;
    totalCount: number;
    totalRecord: number;
}

export class OnboardingPaymentInfo implements IOnboardingPaymentInfo {
    onboardingId!: number;
    bankNameId!: number;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    accountTypeId!: number;
    paymentMethodId!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IOnboardingPaymentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onboardingId = _data["onboardingId"];
            this.bankNameId = _data["bankNameId"];
            this.accountName = _data["accountName"];
            this.accountNumber = _data["accountNumber"];
            this.accountTypeId = _data["accountTypeId"];
            this.paymentMethodId = _data["paymentMethodId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): OnboardingPaymentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingPaymentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onboardingId"] = this.onboardingId;
        data["bankNameId"] = this.bankNameId;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["accountTypeId"] = this.accountTypeId;
        data["paymentMethodId"] = this.paymentMethodId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): OnboardingPaymentInfo {
        const json = this.toJSON();
        let result = new OnboardingPaymentInfo();
        result.init(json);
        return result;
    }
}

export interface IOnboardingPaymentInfo {
    onboardingId: number;
    bankNameId: number;
    accountName: string | undefined;
    accountNumber: string | undefined;
    accountTypeId: number;
    paymentMethodId: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class OnboardingWorkInformation implements IOnboardingWorkInformation {
    onboardingId!: number;
    hireDate!: Date;
    dateofJoining!: Date;
    salaryPerAnnum!: number;
    desginationId!: number;
    employeeTypeId!: number;
    departmentId!: number;
    reportingManagerId!: number;
    location!: string | undefined;
    workEmail!: string | undefined;
    linkExpireDate!: Date | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IOnboardingWorkInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onboardingId = _data["onboardingId"];
            this.hireDate = _data["hireDate"] ? new Date(_data["hireDate"].toString()) : <any>undefined;
            this.dateofJoining = _data["dateofJoining"] ? new Date(_data["dateofJoining"].toString()) : <any>undefined;
            this.salaryPerAnnum = _data["salaryPerAnnum"];
            this.desginationId = _data["desginationId"];
            this.employeeTypeId = _data["employeeTypeId"];
            this.departmentId = _data["departmentId"];
            this.reportingManagerId = _data["reportingManagerId"];
            this.location = _data["location"];
            this.workEmail = _data["workEmail"];
            this.linkExpireDate = _data["linkExpireDate"] ? new Date(_data["linkExpireDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): OnboardingWorkInformation {
        data = typeof data === 'object' ? data : {};
        let result = new OnboardingWorkInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onboardingId"] = this.onboardingId;
        data["hireDate"] = this.hireDate ? this.hireDate.toISOString() : <any>undefined;
        data["dateofJoining"] = this.dateofJoining ? this.dateofJoining.toISOString() : <any>undefined;
        data["salaryPerAnnum"] = this.salaryPerAnnum;
        data["desginationId"] = this.desginationId;
        data["employeeTypeId"] = this.employeeTypeId;
        data["departmentId"] = this.departmentId;
        data["reportingManagerId"] = this.reportingManagerId;
        data["location"] = this.location;
        data["workEmail"] = this.workEmail;
        data["linkExpireDate"] = this.linkExpireDate ? this.linkExpireDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): OnboardingWorkInformation {
        const json = this.toJSON();
        let result = new OnboardingWorkInformation();
        result.init(json);
        return result;
    }
}

export interface IOnboardingWorkInformation {
    onboardingId: number;
    hireDate: Date;
    dateofJoining: Date;
    salaryPerAnnum: number;
    desginationId: number;
    employeeTypeId: number;
    departmentId: number;
    reportingManagerId: number;
    location: string | undefined;
    workEmail: string | undefined;
    linkExpireDate: Date | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeOnboardingPersonalData implements IEmployeeOnboardingPersonalData {
    onboardingId!: number;
    onboardingDocumentInfo!: OnboardingDocumentInfo;
    onboardingMedicalDisclosureInfo!: OnboardingMedicalDisclosureInfo;
    onboardingPaymentInfo!: OnboardingPaymentInfo;
    onboardingPersonalInfo!: OnboardingPersonalInfo;
    onboardingTaxInfo!: OnboardingTaxInfo;
    onboardingWorkInformation!: OnboardingWorkInformation;

    constructor(data?: IEmployeeOnboardingPersonalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onboardingId = _data["onboardingId"];
            this.onboardingDocumentInfo = _data["onboardingDocumentInfo"] ? OnboardingDocumentInfo.fromJS(_data["onboardingDocumentInfo"]) : <any>undefined;
            this.onboardingMedicalDisclosureInfo = _data["onboardingMedicalDisclosureInfo"] ? OnboardingMedicalDisclosureInfo.fromJS(_data["onboardingMedicalDisclosureInfo"]) : <any>undefined;
            this.onboardingPaymentInfo = _data["onboardingPaymentInfo"] ? OnboardingPaymentInfo.fromJS(_data["onboardingPaymentInfo"]) : <any>undefined;
            this.onboardingPersonalInfo = _data["onboardingPersonalInfo"] ? OnboardingPersonalInfo.fromJS(_data["onboardingPersonalInfo"]) : <any>undefined;
            this.onboardingTaxInfo = _data["onboardingTaxInfo"] ? OnboardingTaxInfo.fromJS(_data["onboardingTaxInfo"]) : <any>undefined;
            this.onboardingWorkInformation = _data["onboardingWorkInformation"] ? OnboardingWorkInformation.fromJS(_data["onboardingWorkInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmployeeOnboardingPersonalData {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeOnboardingPersonalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onboardingId"] = this.onboardingId;
        data["onboardingDocumentInfo"] = this.onboardingDocumentInfo ? this.onboardingDocumentInfo.toJSON() : <any>undefined;
        data["onboardingMedicalDisclosureInfo"] = this.onboardingMedicalDisclosureInfo ? this.onboardingMedicalDisclosureInfo.toJSON() : <any>undefined;
        data["onboardingPaymentInfo"] = this.onboardingPaymentInfo ? this.onboardingPaymentInfo.toJSON() : <any>undefined;
        data["onboardingPersonalInfo"] = this.onboardingPersonalInfo ? this.onboardingPersonalInfo.toJSON() : <any>undefined;
        data["onboardingTaxInfo"] = this.onboardingTaxInfo ? this.onboardingTaxInfo.toJSON() : <any>undefined;
        data["onboardingWorkInformation"] = this.onboardingWorkInformation ? this.onboardingWorkInformation.toJSON() : <any>undefined;
        return data; 
    }

    clone(): EmployeeOnboardingPersonalData {
        const json = this.toJSON();
        let result = new EmployeeOnboardingPersonalData();
        result.init(json);
        return result;
    }
}

export interface IEmployeeOnboardingPersonalData {
    onboardingId: number;
    onboardingDocumentInfo: OnboardingDocumentInfo;
    onboardingMedicalDisclosureInfo: OnboardingMedicalDisclosureInfo;
    onboardingPaymentInfo: OnboardingPaymentInfo;
    onboardingPersonalInfo: OnboardingPersonalInfo;
    onboardingTaxInfo: OnboardingTaxInfo;
    onboardingWorkInformation: OnboardingWorkInformation;
}

export class EmployeeOnboardingPersonalDataListApiResult implements IEmployeeOnboardingPersonalDataListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeOnboardingPersonalData[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmployeeOnboardingPersonalDataListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmployeeOnboardingPersonalData.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmployeeOnboardingPersonalDataListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeOnboardingPersonalDataListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmployeeOnboardingPersonalDataListApiResult {
        const json = this.toJSON();
        let result = new EmployeeOnboardingPersonalDataListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeOnboardingPersonalDataListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeOnboardingPersonalData[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ManagePayElementDTO implements IManagePayElementDTO {
    id!: number;
    paymentInstitutionId!: number;
    name!: string | undefined;
    elementTypeId!: number;
    elementCategoryId!: number;
    is_reoccurring!: boolean;
    isTaxDeduct!: boolean;
    amount!: number | undefined;
    is_variable!: boolean;
    ratio!: number | undefined;
    taxPercentage!: number | undefined;
    hourlyPay!: number | undefined;
    noOfWorkHours!: number | undefined;
    start_date!: Date | undefined;
    end_date!: Date | undefined;

    constructor(data?: IManagePayElementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentInstitutionId = _data["paymentInstitutionId"];
            this.name = _data["name"];
            this.elementTypeId = _data["elementTypeId"];
            this.elementCategoryId = _data["elementCategoryId"];
            this.is_reoccurring = _data["is_reoccurring"];
            this.isTaxDeduct = _data["isTaxDeduct"];
            this.amount = _data["amount"];
            this.is_variable = _data["is_variable"];
            this.ratio = _data["ratio"];
            this.taxPercentage = _data["taxPercentage"];
            this.hourlyPay = _data["hourlyPay"];
            this.noOfWorkHours = _data["noOfWorkHours"];
            this.start_date = _data["start_date"] ? new Date(_data["start_date"].toString()) : <any>undefined;
            this.end_date = _data["end_date"] ? new Date(_data["end_date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ManagePayElementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManagePayElementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentInstitutionId"] = this.paymentInstitutionId;
        data["name"] = this.name;
        data["elementTypeId"] = this.elementTypeId;
        data["elementCategoryId"] = this.elementCategoryId;
        data["is_reoccurring"] = this.is_reoccurring;
        data["isTaxDeduct"] = this.isTaxDeduct;
        data["amount"] = this.amount;
        data["is_variable"] = this.is_variable;
        data["ratio"] = this.ratio;
        data["taxPercentage"] = this.taxPercentage;
        data["hourlyPay"] = this.hourlyPay;
        data["noOfWorkHours"] = this.noOfWorkHours;
        data["start_date"] = this.start_date ? this.start_date.toISOString() : <any>undefined;
        data["end_date"] = this.end_date ? this.end_date.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ManagePayElementDTO {
        const json = this.toJSON();
        let result = new ManagePayElementDTO();
        result.init(json);
        return result;
    }
}

export interface IManagePayElementDTO {
    id: number;
    paymentInstitutionId: number;
    name: string | undefined;
    elementTypeId: number;
    elementCategoryId: number;
    is_reoccurring: boolean;
    isTaxDeduct: boolean;
    amount: number | undefined;
    is_variable: boolean;
    ratio: number | undefined;
    taxPercentage: number | undefined;
    hourlyPay: number | undefined;
    noOfWorkHours: number | undefined;
    start_date: Date | undefined;
    end_date: Date | undefined;
}

export class PayElementDTO implements IPayElementDTO {
    id!: number;
    company_id!: number;
    sub_id!: number;
    paymentInstitutionId!: number;
    paymentInstitution!: string | undefined;
    name!: string | undefined;
    elementTypeId!: number;
    elementType!: string | undefined;
    elementCategoryId!: number;
    elementCategory!: string | undefined;
    is_reoccurring!: boolean;
    isTaxDeduct!: boolean;
    amount!: number | undefined;
    is_variable!: boolean;
    ratio!: number | undefined;
    taxPercentage!: number | undefined;
    hourlyPay!: number | undefined;
    noOfWorkHours!: number | undefined;
    start_date!: Date | undefined;
    end_date!: Date | undefined;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;

    constructor(data?: IPayElementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.paymentInstitutionId = _data["paymentInstitutionId"];
            this.paymentInstitution = _data["paymentInstitution"];
            this.name = _data["name"];
            this.elementTypeId = _data["elementTypeId"];
            this.elementType = _data["elementType"];
            this.elementCategoryId = _data["elementCategoryId"];
            this.elementCategory = _data["elementCategory"];
            this.is_reoccurring = _data["is_reoccurring"];
            this.isTaxDeduct = _data["isTaxDeduct"];
            this.amount = _data["amount"];
            this.is_variable = _data["is_variable"];
            this.ratio = _data["ratio"];
            this.taxPercentage = _data["taxPercentage"];
            this.hourlyPay = _data["hourlyPay"];
            this.noOfWorkHours = _data["noOfWorkHours"];
            this.start_date = _data["start_date"] ? new Date(_data["start_date"].toString()) : <any>undefined;
            this.end_date = _data["end_date"] ? new Date(_data["end_date"].toString()) : <any>undefined;
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PayElementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PayElementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["paymentInstitutionId"] = this.paymentInstitutionId;
        data["paymentInstitution"] = this.paymentInstitution;
        data["name"] = this.name;
        data["elementTypeId"] = this.elementTypeId;
        data["elementType"] = this.elementType;
        data["elementCategoryId"] = this.elementCategoryId;
        data["elementCategory"] = this.elementCategory;
        data["is_reoccurring"] = this.is_reoccurring;
        data["isTaxDeduct"] = this.isTaxDeduct;
        data["amount"] = this.amount;
        data["is_variable"] = this.is_variable;
        data["ratio"] = this.ratio;
        data["taxPercentage"] = this.taxPercentage;
        data["hourlyPay"] = this.hourlyPay;
        data["noOfWorkHours"] = this.noOfWorkHours;
        data["start_date"] = this.start_date ? this.start_date.toISOString() : <any>undefined;
        data["end_date"] = this.end_date ? this.end_date.toISOString() : <any>undefined;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        return data; 
    }

    clone(): PayElementDTO {
        const json = this.toJSON();
        let result = new PayElementDTO();
        result.init(json);
        return result;
    }
}

export interface IPayElementDTO {
    id: number;
    company_id: number;
    sub_id: number;
    paymentInstitutionId: number;
    paymentInstitution: string | undefined;
    name: string | undefined;
    elementTypeId: number;
    elementType: string | undefined;
    elementCategoryId: number;
    elementCategory: string | undefined;
    is_reoccurring: boolean;
    isTaxDeduct: boolean;
    amount: number | undefined;
    is_variable: boolean;
    ratio: number | undefined;
    taxPercentage: number | undefined;
    hourlyPay: number | undefined;
    noOfWorkHours: number | undefined;
    start_date: Date | undefined;
    end_date: Date | undefined;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
}

export class PayElementDTOListApiResult implements IPayElementDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayElementDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPayElementDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PayElementDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PayElementDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayElementDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PayElementDTOListApiResult {
        const json = this.toJSON();
        let result = new PayElementDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayElementDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayElementDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class PayElementDTOApiResult implements IPayElementDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayElementDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPayElementDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? PayElementDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PayElementDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayElementDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PayElementDTOApiResult {
        const json = this.toJSON();
        let result = new PayElementDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayElementDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayElementDTO;
    totalCount: number;
    totalRecord: number;
}

export class ManagePayInstitutionDTO implements IManagePayInstitutionDTO {
    id!: number;
    categoryId!: number;
    name!: string | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    bankId!: number;

    constructor(data?: IManagePayInstitutionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.accountName = _data["accountName"];
            this.accountNumber = _data["accountNumber"];
            this.bankId = _data["bankId"];
        }
    }

    static fromJS(data: any): ManagePayInstitutionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManagePayInstitutionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["bankId"] = this.bankId;
        return data; 
    }

    clone(): ManagePayInstitutionDTO {
        const json = this.toJSON();
        let result = new ManagePayInstitutionDTO();
        result.init(json);
        return result;
    }
}

export interface IManagePayInstitutionDTO {
    id: number;
    categoryId: number;
    name: string | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    bankId: number;
}

export class PayInstitutionDTO implements IPayInstitutionDTO {
    id!: number;
    company_id!: number;
    sub_id!: number;
    categoryId!: number;
    name!: string | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    bankId!: number;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;

    constructor(data?: IPayInstitutionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.accountName = _data["accountName"];
            this.accountNumber = _data["accountNumber"];
            this.bankId = _data["bankId"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PayInstitutionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PayInstitutionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["bankId"] = this.bankId;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        return data; 
    }

    clone(): PayInstitutionDTO {
        const json = this.toJSON();
        let result = new PayInstitutionDTO();
        result.init(json);
        return result;
    }
}

export interface IPayInstitutionDTO {
    id: number;
    company_id: number;
    sub_id: number;
    categoryId: number;
    name: string | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    bankId: number;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
}

export class PayInstitutionDTOListApiResult implements IPayInstitutionDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayInstitutionDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPayInstitutionDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PayInstitutionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PayInstitutionDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayInstitutionDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PayInstitutionDTOListApiResult {
        const json = this.toJSON();
        let result = new PayInstitutionDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayInstitutionDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayInstitutionDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class PayInstitutionDTOApiResult implements IPayInstitutionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayInstitutionDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPayInstitutionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? PayInstitutionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PayInstitutionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayInstitutionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PayInstitutionDTOApiResult {
        const json = this.toJSON();
        let result = new PayInstitutionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayInstitutionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayInstitutionDTO;
    totalCount: number;
    totalRecord: number;
}

export class RptPayslipAnalyzer implements IRptPayslipAnalyzer {
    percentageDiff!: number;
    employeeContractId!: number;
    employeeName!: string | undefined;
    assignmentNo!: string | undefined;
    totalCurrentEarning!: number;
    totalPreviousEarning!: number;
    totalCurrentDeduction!: number;
    totalPreviousDeduction!: number;
    totalCurrentNetPay!: number;
    totalPreviousNetPay!: number;

    constructor(data?: IRptPayslipAnalyzer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.percentageDiff = _data["percentageDiff"];
            this.employeeContractId = _data["employeeContractId"];
            this.employeeName = _data["employeeName"];
            this.assignmentNo = _data["assignmentNo"];
            this.totalCurrentEarning = _data["totalCurrentEarning"];
            this.totalPreviousEarning = _data["totalPreviousEarning"];
            this.totalCurrentDeduction = _data["totalCurrentDeduction"];
            this.totalPreviousDeduction = _data["totalPreviousDeduction"];
            this.totalCurrentNetPay = _data["totalCurrentNetPay"];
            this.totalPreviousNetPay = _data["totalPreviousNetPay"];
        }
    }

    static fromJS(data: any): RptPayslipAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new RptPayslipAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["percentageDiff"] = this.percentageDiff;
        data["employeeContractId"] = this.employeeContractId;
        data["employeeName"] = this.employeeName;
        data["assignmentNo"] = this.assignmentNo;
        data["totalCurrentEarning"] = this.totalCurrentEarning;
        data["totalPreviousEarning"] = this.totalPreviousEarning;
        data["totalCurrentDeduction"] = this.totalCurrentDeduction;
        data["totalPreviousDeduction"] = this.totalPreviousDeduction;
        data["totalCurrentNetPay"] = this.totalCurrentNetPay;
        data["totalPreviousNetPay"] = this.totalPreviousNetPay;
        return data; 
    }

    clone(): RptPayslipAnalyzer {
        const json = this.toJSON();
        let result = new RptPayslipAnalyzer();
        result.init(json);
        return result;
    }
}

export interface IRptPayslipAnalyzer {
    percentageDiff: number;
    employeeContractId: number;
    employeeName: string | undefined;
    assignmentNo: string | undefined;
    totalCurrentEarning: number;
    totalPreviousEarning: number;
    totalCurrentDeduction: number;
    totalPreviousDeduction: number;
    totalCurrentNetPay: number;
    totalPreviousNetPay: number;
}

export class RptPayslipAnalyzerListApiResult implements IRptPayslipAnalyzerListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RptPayslipAnalyzer[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRptPayslipAnalyzerListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RptPayslipAnalyzer.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RptPayslipAnalyzerListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RptPayslipAnalyzerListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RptPayslipAnalyzerListApiResult {
        const json = this.toJSON();
        let result = new RptPayslipAnalyzerListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRptPayslipAnalyzerListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RptPayslipAnalyzer[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RptPayrollRunAnalysis implements IRptPayrollRunAnalysis {
    payrollRunId!: number;
    payPeriod!: string | undefined;
    payrollType!: string | undefined;
    totalEarning!: number;
    totalDeduction!: number;
    totalNetPayt!: number;

    constructor(data?: IRptPayrollRunAnalysis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.payrollRunId = _data["payrollRunId"];
            this.payPeriod = _data["payPeriod"];
            this.payrollType = _data["payrollType"];
            this.totalEarning = _data["totalEarning"];
            this.totalDeduction = _data["totalDeduction"];
            this.totalNetPayt = _data["totalNetPayt"];
        }
    }

    static fromJS(data: any): RptPayrollRunAnalysis {
        data = typeof data === 'object' ? data : {};
        let result = new RptPayrollRunAnalysis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payrollRunId"] = this.payrollRunId;
        data["payPeriod"] = this.payPeriod;
        data["payrollType"] = this.payrollType;
        data["totalEarning"] = this.totalEarning;
        data["totalDeduction"] = this.totalDeduction;
        data["totalNetPayt"] = this.totalNetPayt;
        return data; 
    }

    clone(): RptPayrollRunAnalysis {
        const json = this.toJSON();
        let result = new RptPayrollRunAnalysis();
        result.init(json);
        return result;
    }
}

export interface IRptPayrollRunAnalysis {
    payrollRunId: number;
    payPeriod: string | undefined;
    payrollType: string | undefined;
    totalEarning: number;
    totalDeduction: number;
    totalNetPayt: number;
}

export class RptPayrollRunAnalysisListApiResult implements IRptPayrollRunAnalysisListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RptPayrollRunAnalysis[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRptPayrollRunAnalysisListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RptPayrollRunAnalysis.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RptPayrollRunAnalysisListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RptPayrollRunAnalysisListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RptPayrollRunAnalysisListApiResult {
        const json = this.toJSON();
        let result = new RptPayrollRunAnalysisListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRptPayrollRunAnalysisListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RptPayrollRunAnalysis[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RptBankSchedule implements IRptBankSchedule {
    sn!: string | undefined;
    employeeNo!: string | undefined;
    fullName!: string | undefined;
    dept!: string | undefined;
    bankName!: string | undefined;
    bankCode!: string | undefined;
    accountNo!: string | undefined;
    earnings!: string | undefined;
    deductions!: string | undefined;
    netPay!: string | undefined;
    gradeLevel!: string | undefined;
    step!: string | undefined;
    location!: string | undefined;

    constructor(data?: IRptBankSchedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sn = _data["sn"];
            this.employeeNo = _data["employeeNo"];
            this.fullName = _data["fullName"];
            this.dept = _data["dept"];
            this.bankName = _data["bankName"];
            this.bankCode = _data["bankCode"];
            this.accountNo = _data["accountNo"];
            this.earnings = _data["earnings"];
            this.deductions = _data["deductions"];
            this.netPay = _data["netPay"];
            this.gradeLevel = _data["gradeLevel"];
            this.step = _data["step"];
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): RptBankSchedule {
        data = typeof data === 'object' ? data : {};
        let result = new RptBankSchedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sn"] = this.sn;
        data["employeeNo"] = this.employeeNo;
        data["fullName"] = this.fullName;
        data["dept"] = this.dept;
        data["bankName"] = this.bankName;
        data["bankCode"] = this.bankCode;
        data["accountNo"] = this.accountNo;
        data["earnings"] = this.earnings;
        data["deductions"] = this.deductions;
        data["netPay"] = this.netPay;
        data["gradeLevel"] = this.gradeLevel;
        data["step"] = this.step;
        data["location"] = this.location;
        return data; 
    }

    clone(): RptBankSchedule {
        const json = this.toJSON();
        let result = new RptBankSchedule();
        result.init(json);
        return result;
    }
}

export interface IRptBankSchedule {
    sn: string | undefined;
    employeeNo: string | undefined;
    fullName: string | undefined;
    dept: string | undefined;
    bankName: string | undefined;
    bankCode: string | undefined;
    accountNo: string | undefined;
    earnings: string | undefined;
    deductions: string | undefined;
    netPay: string | undefined;
    gradeLevel: string | undefined;
    step: string | undefined;
    location: string | undefined;
}

export class RptBankScheduleListApiResult implements IRptBankScheduleListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RptBankSchedule[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRptBankScheduleListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RptBankSchedule.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RptBankScheduleListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RptBankScheduleListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RptBankScheduleListApiResult {
        const json = this.toJSON();
        let result = new RptBankScheduleListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRptBankScheduleListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RptBankSchedule[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RptEarnings implements IRptEarnings {
    sn!: string | undefined;
    employeeNo!: string | undefined;
    employeeName!: string | undefined;
    elementName!: string | undefined;
    amount!: string | undefined;
    locationName!: string | undefined;

    constructor(data?: IRptEarnings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sn = _data["sn"];
            this.employeeNo = _data["employeeNo"];
            this.employeeName = _data["employeeName"];
            this.elementName = _data["elementName"];
            this.amount = _data["amount"];
            this.locationName = _data["locationName"];
        }
    }

    static fromJS(data: any): RptEarnings {
        data = typeof data === 'object' ? data : {};
        let result = new RptEarnings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sn"] = this.sn;
        data["employeeNo"] = this.employeeNo;
        data["employeeName"] = this.employeeName;
        data["elementName"] = this.elementName;
        data["amount"] = this.amount;
        data["locationName"] = this.locationName;
        return data; 
    }

    clone(): RptEarnings {
        const json = this.toJSON();
        let result = new RptEarnings();
        result.init(json);
        return result;
    }
}

export interface IRptEarnings {
    sn: string | undefined;
    employeeNo: string | undefined;
    employeeName: string | undefined;
    elementName: string | undefined;
    amount: string | undefined;
    locationName: string | undefined;
}

export class RptEarningsListApiResult implements IRptEarningsListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RptEarnings[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRptEarningsListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RptEarnings.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RptEarningsListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RptEarningsListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RptEarningsListApiResult {
        const json = this.toJSON();
        let result = new RptEarningsListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRptEarningsListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RptEarnings[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RptDeductions implements IRptDeductions {
    sn!: string | undefined;
    employeeNo!: string | undefined;
    employeeName!: string | undefined;
    elementName!: string | undefined;
    amount!: string | undefined;
    locationName!: string | undefined;

    constructor(data?: IRptDeductions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sn = _data["sn"];
            this.employeeNo = _data["employeeNo"];
            this.employeeName = _data["employeeName"];
            this.elementName = _data["elementName"];
            this.amount = _data["amount"];
            this.locationName = _data["locationName"];
        }
    }

    static fromJS(data: any): RptDeductions {
        data = typeof data === 'object' ? data : {};
        let result = new RptDeductions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sn"] = this.sn;
        data["employeeNo"] = this.employeeNo;
        data["employeeName"] = this.employeeName;
        data["elementName"] = this.elementName;
        data["amount"] = this.amount;
        data["locationName"] = this.locationName;
        return data; 
    }

    clone(): RptDeductions {
        const json = this.toJSON();
        let result = new RptDeductions();
        result.init(json);
        return result;
    }
}

export interface IRptDeductions {
    sn: string | undefined;
    employeeNo: string | undefined;
    employeeName: string | undefined;
    elementName: string | undefined;
    amount: string | undefined;
    locationName: string | undefined;
}

export class RptDeductionsListApiResult implements IRptDeductionsListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RptDeductions[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRptDeductionsListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RptDeductions.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RptDeductionsListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RptDeductionsListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RptDeductionsListApiResult {
        const json = this.toJSON();
        let result = new RptDeductionsListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRptDeductionsListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RptDeductions[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RptAllElementSheet implements IRptAllElementSheet {
    sn!: string | undefined;
    employeeNo!: string | undefined;
    employeeName!: string | undefined;
    elementName!: string | undefined;
    amount!: string | undefined;
    locationName!: string | undefined;

    constructor(data?: IRptAllElementSheet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sn = _data["sn"];
            this.employeeNo = _data["employeeNo"];
            this.employeeName = _data["employeeName"];
            this.elementName = _data["elementName"];
            this.amount = _data["amount"];
            this.locationName = _data["locationName"];
        }
    }

    static fromJS(data: any): RptAllElementSheet {
        data = typeof data === 'object' ? data : {};
        let result = new RptAllElementSheet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sn"] = this.sn;
        data["employeeNo"] = this.employeeNo;
        data["employeeName"] = this.employeeName;
        data["elementName"] = this.elementName;
        data["amount"] = this.amount;
        data["locationName"] = this.locationName;
        return data; 
    }

    clone(): RptAllElementSheet {
        const json = this.toJSON();
        let result = new RptAllElementSheet();
        result.init(json);
        return result;
    }
}

export interface IRptAllElementSheet {
    sn: string | undefined;
    employeeNo: string | undefined;
    employeeName: string | undefined;
    elementName: string | undefined;
    amount: string | undefined;
    locationName: string | undefined;
}

export class RptAllElementSheetListApiResult implements IRptAllElementSheetListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RptAllElementSheet[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRptAllElementSheetListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RptAllElementSheet.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RptAllElementSheetListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RptAllElementSheetListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RptAllElementSheetListApiResult {
        const json = this.toJSON();
        let result = new RptAllElementSheetListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRptAllElementSheetListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RptAllElementSheet[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RptDeductionSummary implements IRptDeductionSummary {
    sn!: string | undefined;
    elementName!: string | undefined;
    amount!: string | undefined;

    constructor(data?: IRptDeductionSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sn = _data["sn"];
            this.elementName = _data["elementName"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): RptDeductionSummary {
        data = typeof data === 'object' ? data : {};
        let result = new RptDeductionSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sn"] = this.sn;
        data["elementName"] = this.elementName;
        data["amount"] = this.amount;
        return data; 
    }

    clone(): RptDeductionSummary {
        const json = this.toJSON();
        let result = new RptDeductionSummary();
        result.init(json);
        return result;
    }
}

export interface IRptDeductionSummary {
    sn: string | undefined;
    elementName: string | undefined;
    amount: string | undefined;
}

export class RptDeductionSummaryListApiResult implements IRptDeductionSummaryListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RptDeductionSummary[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRptDeductionSummaryListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RptDeductionSummary.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RptDeductionSummaryListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RptDeductionSummaryListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RptDeductionSummaryListApiResult {
        const json = this.toJSON();
        let result = new RptDeductionSummaryListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRptDeductionSummaryListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RptDeductionSummary[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RptPaymentSummary implements IRptPaymentSummary {
    sn!: string | undefined;
    elementName!: string | undefined;
    amount!: string | undefined;

    constructor(data?: IRptPaymentSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sn = _data["sn"];
            this.elementName = _data["elementName"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): RptPaymentSummary {
        data = typeof data === 'object' ? data : {};
        let result = new RptPaymentSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sn"] = this.sn;
        data["elementName"] = this.elementName;
        data["amount"] = this.amount;
        return data; 
    }

    clone(): RptPaymentSummary {
        const json = this.toJSON();
        let result = new RptPaymentSummary();
        result.init(json);
        return result;
    }
}

export interface IRptPaymentSummary {
    sn: string | undefined;
    elementName: string | undefined;
    amount: string | undefined;
}

export class RptPaymentSummaryListApiResult implements IRptPaymentSummaryListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RptPaymentSummary[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRptPaymentSummaryListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RptPaymentSummary.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RptPaymentSummaryListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RptPaymentSummaryListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RptPaymentSummaryListApiResult {
        const json = this.toJSON();
        let result = new RptPaymentSummaryListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRptPaymentSummaryListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RptPaymentSummary[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RptTaxDetail implements IRptTaxDetail {
    employeeNo!: string | undefined;
    employeeName!: string | undefined;
    location!: string | undefined;
    elementName!: string | undefined;
    amount!: string | undefined;

    constructor(data?: IRptTaxDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeNo = _data["employeeNo"];
            this.employeeName = _data["employeeName"];
            this.location = _data["location"];
            this.elementName = _data["elementName"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): RptTaxDetail {
        data = typeof data === 'object' ? data : {};
        let result = new RptTaxDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeNo"] = this.employeeNo;
        data["employeeName"] = this.employeeName;
        data["location"] = this.location;
        data["elementName"] = this.elementName;
        data["amount"] = this.amount;
        return data; 
    }

    clone(): RptTaxDetail {
        const json = this.toJSON();
        let result = new RptTaxDetail();
        result.init(json);
        return result;
    }
}

export interface IRptTaxDetail {
    employeeNo: string | undefined;
    employeeName: string | undefined;
    location: string | undefined;
    elementName: string | undefined;
    amount: string | undefined;
}

export class RptTaxDetailListApiResult implements IRptTaxDetailListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RptTaxDetail[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRptTaxDetailListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RptTaxDetail.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RptTaxDetailListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RptTaxDetailListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RptTaxDetailListApiResult {
        const json = this.toJSON();
        let result = new RptTaxDetailListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRptTaxDetailListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RptTaxDetail[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RptTaxSummary implements IRptTaxSummary {
    location!: string | undefined;
    amount!: string | undefined;

    constructor(data?: IRptTaxSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location = _data["location"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): RptTaxSummary {
        data = typeof data === 'object' ? data : {};
        let result = new RptTaxSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        data["amount"] = this.amount;
        return data; 
    }

    clone(): RptTaxSummary {
        const json = this.toJSON();
        let result = new RptTaxSummary();
        result.init(json);
        return result;
    }
}

export interface IRptTaxSummary {
    location: string | undefined;
    amount: string | undefined;
}

export class RptTaxSummaryListApiResult implements IRptTaxSummaryListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RptTaxSummary[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRptTaxSummaryListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RptTaxSummary.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RptTaxSummaryListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RptTaxSummaryListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RptTaxSummaryListApiResult {
        const json = this.toJSON();
        let result = new RptTaxSummaryListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRptTaxSummaryListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RptTaxSummary[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RptPensionDetail implements IRptPensionDetail {
    employeeNo!: string | undefined;
    employeeName!: string | undefined;
    pfaCode!: string | undefined;
    pfaName!: string | undefined;
    pensionPIN!: string | undefined;
    periodName!: string | undefined;
    employeeContribution!: string | undefined;
    employerContribution!: string | undefined;
    remittance!: string | undefined;

    constructor(data?: IRptPensionDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeNo = _data["employeeNo"];
            this.employeeName = _data["employeeName"];
            this.pfaCode = _data["pfaCode"];
            this.pfaName = _data["pfaName"];
            this.pensionPIN = _data["pensionPIN"];
            this.periodName = _data["periodName"];
            this.employeeContribution = _data["employeeContribution"];
            this.employerContribution = _data["employerContribution"];
            this.remittance = _data["remittance"];
        }
    }

    static fromJS(data: any): RptPensionDetail {
        data = typeof data === 'object' ? data : {};
        let result = new RptPensionDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeNo"] = this.employeeNo;
        data["employeeName"] = this.employeeName;
        data["pfaCode"] = this.pfaCode;
        data["pfaName"] = this.pfaName;
        data["pensionPIN"] = this.pensionPIN;
        data["periodName"] = this.periodName;
        data["employeeContribution"] = this.employeeContribution;
        data["employerContribution"] = this.employerContribution;
        data["remittance"] = this.remittance;
        return data; 
    }

    clone(): RptPensionDetail {
        const json = this.toJSON();
        let result = new RptPensionDetail();
        result.init(json);
        return result;
    }
}

export interface IRptPensionDetail {
    employeeNo: string | undefined;
    employeeName: string | undefined;
    pfaCode: string | undefined;
    pfaName: string | undefined;
    pensionPIN: string | undefined;
    periodName: string | undefined;
    employeeContribution: string | undefined;
    employerContribution: string | undefined;
    remittance: string | undefined;
}

export class RptPensionDetailListApiResult implements IRptPensionDetailListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RptPensionDetail[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRptPensionDetailListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RptPensionDetail.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RptPensionDetailListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RptPensionDetailListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RptPensionDetailListApiResult {
        const json = this.toJSON();
        let result = new RptPensionDetailListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRptPensionDetailListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RptPensionDetail[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RptPensionSummary implements IRptPensionSummary {
    pfaCode!: string | undefined;
    pfaName!: string | undefined;
    empCount!: number;
    employeeContribution!: string | undefined;
    employerContribution!: string | undefined;
    remittance!: string | undefined;

    constructor(data?: IRptPensionSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pfaCode = _data["pfaCode"];
            this.pfaName = _data["pfaName"];
            this.empCount = _data["empCount"];
            this.employeeContribution = _data["employeeContribution"];
            this.employerContribution = _data["employerContribution"];
            this.remittance = _data["remittance"];
        }
    }

    static fromJS(data: any): RptPensionSummary {
        data = typeof data === 'object' ? data : {};
        let result = new RptPensionSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pfaCode"] = this.pfaCode;
        data["pfaName"] = this.pfaName;
        data["empCount"] = this.empCount;
        data["employeeContribution"] = this.employeeContribution;
        data["employerContribution"] = this.employerContribution;
        data["remittance"] = this.remittance;
        return data; 
    }

    clone(): RptPensionSummary {
        const json = this.toJSON();
        let result = new RptPensionSummary();
        result.init(json);
        return result;
    }
}

export interface IRptPensionSummary {
    pfaCode: string | undefined;
    pfaName: string | undefined;
    empCount: number;
    employeeContribution: string | undefined;
    employerContribution: string | undefined;
    remittance: string | undefined;
}

export class RptPensionSummaryListApiResult implements IRptPensionSummaryListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RptPensionSummary[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRptPensionSummaryListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RptPensionSummary.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RptPensionSummaryListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RptPensionSummaryListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RptPensionSummaryListApiResult {
        const json = this.toJSON();
        let result = new RptPensionSummaryListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRptPensionSummaryListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RptPensionSummary[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class PayrollRun implements IPayrollRun {
    id!: number;
    payrollTypeId!: number;
    payPeriodId!: number;
    effectiveDate!: Date;
    periodStart!: Date;
    periodEnd!: Date;
    refNo!: string | undefined;
    initiatedBy!: string | undefined;
    dateInitiated!: Date | undefined;
    isComplete!: boolean;
    dateCompleted!: Date | undefined;
    log_status!: number;
    noOfItems!: number;
    totalEarning!: number;
    totalDeduction!: number;
    totalNetPayt!: number;
    generatePayslip!: boolean;
    isGenerated!: boolean;
    companyId!: number;
    subId!: number;
    assignmentNumbers!: string | undefined;
    runAll!: boolean | undefined;
    checkComplete!: boolean;
    showPayslips!: boolean | undefined;
    isReRun!: boolean;
    runCount!: number | undefined;
    ministryId!: number | undefined;
    locationId!: number | undefined;
    departmentId!: number | undefined;

    constructor(data?: IPayrollRun) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.payrollTypeId = _data["payrollTypeId"];
            this.payPeriodId = _data["payPeriodId"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.periodStart = _data["periodStart"] ? new Date(_data["periodStart"].toString()) : <any>undefined;
            this.periodEnd = _data["periodEnd"] ? new Date(_data["periodEnd"].toString()) : <any>undefined;
            this.refNo = _data["refNo"];
            this.initiatedBy = _data["initiatedBy"];
            this.dateInitiated = _data["dateInitiated"] ? new Date(_data["dateInitiated"].toString()) : <any>undefined;
            this.isComplete = _data["isComplete"];
            this.dateCompleted = _data["dateCompleted"] ? new Date(_data["dateCompleted"].toString()) : <any>undefined;
            this.log_status = _data["log_status"];
            this.noOfItems = _data["noOfItems"];
            this.totalEarning = _data["totalEarning"];
            this.totalDeduction = _data["totalDeduction"];
            this.totalNetPayt = _data["totalNetPayt"];
            this.generatePayslip = _data["generatePayslip"];
            this.isGenerated = _data["isGenerated"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.assignmentNumbers = _data["assignmentNumbers"];
            this.runAll = _data["runAll"];
            this.checkComplete = _data["checkComplete"];
            this.showPayslips = _data["showPayslips"];
            this.isReRun = _data["isReRun"];
            this.runCount = _data["runCount"];
            this.ministryId = _data["ministryId"];
            this.locationId = _data["locationId"];
            this.departmentId = _data["departmentId"];
        }
    }

    static fromJS(data: any): PayrollRun {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollRun();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["payrollTypeId"] = this.payrollTypeId;
        data["payPeriodId"] = this.payPeriodId;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["periodStart"] = this.periodStart ? this.periodStart.toISOString() : <any>undefined;
        data["periodEnd"] = this.periodEnd ? this.periodEnd.toISOString() : <any>undefined;
        data["refNo"] = this.refNo;
        data["initiatedBy"] = this.initiatedBy;
        data["dateInitiated"] = this.dateInitiated ? this.dateInitiated.toISOString() : <any>undefined;
        data["isComplete"] = this.isComplete;
        data["dateCompleted"] = this.dateCompleted ? this.dateCompleted.toISOString() : <any>undefined;
        data["log_status"] = this.log_status;
        data["noOfItems"] = this.noOfItems;
        data["totalEarning"] = this.totalEarning;
        data["totalDeduction"] = this.totalDeduction;
        data["totalNetPayt"] = this.totalNetPayt;
        data["generatePayslip"] = this.generatePayslip;
        data["isGenerated"] = this.isGenerated;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["assignmentNumbers"] = this.assignmentNumbers;
        data["runAll"] = this.runAll;
        data["checkComplete"] = this.checkComplete;
        data["showPayslips"] = this.showPayslips;
        data["isReRun"] = this.isReRun;
        data["runCount"] = this.runCount;
        data["ministryId"] = this.ministryId;
        data["locationId"] = this.locationId;
        data["departmentId"] = this.departmentId;
        return data; 
    }

    clone(): PayrollRun {
        const json = this.toJSON();
        let result = new PayrollRun();
        result.init(json);
        return result;
    }
}

export interface IPayrollRun {
    id: number;
    payrollTypeId: number;
    payPeriodId: number;
    effectiveDate: Date;
    periodStart: Date;
    periodEnd: Date;
    refNo: string | undefined;
    initiatedBy: string | undefined;
    dateInitiated: Date | undefined;
    isComplete: boolean;
    dateCompleted: Date | undefined;
    log_status: number;
    noOfItems: number;
    totalEarning: number;
    totalDeduction: number;
    totalNetPayt: number;
    generatePayslip: boolean;
    isGenerated: boolean;
    companyId: number;
    subId: number;
    assignmentNumbers: string | undefined;
    runAll: boolean | undefined;
    checkComplete: boolean;
    showPayslips: boolean | undefined;
    isReRun: boolean;
    runCount: number | undefined;
    ministryId: number | undefined;
    locationId: number | undefined;
    departmentId: number | undefined;
}

export class PayrollRunListApiResult implements IPayrollRunListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayrollRun[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPayrollRunListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PayrollRun.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PayrollRunListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollRunListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PayrollRunListApiResult {
        const json = this.toJSON();
        let result = new PayrollRunListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayrollRunListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayrollRun[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class Payslip implements IPayslip {
    id!: number;
    payrollRunId!: number;
    employeeContractId!: number;
    fullname!: string | undefined;
    staffNo!: string | undefined;
    employmentType!: string | undefined;
    gradeStep!: string | undefined;
    salaryScale!: string | undefined;
    paymentDate!: Date;
    periodStart!: Date;
    periodEnd!: Date;
    totalEarning!: number;
    totalDeduction!: number;
    netPayt!: number;
    accountNo!: string | undefined;
    bankName!: string | undefined;
    bankId!: number | undefined;
    pfaId!: number | undefined;
    rsaNo!: string | undefined;
    locationId!: number | undefined;
    lcdaId!: number | undefined;
    pensionBalance!: number | undefined;
    taxBalanceYTD!: number | undefined;
    taxableIncomeYTD!: number | undefined;

    constructor(data?: IPayslip) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.payrollRunId = _data["payrollRunId"];
            this.employeeContractId = _data["employeeContractId"];
            this.fullname = _data["fullname"];
            this.staffNo = _data["staffNo"];
            this.employmentType = _data["employmentType"];
            this.gradeStep = _data["gradeStep"];
            this.salaryScale = _data["salaryScale"];
            this.paymentDate = _data["paymentDate"] ? new Date(_data["paymentDate"].toString()) : <any>undefined;
            this.periodStart = _data["periodStart"] ? new Date(_data["periodStart"].toString()) : <any>undefined;
            this.periodEnd = _data["periodEnd"] ? new Date(_data["periodEnd"].toString()) : <any>undefined;
            this.totalEarning = _data["totalEarning"];
            this.totalDeduction = _data["totalDeduction"];
            this.netPayt = _data["netPayt"];
            this.accountNo = _data["accountNo"];
            this.bankName = _data["bankName"];
            this.bankId = _data["bankId"];
            this.pfaId = _data["pfaId"];
            this.rsaNo = _data["rsaNo"];
            this.locationId = _data["locationId"];
            this.lcdaId = _data["lcdaId"];
            this.pensionBalance = _data["pensionBalance"];
            this.taxBalanceYTD = _data["taxBalanceYTD"];
            this.taxableIncomeYTD = _data["taxableIncomeYTD"];
        }
    }

    static fromJS(data: any): Payslip {
        data = typeof data === 'object' ? data : {};
        let result = new Payslip();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["payrollRunId"] = this.payrollRunId;
        data["employeeContractId"] = this.employeeContractId;
        data["fullname"] = this.fullname;
        data["staffNo"] = this.staffNo;
        data["employmentType"] = this.employmentType;
        data["gradeStep"] = this.gradeStep;
        data["salaryScale"] = this.salaryScale;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["periodStart"] = this.periodStart ? this.periodStart.toISOString() : <any>undefined;
        data["periodEnd"] = this.periodEnd ? this.periodEnd.toISOString() : <any>undefined;
        data["totalEarning"] = this.totalEarning;
        data["totalDeduction"] = this.totalDeduction;
        data["netPayt"] = this.netPayt;
        data["accountNo"] = this.accountNo;
        data["bankName"] = this.bankName;
        data["bankId"] = this.bankId;
        data["pfaId"] = this.pfaId;
        data["rsaNo"] = this.rsaNo;
        data["locationId"] = this.locationId;
        data["lcdaId"] = this.lcdaId;
        data["pensionBalance"] = this.pensionBalance;
        data["taxBalanceYTD"] = this.taxBalanceYTD;
        data["taxableIncomeYTD"] = this.taxableIncomeYTD;
        return data; 
    }

    clone(): Payslip {
        const json = this.toJSON();
        let result = new Payslip();
        result.init(json);
        return result;
    }
}

export interface IPayslip {
    id: number;
    payrollRunId: number;
    employeeContractId: number;
    fullname: string | undefined;
    staffNo: string | undefined;
    employmentType: string | undefined;
    gradeStep: string | undefined;
    salaryScale: string | undefined;
    paymentDate: Date;
    periodStart: Date;
    periodEnd: Date;
    totalEarning: number;
    totalDeduction: number;
    netPayt: number;
    accountNo: string | undefined;
    bankName: string | undefined;
    bankId: number | undefined;
    pfaId: number | undefined;
    rsaNo: string | undefined;
    locationId: number | undefined;
    lcdaId: number | undefined;
    pensionBalance: number | undefined;
    taxBalanceYTD: number | undefined;
    taxableIncomeYTD: number | undefined;
}

export class PayslipListApiResult implements IPayslipListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Payslip[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPayslipListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Payslip.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PayslipListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayslipListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PayslipListApiResult {
        const json = this.toJSON();
        let result = new PayslipListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayslipListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Payslip[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class PayslipItem implements IPayslipItem {
    id!: number;
    payslipId!: number;
    payrollRunId!: number;
    elementId!: number;
    elementName!: string | undefined;
    elementInputId!: number;
    elementInputName!: string | undefined;
    inputVal!: string | undefined;
    outputVal!: string | undefined;
    isEarning!: boolean | undefined;
    isProcessed!: boolean;
    dateProcessed!: Date;
    varianceId!: number | undefined;

    constructor(data?: IPayslipItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.payslipId = _data["payslipId"];
            this.payrollRunId = _data["payrollRunId"];
            this.elementId = _data["elementId"];
            this.elementName = _data["elementName"];
            this.elementInputId = _data["elementInputId"];
            this.elementInputName = _data["elementInputName"];
            this.inputVal = _data["inputVal"];
            this.outputVal = _data["outputVal"];
            this.isEarning = _data["isEarning"];
            this.isProcessed = _data["isProcessed"];
            this.dateProcessed = _data["dateProcessed"] ? new Date(_data["dateProcessed"].toString()) : <any>undefined;
            this.varianceId = _data["varianceId"];
        }
    }

    static fromJS(data: any): PayslipItem {
        data = typeof data === 'object' ? data : {};
        let result = new PayslipItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["payslipId"] = this.payslipId;
        data["payrollRunId"] = this.payrollRunId;
        data["elementId"] = this.elementId;
        data["elementName"] = this.elementName;
        data["elementInputId"] = this.elementInputId;
        data["elementInputName"] = this.elementInputName;
        data["inputVal"] = this.inputVal;
        data["outputVal"] = this.outputVal;
        data["isEarning"] = this.isEarning;
        data["isProcessed"] = this.isProcessed;
        data["dateProcessed"] = this.dateProcessed ? this.dateProcessed.toISOString() : <any>undefined;
        data["varianceId"] = this.varianceId;
        return data; 
    }

    clone(): PayslipItem {
        const json = this.toJSON();
        let result = new PayslipItem();
        result.init(json);
        return result;
    }
}

export interface IPayslipItem {
    id: number;
    payslipId: number;
    payrollRunId: number;
    elementId: number;
    elementName: string | undefined;
    elementInputId: number;
    elementInputName: string | undefined;
    inputVal: string | undefined;
    outputVal: string | undefined;
    isEarning: boolean | undefined;
    isProcessed: boolean;
    dateProcessed: Date;
    varianceId: number | undefined;
}

export class PayslipItemListApiResult implements IPayslipItemListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayslipItem[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPayslipItemListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PayslipItem.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PayslipItemListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayslipItemListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PayslipItemListApiResult {
        const json = this.toJSON();
        let result = new PayslipItemListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayslipItemListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayslipItem[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ManagePayrollTypeDTO implements IManagePayrollTypeDTO {
    id!: number;
    name!: string | undefined;
    frequencyRuleId!: number;
    firstPeriodEndDate!: Date;
    noOfYears!: number;
    effectiveDate!: Date;
    negativePaymentAllowed!: boolean;
    code!: string | undefined;

    constructor(data?: IManagePayrollTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.frequencyRuleId = _data["frequencyRuleId"];
            this.firstPeriodEndDate = _data["firstPeriodEndDate"] ? new Date(_data["firstPeriodEndDate"].toString()) : <any>undefined;
            this.noOfYears = _data["noOfYears"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.negativePaymentAllowed = _data["negativePaymentAllowed"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ManagePayrollTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManagePayrollTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["frequencyRuleId"] = this.frequencyRuleId;
        data["firstPeriodEndDate"] = this.firstPeriodEndDate ? this.firstPeriodEndDate.toISOString() : <any>undefined;
        data["noOfYears"] = this.noOfYears;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["negativePaymentAllowed"] = this.negativePaymentAllowed;
        data["code"] = this.code;
        return data; 
    }

    clone(): ManagePayrollTypeDTO {
        const json = this.toJSON();
        let result = new ManagePayrollTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IManagePayrollTypeDTO {
    id: number;
    name: string | undefined;
    frequencyRuleId: number;
    firstPeriodEndDate: Date;
    noOfYears: number;
    effectiveDate: Date;
    negativePaymentAllowed: boolean;
    code: string | undefined;
}

export class EmployeeProfileDTO implements IEmployeeProfileDTO {
    employeeNumber!: string | undefined;
    fullName!: string | undefined;
    employeeId!: number;
    contractId!: number;
    salaryScaleId!: number;
    salaryScale!: string | undefined;
    departmentId!: number;
    department!: string | undefined;
    gradeId!: number;
    grade!: string | undefined;
    employmentTypeId!: number;
    employmentType!: string | undefined;

    constructor(data?: IEmployeeProfileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeNumber = _data["employeeNumber"];
            this.fullName = _data["fullName"];
            this.employeeId = _data["employeeId"];
            this.contractId = _data["contractId"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.salaryScale = _data["salaryScale"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"];
            this.gradeId = _data["gradeId"];
            this.grade = _data["grade"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.employmentType = _data["employmentType"];
        }
    }

    static fromJS(data: any): EmployeeProfileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeProfileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeNumber"] = this.employeeNumber;
        data["fullName"] = this.fullName;
        data["employeeId"] = this.employeeId;
        data["contractId"] = this.contractId;
        data["salaryScaleId"] = this.salaryScaleId;
        data["salaryScale"] = this.salaryScale;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department;
        data["gradeId"] = this.gradeId;
        data["grade"] = this.grade;
        data["employmentTypeId"] = this.employmentTypeId;
        data["employmentType"] = this.employmentType;
        return data; 
    }

    clone(): EmployeeProfileDTO {
        const json = this.toJSON();
        let result = new EmployeeProfileDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeProfileDTO {
    employeeNumber: string | undefined;
    fullName: string | undefined;
    employeeId: number;
    contractId: number;
    salaryScaleId: number;
    salaryScale: string | undefined;
    departmentId: number;
    department: string | undefined;
    gradeId: number;
    grade: string | undefined;
    employmentTypeId: number;
    employmentType: string | undefined;
}

export class PayrollTypeDTO implements IPayrollTypeDTO {
    id!: number;
    company_id!: number;
    sub_id!: number;
    name!: string | undefined;
    frequencyRuleId!: number;
    frequencyRule!: string | undefined;
    firstPeriodEndDate!: Date;
    noOfEmployees!: number;
    noOfYears!: number;
    effectiveDate!: Date;
    negativePaymentAllowed!: boolean;
    code!: string | undefined;
    is_deleted!: boolean;
    is_active!: boolean;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    updated_by!: string | undefined;
    date_created!: Date;
    last_update_created!: Date | undefined;
    employees!: EmployeeProfileDTO[] | undefined;

    constructor(data?: IPayrollTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.sub_id = _data["sub_id"];
            this.name = _data["name"];
            this.frequencyRuleId = _data["frequencyRuleId"];
            this.frequencyRule = _data["frequencyRule"];
            this.firstPeriodEndDate = _data["firstPeriodEndDate"] ? new Date(_data["firstPeriodEndDate"].toString()) : <any>undefined;
            this.noOfEmployees = _data["noOfEmployees"];
            this.noOfYears = _data["noOfYears"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.negativePaymentAllowed = _data["negativePaymentAllowed"];
            this.code = _data["code"];
            this.is_deleted = _data["is_deleted"];
            this.is_active = _data["is_active"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.updated_by = _data["updated_by"];
            this.date_created = _data["date_created"] ? new Date(_data["date_created"].toString()) : <any>undefined;
            this.last_update_created = _data["last_update_created"] ? new Date(_data["last_update_created"].toString()) : <any>undefined;
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(EmployeeProfileDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PayrollTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["sub_id"] = this.sub_id;
        data["name"] = this.name;
        data["frequencyRuleId"] = this.frequencyRuleId;
        data["frequencyRule"] = this.frequencyRule;
        data["firstPeriodEndDate"] = this.firstPeriodEndDate ? this.firstPeriodEndDate.toISOString() : <any>undefined;
        data["noOfEmployees"] = this.noOfEmployees;
        data["noOfYears"] = this.noOfYears;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["negativePaymentAllowed"] = this.negativePaymentAllowed;
        data["code"] = this.code;
        data["is_deleted"] = this.is_deleted;
        data["is_active"] = this.is_active;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["updated_by"] = this.updated_by;
        data["date_created"] = this.date_created ? this.date_created.toISOString() : <any>undefined;
        data["last_update_created"] = this.last_update_created ? this.last_update_created.toISOString() : <any>undefined;
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PayrollTypeDTO {
        const json = this.toJSON();
        let result = new PayrollTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IPayrollTypeDTO {
    id: number;
    company_id: number;
    sub_id: number;
    name: string | undefined;
    frequencyRuleId: number;
    frequencyRule: string | undefined;
    firstPeriodEndDate: Date;
    noOfEmployees: number;
    noOfYears: number;
    effectiveDate: Date;
    negativePaymentAllowed: boolean;
    code: string | undefined;
    is_deleted: boolean;
    is_active: boolean;
    created_by: string | undefined;
    deleted_by: string | undefined;
    updated_by: string | undefined;
    date_created: Date;
    last_update_created: Date | undefined;
    employees: EmployeeProfileDTO[] | undefined;
}

export class PayrollTypeDTOListApiResult implements IPayrollTypeDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayrollTypeDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPayrollTypeDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PayrollTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PayrollTypeDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollTypeDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PayrollTypeDTOListApiResult {
        const json = this.toJSON();
        let result = new PayrollTypeDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayrollTypeDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayrollTypeDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class PayrollTypeDTOApiResult implements IPayrollTypeDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PayrollTypeDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPayrollTypeDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? PayrollTypeDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PayrollTypeDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollTypeDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PayrollTypeDTOApiResult {
        const json = this.toJSON();
        let result = new PayrollTypeDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IPayrollTypeDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PayrollTypeDTO;
    totalCount: number;
    totalRecord: number;
}

export class CycleDTO implements ICycleDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string;
    description!: string;
    instruction!: string | undefined;
    reviewPurposeId!: number;
    appraisalTypeId!: number;
    ratingTypeId!: number;
    minRating!: number | undefined;
    maxRating!: number | undefined;
    departmentId!: number | undefined;
    locationId!: number | undefined;
    unitId!: number | undefined;
    cycleInfo!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    periodUnderReview!: string | undefined;
    lastPeriodUnderReview!: string | undefined;
    dueDate!: Date;
    dateStopped!: Date | undefined;
    frequencyId!: number;
    repeatKPI!: boolean;
    isNotify!: boolean;
    employeeCanSignOffOnManager!: boolean;
    recommendators!: string | undefined;
    commendators!: string | undefined;
    isStopped!: boolean;
    isManualSupervisorSetup!: boolean;
    status!: number;
    log_status!: number;
    approvalProcessId!: number;
    dateApproved!: Date | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    readonly statusType!: string | undefined;
    readonly reviewPurpose!: string | undefined;
    readonly appraisalType!: string | undefined;
    readonly ratingType!: string | undefined;

    constructor(data?: ICycleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.instruction = _data["instruction"];
            this.reviewPurposeId = _data["reviewPurposeId"];
            this.appraisalTypeId = _data["appraisalTypeId"];
            this.ratingTypeId = _data["ratingTypeId"];
            this.minRating = _data["minRating"];
            this.maxRating = _data["maxRating"];
            this.departmentId = _data["departmentId"];
            this.locationId = _data["locationId"];
            this.unitId = _data["unitId"];
            this.cycleInfo = _data["cycleInfo"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.periodUnderReview = _data["periodUnderReview"];
            this.lastPeriodUnderReview = _data["lastPeriodUnderReview"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.dateStopped = _data["dateStopped"] ? new Date(_data["dateStopped"].toString()) : <any>undefined;
            this.frequencyId = _data["frequencyId"];
            this.repeatKPI = _data["repeatKPI"];
            this.isNotify = _data["isNotify"];
            this.employeeCanSignOffOnManager = _data["employeeCanSignOffOnManager"];
            this.recommendators = _data["recommendators"];
            this.commendators = _data["commendators"];
            this.isStopped = _data["isStopped"];
            this.isManualSupervisorSetup = _data["isManualSupervisorSetup"];
            this.status = _data["status"];
            this.log_status = _data["log_status"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            (<any>this).statusType = _data["statusType"];
            (<any>this).reviewPurpose = _data["reviewPurpose"];
            (<any>this).appraisalType = _data["appraisalType"];
            (<any>this).ratingType = _data["ratingType"];
        }
    }

    static fromJS(data: any): CycleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CycleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["instruction"] = this.instruction;
        data["reviewPurposeId"] = this.reviewPurposeId;
        data["appraisalTypeId"] = this.appraisalTypeId;
        data["ratingTypeId"] = this.ratingTypeId;
        data["minRating"] = this.minRating;
        data["maxRating"] = this.maxRating;
        data["departmentId"] = this.departmentId;
        data["locationId"] = this.locationId;
        data["unitId"] = this.unitId;
        data["cycleInfo"] = this.cycleInfo;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["periodUnderReview"] = this.periodUnderReview;
        data["lastPeriodUnderReview"] = this.lastPeriodUnderReview;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["dateStopped"] = this.dateStopped ? this.dateStopped.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["repeatKPI"] = this.repeatKPI;
        data["isNotify"] = this.isNotify;
        data["employeeCanSignOffOnManager"] = this.employeeCanSignOffOnManager;
        data["recommendators"] = this.recommendators;
        data["commendators"] = this.commendators;
        data["isStopped"] = this.isStopped;
        data["isManualSupervisorSetup"] = this.isManualSupervisorSetup;
        data["status"] = this.status;
        data["log_status"] = this.log_status;
        data["approvalProcessId"] = this.approvalProcessId;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["statusType"] = this.statusType;
        data["reviewPurpose"] = this.reviewPurpose;
        data["appraisalType"] = this.appraisalType;
        data["ratingType"] = this.ratingType;
        return data; 
    }

    clone(): CycleDTO {
        const json = this.toJSON();
        let result = new CycleDTO();
        result.init(json);
        return result;
    }
}

export interface ICycleDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string;
    description: string;
    instruction: string | undefined;
    reviewPurposeId: number;
    appraisalTypeId: number;
    ratingTypeId: number;
    minRating: number | undefined;
    maxRating: number | undefined;
    departmentId: number | undefined;
    locationId: number | undefined;
    unitId: number | undefined;
    cycleInfo: string | undefined;
    startDate: Date;
    endDate: Date;
    periodUnderReview: string | undefined;
    lastPeriodUnderReview: string | undefined;
    dueDate: Date;
    dateStopped: Date | undefined;
    frequencyId: number;
    repeatKPI: boolean;
    isNotify: boolean;
    employeeCanSignOffOnManager: boolean;
    recommendators: string | undefined;
    commendators: string | undefined;
    isStopped: boolean;
    isManualSupervisorSetup: boolean;
    status: number;
    log_status: number;
    approvalProcessId: number;
    dateApproved: Date | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    statusType: string | undefined;
    reviewPurpose: string | undefined;
    appraisalType: string | undefined;
    ratingType: string | undefined;
}

export class CycleDTOIListApiResult implements ICycleDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CycleDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICycleDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CycleDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CycleDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CycleDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CycleDTOIListApiResult {
        const json = this.toJSON();
        let result = new CycleDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICycleDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CycleDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class CycleDTOApiResult implements ICycleDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CycleDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICycleDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? CycleDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CycleDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CycleDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CycleDTOApiResult {
        const json = this.toJSON();
        let result = new CycleDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ICycleDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CycleDTO;
    totalCount: number;
    totalRecord: number;
}

export class ManageCycleDTO implements IManageCycleDTO {
    id!: number;
    name!: string;
    description!: string;
    instructions!: string | undefined;
    reviewPurposeId!: number;
    appraisalTypeId!: number;
    ratingTypeId!: number;
    minRating!: number | undefined;
    maxRating!: number | undefined;
    departmentId!: number | undefined;
    locationId!: number | undefined;
    unitId!: number | undefined;
    cycleInfo!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    periodUnderReview!: string | undefined;
    lastPeriodUnderReview!: string | undefined;
    dueDate!: Date;
    isActive!: boolean;

    constructor(data?: IManageCycleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.instructions = _data["instructions"];
            this.reviewPurposeId = _data["reviewPurposeId"];
            this.appraisalTypeId = _data["appraisalTypeId"];
            this.ratingTypeId = _data["ratingTypeId"];
            this.minRating = _data["minRating"];
            this.maxRating = _data["maxRating"];
            this.departmentId = _data["departmentId"];
            this.locationId = _data["locationId"];
            this.unitId = _data["unitId"];
            this.cycleInfo = _data["cycleInfo"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.periodUnderReview = _data["periodUnderReview"];
            this.lastPeriodUnderReview = _data["lastPeriodUnderReview"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ManageCycleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageCycleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["instructions"] = this.instructions;
        data["reviewPurposeId"] = this.reviewPurposeId;
        data["appraisalTypeId"] = this.appraisalTypeId;
        data["ratingTypeId"] = this.ratingTypeId;
        data["minRating"] = this.minRating;
        data["maxRating"] = this.maxRating;
        data["departmentId"] = this.departmentId;
        data["locationId"] = this.locationId;
        data["unitId"] = this.unitId;
        data["cycleInfo"] = this.cycleInfo;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["periodUnderReview"] = this.periodUnderReview;
        data["lastPeriodUnderReview"] = this.lastPeriodUnderReview;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ManageCycleDTO {
        const json = this.toJSON();
        let result = new ManageCycleDTO();
        result.init(json);
        return result;
    }
}

export interface IManageCycleDTO {
    id: number;
    name: string;
    description: string;
    instructions: string | undefined;
    reviewPurposeId: number;
    appraisalTypeId: number;
    ratingTypeId: number;
    minRating: number | undefined;
    maxRating: number | undefined;
    departmentId: number | undefined;
    locationId: number | undefined;
    unitId: number | undefined;
    cycleInfo: string | undefined;
    startDate: Date;
    endDate: Date;
    periodUnderReview: string | undefined;
    lastPeriodUnderReview: string | undefined;
    dueDate: Date;
    isActive: boolean;
}

export class ManagePositionDTO implements IManagePositionDTO {
    id!: number;
    title!: string;
    description!: string;
    basic_salary!: number | undefined;
    promotion_min_years!: number | undefined;
    min_years_experience!: number | undefined;
    parent_id!: number | undefined;
    next_position_id!: number | undefined;
    selectedQualifications!: string | undefined;
    selectedCertifications!: string | undefined;

    constructor(data?: IManagePositionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.basic_salary = _data["basic_salary"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.min_years_experience = _data["min_years_experience"];
            this.parent_id = _data["parent_id"];
            this.next_position_id = _data["next_position_id"];
            this.selectedQualifications = _data["selectedQualifications"];
            this.selectedCertifications = _data["selectedCertifications"];
        }
    }

    static fromJS(data: any): ManagePositionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManagePositionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["basic_salary"] = this.basic_salary;
        data["promotion_min_years"] = this.promotion_min_years;
        data["min_years_experience"] = this.min_years_experience;
        data["parent_id"] = this.parent_id;
        data["next_position_id"] = this.next_position_id;
        data["selectedQualifications"] = this.selectedQualifications;
        data["selectedCertifications"] = this.selectedCertifications;
        return data; 
    }

    clone(): ManagePositionDTO {
        const json = this.toJSON();
        let result = new ManagePositionDTO();
        result.init(json);
        return result;
    }
}

export interface IManagePositionDTO {
    id: number;
    title: string;
    description: string;
    basic_salary: number | undefined;
    promotion_min_years: number | undefined;
    min_years_experience: number | undefined;
    parent_id: number | undefined;
    next_position_id: number | undefined;
    selectedQualifications: string | undefined;
    selectedCertifications: string | undefined;
}

export class PositionDTO implements IPositionDTO {
    id!: number;
    title!: string | undefined;
    description!: string | undefined;
    companyID!: number;
    subID!: number;
    basic_salary!: number | undefined;
    promotion_min_years!: number | undefined;
    min_years_experience!: number | undefined;
    parent_id!: number | undefined;
    next_position_id!: number | undefined;
    next_position!: string | undefined;
    parent_position!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    positionRequirements!: PositionRequirement[] | undefined;

    constructor(data?: IPositionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.basic_salary = _data["basic_salary"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.min_years_experience = _data["min_years_experience"];
            this.parent_id = _data["parent_id"];
            this.next_position_id = _data["next_position_id"];
            this.next_position = _data["next_position"];
            this.parent_position = _data["parent_position"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            if (Array.isArray(_data["positionRequirements"])) {
                this.positionRequirements = [] as any;
                for (let item of _data["positionRequirements"])
                    this.positionRequirements!.push(PositionRequirement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PositionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PositionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["basic_salary"] = this.basic_salary;
        data["promotion_min_years"] = this.promotion_min_years;
        data["min_years_experience"] = this.min_years_experience;
        data["parent_id"] = this.parent_id;
        data["next_position_id"] = this.next_position_id;
        data["next_position"] = this.next_position;
        data["parent_position"] = this.parent_position;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        if (Array.isArray(this.positionRequirements)) {
            data["positionRequirements"] = [];
            for (let item of this.positionRequirements)
                data["positionRequirements"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PositionDTO {
        const json = this.toJSON();
        let result = new PositionDTO();
        result.init(json);
        return result;
    }
}

export interface IPositionDTO {
    id: number;
    title: string | undefined;
    description: string | undefined;
    companyID: number;
    subID: number;
    basic_salary: number | undefined;
    promotion_min_years: number | undefined;
    min_years_experience: number | undefined;
    parent_id: number | undefined;
    next_position_id: number | undefined;
    next_position: string | undefined;
    parent_position: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    positionRequirements: PositionRequirement[] | undefined;
}

export class PositionDTOListApiResult implements IPositionDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PositionDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPositionDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PositionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PositionDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PositionDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PositionDTOListApiResult {
        const json = this.toJSON();
        let result = new PositionDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPositionDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PositionDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class PositionDTOApiResult implements IPositionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PositionDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPositionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? PositionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PositionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PositionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PositionDTOApiResult {
        const json = this.toJSON();
        let result = new PositionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IPositionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PositionDTO;
    totalCount: number;
    totalRecord: number;
}

export class ManageProfessionalBodyDTO implements IManageProfessionalBodyDTO {
    id!: number;
    sectorId!: number;
    name!: string | undefined;
    code!: string | undefined;
    website!: string | undefined;

    constructor(data?: IManageProfessionalBodyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sectorId = _data["sectorId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.website = _data["website"];
        }
    }

    static fromJS(data: any): ManageProfessionalBodyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageProfessionalBodyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sectorId"] = this.sectorId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["website"] = this.website;
        return data; 
    }

    clone(): ManageProfessionalBodyDTO {
        const json = this.toJSON();
        let result = new ManageProfessionalBodyDTO();
        result.init(json);
        return result;
    }
}

export interface IManageProfessionalBodyDTO {
    id: number;
    sectorId: number;
    name: string | undefined;
    code: string | undefined;
    website: string | undefined;
}

export class ProfessionalBodyDTO implements IProfessionalBodyDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    sectorId!: number;
    sector!: string | undefined;
    name!: string | undefined;
    code!: string | undefined;
    website!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IProfessionalBodyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.sectorId = _data["sectorId"];
            this.sector = _data["sector"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.website = _data["website"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ProfessionalBodyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalBodyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["sectorId"] = this.sectorId;
        data["sector"] = this.sector;
        data["name"] = this.name;
        data["code"] = this.code;
        data["website"] = this.website;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ProfessionalBodyDTO {
        const json = this.toJSON();
        let result = new ProfessionalBodyDTO();
        result.init(json);
        return result;
    }
}

export interface IProfessionalBodyDTO {
    id: number;
    companyID: number;
    subID: number;
    sectorId: number;
    sector: string | undefined;
    name: string | undefined;
    code: string | undefined;
    website: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ProfessionalBodyDTOListApiResult implements IProfessionalBodyDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ProfessionalBodyDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IProfessionalBodyDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ProfessionalBodyDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ProfessionalBodyDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalBodyDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ProfessionalBodyDTOListApiResult {
        const json = this.toJSON();
        let result = new ProfessionalBodyDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IProfessionalBodyDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ProfessionalBodyDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ProfessionalBodyDTOApiResult implements IProfessionalBodyDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ProfessionalBodyDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IProfessionalBodyDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? ProfessionalBodyDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ProfessionalBodyDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalBodyDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ProfessionalBodyDTOApiResult {
        const json = this.toJSON();
        let result = new ProfessionalBodyDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IProfessionalBodyDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ProfessionalBodyDTO;
    totalCount: number;
    totalRecord: number;
}

export class SelectListGroup implements ISelectListGroup {
    disabled!: boolean;
    name!: string | undefined;

    constructor(data?: ISelectListGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SelectListGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["name"] = this.name;
        return data; 
    }

    clone(): SelectListGroup {
        const json = this.toJSON();
        let result = new SelectListGroup();
        result.init(json);
        return result;
    }
}

export interface ISelectListGroup {
    disabled: boolean;
    name: string | undefined;
}

export class SelectListItem implements ISelectListItem {
    disabled!: boolean;
    group!: SelectListGroup;
    selected!: boolean;
    text!: string | undefined;
    value!: string | undefined;

    constructor(data?: ISelectListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.group = _data["group"] ? SelectListGroup.fromJS(_data["group"]) : <any>undefined;
            this.selected = _data["selected"];
            this.text = _data["text"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SelectListItem {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["selected"] = this.selected;
        data["text"] = this.text;
        data["value"] = this.value;
        return data; 
    }

    clone(): SelectListItem {
        const json = this.toJSON();
        let result = new SelectListItem();
        result.init(json);
        return result;
    }
}

export interface ISelectListItem {
    disabled: boolean;
    group: SelectListGroup;
    selected: boolean;
    text: string | undefined;
    value: string | undefined;
}

export class Sp_FetchEligibleEmployees implements ISp_FetchEligibleEmployees {
    current_position_id!: number | undefined;
    current_position!: string | undefined;
    period_in_current_postion!: string | undefined;
    years_in_current_position!: number | undefined;
    next_position!: string | undefined;
    next_position_id!: number | undefined;
    current_position_parent_id!: number | undefined;
    current_parent_position!: string | undefined;
    current_grade_id!: number | undefined;
    current_grade!: string | undefined;
    salaryScale!: string | undefined;
    comments!: string | undefined;
    id!: number | undefined;
    employee_id!: number | undefined;
    employee_name!: string | undefined;
    employee_contract_id!: number;
    eligiblility_id!: number | undefined;
    date_of_appointment!: Date | undefined;
    date_of_birth!: Date | undefined;
    date_of_confirmation!: Date | undefined;
    first_name!: string | undefined;
    last_name!: string | undefined;
    other_names!: string | undefined;
    profile_pic!: string | undefined;
    last_promotion_date!: Date | undefined;
    period_in_current_grade!: string | undefined;
    years_in_current_grade!: number | undefined;
    oracle_no!: string | undefined;
    professional_qualifications!: number | undefined;
    department!: string | undefined;
    location!: string | undefined;
    job_role!: string | undefined;
    is_submitted!: boolean;
    is_selected!: boolean;
    date_submitted!: Date | undefined;
    current_step!: string | undefined;
    current_step_id!: number | undefined;
    current_step_no!: number;
    next_grade!: string | undefined;
    next_step!: string | undefined;
    next_step_id!: number | undefined;
    salaryScaleId!: number | undefined;
    log_status!: string | undefined;
    log_status_id!: number;
    effective_date!: Date | undefined;
    str_effective_date!: string | undefined;

    constructor(data?: ISp_FetchEligibleEmployees) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.current_position_id = _data["current_position_id"];
            this.current_position = _data["current_position"];
            this.period_in_current_postion = _data["period_in_current_postion"];
            this.years_in_current_position = _data["years_in_current_position"];
            this.next_position = _data["next_position"];
            this.next_position_id = _data["next_position_id"];
            this.current_position_parent_id = _data["current_position_parent_id"];
            this.current_parent_position = _data["current_parent_position"];
            this.current_grade_id = _data["current_grade_id"];
            this.current_grade = _data["current_grade"];
            this.salaryScale = _data["salaryScale"];
            this.comments = _data["comments"];
            this.id = _data["id"];
            this.employee_id = _data["employee_id"];
            this.employee_name = _data["employee_name"];
            this.employee_contract_id = _data["employee_contract_id"];
            this.eligiblility_id = _data["eligiblility_id"];
            this.date_of_appointment = _data["date_of_appointment"] ? new Date(_data["date_of_appointment"].toString()) : <any>undefined;
            this.date_of_birth = _data["date_of_birth"] ? new Date(_data["date_of_birth"].toString()) : <any>undefined;
            this.date_of_confirmation = _data["date_of_confirmation"] ? new Date(_data["date_of_confirmation"].toString()) : <any>undefined;
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            this.other_names = _data["other_names"];
            this.profile_pic = _data["profile_pic"];
            this.last_promotion_date = _data["last_promotion_date"] ? new Date(_data["last_promotion_date"].toString()) : <any>undefined;
            this.period_in_current_grade = _data["period_in_current_grade"];
            this.years_in_current_grade = _data["years_in_current_grade"];
            this.oracle_no = _data["oracle_no"];
            this.professional_qualifications = _data["professional_qualifications"];
            this.department = _data["department"];
            this.location = _data["location"];
            this.job_role = _data["job_role"];
            this.is_submitted = _data["is_submitted"];
            this.is_selected = _data["is_selected"];
            this.date_submitted = _data["date_submitted"] ? new Date(_data["date_submitted"].toString()) : <any>undefined;
            this.current_step = _data["current_step"];
            this.current_step_id = _data["current_step_id"];
            this.current_step_no = _data["current_step_no"];
            this.next_grade = _data["next_grade"];
            this.next_step = _data["next_step"];
            this.next_step_id = _data["next_step_id"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.log_status = _data["log_status"];
            this.log_status_id = _data["log_status_id"];
            this.effective_date = _data["effective_date"] ? new Date(_data["effective_date"].toString()) : <any>undefined;
            this.str_effective_date = _data["str_effective_date"];
        }
    }

    static fromJS(data: any): Sp_FetchEligibleEmployees {
        data = typeof data === 'object' ? data : {};
        let result = new Sp_FetchEligibleEmployees();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["current_position_id"] = this.current_position_id;
        data["current_position"] = this.current_position;
        data["period_in_current_postion"] = this.period_in_current_postion;
        data["years_in_current_position"] = this.years_in_current_position;
        data["next_position"] = this.next_position;
        data["next_position_id"] = this.next_position_id;
        data["current_position_parent_id"] = this.current_position_parent_id;
        data["current_parent_position"] = this.current_parent_position;
        data["current_grade_id"] = this.current_grade_id;
        data["current_grade"] = this.current_grade;
        data["salaryScale"] = this.salaryScale;
        data["comments"] = this.comments;
        data["id"] = this.id;
        data["employee_id"] = this.employee_id;
        data["employee_name"] = this.employee_name;
        data["employee_contract_id"] = this.employee_contract_id;
        data["eligiblility_id"] = this.eligiblility_id;
        data["date_of_appointment"] = this.date_of_appointment ? this.date_of_appointment.toISOString() : <any>undefined;
        data["date_of_birth"] = this.date_of_birth ? this.date_of_birth.toISOString() : <any>undefined;
        data["date_of_confirmation"] = this.date_of_confirmation ? this.date_of_confirmation.toISOString() : <any>undefined;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["other_names"] = this.other_names;
        data["profile_pic"] = this.profile_pic;
        data["last_promotion_date"] = this.last_promotion_date ? this.last_promotion_date.toISOString() : <any>undefined;
        data["period_in_current_grade"] = this.period_in_current_grade;
        data["years_in_current_grade"] = this.years_in_current_grade;
        data["oracle_no"] = this.oracle_no;
        data["professional_qualifications"] = this.professional_qualifications;
        data["department"] = this.department;
        data["location"] = this.location;
        data["job_role"] = this.job_role;
        data["is_submitted"] = this.is_submitted;
        data["is_selected"] = this.is_selected;
        data["date_submitted"] = this.date_submitted ? this.date_submitted.toISOString() : <any>undefined;
        data["current_step"] = this.current_step;
        data["current_step_id"] = this.current_step_id;
        data["current_step_no"] = this.current_step_no;
        data["next_grade"] = this.next_grade;
        data["next_step"] = this.next_step;
        data["next_step_id"] = this.next_step_id;
        data["salaryScaleId"] = this.salaryScaleId;
        data["log_status"] = this.log_status;
        data["log_status_id"] = this.log_status_id;
        data["effective_date"] = this.effective_date ? this.effective_date.toISOString() : <any>undefined;
        data["str_effective_date"] = this.str_effective_date;
        return data; 
    }

    clone(): Sp_FetchEligibleEmployees {
        const json = this.toJSON();
        let result = new Sp_FetchEligibleEmployees();
        result.init(json);
        return result;
    }
}

export interface ISp_FetchEligibleEmployees {
    current_position_id: number | undefined;
    current_position: string | undefined;
    period_in_current_postion: string | undefined;
    years_in_current_position: number | undefined;
    next_position: string | undefined;
    next_position_id: number | undefined;
    current_position_parent_id: number | undefined;
    current_parent_position: string | undefined;
    current_grade_id: number | undefined;
    current_grade: string | undefined;
    salaryScale: string | undefined;
    comments: string | undefined;
    id: number | undefined;
    employee_id: number | undefined;
    employee_name: string | undefined;
    employee_contract_id: number;
    eligiblility_id: number | undefined;
    date_of_appointment: Date | undefined;
    date_of_birth: Date | undefined;
    date_of_confirmation: Date | undefined;
    first_name: string | undefined;
    last_name: string | undefined;
    other_names: string | undefined;
    profile_pic: string | undefined;
    last_promotion_date: Date | undefined;
    period_in_current_grade: string | undefined;
    years_in_current_grade: number | undefined;
    oracle_no: string | undefined;
    professional_qualifications: number | undefined;
    department: string | undefined;
    location: string | undefined;
    job_role: string | undefined;
    is_submitted: boolean;
    is_selected: boolean;
    date_submitted: Date | undefined;
    current_step: string | undefined;
    current_step_id: number | undefined;
    current_step_no: number;
    next_grade: string | undefined;
    next_step: string | undefined;
    next_step_id: number | undefined;
    salaryScaleId: number | undefined;
    log_status: string | undefined;
    log_status_id: number;
    effective_date: Date | undefined;
    str_effective_date: string | undefined;
}

export class PromotionEligibilityViewModel implements IPromotionEligibilityViewModel {
    id!: number;
    company_id!: number;
    subsidiary_id!: number;
    name!: string;
    date_generated!: Date;
    generated_by!: string | undefined;
    submitted_by!: string | undefined;
    is_closed!: boolean;
    date_closed!: Date | undefined;
    closed_by!: string | undefined;
    comments!: string;
    noOfMembers!: number;
    is_active!: boolean;
    approvalProcessId!: number | undefined;
    actionTitle!: string | undefined;
    eligiblesEmployees!: string | undefined;
    approvalWorkFlows!: SelectListItem[] | undefined;
    eligibles!: Sp_FetchEligibleEmployees[] | undefined;
    readonly strDateGenerated!: string | undefined;
    readonly isClosed!: string | undefined;
    readonly strDateClosed!: string | undefined;

    constructor(data?: IPromotionEligibilityViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.subsidiary_id = _data["subsidiary_id"];
            this.name = _data["name"];
            this.date_generated = _data["date_generated"] ? new Date(_data["date_generated"].toString()) : <any>undefined;
            this.generated_by = _data["generated_by"];
            this.submitted_by = _data["submitted_by"];
            this.is_closed = _data["is_closed"];
            this.date_closed = _data["date_closed"] ? new Date(_data["date_closed"].toString()) : <any>undefined;
            this.closed_by = _data["closed_by"];
            this.comments = _data["comments"];
            this.noOfMembers = _data["noOfMembers"];
            this.is_active = _data["is_active"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.actionTitle = _data["actionTitle"];
            this.eligiblesEmployees = _data["eligiblesEmployees"];
            if (Array.isArray(_data["approvalWorkFlows"])) {
                this.approvalWorkFlows = [] as any;
                for (let item of _data["approvalWorkFlows"])
                    this.approvalWorkFlows!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["eligibles"])) {
                this.eligibles = [] as any;
                for (let item of _data["eligibles"])
                    this.eligibles!.push(Sp_FetchEligibleEmployees.fromJS(item));
            }
            (<any>this).strDateGenerated = _data["strDateGenerated"];
            (<any>this).isClosed = _data["isClosed"];
            (<any>this).strDateClosed = _data["strDateClosed"];
        }
    }

    static fromJS(data: any): PromotionEligibilityViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionEligibilityViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["subsidiary_id"] = this.subsidiary_id;
        data["name"] = this.name;
        data["date_generated"] = this.date_generated ? this.date_generated.toISOString() : <any>undefined;
        data["generated_by"] = this.generated_by;
        data["submitted_by"] = this.submitted_by;
        data["is_closed"] = this.is_closed;
        data["date_closed"] = this.date_closed ? this.date_closed.toISOString() : <any>undefined;
        data["closed_by"] = this.closed_by;
        data["comments"] = this.comments;
        data["noOfMembers"] = this.noOfMembers;
        data["is_active"] = this.is_active;
        data["approvalProcessId"] = this.approvalProcessId;
        data["actionTitle"] = this.actionTitle;
        data["eligiblesEmployees"] = this.eligiblesEmployees;
        if (Array.isArray(this.approvalWorkFlows)) {
            data["approvalWorkFlows"] = [];
            for (let item of this.approvalWorkFlows)
                data["approvalWorkFlows"].push(item.toJSON());
        }
        if (Array.isArray(this.eligibles)) {
            data["eligibles"] = [];
            for (let item of this.eligibles)
                data["eligibles"].push(item.toJSON());
        }
        data["strDateGenerated"] = this.strDateGenerated;
        data["isClosed"] = this.isClosed;
        data["strDateClosed"] = this.strDateClosed;
        return data; 
    }

    clone(): PromotionEligibilityViewModel {
        const json = this.toJSON();
        let result = new PromotionEligibilityViewModel();
        result.init(json);
        return result;
    }
}

export interface IPromotionEligibilityViewModel {
    id: number;
    company_id: number;
    subsidiary_id: number;
    name: string;
    date_generated: Date;
    generated_by: string | undefined;
    submitted_by: string | undefined;
    is_closed: boolean;
    date_closed: Date | undefined;
    closed_by: string | undefined;
    comments: string;
    noOfMembers: number;
    is_active: boolean;
    approvalProcessId: number | undefined;
    actionTitle: string | undefined;
    eligiblesEmployees: string | undefined;
    approvalWorkFlows: SelectListItem[] | undefined;
    eligibles: Sp_FetchEligibleEmployees[] | undefined;
    strDateGenerated: string | undefined;
    isClosed: string | undefined;
    strDateClosed: string | undefined;
}

export class PromotionLog implements IPromotionLog {
    employee_contract_id!: number;
    current_grade!: string | undefined;
    new_grade!: string | undefined;
    current_step_id!: number | undefined;
    next_step_id!: number | undefined;
    period_in_current_grade!: string | undefined;
    current_position_id!: number | undefined;
    next_position_id!: number | undefined;
    period_in_current_position!: string | undefined;
    log_status!: number;
    bulkaction_id!: number | undefined;
    notional_date!: Date | undefined;
    effective_date!: Date | undefined;
    eligibility_id!: number;
    is_submitted!: boolean;
    date_submitted!: Date | undefined;
    submitted_by!: string | undefined;
    last_promotion_date!: Date | undefined;
    professional_qualifications!: number;
    department!: string | undefined;
    location!: string | undefined;
    job_role!: string | undefined;
    is_treated!: boolean | undefined;
    mail_sent!: number;
    date_deleted!: Date | undefined;
    deleted_by!: string | undefined;
    timestamp!: Date | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IPromotionLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employee_contract_id = _data["employee_contract_id"];
            this.current_grade = _data["current_grade"];
            this.new_grade = _data["new_grade"];
            this.current_step_id = _data["current_step_id"];
            this.next_step_id = _data["next_step_id"];
            this.period_in_current_grade = _data["period_in_current_grade"];
            this.current_position_id = _data["current_position_id"];
            this.next_position_id = _data["next_position_id"];
            this.period_in_current_position = _data["period_in_current_position"];
            this.log_status = _data["log_status"];
            this.bulkaction_id = _data["bulkaction_id"];
            this.notional_date = _data["notional_date"] ? new Date(_data["notional_date"].toString()) : <any>undefined;
            this.effective_date = _data["effective_date"] ? new Date(_data["effective_date"].toString()) : <any>undefined;
            this.eligibility_id = _data["eligibility_id"];
            this.is_submitted = _data["is_submitted"];
            this.date_submitted = _data["date_submitted"] ? new Date(_data["date_submitted"].toString()) : <any>undefined;
            this.submitted_by = _data["submitted_by"];
            this.last_promotion_date = _data["last_promotion_date"] ? new Date(_data["last_promotion_date"].toString()) : <any>undefined;
            this.professional_qualifications = _data["professional_qualifications"];
            this.department = _data["department"];
            this.location = _data["location"];
            this.job_role = _data["job_role"];
            this.is_treated = _data["is_treated"];
            this.mail_sent = _data["mail_sent"];
            this.date_deleted = _data["date_deleted"] ? new Date(_data["date_deleted"].toString()) : <any>undefined;
            this.deleted_by = _data["deleted_by"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): PromotionLog {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employee_contract_id"] = this.employee_contract_id;
        data["current_grade"] = this.current_grade;
        data["new_grade"] = this.new_grade;
        data["current_step_id"] = this.current_step_id;
        data["next_step_id"] = this.next_step_id;
        data["period_in_current_grade"] = this.period_in_current_grade;
        data["current_position_id"] = this.current_position_id;
        data["next_position_id"] = this.next_position_id;
        data["period_in_current_position"] = this.period_in_current_position;
        data["log_status"] = this.log_status;
        data["bulkaction_id"] = this.bulkaction_id;
        data["notional_date"] = this.notional_date ? this.notional_date.toISOString() : <any>undefined;
        data["effective_date"] = this.effective_date ? this.effective_date.toISOString() : <any>undefined;
        data["eligibility_id"] = this.eligibility_id;
        data["is_submitted"] = this.is_submitted;
        data["date_submitted"] = this.date_submitted ? this.date_submitted.toISOString() : <any>undefined;
        data["submitted_by"] = this.submitted_by;
        data["last_promotion_date"] = this.last_promotion_date ? this.last_promotion_date.toISOString() : <any>undefined;
        data["professional_qualifications"] = this.professional_qualifications;
        data["department"] = this.department;
        data["location"] = this.location;
        data["job_role"] = this.job_role;
        data["is_treated"] = this.is_treated;
        data["mail_sent"] = this.mail_sent;
        data["date_deleted"] = this.date_deleted ? this.date_deleted.toISOString() : <any>undefined;
        data["deleted_by"] = this.deleted_by;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): PromotionLog {
        const json = this.toJSON();
        let result = new PromotionLog();
        result.init(json);
        return result;
    }
}

export interface IPromotionLog {
    employee_contract_id: number;
    current_grade: string | undefined;
    new_grade: string | undefined;
    current_step_id: number | undefined;
    next_step_id: number | undefined;
    period_in_current_grade: string | undefined;
    current_position_id: number | undefined;
    next_position_id: number | undefined;
    period_in_current_position: string | undefined;
    log_status: number;
    bulkaction_id: number | undefined;
    notional_date: Date | undefined;
    effective_date: Date | undefined;
    eligibility_id: number;
    is_submitted: boolean;
    date_submitted: Date | undefined;
    submitted_by: string | undefined;
    last_promotion_date: Date | undefined;
    professional_qualifications: number;
    department: string | undefined;
    location: string | undefined;
    job_role: string | undefined;
    is_treated: boolean | undefined;
    mail_sent: number;
    date_deleted: Date | undefined;
    deleted_by: string | undefined;
    timestamp: Date | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class PromotionLogIListApiResult implements IPromotionLogIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PromotionLog[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPromotionLogIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PromotionLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PromotionLogIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionLogIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PromotionLogIListApiResult {
        const json = this.toJSON();
        let result = new PromotionLogIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPromotionLogIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PromotionLog[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class PromotionEligibilityViewModelIListApiResult implements IPromotionEligibilityViewModelIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PromotionEligibilityViewModel[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IPromotionEligibilityViewModelIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PromotionEligibilityViewModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): PromotionEligibilityViewModelIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionEligibilityViewModelIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): PromotionEligibilityViewModelIListApiResult {
        const json = this.toJSON();
        let result = new PromotionEligibilityViewModelIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPromotionEligibilityViewModelIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PromotionEligibilityViewModel[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class Sp_FetchEligibleEmployeesIListApiResult implements ISp_FetchEligibleEmployeesIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Sp_FetchEligibleEmployees[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISp_FetchEligibleEmployeesIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Sp_FetchEligibleEmployees.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): Sp_FetchEligibleEmployeesIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new Sp_FetchEligibleEmployeesIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): Sp_FetchEligibleEmployeesIListApiResult {
        const json = this.toJSON();
        let result = new Sp_FetchEligibleEmployeesIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISp_FetchEligibleEmployeesIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Sp_FetchEligibleEmployees[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ManageQualificationDTO implements IManageQualificationDTO {
    id!: number;
    categoryId!: number;
    name!: string;
    code!: string | undefined;
    point!: number | undefined;

    constructor(data?: IManageQualificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
        }
    }

    static fromJS(data: any): ManageQualificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageQualificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        return data; 
    }

    clone(): ManageQualificationDTO {
        const json = this.toJSON();
        let result = new ManageQualificationDTO();
        result.init(json);
        return result;
    }
}

export interface IManageQualificationDTO {
    id: number;
    categoryId: number;
    name: string;
    code: string | undefined;
    point: number | undefined;
}

export class QualificationDTO implements IQualificationDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    categoryId!: number;
    category!: string | undefined;
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IQualificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): QualificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QualificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): QualificationDTO {
        const json = this.toJSON();
        let result = new QualificationDTO();
        result.init(json);
        return result;
    }
}

export interface IQualificationDTO {
    id: number;
    companyID: number;
    subID: number;
    categoryId: number;
    category: string | undefined;
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class QualificationDTOListApiResult implements IQualificationDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: QualificationDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IQualificationDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(QualificationDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): QualificationDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new QualificationDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): QualificationDTOListApiResult {
        const json = this.toJSON();
        let result = new QualificationDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IQualificationDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: QualificationDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class QualificationDTOApiResult implements IQualificationDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: QualificationDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IQualificationDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? QualificationDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): QualificationDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new QualificationDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): QualificationDTOApiResult {
        const json = this.toJSON();
        let result = new QualificationDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IQualificationDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: QualificationDTO;
    totalCount: number;
    totalRecord: number;
}

export class RatingDTO implements IRatingDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    scoreFrom!: number;
    scoreTo!: number;
    grade!: string | undefined;
    description!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRatingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.scoreFrom = _data["scoreFrom"];
            this.scoreTo = _data["scoreTo"];
            this.grade = _data["grade"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RatingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RatingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["scoreFrom"] = this.scoreFrom;
        data["scoreTo"] = this.scoreTo;
        data["grade"] = this.grade;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RatingDTO {
        const json = this.toJSON();
        let result = new RatingDTO();
        result.init(json);
        return result;
    }
}

export interface IRatingDTO {
    id: number;
    companyID: number;
    subID: number;
    scoreFrom: number;
    scoreTo: number;
    grade: string | undefined;
    description: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RatingDTOIListApiResult implements IRatingDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RatingDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRatingDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RatingDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RatingDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RatingDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RatingDTOIListApiResult {
        const json = this.toJSON();
        let result = new RatingDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRatingDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RatingDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ManageJobDTO implements IManageJobDTO {
    id!: number;
    position!: string | undefined;
    departmentId!: number;
    countryId!: number;
    stateId!: number;
    location!: string | undefined;
    description!: string | undefined;
    requirements!: string | undefined;
    ref!: string | undefined;
    jobAvailabilityId!: number;
    employmentTypeId!: number;
    experience!: number;
    minQualificationId!: number;
    maxQualificationId!: number;
    currency!: string | undefined;
    minSalary!: number | undefined;
    maxSalary!: number | undefined;
    scoreCardId!: number | undefined;

    constructor(data?: IManageJobDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.position = _data["position"];
            this.departmentId = _data["departmentId"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.location = _data["location"];
            this.description = _data["description"];
            this.requirements = _data["requirements"];
            this.ref = _data["ref"];
            this.jobAvailabilityId = _data["jobAvailabilityId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.experience = _data["experience"];
            this.minQualificationId = _data["minQualificationId"];
            this.maxQualificationId = _data["maxQualificationId"];
            this.currency = _data["currency"];
            this.minSalary = _data["minSalary"];
            this.maxSalary = _data["maxSalary"];
            this.scoreCardId = _data["scoreCardId"];
        }
    }

    static fromJS(data: any): ManageJobDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageJobDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["position"] = this.position;
        data["departmentId"] = this.departmentId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["location"] = this.location;
        data["description"] = this.description;
        data["requirements"] = this.requirements;
        data["ref"] = this.ref;
        data["jobAvailabilityId"] = this.jobAvailabilityId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["experience"] = this.experience;
        data["minQualificationId"] = this.minQualificationId;
        data["maxQualificationId"] = this.maxQualificationId;
        data["currency"] = this.currency;
        data["minSalary"] = this.minSalary;
        data["maxSalary"] = this.maxSalary;
        data["scoreCardId"] = this.scoreCardId;
        return data; 
    }

    clone(): ManageJobDTO {
        const json = this.toJSON();
        let result = new ManageJobDTO();
        result.init(json);
        return result;
    }
}

export interface IManageJobDTO {
    id: number;
    position: string | undefined;
    departmentId: number;
    countryId: number;
    stateId: number;
    location: string | undefined;
    description: string | undefined;
    requirements: string | undefined;
    ref: string | undefined;
    jobAvailabilityId: number;
    employmentTypeId: number;
    experience: number;
    minQualificationId: number;
    maxQualificationId: number;
    currency: string | undefined;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    scoreCardId: number | undefined;
}

export class JobFilterDTO implements IJobFilterDTO {
    pageNumber!: number;
    pageSize!: number;

    constructor(data?: IJobFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): JobFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new JobFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data; 
    }

    clone(): JobFilterDTO {
        const json = this.toJSON();
        let result = new JobFilterDTO();
        result.init(json);
        return result;
    }
}

export interface IJobFilterDTO {
    pageNumber: number;
    pageSize: number;
}

export class JobDTO implements IJobDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    position!: string | undefined;
    departmentId!: number;
    department!: string | undefined;
    countryId!: number;
    country!: string | undefined;
    stateId!: number;
    state!: string | undefined;
    location!: string | undefined;
    description!: string | undefined;
    requirements!: string | undefined;
    ref!: string | undefined;
    jobAvailabilityId!: number;
    employmentTypeId!: number;
    employmentType!: string | undefined;
    experience!: number;
    minQualificationId!: number;
    maxQualificationId!: number;
    currency!: string | undefined;
    minSalary!: number | undefined;
    maxSalary!: number | undefined;
    scoreCardId!: number | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    readonly availability!: string | undefined;

    constructor(data?: IJobDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.position = _data["position"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"];
            this.countryId = _data["countryId"];
            this.country = _data["country"];
            this.stateId = _data["stateId"];
            this.state = _data["state"];
            this.location = _data["location"];
            this.description = _data["description"];
            this.requirements = _data["requirements"];
            this.ref = _data["ref"];
            this.jobAvailabilityId = _data["jobAvailabilityId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.employmentType = _data["employmentType"];
            this.experience = _data["experience"];
            this.minQualificationId = _data["minQualificationId"];
            this.maxQualificationId = _data["maxQualificationId"];
            this.currency = _data["currency"];
            this.minSalary = _data["minSalary"];
            this.maxSalary = _data["maxSalary"];
            this.scoreCardId = _data["scoreCardId"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            (<any>this).availability = _data["availability"];
        }
    }

    static fromJS(data: any): JobDTO {
        data = typeof data === 'object' ? data : {};
        let result = new JobDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["position"] = this.position;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department;
        data["countryId"] = this.countryId;
        data["country"] = this.country;
        data["stateId"] = this.stateId;
        data["state"] = this.state;
        data["location"] = this.location;
        data["description"] = this.description;
        data["requirements"] = this.requirements;
        data["ref"] = this.ref;
        data["jobAvailabilityId"] = this.jobAvailabilityId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["employmentType"] = this.employmentType;
        data["experience"] = this.experience;
        data["minQualificationId"] = this.minQualificationId;
        data["maxQualificationId"] = this.maxQualificationId;
        data["currency"] = this.currency;
        data["minSalary"] = this.minSalary;
        data["maxSalary"] = this.maxSalary;
        data["scoreCardId"] = this.scoreCardId;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["availability"] = this.availability;
        return data; 
    }

    clone(): JobDTO {
        const json = this.toJSON();
        let result = new JobDTO();
        result.init(json);
        return result;
    }
}

export interface IJobDTO {
    id: number;
    companyID: number;
    subID: number;
    position: string | undefined;
    departmentId: number;
    department: string | undefined;
    countryId: number;
    country: string | undefined;
    stateId: number;
    state: string | undefined;
    location: string | undefined;
    description: string | undefined;
    requirements: string | undefined;
    ref: string | undefined;
    jobAvailabilityId: number;
    employmentTypeId: number;
    employmentType: string | undefined;
    experience: number;
    minQualificationId: number;
    maxQualificationId: number;
    currency: string | undefined;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    scoreCardId: number | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    availability: string | undefined;
}

export class JobDTOListApiResult implements IJobDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: JobDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IJobDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(JobDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): JobDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): JobDTOListApiResult {
        const json = this.toJSON();
        let result = new JobDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IJobDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: JobDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ApplicantDocument implements IApplicantDocument {
    jobApplicantId!: number;
    docUrl!: string | undefined;
    lastModifiedDate!: Date | undefined;
    jobApplicant!: JobApplicant;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IApplicantDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobApplicantId = _data["jobApplicantId"];
            this.docUrl = _data["docUrl"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.jobApplicant = _data["jobApplicant"] ? JobApplicant.fromJS(_data["jobApplicant"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ApplicantDocument {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicantDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobApplicantId"] = this.jobApplicantId;
        data["docUrl"] = this.docUrl;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["jobApplicant"] = this.jobApplicant ? this.jobApplicant.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ApplicantDocument {
        const json = this.toJSON();
        let result = new ApplicantDocument();
        result.init(json);
        return result;
    }
}

export interface IApplicantDocument {
    jobApplicantId: number;
    docUrl: string | undefined;
    lastModifiedDate: Date | undefined;
    jobApplicant: JobApplicant;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class JobApplicant implements IJobApplicant {
    userId!: number | undefined;
    titleId!: number;
    firstName!: string | undefined;
    lastName!: string | undefined;
    otherName!: string | undefined;
    email!: string | undefined;
    mobile!: string | undefined;
    birthDate!: Date | undefined;
    stateOfResidentId!: number | undefined;
    nationalityId!: number | undefined;
    skills!: string | undefined;
    yearOfExperience!: number | undefined;
    lastUpdate!: Date | undefined;
    password!: string | undefined;
    gender!: number | undefined;
    title!: string | undefined;
    nyscStatus!: number | undefined;
    workAchievements!: string | undefined;
    cvName!: string | undefined;
    cvMimeType!: string | undefined;
    desiredSalaryCurrency!: string | undefined;
    desiredSalaryAnnum!: number | undefined;
    desiredSalaryNegotiable!: boolean;
    willingToRelocate!: boolean;
    photoName!: string | undefined;
    photoMimeType!: string | undefined;
    completeProfile!: boolean | undefined;
    age!: number;
    jobApplications!: JobApplication[] | undefined;
    applicantDocuments!: ApplicantDocument[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IJobApplicant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.titleId = _data["titleId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherName = _data["otherName"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.stateOfResidentId = _data["stateOfResidentId"];
            this.nationalityId = _data["nationalityId"];
            this.skills = _data["skills"];
            this.yearOfExperience = _data["yearOfExperience"];
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
            this.password = _data["password"];
            this.gender = _data["gender"];
            this.title = _data["title"];
            this.nyscStatus = _data["nyscStatus"];
            this.workAchievements = _data["workAchievements"];
            this.cvName = _data["cvName"];
            this.cvMimeType = _data["cvMimeType"];
            this.desiredSalaryCurrency = _data["desiredSalaryCurrency"];
            this.desiredSalaryAnnum = _data["desiredSalaryAnnum"];
            this.desiredSalaryNegotiable = _data["desiredSalaryNegotiable"];
            this.willingToRelocate = _data["willingToRelocate"];
            this.photoName = _data["photoName"];
            this.photoMimeType = _data["photoMimeType"];
            this.completeProfile = _data["completeProfile"];
            this.age = _data["age"];
            if (Array.isArray(_data["jobApplications"])) {
                this.jobApplications = [] as any;
                for (let item of _data["jobApplications"])
                    this.jobApplications!.push(JobApplication.fromJS(item));
            }
            if (Array.isArray(_data["applicantDocuments"])) {
                this.applicantDocuments = [] as any;
                for (let item of _data["applicantDocuments"])
                    this.applicantDocuments!.push(ApplicantDocument.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): JobApplicant {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplicant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["titleId"] = this.titleId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherName"] = this.otherName;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["stateOfResidentId"] = this.stateOfResidentId;
        data["nationalityId"] = this.nationalityId;
        data["skills"] = this.skills;
        data["yearOfExperience"] = this.yearOfExperience;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        data["password"] = this.password;
        data["gender"] = this.gender;
        data["title"] = this.title;
        data["nyscStatus"] = this.nyscStatus;
        data["workAchievements"] = this.workAchievements;
        data["cvName"] = this.cvName;
        data["cvMimeType"] = this.cvMimeType;
        data["desiredSalaryCurrency"] = this.desiredSalaryCurrency;
        data["desiredSalaryAnnum"] = this.desiredSalaryAnnum;
        data["desiredSalaryNegotiable"] = this.desiredSalaryNegotiable;
        data["willingToRelocate"] = this.willingToRelocate;
        data["photoName"] = this.photoName;
        data["photoMimeType"] = this.photoMimeType;
        data["completeProfile"] = this.completeProfile;
        data["age"] = this.age;
        if (Array.isArray(this.jobApplications)) {
            data["jobApplications"] = [];
            for (let item of this.jobApplications)
                data["jobApplications"].push(item.toJSON());
        }
        if (Array.isArray(this.applicantDocuments)) {
            data["applicantDocuments"] = [];
            for (let item of this.applicantDocuments)
                data["applicantDocuments"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): JobApplicant {
        const json = this.toJSON();
        let result = new JobApplicant();
        result.init(json);
        return result;
    }
}

export interface IJobApplicant {
    userId: number | undefined;
    titleId: number;
    firstName: string | undefined;
    lastName: string | undefined;
    otherName: string | undefined;
    email: string | undefined;
    mobile: string | undefined;
    birthDate: Date | undefined;
    stateOfResidentId: number | undefined;
    nationalityId: number | undefined;
    skills: string | undefined;
    yearOfExperience: number | undefined;
    lastUpdate: Date | undefined;
    password: string | undefined;
    gender: number | undefined;
    title: string | undefined;
    nyscStatus: number | undefined;
    workAchievements: string | undefined;
    cvName: string | undefined;
    cvMimeType: string | undefined;
    desiredSalaryCurrency: string | undefined;
    desiredSalaryAnnum: number | undefined;
    desiredSalaryNegotiable: boolean;
    willingToRelocate: boolean;
    photoName: string | undefined;
    photoMimeType: string | undefined;
    completeProfile: boolean | undefined;
    age: number;
    jobApplications: JobApplication[] | undefined;
    applicantDocuments: ApplicantDocument[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class JobApplication implements IJobApplication {
    jobId!: number;
    applicantCode!: string | undefined;
    jobApplicantId!: number;
    dateApplied!: Date;
    lastUpdate!: Date | undefined;
    alertSent!: boolean;
    coverLetter!: string | undefined;
    jobLocation!: number | undefined;
    hireStageId!: number | undefined;
    testPassCode!: string | undefined;
    job!: Job;
    jobApplicant!: JobApplicant;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IJobApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.applicantCode = _data["applicantCode"];
            this.jobApplicantId = _data["jobApplicantId"];
            this.dateApplied = _data["dateApplied"] ? new Date(_data["dateApplied"].toString()) : <any>undefined;
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
            this.alertSent = _data["alertSent"];
            this.coverLetter = _data["coverLetter"];
            this.jobLocation = _data["jobLocation"];
            this.hireStageId = _data["hireStageId"];
            this.testPassCode = _data["testPassCode"];
            this.job = _data["job"] ? Job.fromJS(_data["job"]) : <any>undefined;
            this.jobApplicant = _data["jobApplicant"] ? JobApplicant.fromJS(_data["jobApplicant"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): JobApplication {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["applicantCode"] = this.applicantCode;
        data["jobApplicantId"] = this.jobApplicantId;
        data["dateApplied"] = this.dateApplied ? this.dateApplied.toISOString() : <any>undefined;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        data["alertSent"] = this.alertSent;
        data["coverLetter"] = this.coverLetter;
        data["jobLocation"] = this.jobLocation;
        data["hireStageId"] = this.hireStageId;
        data["testPassCode"] = this.testPassCode;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["jobApplicant"] = this.jobApplicant ? this.jobApplicant.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): JobApplication {
        const json = this.toJSON();
        let result = new JobApplication();
        result.init(json);
        return result;
    }
}

export interface IJobApplication {
    jobId: number;
    applicantCode: string | undefined;
    jobApplicantId: number;
    dateApplied: Date;
    lastUpdate: Date | undefined;
    alertSent: boolean;
    coverLetter: string | undefined;
    jobLocation: number | undefined;
    hireStageId: number | undefined;
    testPassCode: string | undefined;
    job: Job;
    jobApplicant: JobApplicant;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Job implements IJob {
    position!: string | undefined;
    departmentId!: number;
    countryId!: number;
    stateId!: number;
    location!: string | undefined;
    description!: string | undefined;
    requirements!: string | undefined;
    ref!: string | undefined;
    jobAvailabilityId!: number;
    employmentTypeId!: number;
    experience!: number;
    minQualificationId!: number;
    maxQualificationId!: number;
    currency!: string | undefined;
    minSalary!: number | undefined;
    maxSalary!: number | undefined;
    scoreCardId!: number | undefined;
    datePosted!: Date;
    endDate!: Date | undefined;
    alertSent!: boolean;
    jobApplicants!: JobApplication[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
            this.departmentId = _data["departmentId"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.location = _data["location"];
            this.description = _data["description"];
            this.requirements = _data["requirements"];
            this.ref = _data["ref"];
            this.jobAvailabilityId = _data["jobAvailabilityId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.experience = _data["experience"];
            this.minQualificationId = _data["minQualificationId"];
            this.maxQualificationId = _data["maxQualificationId"];
            this.currency = _data["currency"];
            this.minSalary = _data["minSalary"];
            this.maxSalary = _data["maxSalary"];
            this.scoreCardId = _data["scoreCardId"];
            this.datePosted = _data["datePosted"] ? new Date(_data["datePosted"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.alertSent = _data["alertSent"];
            if (Array.isArray(_data["jobApplicants"])) {
                this.jobApplicants = [] as any;
                for (let item of _data["jobApplicants"])
                    this.jobApplicants!.push(JobApplication.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Job {
        data = typeof data === 'object' ? data : {};
        let result = new Job();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["departmentId"] = this.departmentId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["location"] = this.location;
        data["description"] = this.description;
        data["requirements"] = this.requirements;
        data["ref"] = this.ref;
        data["jobAvailabilityId"] = this.jobAvailabilityId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["experience"] = this.experience;
        data["minQualificationId"] = this.minQualificationId;
        data["maxQualificationId"] = this.maxQualificationId;
        data["currency"] = this.currency;
        data["minSalary"] = this.minSalary;
        data["maxSalary"] = this.maxSalary;
        data["scoreCardId"] = this.scoreCardId;
        data["datePosted"] = this.datePosted ? this.datePosted.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["alertSent"] = this.alertSent;
        if (Array.isArray(this.jobApplicants)) {
            data["jobApplicants"] = [];
            for (let item of this.jobApplicants)
                data["jobApplicants"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Job {
        const json = this.toJSON();
        let result = new Job();
        result.init(json);
        return result;
    }
}

export interface IJob {
    position: string | undefined;
    departmentId: number;
    countryId: number;
    stateId: number;
    location: string | undefined;
    description: string | undefined;
    requirements: string | undefined;
    ref: string | undefined;
    jobAvailabilityId: number;
    employmentTypeId: number;
    experience: number;
    minQualificationId: number;
    maxQualificationId: number;
    currency: string | undefined;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    scoreCardId: number | undefined;
    datePosted: Date;
    endDate: Date | undefined;
    alertSent: boolean;
    jobApplicants: JobApplication[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class JobIListApiResult implements IJobIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Job[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IJobIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Job.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): JobIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): JobIListApiResult {
        const json = this.toJSON();
        let result = new JobIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IJobIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Job[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class JobDTOApiResult implements IJobDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: JobDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IJobDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? JobDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): JobDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): JobDTOApiResult {
        const json = this.toJSON();
        let result = new JobDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IJobDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: JobDTO;
    totalCount: number;
    totalRecord: number;
}

export class JobApplicationSearch implements IJobApplicationSearch {
    skills!: string | undefined;
    email!: string | undefined;
    mobile!: string | undefined;
    jobId!: number;
    applicantCode!: string | undefined;
    jobApplicantId!: number;
    dateApplied!: Date;
    alertSent!: boolean;
    coverLetter!: string | undefined;
    jobLocation!: number;
    id!: number;
    pageNumber!: number;
    pageSize!: number;

    constructor(data?: IJobApplicationSearch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skills = _data["skills"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.jobId = _data["jobId"];
            this.applicantCode = _data["applicantCode"];
            this.jobApplicantId = _data["jobApplicantId"];
            this.dateApplied = _data["dateApplied"] ? new Date(_data["dateApplied"].toString()) : <any>undefined;
            this.alertSent = _data["alertSent"];
            this.coverLetter = _data["coverLetter"];
            this.jobLocation = _data["jobLocation"];
            this.id = _data["id"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): JobApplicationSearch {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplicationSearch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skills"] = this.skills;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["jobId"] = this.jobId;
        data["applicantCode"] = this.applicantCode;
        data["jobApplicantId"] = this.jobApplicantId;
        data["dateApplied"] = this.dateApplied ? this.dateApplied.toISOString() : <any>undefined;
        data["alertSent"] = this.alertSent;
        data["coverLetter"] = this.coverLetter;
        data["jobLocation"] = this.jobLocation;
        data["id"] = this.id;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data; 
    }

    clone(): JobApplicationSearch {
        const json = this.toJSON();
        let result = new JobApplicationSearch();
        result.init(json);
        return result;
    }
}

export interface IJobApplicationSearch {
    skills: string | undefined;
    email: string | undefined;
    mobile: string | undefined;
    jobId: number;
    applicantCode: string | undefined;
    jobApplicantId: number;
    dateApplied: Date;
    alertSent: boolean;
    coverLetter: string | undefined;
    jobLocation: number;
    id: number;
    pageNumber: number;
    pageSize: number;
}

export class JobApplicationSearchIListApiResult implements IJobApplicationSearchIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: JobApplicationSearch[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IJobApplicationSearchIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(JobApplicationSearch.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): JobApplicationSearchIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplicationSearchIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): JobApplicationSearchIListApiResult {
        const json = this.toJSON();
        let result = new JobApplicationSearchIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IJobApplicationSearchIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: JobApplicationSearch[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class JobScheduleInterview implements IJobScheduleInterview {
    jobApplicantId!: number;
    interviewerEmployeeId!: number;
    interviewDate!: Date;
    interviewTime!: Date;
    duration!: number;
    interviewType!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IJobScheduleInterview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobApplicantId = _data["jobApplicantId"];
            this.interviewerEmployeeId = _data["interviewerEmployeeId"];
            this.interviewDate = _data["interviewDate"] ? new Date(_data["interviewDate"].toString()) : <any>undefined;
            this.interviewTime = _data["interviewTime"] ? new Date(_data["interviewTime"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.interviewType = _data["interviewType"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): JobScheduleInterview {
        data = typeof data === 'object' ? data : {};
        let result = new JobScheduleInterview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobApplicantId"] = this.jobApplicantId;
        data["interviewerEmployeeId"] = this.interviewerEmployeeId;
        data["interviewDate"] = this.interviewDate ? this.interviewDate.toISOString() : <any>undefined;
        data["interviewTime"] = this.interviewTime ? this.interviewTime.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["interviewType"] = this.interviewType;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): JobScheduleInterview {
        const json = this.toJSON();
        let result = new JobScheduleInterview();
        result.init(json);
        return result;
    }
}

export interface IJobScheduleInterview {
    jobApplicantId: number;
    interviewerEmployeeId: number;
    interviewDate: Date;
    interviewTime: Date;
    duration: number;
    interviewType: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class JobScheduleInterviewIListApiResult implements IJobScheduleInterviewIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: JobScheduleInterview[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IJobScheduleInterviewIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(JobScheduleInterview.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): JobScheduleInterviewIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobScheduleInterviewIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): JobScheduleInterviewIListApiResult {
        const json = this.toJSON();
        let result = new JobScheduleInterviewIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IJobScheduleInterviewIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: JobScheduleInterview[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class JobApplicationIListApiResult implements IJobApplicationIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: JobApplication[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IJobApplicationIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(JobApplication.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): JobApplicationIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplicationIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): JobApplicationIListApiResult {
        const json = this.toJSON();
        let result = new JobApplicationIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IJobApplicationIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: JobApplication[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class JobApplicantDto implements IJobApplicantDto {
    id!: number;
    userId!: number | undefined;
    titleId!: number;
    firstName!: string | undefined;
    lastName!: string | undefined;
    otherName!: string | undefined;
    email!: string | undefined;
    mobile!: string | undefined;
    birthDate!: Date | undefined;
    stateOfResidentId!: number | undefined;
    nationalityId!: number | undefined;
    skills!: string | undefined;
    yearOfExperience!: number | undefined;
    lastUpdate!: Date | undefined;
    password!: string | undefined;
    gender!: number | undefined;
    title!: string | undefined;
    nyscStatus!: number | undefined;
    workAchievements!: string | undefined;
    cvName!: string | undefined;
    cvMimeType!: string | undefined;
    desiredSalaryCurrency!: string | undefined;
    desiredSalaryAnnum!: number | undefined;
    desiredSalaryNegotiable!: boolean;
    willingToRelocate!: boolean;
    photoName!: string | undefined;
    photoMimeType!: string | undefined;
    completeProfile!: boolean | undefined;
    age!: number;
    isDeleted!: boolean;
    isActive!: boolean;
    jobApplications!: JobApplication[] | undefined;
    applicantDocuments!: ApplicantDocument[] | undefined;

    constructor(data?: IJobApplicantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.titleId = _data["titleId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherName = _data["otherName"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.stateOfResidentId = _data["stateOfResidentId"];
            this.nationalityId = _data["nationalityId"];
            this.skills = _data["skills"];
            this.yearOfExperience = _data["yearOfExperience"];
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
            this.password = _data["password"];
            this.gender = _data["gender"];
            this.title = _data["title"];
            this.nyscStatus = _data["nyscStatus"];
            this.workAchievements = _data["workAchievements"];
            this.cvName = _data["cvName"];
            this.cvMimeType = _data["cvMimeType"];
            this.desiredSalaryCurrency = _data["desiredSalaryCurrency"];
            this.desiredSalaryAnnum = _data["desiredSalaryAnnum"];
            this.desiredSalaryNegotiable = _data["desiredSalaryNegotiable"];
            this.willingToRelocate = _data["willingToRelocate"];
            this.photoName = _data["photoName"];
            this.photoMimeType = _data["photoMimeType"];
            this.completeProfile = _data["completeProfile"];
            this.age = _data["age"];
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["jobApplications"])) {
                this.jobApplications = [] as any;
                for (let item of _data["jobApplications"])
                    this.jobApplications!.push(JobApplication.fromJS(item));
            }
            if (Array.isArray(_data["applicantDocuments"])) {
                this.applicantDocuments = [] as any;
                for (let item of _data["applicantDocuments"])
                    this.applicantDocuments!.push(ApplicantDocument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobApplicantDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplicantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["titleId"] = this.titleId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherName"] = this.otherName;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["stateOfResidentId"] = this.stateOfResidentId;
        data["nationalityId"] = this.nationalityId;
        data["skills"] = this.skills;
        data["yearOfExperience"] = this.yearOfExperience;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        data["password"] = this.password;
        data["gender"] = this.gender;
        data["title"] = this.title;
        data["nyscStatus"] = this.nyscStatus;
        data["workAchievements"] = this.workAchievements;
        data["cvName"] = this.cvName;
        data["cvMimeType"] = this.cvMimeType;
        data["desiredSalaryCurrency"] = this.desiredSalaryCurrency;
        data["desiredSalaryAnnum"] = this.desiredSalaryAnnum;
        data["desiredSalaryNegotiable"] = this.desiredSalaryNegotiable;
        data["willingToRelocate"] = this.willingToRelocate;
        data["photoName"] = this.photoName;
        data["photoMimeType"] = this.photoMimeType;
        data["completeProfile"] = this.completeProfile;
        data["age"] = this.age;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.jobApplications)) {
            data["jobApplications"] = [];
            for (let item of this.jobApplications)
                data["jobApplications"].push(item.toJSON());
        }
        if (Array.isArray(this.applicantDocuments)) {
            data["applicantDocuments"] = [];
            for (let item of this.applicantDocuments)
                data["applicantDocuments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): JobApplicantDto {
        const json = this.toJSON();
        let result = new JobApplicantDto();
        result.init(json);
        return result;
    }
}

export interface IJobApplicantDto {
    id: number;
    userId: number | undefined;
    titleId: number;
    firstName: string | undefined;
    lastName: string | undefined;
    otherName: string | undefined;
    email: string | undefined;
    mobile: string | undefined;
    birthDate: Date | undefined;
    stateOfResidentId: number | undefined;
    nationalityId: number | undefined;
    skills: string | undefined;
    yearOfExperience: number | undefined;
    lastUpdate: Date | undefined;
    password: string | undefined;
    gender: number | undefined;
    title: string | undefined;
    nyscStatus: number | undefined;
    workAchievements: string | undefined;
    cvName: string | undefined;
    cvMimeType: string | undefined;
    desiredSalaryCurrency: string | undefined;
    desiredSalaryAnnum: number | undefined;
    desiredSalaryNegotiable: boolean;
    willingToRelocate: boolean;
    photoName: string | undefined;
    photoMimeType: string | undefined;
    completeProfile: boolean | undefined;
    age: number;
    isDeleted: boolean;
    isActive: boolean;
    jobApplications: JobApplication[] | undefined;
    applicantDocuments: ApplicantDocument[] | undefined;
}

export class JobApplicantScheduleInterview implements IJobApplicantScheduleInterview {
    jobApplicantId!: number;
    interviewerIds!: number[] | undefined;
    interviewDate!: Date;
    interviewTime!: Date;
    duration!: number;
    interviewType!: number;
    employeeName!: string | undefined;

    constructor(data?: IJobApplicantScheduleInterview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobApplicantId = _data["jobApplicantId"];
            if (Array.isArray(_data["interviewerIds"])) {
                this.interviewerIds = [] as any;
                for (let item of _data["interviewerIds"])
                    this.interviewerIds!.push(item);
            }
            this.interviewDate = _data["interviewDate"] ? new Date(_data["interviewDate"].toString()) : <any>undefined;
            this.interviewTime = _data["interviewTime"] ? new Date(_data["interviewTime"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.interviewType = _data["interviewType"];
            this.employeeName = _data["employeeName"];
        }
    }

    static fromJS(data: any): JobApplicantScheduleInterview {
        data = typeof data === 'object' ? data : {};
        let result = new JobApplicantScheduleInterview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobApplicantId"] = this.jobApplicantId;
        if (Array.isArray(this.interviewerIds)) {
            data["interviewerIds"] = [];
            for (let item of this.interviewerIds)
                data["interviewerIds"].push(item);
        }
        data["interviewDate"] = this.interviewDate ? this.interviewDate.toISOString() : <any>undefined;
        data["interviewTime"] = this.interviewTime ? this.interviewTime.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["interviewType"] = this.interviewType;
        data["employeeName"] = this.employeeName;
        return data; 
    }

    clone(): JobApplicantScheduleInterview {
        const json = this.toJSON();
        let result = new JobApplicantScheduleInterview();
        result.init(json);
        return result;
    }
}

export interface IJobApplicantScheduleInterview {
    jobApplicantId: number;
    interviewerIds: number[] | undefined;
    interviewDate: Date;
    interviewTime: Date;
    duration: number;
    interviewType: number;
    employeeName: string | undefined;
}

export class ManageQuizDTO implements IManageQuizDTO {
    id!: number;
    name!: string | undefined;
    typeId!: number;
    questions!: string | undefined;

    constructor(data?: IManageQuizDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.questions = _data["questions"];
        }
    }

    static fromJS(data: any): ManageQuizDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageQuizDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["questions"] = this.questions;
        return data; 
    }

    clone(): ManageQuizDTO {
        const json = this.toJSON();
        let result = new ManageQuizDTO();
        result.init(json);
        return result;
    }
}

export interface IManageQuizDTO {
    id: number;
    name: string | undefined;
    typeId: number;
    questions: string | undefined;
}

export class QuestionOptionDTO implements IQuestionOptionDTO {
    id!: number;
    questionId!: number;
    question!: string | undefined;
    value!: string | undefined;
    isAnswer!: boolean;

    constructor(data?: IQuestionOptionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.question = _data["question"];
            this.value = _data["value"];
            this.isAnswer = _data["isAnswer"];
        }
    }

    static fromJS(data: any): QuestionOptionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionOptionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["question"] = this.question;
        data["value"] = this.value;
        data["isAnswer"] = this.isAnswer;
        return data; 
    }

    clone(): QuestionOptionDTO {
        const json = this.toJSON();
        let result = new QuestionOptionDTO();
        result.init(json);
        return result;
    }
}

export interface IQuestionOptionDTO {
    id: number;
    questionId: number;
    question: string | undefined;
    value: string | undefined;
    isAnswer: boolean;
}

export class QuestionDTO implements IQuestionDTO {
    id!: number;
    questionText!: string | undefined;
    typeId!: number;
    type!: string | undefined;
    quizId!: number;
    quizName!: string | undefined;
    questionOptions!: QuestionOptionDTO[] | undefined;
    readonly totalAnswers!: number;

    constructor(data?: IQuestionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionText = _data["questionText"];
            this.typeId = _data["typeId"];
            this.type = _data["type"];
            this.quizId = _data["quizId"];
            this.quizName = _data["quizName"];
            if (Array.isArray(_data["questionOptions"])) {
                this.questionOptions = [] as any;
                for (let item of _data["questionOptions"])
                    this.questionOptions!.push(QuestionOptionDTO.fromJS(item));
            }
            (<any>this).totalAnswers = _data["totalAnswers"];
        }
    }

    static fromJS(data: any): QuestionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionText"] = this.questionText;
        data["typeId"] = this.typeId;
        data["type"] = this.type;
        data["quizId"] = this.quizId;
        data["quizName"] = this.quizName;
        if (Array.isArray(this.questionOptions)) {
            data["questionOptions"] = [];
            for (let item of this.questionOptions)
                data["questionOptions"].push(item.toJSON());
        }
        data["totalAnswers"] = this.totalAnswers;
        return data; 
    }

    clone(): QuestionDTO {
        const json = this.toJSON();
        let result = new QuestionDTO();
        result.init(json);
        return result;
    }
}

export interface IQuestionDTO {
    id: number;
    questionText: string | undefined;
    typeId: number;
    type: string | undefined;
    quizId: number;
    quizName: string | undefined;
    questionOptions: QuestionOptionDTO[] | undefined;
    totalAnswers: number;
}

export class QuizDTO implements IQuizDTO {
    id!: number;
    name!: string | undefined;
    type!: string | undefined;
    typeId!: number;
    companyID!: number;
    subID!: number;
    questions!: QuestionDTO[] | undefined;
    readonly totalQuestions!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IQuizDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.typeId = _data["typeId"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionDTO.fromJS(item));
            }
            (<any>this).totalQuestions = _data["totalQuestions"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): QuizDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QuizDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["typeId"] = this.typeId;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        data["totalQuestions"] = this.totalQuestions;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): QuizDTO {
        const json = this.toJSON();
        let result = new QuizDTO();
        result.init(json);
        return result;
    }
}

export interface IQuizDTO {
    id: number;
    name: string | undefined;
    type: string | undefined;
    typeId: number;
    companyID: number;
    subID: number;
    questions: QuestionDTO[] | undefined;
    totalQuestions: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class QuizDTOListApiResult implements IQuizDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: QuizDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IQuizDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(QuizDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): QuizDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new QuizDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): QuizDTOListApiResult {
        const json = this.toJSON();
        let result = new QuizDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IQuizDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: QuizDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class QuizDTOApiResult implements IQuizDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: QuizDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IQuizDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? QuizDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): QuizDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new QuizDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): QuizDTOApiResult {
        const json = this.toJSON();
        let result = new QuizDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IQuizDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: QuizDTO;
    totalCount: number;
    totalRecord: number;
}

export class ManageHireStageDTO implements IManageHireStageDTO {
    id!: number;
    name!: string | undefined;
    emailTemplateId!: number;
    autoEmailRespond!: boolean;
    reviewers!: string | undefined;

    constructor(data?: IManageHireStageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.emailTemplateId = _data["emailTemplateId"];
            this.autoEmailRespond = _data["autoEmailRespond"];
            this.reviewers = _data["reviewers"];
        }
    }

    static fromJS(data: any): ManageHireStageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageHireStageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["emailTemplateId"] = this.emailTemplateId;
        data["autoEmailRespond"] = this.autoEmailRespond;
        data["reviewers"] = this.reviewers;
        return data; 
    }

    clone(): ManageHireStageDTO {
        const json = this.toJSON();
        let result = new ManageHireStageDTO();
        result.init(json);
        return result;
    }
}

export interface IManageHireStageDTO {
    id: number;
    name: string | undefined;
    emailTemplateId: number;
    autoEmailRespond: boolean;
    reviewers: string | undefined;
}

export class SubHireStageReviewer implements ISubHireStageReviewer {
    subHireStageId!: number;
    reviewerId!: number;
    reviewerName!: string | undefined;
    reviewerEmail!: string | undefined;
    subHireStage!: SubHireStage;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISubHireStageReviewer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subHireStageId = _data["subHireStageId"];
            this.reviewerId = _data["reviewerId"];
            this.reviewerName = _data["reviewerName"];
            this.reviewerEmail = _data["reviewerEmail"];
            this.subHireStage = _data["subHireStage"] ? SubHireStage.fromJS(_data["subHireStage"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): SubHireStageReviewer {
        data = typeof data === 'object' ? data : {};
        let result = new SubHireStageReviewer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subHireStageId"] = this.subHireStageId;
        data["reviewerId"] = this.reviewerId;
        data["reviewerName"] = this.reviewerName;
        data["reviewerEmail"] = this.reviewerEmail;
        data["subHireStage"] = this.subHireStage ? this.subHireStage.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): SubHireStageReviewer {
        const json = this.toJSON();
        let result = new SubHireStageReviewer();
        result.init(json);
        return result;
    }
}

export interface ISubHireStageReviewer {
    subHireStageId: number;
    reviewerId: number;
    reviewerName: string | undefined;
    reviewerEmail: string | undefined;
    subHireStage: SubHireStage;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class SubHireStage implements ISubHireStage {
    hireStageId!: number;
    name!: string | undefined;
    emailTemplateId!: number;
    autoEmailRespond!: boolean;
    scoreCard!: number;
    hireStage!: HireStage;
    subHireStageReviewers!: SubHireStageReviewer[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISubHireStage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hireStageId = _data["hireStageId"];
            this.name = _data["name"];
            this.emailTemplateId = _data["emailTemplateId"];
            this.autoEmailRespond = _data["autoEmailRespond"];
            this.scoreCard = _data["scoreCard"];
            this.hireStage = _data["hireStage"] ? HireStage.fromJS(_data["hireStage"]) : <any>undefined;
            if (Array.isArray(_data["subHireStageReviewers"])) {
                this.subHireStageReviewers = [] as any;
                for (let item of _data["subHireStageReviewers"])
                    this.subHireStageReviewers!.push(SubHireStageReviewer.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): SubHireStage {
        data = typeof data === 'object' ? data : {};
        let result = new SubHireStage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hireStageId"] = this.hireStageId;
        data["name"] = this.name;
        data["emailTemplateId"] = this.emailTemplateId;
        data["autoEmailRespond"] = this.autoEmailRespond;
        data["scoreCard"] = this.scoreCard;
        data["hireStage"] = this.hireStage ? this.hireStage.toJSON() : <any>undefined;
        if (Array.isArray(this.subHireStageReviewers)) {
            data["subHireStageReviewers"] = [];
            for (let item of this.subHireStageReviewers)
                data["subHireStageReviewers"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): SubHireStage {
        const json = this.toJSON();
        let result = new SubHireStage();
        result.init(json);
        return result;
    }
}

export interface ISubHireStage {
    hireStageId: number;
    name: string | undefined;
    emailTemplateId: number;
    autoEmailRespond: boolean;
    scoreCard: number;
    hireStage: HireStage;
    subHireStageReviewers: SubHireStageReviewer[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class HireStage implements IHireStage {
    name!: string | undefined;
    emailTemplateId!: number;
    autoEmailRespond!: boolean;
    hireStageReviewers!: HireStageReviewer[] | undefined;
    subHireStages!: SubHireStage[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IHireStage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.emailTemplateId = _data["emailTemplateId"];
            this.autoEmailRespond = _data["autoEmailRespond"];
            if (Array.isArray(_data["hireStageReviewers"])) {
                this.hireStageReviewers = [] as any;
                for (let item of _data["hireStageReviewers"])
                    this.hireStageReviewers!.push(HireStageReviewer.fromJS(item));
            }
            if (Array.isArray(_data["subHireStages"])) {
                this.subHireStages = [] as any;
                for (let item of _data["subHireStages"])
                    this.subHireStages!.push(SubHireStage.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): HireStage {
        data = typeof data === 'object' ? data : {};
        let result = new HireStage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["emailTemplateId"] = this.emailTemplateId;
        data["autoEmailRespond"] = this.autoEmailRespond;
        if (Array.isArray(this.hireStageReviewers)) {
            data["hireStageReviewers"] = [];
            for (let item of this.hireStageReviewers)
                data["hireStageReviewers"].push(item.toJSON());
        }
        if (Array.isArray(this.subHireStages)) {
            data["subHireStages"] = [];
            for (let item of this.subHireStages)
                data["subHireStages"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): HireStage {
        const json = this.toJSON();
        let result = new HireStage();
        result.init(json);
        return result;
    }
}

export interface IHireStage {
    name: string | undefined;
    emailTemplateId: number;
    autoEmailRespond: boolean;
    hireStageReviewers: HireStageReviewer[] | undefined;
    subHireStages: SubHireStage[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class HireStageReviewer implements IHireStageReviewer {
    hireStageId!: number;
    reviewerId!: number;
    reviewerName!: string | undefined;
    reviewerEmail!: string | undefined;
    hireStage!: HireStage;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IHireStageReviewer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hireStageId = _data["hireStageId"];
            this.reviewerId = _data["reviewerId"];
            this.reviewerName = _data["reviewerName"];
            this.reviewerEmail = _data["reviewerEmail"];
            this.hireStage = _data["hireStage"] ? HireStage.fromJS(_data["hireStage"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): HireStageReviewer {
        data = typeof data === 'object' ? data : {};
        let result = new HireStageReviewer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hireStageId"] = this.hireStageId;
        data["reviewerId"] = this.reviewerId;
        data["reviewerName"] = this.reviewerName;
        data["reviewerEmail"] = this.reviewerEmail;
        data["hireStage"] = this.hireStage ? this.hireStage.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): HireStageReviewer {
        const json = this.toJSON();
        let result = new HireStageReviewer();
        result.init(json);
        return result;
    }
}

export interface IHireStageReviewer {
    hireStageId: number;
    reviewerId: number;
    reviewerName: string | undefined;
    reviewerEmail: string | undefined;
    hireStage: HireStage;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class SubHireStageDTO implements ISubHireStageDTO {
    id!: number;
    hireStageId!: number;
    hireStage!: string | undefined;
    name!: string | undefined;
    emailTemplateId!: number;
    autoEmailRespond!: boolean;
    scoreCard!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    reviewers!: SubHireStageReviewer[] | undefined;

    constructor(data?: ISubHireStageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hireStageId = _data["hireStageId"];
            this.hireStage = _data["hireStage"];
            this.name = _data["name"];
            this.emailTemplateId = _data["emailTemplateId"];
            this.autoEmailRespond = _data["autoEmailRespond"];
            this.scoreCard = _data["scoreCard"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            if (Array.isArray(_data["reviewers"])) {
                this.reviewers = [] as any;
                for (let item of _data["reviewers"])
                    this.reviewers!.push(SubHireStageReviewer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubHireStageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SubHireStageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hireStageId"] = this.hireStageId;
        data["hireStage"] = this.hireStage;
        data["name"] = this.name;
        data["emailTemplateId"] = this.emailTemplateId;
        data["autoEmailRespond"] = this.autoEmailRespond;
        data["scoreCard"] = this.scoreCard;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        if (Array.isArray(this.reviewers)) {
            data["reviewers"] = [];
            for (let item of this.reviewers)
                data["reviewers"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SubHireStageDTO {
        const json = this.toJSON();
        let result = new SubHireStageDTO();
        result.init(json);
        return result;
    }
}

export interface ISubHireStageDTO {
    id: number;
    hireStageId: number;
    hireStage: string | undefined;
    name: string | undefined;
    emailTemplateId: number;
    autoEmailRespond: boolean;
    scoreCard: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    reviewers: SubHireStageReviewer[] | undefined;
}

export class HireStageDTO implements IHireStageDTO {
    id!: number;
    name!: string | undefined;
    emailTemplateId!: number;
    autoEmailRespond!: boolean;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    reviewers!: HireStageReviewer[] | undefined;
    subStages!: SubHireStageDTO[] | undefined;

    constructor(data?: IHireStageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.emailTemplateId = _data["emailTemplateId"];
            this.autoEmailRespond = _data["autoEmailRespond"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            if (Array.isArray(_data["reviewers"])) {
                this.reviewers = [] as any;
                for (let item of _data["reviewers"])
                    this.reviewers!.push(HireStageReviewer.fromJS(item));
            }
            if (Array.isArray(_data["subStages"])) {
                this.subStages = [] as any;
                for (let item of _data["subStages"])
                    this.subStages!.push(SubHireStageDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HireStageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new HireStageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["emailTemplateId"] = this.emailTemplateId;
        data["autoEmailRespond"] = this.autoEmailRespond;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        if (Array.isArray(this.reviewers)) {
            data["reviewers"] = [];
            for (let item of this.reviewers)
                data["reviewers"].push(item.toJSON());
        }
        if (Array.isArray(this.subStages)) {
            data["subStages"] = [];
            for (let item of this.subStages)
                data["subStages"].push(item.toJSON());
        }
        return data; 
    }

    clone(): HireStageDTO {
        const json = this.toJSON();
        let result = new HireStageDTO();
        result.init(json);
        return result;
    }
}

export interface IHireStageDTO {
    id: number;
    name: string | undefined;
    emailTemplateId: number;
    autoEmailRespond: boolean;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    reviewers: HireStageReviewer[] | undefined;
    subStages: SubHireStageDTO[] | undefined;
}

export class HireStageDTOListApiResult implements IHireStageDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: HireStageDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IHireStageDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(HireStageDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): HireStageDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new HireStageDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): HireStageDTOListApiResult {
        const json = this.toJSON();
        let result = new HireStageDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IHireStageDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: HireStageDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class HireStageIListApiResult implements IHireStageIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: HireStage[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IHireStageIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(HireStage.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): HireStageIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new HireStageIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): HireStageIListApiResult {
        const json = this.toJSON();
        let result = new HireStageIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IHireStageIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: HireStage[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class HireStageDTOApiResult implements IHireStageDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: HireStageDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IHireStageDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? HireStageDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): HireStageDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new HireStageDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): HireStageDTOApiResult {
        const json = this.toJSON();
        let result = new HireStageDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IHireStageDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: HireStageDTO;
    totalCount: number;
    totalRecord: number;
}

export class ManageSubHireStageDTO implements IManageSubHireStageDTO {
    id!: number;
    hireStageId!: number;
    name!: string | undefined;
    emailTemplateId!: number;
    autoEmailRespond!: boolean;
    scoreCard!: number;
    reviewers!: string | undefined;

    constructor(data?: IManageSubHireStageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hireStageId = _data["hireStageId"];
            this.name = _data["name"];
            this.emailTemplateId = _data["emailTemplateId"];
            this.autoEmailRespond = _data["autoEmailRespond"];
            this.scoreCard = _data["scoreCard"];
            this.reviewers = _data["reviewers"];
        }
    }

    static fromJS(data: any): ManageSubHireStageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageSubHireStageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hireStageId"] = this.hireStageId;
        data["name"] = this.name;
        data["emailTemplateId"] = this.emailTemplateId;
        data["autoEmailRespond"] = this.autoEmailRespond;
        data["scoreCard"] = this.scoreCard;
        data["reviewers"] = this.reviewers;
        return data; 
    }

    clone(): ManageSubHireStageDTO {
        const json = this.toJSON();
        let result = new ManageSubHireStageDTO();
        result.init(json);
        return result;
    }
}

export interface IManageSubHireStageDTO {
    id: number;
    hireStageId: number;
    name: string | undefined;
    emailTemplateId: number;
    autoEmailRespond: boolean;
    scoreCard: number;
    reviewers: string | undefined;
}

export class SubHireStageDTOListApiResult implements ISubHireStageDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubHireStageDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISubHireStageDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SubHireStageDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SubHireStageDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubHireStageDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SubHireStageDTOListApiResult {
        const json = this.toJSON();
        let result = new SubHireStageDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubHireStageDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubHireStageDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class SubHireStageIListApiResult implements ISubHireStageIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubHireStage[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISubHireStageIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SubHireStage.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SubHireStageIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubHireStageIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SubHireStageIListApiResult {
        const json = this.toJSON();
        let result = new SubHireStageIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubHireStageIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubHireStage[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class SubHireStageDTOApiResult implements ISubHireStageDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubHireStageDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISubHireStageDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? SubHireStageDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SubHireStageDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubHireStageDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SubHireStageDTOApiResult {
        const json = this.toJSON();
        let result = new SubHireStageDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubHireStageDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubHireStageDTO;
    totalCount: number;
    totalRecord: number;
}

export class ManageRecruitmentScoreCardDTO implements IManageRecruitmentScoreCardDTO {
    id!: number;
    focusArea!: string | undefined;
    totalWeight!: number;
    scoringTypeId!: number | undefined;
    questions!: string | undefined;

    constructor(data?: IManageRecruitmentScoreCardDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.focusArea = _data["focusArea"];
            this.totalWeight = _data["totalWeight"];
            this.scoringTypeId = _data["scoringTypeId"];
            this.questions = _data["questions"];
        }
    }

    static fromJS(data: any): ManageRecruitmentScoreCardDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageRecruitmentScoreCardDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["focusArea"] = this.focusArea;
        data["totalWeight"] = this.totalWeight;
        data["scoringTypeId"] = this.scoringTypeId;
        data["questions"] = this.questions;
        return data; 
    }

    clone(): ManageRecruitmentScoreCardDTO {
        const json = this.toJSON();
        let result = new ManageRecruitmentScoreCardDTO();
        result.init(json);
        return result;
    }
}

export interface IManageRecruitmentScoreCardDTO {
    id: number;
    focusArea: string | undefined;
    totalWeight: number;
    scoringTypeId: number | undefined;
    questions: string | undefined;
}

export class RecruitmentScoreCard implements IRecruitmentScoreCard {
    focusArea!: string | undefined;
    totalWeight!: number;
    scoringTypeId!: number | undefined;
    scoreCardQuestions!: ScoreCardQuestion[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRecruitmentScoreCard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.focusArea = _data["focusArea"];
            this.totalWeight = _data["totalWeight"];
            this.scoringTypeId = _data["scoringTypeId"];
            if (Array.isArray(_data["scoreCardQuestions"])) {
                this.scoreCardQuestions = [] as any;
                for (let item of _data["scoreCardQuestions"])
                    this.scoreCardQuestions!.push(ScoreCardQuestion.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RecruitmentScoreCard {
        data = typeof data === 'object' ? data : {};
        let result = new RecruitmentScoreCard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["focusArea"] = this.focusArea;
        data["totalWeight"] = this.totalWeight;
        data["scoringTypeId"] = this.scoringTypeId;
        if (Array.isArray(this.scoreCardQuestions)) {
            data["scoreCardQuestions"] = [];
            for (let item of this.scoreCardQuestions)
                data["scoreCardQuestions"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RecruitmentScoreCard {
        const json = this.toJSON();
        let result = new RecruitmentScoreCard();
        result.init(json);
        return result;
    }
}

export interface IRecruitmentScoreCard {
    focusArea: string | undefined;
    totalWeight: number;
    scoringTypeId: number | undefined;
    scoreCardQuestions: ScoreCardQuestion[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ScoreCardQuestion implements IScoreCardQuestion {
    recruitmentScoreCardId!: number;
    question!: string | undefined;
    weight!: number;
    scoreCard!: RecruitmentScoreCard;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IScoreCardQuestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recruitmentScoreCardId = _data["recruitmentScoreCardId"];
            this.question = _data["question"];
            this.weight = _data["weight"];
            this.scoreCard = _data["scoreCard"] ? RecruitmentScoreCard.fromJS(_data["scoreCard"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ScoreCardQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreCardQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recruitmentScoreCardId"] = this.recruitmentScoreCardId;
        data["question"] = this.question;
        data["weight"] = this.weight;
        data["scoreCard"] = this.scoreCard ? this.scoreCard.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ScoreCardQuestion {
        const json = this.toJSON();
        let result = new ScoreCardQuestion();
        result.init(json);
        return result;
    }
}

export interface IScoreCardQuestion {
    recruitmentScoreCardId: number;
    question: string | undefined;
    weight: number;
    scoreCard: RecruitmentScoreCard;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RecruitmentScoreCardDTO implements IRecruitmentScoreCardDTO {
    id!: number;
    focusArea!: string | undefined;
    totalWeight!: number;
    scoringTypeId!: number | undefined;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    questions!: ScoreCardQuestion[] | undefined;

    constructor(data?: IRecruitmentScoreCardDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.focusArea = _data["focusArea"];
            this.totalWeight = _data["totalWeight"];
            this.scoringTypeId = _data["scoringTypeId"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(ScoreCardQuestion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecruitmentScoreCardDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RecruitmentScoreCardDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["focusArea"] = this.focusArea;
        data["totalWeight"] = this.totalWeight;
        data["scoringTypeId"] = this.scoringTypeId;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RecruitmentScoreCardDTO {
        const json = this.toJSON();
        let result = new RecruitmentScoreCardDTO();
        result.init(json);
        return result;
    }
}

export interface IRecruitmentScoreCardDTO {
    id: number;
    focusArea: string | undefined;
    totalWeight: number;
    scoringTypeId: number | undefined;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    questions: ScoreCardQuestion[] | undefined;
}

export class RecruitmentScoreCardDTOListApiResult implements IRecruitmentScoreCardDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RecruitmentScoreCardDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRecruitmentScoreCardDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RecruitmentScoreCardDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RecruitmentScoreCardDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RecruitmentScoreCardDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RecruitmentScoreCardDTOListApiResult {
        const json = this.toJSON();
        let result = new RecruitmentScoreCardDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRecruitmentScoreCardDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RecruitmentScoreCardDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RecruitmentScoreCardIListApiResult implements IRecruitmentScoreCardIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RecruitmentScoreCard[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRecruitmentScoreCardIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RecruitmentScoreCard.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RecruitmentScoreCardIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RecruitmentScoreCardIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RecruitmentScoreCardIListApiResult {
        const json = this.toJSON();
        let result = new RecruitmentScoreCardIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRecruitmentScoreCardIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RecruitmentScoreCard[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RecruitmentScoreCardDTOApiResult implements IRecruitmentScoreCardDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RecruitmentScoreCardDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRecruitmentScoreCardDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? RecruitmentScoreCardDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RecruitmentScoreCardDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RecruitmentScoreCardDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RecruitmentScoreCardDTOApiResult {
        const json = this.toJSON();
        let result = new RecruitmentScoreCardDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IRecruitmentScoreCardDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RecruitmentScoreCardDTO;
    totalCount: number;
    totalRecord: number;
}

export class ManageRequestDTO implements IManageRequestDTO {
    id!: number;
    requestTypeId!: number;
    employeeId!: number;
    employeeContractId!: number;
    request_date!: Date;
    title!: string;
    description!: string;
    log_status!: number;
    resolution!: string | undefined;
    temp_resolution!: string | undefined;
    submitted_by!: string | undefined;
    date_resolved!: Date;
    refNo!: string | undefined;

    constructor(data?: IManageRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requestTypeId = _data["requestTypeId"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.log_status = _data["log_status"];
            this.resolution = _data["resolution"];
            this.temp_resolution = _data["temp_resolution"];
            this.submitted_by = _data["submitted_by"];
            this.date_resolved = _data["date_resolved"] ? new Date(_data["date_resolved"].toString()) : <any>undefined;
            this.refNo = _data["refNo"];
        }
    }

    static fromJS(data: any): ManageRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requestTypeId"] = this.requestTypeId;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["log_status"] = this.log_status;
        data["resolution"] = this.resolution;
        data["temp_resolution"] = this.temp_resolution;
        data["submitted_by"] = this.submitted_by;
        data["date_resolved"] = this.date_resolved ? this.date_resolved.toISOString() : <any>undefined;
        data["refNo"] = this.refNo;
        return data; 
    }

    clone(): ManageRequestDTO {
        const json = this.toJSON();
        let result = new ManageRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IManageRequestDTO {
    id: number;
    requestTypeId: number;
    employeeId: number;
    employeeContractId: number;
    request_date: Date;
    title: string;
    description: string;
    log_status: number;
    resolution: string | undefined;
    temp_resolution: string | undefined;
    submitted_by: string | undefined;
    date_resolved: Date;
    refNo: string | undefined;
}

export class RequestDTO implements IRequestDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    requestTypeId!: number;
    employeeId!: number;
    employeeContractId!: number;
    request_date!: Date;
    title!: string;
    description!: string;
    resolution!: string | undefined;
    temp_resolution!: string | undefined;
    submitted_by!: string | undefined;
    date_resolved!: Date;
    refNo!: string | undefined;
    employeeName!: string | undefined;
    status!: string | undefined;

    constructor(data?: IRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.requestTypeId = _data["requestTypeId"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.resolution = _data["resolution"];
            this.temp_resolution = _data["temp_resolution"];
            this.submitted_by = _data["submitted_by"];
            this.date_resolved = _data["date_resolved"] ? new Date(_data["date_resolved"].toString()) : <any>undefined;
            this.refNo = _data["refNo"];
            this.employeeName = _data["employeeName"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): RequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["requestTypeId"] = this.requestTypeId;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["resolution"] = this.resolution;
        data["temp_resolution"] = this.temp_resolution;
        data["submitted_by"] = this.submitted_by;
        data["date_resolved"] = this.date_resolved ? this.date_resolved.toISOString() : <any>undefined;
        data["refNo"] = this.refNo;
        data["employeeName"] = this.employeeName;
        data["status"] = this.status;
        return data; 
    }

    clone(): RequestDTO {
        const json = this.toJSON();
        let result = new RequestDTO();
        result.init(json);
        return result;
    }
}

export interface IRequestDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    requestTypeId: number;
    employeeId: number;
    employeeContractId: number;
    request_date: Date;
    title: string;
    description: string;
    resolution: string | undefined;
    temp_resolution: string | undefined;
    submitted_by: string | undefined;
    date_resolved: Date;
    refNo: string | undefined;
    employeeName: string | undefined;
    status: string | undefined;
}

export class RequestDTOListApiResult implements IRequestDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRequestDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RequestDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RequestDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RequestDTOListApiResult {
        const json = this.toJSON();
        let result = new RequestDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RequestDTOApiResult implements IRequestDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRequestDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? RequestDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RequestDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RequestDTOApiResult {
        const json = this.toJSON();
        let result = new RequestDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestDTO;
    totalCount: number;
    totalRecord: number;
}

export class ManageRequestTypeDTO implements IManageRequestTypeDTO {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    is_SystemRequirment!: boolean;
    isActive!: boolean;
    is_StepNotify!: boolean;

    constructor(data?: IManageRequestTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.is_SystemRequirment = _data["is_SystemRequirment"];
            this.isActive = _data["isActive"];
            this.is_StepNotify = _data["is_StepNotify"];
        }
    }

    static fromJS(data: any): ManageRequestTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageRequestTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["is_SystemRequirment"] = this.is_SystemRequirment;
        data["isActive"] = this.isActive;
        data["is_StepNotify"] = this.is_StepNotify;
        return data; 
    }

    clone(): ManageRequestTypeDTO {
        const json = this.toJSON();
        let result = new ManageRequestTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IManageRequestTypeDTO {
    id: number;
    name: string | undefined;
    code: string | undefined;
    is_SystemRequirment: boolean;
    isActive: boolean;
    is_StepNotify: boolean;
}

export class RequestTypeDTO implements IRequestTypeDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    typeId!: string | undefined;
    approval!: string | undefined;
    processid!: number;
    enable_step_notify!: boolean;
    is_system_requirement!: boolean;

    constructor(data?: IRequestTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.typeId = _data["typeId"];
            this.approval = _data["approval"];
            this.processid = _data["processid"];
            this.enable_step_notify = _data["enable_step_notify"];
            this.is_system_requirement = _data["is_system_requirement"];
        }
    }

    static fromJS(data: any): RequestTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RequestTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["typeId"] = this.typeId;
        data["approval"] = this.approval;
        data["processid"] = this.processid;
        data["enable_step_notify"] = this.enable_step_notify;
        data["is_system_requirement"] = this.is_system_requirement;
        return data; 
    }

    clone(): RequestTypeDTO {
        const json = this.toJSON();
        let result = new RequestTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IRequestTypeDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    typeId: string | undefined;
    approval: string | undefined;
    processid: number;
    enable_step_notify: boolean;
    is_system_requirement: boolean;
}

export class RequestTypeDTOListApiResult implements IRequestTypeDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestTypeDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRequestTypeDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RequestTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RequestTypeDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestTypeDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RequestTypeDTOListApiResult {
        const json = this.toJSON();
        let result = new RequestTypeDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestTypeDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestTypeDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RequestTypeDTOApiResult implements IRequestTypeDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestTypeDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRequestTypeDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? RequestTypeDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RequestTypeDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestTypeDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RequestTypeDTOApiResult {
        const json = this.toJSON();
        let result = new RequestTypeDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestTypeDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestTypeDTO;
    totalCount: number;
    totalRecord: number;
}

export class ManageRetirementDTO implements IManageRetirementDTO {
    id!: number;
    causeOfLeaving!: string | undefined;
    comment!: string | undefined;
    subReason!: string | undefined;
    sourceofInitiation!: string | undefined;
    retirementTypeId!: number | undefined;
    retirementUserId!: number | undefined;
    requriesBenefits!: boolean | undefined;
    personalEmail!: string | undefined;
    personalPhoneNumber!: string | undefined;
    log_status!: number;
    lastWorkingDate!: Date;
    exitDate!: Date;
    exitChoice!: string | undefined;
    tempref!: string | undefined;
    clearance!: string | undefined;
    survey!: string | undefined;
    employeee!: string | undefined;
    dob!: Date | undefined;
    appointmentDate!: Date | undefined;
    effectiveDate!: Date | undefined;
    strEffectiveDate!: string | undefined;
    reviewedBy!: string | undefined;
    reviewerComment!: string | undefined;
    dateReviewed!: Date | undefined;
    age!: number;
    employeeId!: number;
    employeeContractId!: number;

    constructor(data?: IManageRetirementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.causeOfLeaving = _data["causeOfLeaving"];
            this.comment = _data["comment"];
            this.subReason = _data["subReason"];
            this.sourceofInitiation = _data["sourceofInitiation"];
            this.retirementTypeId = _data["retirementTypeId"];
            this.retirementUserId = _data["retirementUserId"];
            this.requriesBenefits = _data["requriesBenefits"];
            this.personalEmail = _data["personalEmail"];
            this.personalPhoneNumber = _data["personalPhoneNumber"];
            this.log_status = _data["log_status"];
            this.lastWorkingDate = _data["lastWorkingDate"] ? new Date(_data["lastWorkingDate"].toString()) : <any>undefined;
            this.exitDate = _data["exitDate"] ? new Date(_data["exitDate"].toString()) : <any>undefined;
            this.exitChoice = _data["exitChoice"];
            this.tempref = _data["tempref"];
            this.clearance = _data["clearance"];
            this.survey = _data["survey"];
            this.employeee = _data["employeee"];
            this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
            this.appointmentDate = _data["appointmentDate"] ? new Date(_data["appointmentDate"].toString()) : <any>undefined;
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.strEffectiveDate = _data["strEffectiveDate"];
            this.reviewedBy = _data["reviewedBy"];
            this.reviewerComment = _data["reviewerComment"];
            this.dateReviewed = _data["dateReviewed"] ? new Date(_data["dateReviewed"].toString()) : <any>undefined;
            this.age = _data["age"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
        }
    }

    static fromJS(data: any): ManageRetirementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageRetirementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["causeOfLeaving"] = this.causeOfLeaving;
        data["comment"] = this.comment;
        data["subReason"] = this.subReason;
        data["sourceofInitiation"] = this.sourceofInitiation;
        data["retirementTypeId"] = this.retirementTypeId;
        data["retirementUserId"] = this.retirementUserId;
        data["requriesBenefits"] = this.requriesBenefits;
        data["personalEmail"] = this.personalEmail;
        data["personalPhoneNumber"] = this.personalPhoneNumber;
        data["log_status"] = this.log_status;
        data["lastWorkingDate"] = this.lastWorkingDate ? this.lastWorkingDate.toISOString() : <any>undefined;
        data["exitDate"] = this.exitDate ? this.exitDate.toISOString() : <any>undefined;
        data["exitChoice"] = this.exitChoice;
        data["tempref"] = this.tempref;
        data["clearance"] = this.clearance;
        data["survey"] = this.survey;
        data["employeee"] = this.employeee;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>undefined;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["strEffectiveDate"] = this.strEffectiveDate;
        data["reviewedBy"] = this.reviewedBy;
        data["reviewerComment"] = this.reviewerComment;
        data["dateReviewed"] = this.dateReviewed ? this.dateReviewed.toISOString() : <any>undefined;
        data["age"] = this.age;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        return data; 
    }

    clone(): ManageRetirementDTO {
        const json = this.toJSON();
        let result = new ManageRetirementDTO();
        result.init(json);
        return result;
    }
}

export interface IManageRetirementDTO {
    id: number;
    causeOfLeaving: string | undefined;
    comment: string | undefined;
    subReason: string | undefined;
    sourceofInitiation: string | undefined;
    retirementTypeId: number | undefined;
    retirementUserId: number | undefined;
    requriesBenefits: boolean | undefined;
    personalEmail: string | undefined;
    personalPhoneNumber: string | undefined;
    log_status: number;
    lastWorkingDate: Date;
    exitDate: Date;
    exitChoice: string | undefined;
    tempref: string | undefined;
    clearance: string | undefined;
    survey: string | undefined;
    employeee: string | undefined;
    dob: Date | undefined;
    appointmentDate: Date | undefined;
    effectiveDate: Date | undefined;
    strEffectiveDate: string | undefined;
    reviewedBy: string | undefined;
    reviewerComment: string | undefined;
    dateReviewed: Date | undefined;
    age: number;
    employeeId: number;
    employeeContractId: number;
}

export class RetirmentDTO implements IRetirmentDTO {
    id!: number;
    retirementLogId!: number;
    retirementTypeId!: number;
    retirementType!: string | undefined;
    age!: number;
    strAge!: string | undefined;
    yearsOfService!: number;
    strYearsOfService!: string | undefined;
    employeeId!: number;
    employeeContractId!: number;
    staffNo!: string | undefined;
    fullName!: string | undefined;
    dob!: Date | undefined;
    appointmentDate!: Date | undefined;
    effectiveDate!: Date | undefined;
    strEffectiveDate!: string | undefined;
    refNo!: string | undefined;
    causeOfLeaving!: string | undefined;
    otherComments!: string | undefined;
    submittedBy!: string | undefined;
    dateSubmitted!: Date | undefined;
    reviewedBy!: string | undefined;
    reviewerComment!: string | undefined;
    dateReviewed!: Date | undefined;
    isAccepted!: boolean | undefined;
    log_status!: number;
    subReason!: string | undefined;
    sourceofInitiation!: string | undefined;

    constructor(data?: IRetirmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.retirementLogId = _data["retirementLogId"];
            this.retirementTypeId = _data["retirementTypeId"];
            this.retirementType = _data["retirementType"];
            this.age = _data["age"];
            this.strAge = _data["strAge"];
            this.yearsOfService = _data["yearsOfService"];
            this.strYearsOfService = _data["strYearsOfService"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
            this.staffNo = _data["staffNo"];
            this.fullName = _data["fullName"];
            this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
            this.appointmentDate = _data["appointmentDate"] ? new Date(_data["appointmentDate"].toString()) : <any>undefined;
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.strEffectiveDate = _data["strEffectiveDate"];
            this.refNo = _data["refNo"];
            this.causeOfLeaving = _data["causeOfLeaving"];
            this.otherComments = _data["otherComments"];
            this.submittedBy = _data["submittedBy"];
            this.dateSubmitted = _data["dateSubmitted"] ? new Date(_data["dateSubmitted"].toString()) : <any>undefined;
            this.reviewedBy = _data["reviewedBy"];
            this.reviewerComment = _data["reviewerComment"];
            this.dateReviewed = _data["dateReviewed"] ? new Date(_data["dateReviewed"].toString()) : <any>undefined;
            this.isAccepted = _data["isAccepted"];
            this.log_status = _data["log_status"];
            this.subReason = _data["subReason"];
            this.sourceofInitiation = _data["sourceofInitiation"];
        }
    }

    static fromJS(data: any): RetirmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RetirmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["retirementLogId"] = this.retirementLogId;
        data["retirementTypeId"] = this.retirementTypeId;
        data["retirementType"] = this.retirementType;
        data["age"] = this.age;
        data["strAge"] = this.strAge;
        data["yearsOfService"] = this.yearsOfService;
        data["strYearsOfService"] = this.strYearsOfService;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        data["staffNo"] = this.staffNo;
        data["fullName"] = this.fullName;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>undefined;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["strEffectiveDate"] = this.strEffectiveDate;
        data["refNo"] = this.refNo;
        data["causeOfLeaving"] = this.causeOfLeaving;
        data["otherComments"] = this.otherComments;
        data["submittedBy"] = this.submittedBy;
        data["dateSubmitted"] = this.dateSubmitted ? this.dateSubmitted.toISOString() : <any>undefined;
        data["reviewedBy"] = this.reviewedBy;
        data["reviewerComment"] = this.reviewerComment;
        data["dateReviewed"] = this.dateReviewed ? this.dateReviewed.toISOString() : <any>undefined;
        data["isAccepted"] = this.isAccepted;
        data["log_status"] = this.log_status;
        data["subReason"] = this.subReason;
        data["sourceofInitiation"] = this.sourceofInitiation;
        return data; 
    }

    clone(): RetirmentDTO {
        const json = this.toJSON();
        let result = new RetirmentDTO();
        result.init(json);
        return result;
    }
}

export interface IRetirmentDTO {
    id: number;
    retirementLogId: number;
    retirementTypeId: number;
    retirementType: string | undefined;
    age: number;
    strAge: string | undefined;
    yearsOfService: number;
    strYearsOfService: string | undefined;
    employeeId: number;
    employeeContractId: number;
    staffNo: string | undefined;
    fullName: string | undefined;
    dob: Date | undefined;
    appointmentDate: Date | undefined;
    effectiveDate: Date | undefined;
    strEffectiveDate: string | undefined;
    refNo: string | undefined;
    causeOfLeaving: string | undefined;
    otherComments: string | undefined;
    submittedBy: string | undefined;
    dateSubmitted: Date | undefined;
    reviewedBy: string | undefined;
    reviewerComment: string | undefined;
    dateReviewed: Date | undefined;
    isAccepted: boolean | undefined;
    log_status: number;
    subReason: string | undefined;
    sourceofInitiation: string | undefined;
}

export class RetirmentDTOListApiResult implements IRetirmentDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RetirmentDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRetirmentDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RetirmentDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RetirmentDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RetirmentDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RetirmentDTOListApiResult {
        const json = this.toJSON();
        let result = new RetirmentDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRetirmentDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RetirmentDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RetirementLog implements IRetirementLog {
    refNo!: string | undefined;
    employeeId!: number;
    employeeContractId!: number;
    dob!: Date;
    appointmentDate!: Date | undefined;
    age!: number;
    yearsOfService!: number;
    effectiveDate!: Date;
    retirementTypeId!: number;
    causeOfLeaving!: string | undefined;
    otherComments!: string | undefined;
    submittedBy!: string | undefined;
    log_status!: number;
    isAccepted!: boolean;
    reviewedBy!: string | undefined;
    reviewDate!: Date | undefined;
    reviewComment!: string | undefined;
    personalEmail!: string | undefined;
    personalPhoneNumber!: string | undefined;
    lastWorkingDate!: Date;
    exitDate!: Date;
    exitChoice!: string | undefined;
    tempref!: string | undefined;
    clearance!: string | undefined;
    survey!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRetirementLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refNo = _data["refNo"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
            this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
            this.appointmentDate = _data["appointmentDate"] ? new Date(_data["appointmentDate"].toString()) : <any>undefined;
            this.age = _data["age"];
            this.yearsOfService = _data["yearsOfService"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.retirementTypeId = _data["retirementTypeId"];
            this.causeOfLeaving = _data["causeOfLeaving"];
            this.otherComments = _data["otherComments"];
            this.submittedBy = _data["submittedBy"];
            this.log_status = _data["log_status"];
            this.isAccepted = _data["isAccepted"];
            this.reviewedBy = _data["reviewedBy"];
            this.reviewDate = _data["reviewDate"] ? new Date(_data["reviewDate"].toString()) : <any>undefined;
            this.reviewComment = _data["reviewComment"];
            this.personalEmail = _data["personalEmail"];
            this.personalPhoneNumber = _data["personalPhoneNumber"];
            this.lastWorkingDate = _data["lastWorkingDate"] ? new Date(_data["lastWorkingDate"].toString()) : <any>undefined;
            this.exitDate = _data["exitDate"] ? new Date(_data["exitDate"].toString()) : <any>undefined;
            this.exitChoice = _data["exitChoice"];
            this.tempref = _data["tempref"];
            this.clearance = _data["clearance"];
            this.survey = _data["survey"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RetirementLog {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refNo"] = this.refNo;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>undefined;
        data["age"] = this.age;
        data["yearsOfService"] = this.yearsOfService;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["retirementTypeId"] = this.retirementTypeId;
        data["causeOfLeaving"] = this.causeOfLeaving;
        data["otherComments"] = this.otherComments;
        data["submittedBy"] = this.submittedBy;
        data["log_status"] = this.log_status;
        data["isAccepted"] = this.isAccepted;
        data["reviewedBy"] = this.reviewedBy;
        data["reviewDate"] = this.reviewDate ? this.reviewDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["personalEmail"] = this.personalEmail;
        data["personalPhoneNumber"] = this.personalPhoneNumber;
        data["lastWorkingDate"] = this.lastWorkingDate ? this.lastWorkingDate.toISOString() : <any>undefined;
        data["exitDate"] = this.exitDate ? this.exitDate.toISOString() : <any>undefined;
        data["exitChoice"] = this.exitChoice;
        data["tempref"] = this.tempref;
        data["clearance"] = this.clearance;
        data["survey"] = this.survey;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RetirementLog {
        const json = this.toJSON();
        let result = new RetirementLog();
        result.init(json);
        return result;
    }
}

export interface IRetirementLog {
    refNo: string | undefined;
    employeeId: number;
    employeeContractId: number;
    dob: Date;
    appointmentDate: Date | undefined;
    age: number;
    yearsOfService: number;
    effectiveDate: Date;
    retirementTypeId: number;
    causeOfLeaving: string | undefined;
    otherComments: string | undefined;
    submittedBy: string | undefined;
    log_status: number;
    isAccepted: boolean;
    reviewedBy: string | undefined;
    reviewDate: Date | undefined;
    reviewComment: string | undefined;
    personalEmail: string | undefined;
    personalPhoneNumber: string | undefined;
    lastWorkingDate: Date;
    exitDate: Date;
    exitChoice: string | undefined;
    tempref: string | undefined;
    clearance: string | undefined;
    survey: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RetirementLogListApiResult implements IRetirementLogListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RetirementLog[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRetirementLogListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RetirementLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RetirementLogListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementLogListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RetirementLogListApiResult {
        const json = this.toJSON();
        let result = new RetirementLogListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRetirementLogListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RetirementLog[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RetirmentDTOApiResult implements IRetirmentDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RetirmentDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRetirmentDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? RetirmentDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RetirmentDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RetirmentDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RetirmentDTOApiResult {
        const json = this.toJSON();
        let result = new RetirmentDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IRetirmentDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RetirmentDTO;
    totalCount: number;
    totalRecord: number;
}

export class RetirementApiResult implements IRetirementApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Retirement;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRetirementApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? Retirement.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RetirementApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RetirementApiResult {
        const json = this.toJSON();
        let result = new RetirementApiResult();
        result.init(json);
        return result;
    }
}

export interface IRetirementApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Retirement;
    totalCount: number;
    totalRecord: number;
}

export class ManageRetirmentTypeDTO implements IManageRetirmentTypeDTO {
    id!: number;
    name!: string | undefined;
    requirments!: string | undefined;
    isEntitledToBenefits!: boolean;

    constructor(data?: IManageRetirmentTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.requirments = _data["requirments"];
            this.isEntitledToBenefits = _data["isEntitledToBenefits"];
        }
    }

    static fromJS(data: any): ManageRetirmentTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageRetirmentTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["requirments"] = this.requirments;
        data["isEntitledToBenefits"] = this.isEntitledToBenefits;
        return data; 
    }

    clone(): ManageRetirmentTypeDTO {
        const json = this.toJSON();
        let result = new ManageRetirmentTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IManageRetirmentTypeDTO {
    id: number;
    name: string | undefined;
    requirments: string | undefined;
    isEntitledToBenefits: boolean;
}

export class AddRequestViewModel implements IAddRequestViewModel {
    id!: number;
    name!: string | undefined;
    typeId!: string | undefined;
    approval!: string | undefined;
    processid!: number;
    code!: string | undefined;
    enable_step_notify!: boolean;
    is_system_requirement!: boolean;

    constructor(data?: IAddRequestViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.approval = _data["approval"];
            this.processid = _data["processid"];
            this.code = _data["code"];
            this.enable_step_notify = _data["enable_step_notify"];
            this.is_system_requirement = _data["is_system_requirement"];
        }
    }

    static fromJS(data: any): AddRequestViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddRequestViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["approval"] = this.approval;
        data["processid"] = this.processid;
        data["code"] = this.code;
        data["enable_step_notify"] = this.enable_step_notify;
        data["is_system_requirement"] = this.is_system_requirement;
        return data; 
    }

    clone(): AddRequestViewModel {
        const json = this.toJSON();
        let result = new AddRequestViewModel();
        result.init(json);
        return result;
    }
}

export interface IAddRequestViewModel {
    id: number;
    name: string | undefined;
    typeId: string | undefined;
    approval: string | undefined;
    processid: number;
    code: string | undefined;
    enable_step_notify: boolean;
    is_system_requirement: boolean;
}

export class RequestItemViewModel implements IRequestItemViewModel {
    requestType!: string | undefined;
    employeeName!: string | undefined;
    refNo!: string | undefined;
    title!: string | undefined;
    request_date!: Date;
    log_status!: number;
    resolution!: string | undefined;
    dateCreated!: Date;
    id!: number;

    constructor(data?: IRequestItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestType = _data["requestType"];
            this.employeeName = _data["employeeName"];
            this.refNo = _data["refNo"];
            this.title = _data["title"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.log_status = _data["log_status"];
            this.resolution = _data["resolution"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RequestItemViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestItemViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestType"] = this.requestType;
        data["employeeName"] = this.employeeName;
        data["refNo"] = this.refNo;
        data["title"] = this.title;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["log_status"] = this.log_status;
        data["resolution"] = this.resolution;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RequestItemViewModel {
        const json = this.toJSON();
        let result = new RequestItemViewModel();
        result.init(json);
        return result;
    }
}

export interface IRequestItemViewModel {
    requestType: string | undefined;
    employeeName: string | undefined;
    refNo: string | undefined;
    title: string | undefined;
    request_date: Date;
    log_status: number;
    resolution: string | undefined;
    dateCreated: Date;
    id: number;
}

export class RequestViewModel implements IRequestViewModel {
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    log_Status!: number;
    lstOfRequests!: RequestItemViewModel[] | undefined;

    constructor(data?: IRequestViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.log_Status = _data["log_Status"];
            if (Array.isArray(_data["lstOfRequests"])) {
                this.lstOfRequests = [] as any;
                for (let item of _data["lstOfRequests"])
                    this.lstOfRequests!.push(RequestItemViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["log_Status"] = this.log_Status;
        if (Array.isArray(this.lstOfRequests)) {
            data["lstOfRequests"] = [];
            for (let item of this.lstOfRequests)
                data["lstOfRequests"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RequestViewModel {
        const json = this.toJSON();
        let result = new RequestViewModel();
        result.init(json);
        return result;
    }
}

export interface IRequestViewModel {
    startDate: Date | undefined;
    endDate: Date | undefined;
    log_Status: number;
    lstOfRequests: RequestItemViewModel[] | undefined;
}

export class RequestViewModelIListApiResult implements IRequestViewModelIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestViewModel[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRequestViewModelIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RequestViewModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RequestViewModelIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestViewModelIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RequestViewModelIListApiResult {
        const json = this.toJSON();
        let result = new RequestViewModelIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestViewModelIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestViewModel[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RequestFileDto implements IRequestFileDto {
    request!: RequestFile[] | undefined;
    processId!: number[] | undefined;
    employee!: string | undefined;
    itemId!: number;
    employeeName!: string | undefined;

    constructor(data?: IRequestFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["request"])) {
                this.request = [] as any;
                for (let item of _data["request"])
                    this.request!.push(RequestFile.fromJS(item));
            }
            if (Array.isArray(_data["processId"])) {
                this.processId = [] as any;
                for (let item of _data["processId"])
                    this.processId!.push(item);
            }
            this.employee = _data["employee"];
            this.itemId = _data["itemId"];
            this.employeeName = _data["employeeName"];
        }
    }

    static fromJS(data: any): RequestFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.request)) {
            data["request"] = [];
            for (let item of this.request)
                data["request"].push(item.toJSON());
        }
        if (Array.isArray(this.processId)) {
            data["processId"] = [];
            for (let item of this.processId)
                data["processId"].push(item);
        }
        data["employee"] = this.employee;
        data["itemId"] = this.itemId;
        data["employeeName"] = this.employeeName;
        return data; 
    }

    clone(): RequestFileDto {
        const json = this.toJSON();
        let result = new RequestFileDto();
        result.init(json);
        return result;
    }
}

export interface IRequestFileDto {
    request: RequestFile[] | undefined;
    processId: number[] | undefined;
    employee: string | undefined;
    itemId: number;
    employeeName: string | undefined;
}

export class RequestFileDtoIListApiResult implements IRequestFileDtoIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestFileDto[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRequestFileDtoIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RequestFileDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RequestFileDtoIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestFileDtoIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RequestFileDtoIListApiResult {
        const json = this.toJSON();
        let result = new RequestFileDtoIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestFileDtoIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestFileDto[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ApplicationRoleDTO implements IApplicationRoleDTO {
    id!: number;
    name!: string;
    description!: string | undefined;
    isSystemRole!: boolean;

    constructor(data?: IApplicationRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isSystemRole = _data["isSystemRole"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isSystemRole"] = this.isSystemRole;
        return data; 
    }

    clone(): ApplicationRoleDTO {
        const json = this.toJSON();
        let result = new ApplicationRoleDTO();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTO {
    id: number;
    name: string;
    description: string | undefined;
    isSystemRole: boolean;
}

export class ApplicationRoleDTOIListApiResult implements IApplicationRoleDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationRoleDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IApplicationRoleDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApplicationRoleDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ApplicationRoleDTOIListApiResult {
        const json = this.toJSON();
        let result = new ApplicationRoleDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationRoleDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ApplicationRoleDTOApiResult implements IApplicationRoleDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationRoleDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IApplicationRoleDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? ApplicationRoleDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ApplicationRoleDTOApiResult {
        const json = this.toJSON();
        let result = new ApplicationRoleDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationRoleDTO;
    totalCount: number;
    totalRecord: number;
}

export class PermissionDTO implements IPermissionDTO {
    id!: number;
    name!: string | undefined;
    applicationName!: string | undefined;
    code!: string | undefined;

    constructor(data?: IPermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.applicationName = _data["applicationName"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): PermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["applicationName"] = this.applicationName;
        data["code"] = this.code;
        return data; 
    }

    clone(): PermissionDTO {
        const json = this.toJSON();
        let result = new PermissionDTO();
        result.init(json);
        return result;
    }
}

export interface IPermissionDTO {
    id: number;
    name: string | undefined;
    applicationName: string | undefined;
    code: string | undefined;
}

export class RolePermissionDTO implements IRolePermissionDTO {
    roleId!: number;
    roleName!: string | undefined;
    permissions!: PermissionDTO[] | undefined;

    constructor(data?: IRolePermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolePermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RolePermissionDTO {
        const json = this.toJSON();
        let result = new RolePermissionDTO();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTO {
    roleId: number;
    roleName: string | undefined;
    permissions: PermissionDTO[] | undefined;
}

export class RolePermissionDTOIListApiResult implements IRolePermissionDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RolePermissionDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRolePermissionDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RolePermissionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RolePermissionDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RolePermissionDTOIListApiResult {
        const json = this.toJSON();
        let result = new RolePermissionDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RolePermissionDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class RolePermissionDTOApiResult implements IRolePermissionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RolePermissionDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IRolePermissionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? RolePermissionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): RolePermissionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): RolePermissionDTOApiResult {
        const json = this.toJSON();
        let result = new RolePermissionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RolePermissionDTO;
    totalCount: number;
    totalRecord: number;
}

export class RolePermissionMappingDTO implements IRolePermissionMappingDTO {
    roleId!: number;
    permissionIds!: number[];

    constructor(data?: IRolePermissionMappingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permissionIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            if (Array.isArray(_data["permissionIds"])) {
                this.permissionIds = [] as any;
                for (let item of _data["permissionIds"])
                    this.permissionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): RolePermissionMappingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionMappingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        if (Array.isArray(this.permissionIds)) {
            data["permissionIds"] = [];
            for (let item of this.permissionIds)
                data["permissionIds"].push(item);
        }
        return data; 
    }

    clone(): RolePermissionMappingDTO {
        const json = this.toJSON();
        let result = new RolePermissionMappingDTO();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionMappingDTO {
    roleId: number;
    permissionIds: number[];
}

export class ManageSalaryscaleDTO implements IManageSalaryscaleDTO {
    id!: number;
    name!: string;
    code!: string;
    isActive!: boolean;

    constructor(data?: IManageSalaryscaleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ManageSalaryscaleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageSalaryscaleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ManageSalaryscaleDTO {
        const json = this.toJSON();
        let result = new ManageSalaryscaleDTO();
        result.init(json);
        return result;
    }
}

export interface IManageSalaryscaleDTO {
    id: number;
    name: string;
    code: string;
    isActive: boolean;
}

export class SalaryscaleDTO implements ISalaryscaleDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISalaryscaleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): SalaryscaleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryscaleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): SalaryscaleDTO {
        const json = this.toJSON();
        let result = new SalaryscaleDTO();
        result.init(json);
        return result;
    }
}

export interface ISalaryscaleDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class SalaryscaleDTOListApiResult implements ISalaryscaleDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SalaryscaleDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISalaryscaleDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SalaryscaleDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SalaryscaleDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryscaleDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SalaryscaleDTOListApiResult {
        const json = this.toJSON();
        let result = new SalaryscaleDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISalaryscaleDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SalaryscaleDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class SalaryscaleDTOApiResult implements ISalaryscaleDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SalaryscaleDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISalaryscaleDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? SalaryscaleDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SalaryscaleDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryscaleDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SalaryscaleDTOApiResult {
        const json = this.toJSON();
        let result = new SalaryscaleDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ISalaryscaleDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SalaryscaleDTO;
    totalCount: number;
    totalRecord: number;
}

export class ManageSkillDTO implements IManageSkillDTO {
    id!: number;
    categoryId!: number;
    category!: string | undefined;
    skills!: string | undefined;

    constructor(data?: IManageSkillDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"];
            this.skills = _data["skills"];
        }
    }

    static fromJS(data: any): ManageSkillDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageSkillDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category;
        data["skills"] = this.skills;
        return data; 
    }

    clone(): ManageSkillDTO {
        const json = this.toJSON();
        let result = new ManageSkillDTO();
        result.init(json);
        return result;
    }
}

export interface IManageSkillDTO {
    id: number;
    categoryId: number;
    category: string | undefined;
    skills: string | undefined;
}

export class SkillListApiResult implements ISkillListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Skill[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISkillListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Skill.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SkillListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SkillListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SkillListApiResult {
        const json = this.toJSON();
        let result = new SkillListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISkillListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Skill[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class SkillApiResult implements ISkillApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Skill;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISkillApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? Skill.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SkillApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SkillApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SkillApiResult {
        const json = this.toJSON();
        let result = new SkillApiResult();
        result.init(json);
        return result;
    }
}

export interface ISkillApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Skill;
    totalCount: number;
    totalRecord: number;
}

export class Modular implements IModular {
    id!: number;
    name!: string | undefined;
    defaultEnabled!: boolean;
    makeAvailable!: boolean;
    subscriptionPlanModules!: SubscriptionPlanModule[] | undefined;

    constructor(data?: IModular) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.defaultEnabled = _data["defaultEnabled"];
            this.makeAvailable = _data["makeAvailable"];
            if (Array.isArray(_data["subscriptionPlanModules"])) {
                this.subscriptionPlanModules = [] as any;
                for (let item of _data["subscriptionPlanModules"])
                    this.subscriptionPlanModules!.push(SubscriptionPlanModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Modular {
        data = typeof data === 'object' ? data : {};
        let result = new Modular();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["defaultEnabled"] = this.defaultEnabled;
        data["makeAvailable"] = this.makeAvailable;
        if (Array.isArray(this.subscriptionPlanModules)) {
            data["subscriptionPlanModules"] = [];
            for (let item of this.subscriptionPlanModules)
                data["subscriptionPlanModules"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Modular {
        const json = this.toJSON();
        let result = new Modular();
        result.init(json);
        return result;
    }
}

export interface IModular {
    id: number;
    name: string | undefined;
    defaultEnabled: boolean;
    makeAvailable: boolean;
    subscriptionPlanModules: SubscriptionPlanModule[] | undefined;
}

export class SubscriptionPlanModule implements ISubscriptionPlanModule {
    id!: number;
    subscriptionPlanId!: number;
    subscriptionPlanName!: string | undefined;
    modularId!: number;
    modularName!: string | undefined;
    lastDateModified!: Date | undefined;
    modularDefaultEnabled!: boolean;
    subscriptionPlan!: SubscriptionPlan;
    modular!: Modular;

    constructor(data?: ISubscriptionPlanModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.subscriptionPlanName = _data["subscriptionPlanName"];
            this.modularId = _data["modularId"];
            this.modularName = _data["modularName"];
            this.lastDateModified = _data["lastDateModified"] ? new Date(_data["lastDateModified"].toString()) : <any>undefined;
            this.modularDefaultEnabled = _data["modularDefaultEnabled"];
            this.subscriptionPlan = _data["subscriptionPlan"] ? SubscriptionPlan.fromJS(_data["subscriptionPlan"]) : <any>undefined;
            this.modular = _data["modular"] ? Modular.fromJS(_data["modular"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SubscriptionPlanModule {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["subscriptionPlanName"] = this.subscriptionPlanName;
        data["modularId"] = this.modularId;
        data["modularName"] = this.modularName;
        data["lastDateModified"] = this.lastDateModified ? this.lastDateModified.toISOString() : <any>undefined;
        data["modularDefaultEnabled"] = this.modularDefaultEnabled;
        data["subscriptionPlan"] = this.subscriptionPlan ? this.subscriptionPlan.toJSON() : <any>undefined;
        data["modular"] = this.modular ? this.modular.toJSON() : <any>undefined;
        return data; 
    }

    clone(): SubscriptionPlanModule {
        const json = this.toJSON();
        let result = new SubscriptionPlanModule();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanModule {
    id: number;
    subscriptionPlanId: number;
    subscriptionPlanName: string | undefined;
    modularId: number;
    modularName: string | undefined;
    lastDateModified: Date | undefined;
    modularDefaultEnabled: boolean;
    subscriptionPlan: SubscriptionPlan;
    modular: Modular;
}

export class SubscriptionPlan implements ISubscriptionPlan {
    id!: number;
    planCode!: string | undefined;
    name!: string | undefined;
    paymentUrl!: string | undefined;
    amount!: number;
    licenseCount!: number;
    created!: Date | undefined;
    modified!: Date | undefined;
    subscriptionPlanModules!: SubscriptionPlanModule[] | undefined;

    constructor(data?: ISubscriptionPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.planCode = _data["planCode"];
            this.name = _data["name"];
            this.paymentUrl = _data["paymentUrl"];
            this.amount = _data["amount"];
            this.licenseCount = _data["licenseCount"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            if (Array.isArray(_data["subscriptionPlanModules"])) {
                this.subscriptionPlanModules = [] as any;
                for (let item of _data["subscriptionPlanModules"])
                    this.subscriptionPlanModules!.push(SubscriptionPlanModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubscriptionPlan {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["planCode"] = this.planCode;
        data["name"] = this.name;
        data["paymentUrl"] = this.paymentUrl;
        data["amount"] = this.amount;
        data["licenseCount"] = this.licenseCount;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        if (Array.isArray(this.subscriptionPlanModules)) {
            data["subscriptionPlanModules"] = [];
            for (let item of this.subscriptionPlanModules)
                data["subscriptionPlanModules"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SubscriptionPlan {
        const json = this.toJSON();
        let result = new SubscriptionPlan();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlan {
    id: number;
    planCode: string | undefined;
    name: string | undefined;
    paymentUrl: string | undefined;
    amount: number;
    licenseCount: number;
    created: Date | undefined;
    modified: Date | undefined;
    subscriptionPlanModules: SubscriptionPlanModule[] | undefined;
}

export class SubscriptionPlanIListApiResult implements ISubscriptionPlanIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubscriptionPlan[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISubscriptionPlanIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SubscriptionPlan.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SubscriptionPlanIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SubscriptionPlanIListApiResult {
        const json = this.toJSON();
        let result = new SubscriptionPlanIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubscriptionPlan[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class SubscriptionPlanApiResult implements ISubscriptionPlanApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubscriptionPlan;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISubscriptionPlanApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? SubscriptionPlan.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SubscriptionPlanApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SubscriptionPlanApiResult {
        const json = this.toJSON();
        let result = new SubscriptionPlanApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubscriptionPlan;
    totalCount: number;
    totalRecord: number;
}

export class SubscriptionPlanModuleIListApiResult implements ISubscriptionPlanModuleIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubscriptionPlanModule[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ISubscriptionPlanModuleIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SubscriptionPlanModule.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): SubscriptionPlanModuleIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanModuleIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): SubscriptionPlanModuleIListApiResult {
        const json = this.toJSON();
        let result = new SubscriptionPlanModuleIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanModuleIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubscriptionPlanModule[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class TalentManagementRequirmentsDTO implements ITalentManagementRequirmentsDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    requirementCategory!: string | undefined;
    requirmentTypeId!: number;
    requirementPoints!: number;
    skillWeight!: number | undefined;
    experience!: string | undefined;
    experienceWeight!: number | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: ITalentManagementRequirmentsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.requirementCategory = _data["requirementCategory"];
            this.requirmentTypeId = _data["requirmentTypeId"];
            this.requirementPoints = _data["requirementPoints"];
            this.skillWeight = _data["skillWeight"];
            this.experience = _data["experience"];
            this.experienceWeight = _data["experienceWeight"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TalentManagementRequirmentsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TalentManagementRequirmentsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["requirementCategory"] = this.requirementCategory;
        data["requirmentTypeId"] = this.requirmentTypeId;
        data["requirementPoints"] = this.requirementPoints;
        data["skillWeight"] = this.skillWeight;
        data["experience"] = this.experience;
        data["experienceWeight"] = this.experienceWeight;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): TalentManagementRequirmentsDTO {
        const json = this.toJSON();
        let result = new TalentManagementRequirmentsDTO();
        result.init(json);
        return result;
    }
}

export interface ITalentManagementRequirmentsDTO {
    id: number;
    companyID: number;
    subID: number;
    requirementCategory: string | undefined;
    requirmentTypeId: number;
    requirementPoints: number;
    skillWeight: number | undefined;
    experience: string | undefined;
    experienceWeight: number | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AddTalentMangementDTO implements IAddTalentMangementDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    title!: string;
    description!: string | undefined;
    isActive!: boolean;
    dateCreated!: Date;
    isDeleted!: boolean;
    talentManagementRequirmentsDTOs!: TalentManagementRequirmentsDTO[] | undefined;

    constructor(data?: IAddTalentMangementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["talentManagementRequirmentsDTOs"])) {
                this.talentManagementRequirmentsDTOs = [] as any;
                for (let item of _data["talentManagementRequirmentsDTOs"])
                    this.talentManagementRequirmentsDTOs!.push(TalentManagementRequirmentsDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddTalentMangementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AddTalentMangementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.talentManagementRequirmentsDTOs)) {
            data["talentManagementRequirmentsDTOs"] = [];
            for (let item of this.talentManagementRequirmentsDTOs)
                data["talentManagementRequirmentsDTOs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AddTalentMangementDTO {
        const json = this.toJSON();
        let result = new AddTalentMangementDTO();
        result.init(json);
        return result;
    }
}

export interface IAddTalentMangementDTO {
    id: number;
    companyID: number;
    subID: number;
    title: string;
    description: string | undefined;
    isActive: boolean;
    dateCreated: Date;
    isDeleted: boolean;
    talentManagementRequirmentsDTOs: TalentManagementRequirmentsDTO[] | undefined;
}

export class EmployeeTalentMangementPoolHistoryDTO implements IEmployeeTalentMangementPoolHistoryDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    employeeTalentManagementPoolId!: number;
    talentManagementPoolId!: number;
    fromTalentManagementPoolId!: number;
    employeeId!: number;
    comment!: string | undefined;
    employeePoints!: number;
    talentPoints!: number;
    recommendations!: string | undefined;
    actionType!: string | undefined;
    loggedByUserId!: number;
    isActive!: boolean;

    constructor(data?: IEmployeeTalentMangementPoolHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.employeeTalentManagementPoolId = _data["employeeTalentManagementPoolId"];
            this.talentManagementPoolId = _data["talentManagementPoolId"];
            this.fromTalentManagementPoolId = _data["fromTalentManagementPoolId"];
            this.employeeId = _data["employeeId"];
            this.comment = _data["comment"];
            this.employeePoints = _data["employeePoints"];
            this.talentPoints = _data["talentPoints"];
            this.recommendations = _data["recommendations"];
            this.actionType = _data["actionType"];
            this.loggedByUserId = _data["loggedByUserId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): EmployeeTalentMangementPoolHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTalentMangementPoolHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["employeeTalentManagementPoolId"] = this.employeeTalentManagementPoolId;
        data["talentManagementPoolId"] = this.talentManagementPoolId;
        data["fromTalentManagementPoolId"] = this.fromTalentManagementPoolId;
        data["employeeId"] = this.employeeId;
        data["comment"] = this.comment;
        data["employeePoints"] = this.employeePoints;
        data["talentPoints"] = this.talentPoints;
        data["recommendations"] = this.recommendations;
        data["actionType"] = this.actionType;
        data["loggedByUserId"] = this.loggedByUserId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): EmployeeTalentMangementPoolHistoryDTO {
        const json = this.toJSON();
        let result = new EmployeeTalentMangementPoolHistoryDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeTalentMangementPoolHistoryDTO {
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    employeeTalentManagementPoolId: number;
    talentManagementPoolId: number;
    fromTalentManagementPoolId: number;
    employeeId: number;
    comment: string | undefined;
    employeePoints: number;
    talentPoints: number;
    recommendations: string | undefined;
    actionType: string | undefined;
    loggedByUserId: number;
    isActive: boolean;
}

export class AddEmployyeetoPoolDTO implements IAddEmployyeetoPoolDTO {
    id!: number;
    name!: string | undefined;
    employeeId!: number;
    department!: string | undefined;
    purpose!: string | undefined;
    division!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    talentPoolId!: number;
    employeeTalentMangementPoolHistoriesDTO!: EmployeeTalentMangementPoolHistoryDTO[] | undefined;

    constructor(data?: IAddEmployyeetoPoolDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.employeeId = _data["employeeId"];
            this.department = _data["department"];
            this.purpose = _data["purpose"];
            this.division = _data["division"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.talentPoolId = _data["talentPoolId"];
            if (Array.isArray(_data["employeeTalentMangementPoolHistoriesDTO"])) {
                this.employeeTalentMangementPoolHistoriesDTO = [] as any;
                for (let item of _data["employeeTalentMangementPoolHistoriesDTO"])
                    this.employeeTalentMangementPoolHistoriesDTO!.push(EmployeeTalentMangementPoolHistoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddEmployyeetoPoolDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AddEmployyeetoPoolDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["employeeId"] = this.employeeId;
        data["department"] = this.department;
        data["purpose"] = this.purpose;
        data["division"] = this.division;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["talentPoolId"] = this.talentPoolId;
        if (Array.isArray(this.employeeTalentMangementPoolHistoriesDTO)) {
            data["employeeTalentMangementPoolHistoriesDTO"] = [];
            for (let item of this.employeeTalentMangementPoolHistoriesDTO)
                data["employeeTalentMangementPoolHistoriesDTO"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AddEmployyeetoPoolDTO {
        const json = this.toJSON();
        let result = new AddEmployyeetoPoolDTO();
        result.init(json);
        return result;
    }
}

export interface IAddEmployyeetoPoolDTO {
    id: number;
    name: string | undefined;
    employeeId: number;
    department: string | undefined;
    purpose: string | undefined;
    division: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    talentPoolId: number;
    employeeTalentMangementPoolHistoriesDTO: EmployeeTalentMangementPoolHistoryDTO[] | undefined;
}

export class AddTalentMangementDTOListApiResult implements IAddTalentMangementDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AddTalentMangementDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IAddTalentMangementDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AddTalentMangementDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): AddTalentMangementDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AddTalentMangementDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): AddTalentMangementDTOListApiResult {
        const json = this.toJSON();
        let result = new AddTalentMangementDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAddTalentMangementDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AddTalentMangementDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class CompanySignUpDTO implements ICompanySignUpDTO {
    email!: string;
    phoneNumber!: string;
    password!: string;

    constructor(data?: ICompanySignUpDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CompanySignUpDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanySignUpDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        return data; 
    }

    clone(): CompanySignUpDTO {
        const json = this.toJSON();
        let result = new CompanySignUpDTO();
        result.init(json);
        return result;
    }
}

export interface ICompanySignUpDTO {
    email: string;
    phoneNumber: string;
    password: string;
}

export class Company implements ICompany {
    id!: number;
    name!: string | undefined;
    rcNo!: string | undefined;
    logoName!: string | undefined;
    landingImageBGName!: string | undefined;
    shortText!: string | undefined;
    email!: string | undefined;
    address!: string | undefined;
    phoneNumber!: string | undefined;
    adminEmail!: string | undefined;
    subscriptionPlanId!: number;
    lastBillingDate!: Date | undefined;
    lastPaymtDate!: Date | undefined;
    licenseUsuage!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    auditorEmail!: string | undefined;
    isActiveByAdmin!: boolean;
    created!: Date | undefined;
    modified!: Date | undefined;
    code!: string | undefined;
    colorBackGround!: string | undefined;
    domainName!: string | undefined;
    isTrial!: boolean;
    frequencyId!: number | undefined;
    referenceNumber!: string | undefined;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.rcNo = _data["rcNo"];
            this.logoName = _data["logoName"];
            this.landingImageBGName = _data["landingImageBGName"];
            this.shortText = _data["shortText"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.adminEmail = _data["adminEmail"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.lastBillingDate = _data["lastBillingDate"] ? new Date(_data["lastBillingDate"].toString()) : <any>undefined;
            this.lastPaymtDate = _data["lastPaymtDate"] ? new Date(_data["lastPaymtDate"].toString()) : <any>undefined;
            this.licenseUsuage = _data["licenseUsuage"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.auditorEmail = _data["auditorEmail"];
            this.isActiveByAdmin = _data["isActiveByAdmin"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.colorBackGround = _data["colorBackGround"];
            this.domainName = _data["domainName"];
            this.isTrial = _data["isTrial"];
            this.frequencyId = _data["frequencyId"];
            this.referenceNumber = _data["referenceNumber"];
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["rcNo"] = this.rcNo;
        data["logoName"] = this.logoName;
        data["landingImageBGName"] = this.landingImageBGName;
        data["shortText"] = this.shortText;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["adminEmail"] = this.adminEmail;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["lastBillingDate"] = this.lastBillingDate ? this.lastBillingDate.toISOString() : <any>undefined;
        data["lastPaymtDate"] = this.lastPaymtDate ? this.lastPaymtDate.toISOString() : <any>undefined;
        data["licenseUsuage"] = this.licenseUsuage;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["auditorEmail"] = this.auditorEmail;
        data["isActiveByAdmin"] = this.isActiveByAdmin;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["colorBackGround"] = this.colorBackGround;
        data["domainName"] = this.domainName;
        data["isTrial"] = this.isTrial;
        data["frequencyId"] = this.frequencyId;
        data["referenceNumber"] = this.referenceNumber;
        return data; 
    }

    clone(): Company {
        const json = this.toJSON();
        let result = new Company();
        result.init(json);
        return result;
    }
}

export interface ICompany {
    id: number;
    name: string | undefined;
    rcNo: string | undefined;
    logoName: string | undefined;
    landingImageBGName: string | undefined;
    shortText: string | undefined;
    email: string | undefined;
    address: string | undefined;
    phoneNumber: string | undefined;
    adminEmail: string | undefined;
    subscriptionPlanId: number;
    lastBillingDate: Date | undefined;
    lastPaymtDate: Date | undefined;
    licenseUsuage: number;
    isActive: boolean;
    isDeleted: boolean;
    auditorEmail: string | undefined;
    isActiveByAdmin: boolean;
    created: Date | undefined;
    modified: Date | undefined;
    code: string | undefined;
    colorBackGround: string | undefined;
    domainName: string | undefined;
    isTrial: boolean;
    frequencyId: number | undefined;
    referenceNumber: string | undefined;
}

export class CompanyIListApiResult implements ICompanyIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Company[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICompanyIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Company.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CompanyIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CompanyIListApiResult {
        const json = this.toJSON();
        let result = new CompanyIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICompanyIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Company[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class CompanyModuleDTO implements ICompanyModuleDTO {
    id!: number;
    moduleId!: number;
    companyId!: number;
    isEnabled!: boolean;
    moduleName!: string | undefined;
    icon!: string | undefined;
    isReadonly!: boolean;

    constructor(data?: ICompanyModuleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.moduleId = _data["moduleId"];
            this.companyId = _data["companyId"];
            this.isEnabled = _data["isEnabled"];
            this.moduleName = _data["moduleName"];
            this.icon = _data["icon"];
            this.isReadonly = _data["isReadonly"];
        }
    }

    static fromJS(data: any): CompanyModuleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyModuleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["moduleId"] = this.moduleId;
        data["companyId"] = this.companyId;
        data["isEnabled"] = this.isEnabled;
        data["moduleName"] = this.moduleName;
        data["icon"] = this.icon;
        data["isReadonly"] = this.isReadonly;
        return data; 
    }

    clone(): CompanyModuleDTO {
        const json = this.toJSON();
        let result = new CompanyModuleDTO();
        result.init(json);
        return result;
    }
}

export interface ICompanyModuleDTO {
    id: number;
    moduleId: number;
    companyId: number;
    isEnabled: boolean;
    moduleName: string | undefined;
    icon: string | undefined;
    isReadonly: boolean;
}

export class CompanyModuleDTOIListApiResult implements ICompanyModuleDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CompanyModuleDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ICompanyModuleDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CompanyModuleDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): CompanyModuleDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyModuleDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): CompanyModuleDTOIListApiResult {
        const json = this.toJSON();
        let result = new CompanyModuleDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICompanyModuleDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CompanyModuleDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class TrainingVendorPayload implements ITrainingVendorPayload {
    id!: number;
    name!: string;
    contactPerson!: string;
    phoneNo!: string;
    email!: string;
    website!: string | undefined;
    description!: string | undefined;
    trainingSpecializationId!: number;
    trainingTag!: string | undefined;

    constructor(data?: ITrainingVendorPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.contactPerson = _data["contactPerson"];
            this.phoneNo = _data["phoneNo"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.description = _data["description"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.trainingTag = _data["trainingTag"];
        }
    }

    static fromJS(data: any): TrainingVendorPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendorPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["contactPerson"] = this.contactPerson;
        data["phoneNo"] = this.phoneNo;
        data["email"] = this.email;
        data["website"] = this.website;
        data["description"] = this.description;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["trainingTag"] = this.trainingTag;
        return data; 
    }

    clone(): TrainingVendorPayload {
        const json = this.toJSON();
        let result = new TrainingVendorPayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendorPayload {
    id: number;
    name: string;
    contactPerson: string;
    phoneNo: string;
    email: string;
    website: string | undefined;
    description: string | undefined;
    trainingSpecializationId: number;
    trainingTag: string | undefined;
}

export class TrainingSpecialization implements ITrainingSpecialization {
    id!: number;
    name!: string | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingSpecialization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingSpecialization {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecialization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingSpecialization {
        const json = this.toJSON();
        let result = new TrainingSpecialization();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecialization {
    id: number;
    name: string | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingVendorResource implements ITrainingVendorResource {
    id!: number;
    name!: string | undefined;
    phoneNo!: string | undefined;
    email!: string | undefined;
    website!: string | undefined;
    description!: string | undefined;
    expertees!: string | undefined;
    trainingTag!: string | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;
    trainingSpecializationId!: number;
    trainingSpecialization!: TrainingSpecialization;

    constructor(data?: ITrainingVendorResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.phoneNo = _data["phoneNo"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.description = _data["description"];
            this.expertees = _data["expertees"];
            this.trainingTag = _data["trainingTag"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.trainingSpecialization = _data["trainingSpecialization"] ? TrainingSpecialization.fromJS(_data["trainingSpecialization"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingVendorResource {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendorResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["phoneNo"] = this.phoneNo;
        data["email"] = this.email;
        data["website"] = this.website;
        data["description"] = this.description;
        data["expertees"] = this.expertees;
        data["trainingTag"] = this.trainingTag;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["trainingSpecialization"] = this.trainingSpecialization ? this.trainingSpecialization.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TrainingVendorResource {
        const json = this.toJSON();
        let result = new TrainingVendorResource();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendorResource {
    id: number;
    name: string | undefined;
    phoneNo: string | undefined;
    email: string | undefined;
    website: string | undefined;
    description: string | undefined;
    expertees: string | undefined;
    trainingTag: string | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
    trainingSpecializationId: number;
    trainingSpecialization: TrainingSpecialization;
}

export class TrainingVendorResourceListApiResult implements ITrainingVendorResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingVendorResource[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ITrainingVendorResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingVendorResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): TrainingVendorResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendorResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): TrainingVendorResourceListApiResult {
        const json = this.toJSON();
        let result = new TrainingVendorResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendorResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingVendorResource[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class TrainingVendorResourceApiResult implements ITrainingVendorResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingVendorResource;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ITrainingVendorResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? TrainingVendorResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): TrainingVendorResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendorResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): TrainingVendorResourceApiResult {
        const json = this.toJSON();
        let result = new TrainingVendorResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendorResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingVendorResource;
    totalCount: number;
    totalRecord: number;
}

export class TrainingVendor implements ITrainingVendor {
    id!: number;
    name!: string;
    phoneNo!: string | undefined;
    trainingSpecializationId!: number;
    email!: string | undefined;
    website!: string | undefined;
    description!: string | undefined;
    expertees!: string | undefined;
    trainingTag!: string | undefined;
    trainingSpecialization!: TrainingSpecialization;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingVendor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.phoneNo = _data["phoneNo"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.description = _data["description"];
            this.expertees = _data["expertees"];
            this.trainingTag = _data["trainingTag"];
            this.trainingSpecialization = _data["trainingSpecialization"] ? TrainingSpecialization.fromJS(_data["trainingSpecialization"]) : <any>undefined;
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingVendor {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["phoneNo"] = this.phoneNo;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["email"] = this.email;
        data["website"] = this.website;
        data["description"] = this.description;
        data["expertees"] = this.expertees;
        data["trainingTag"] = this.trainingTag;
        data["trainingSpecialization"] = this.trainingSpecialization ? this.trainingSpecialization.toJSON() : <any>undefined;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingVendor {
        const json = this.toJSON();
        let result = new TrainingVendor();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendor {
    id: number;
    name: string;
    phoneNo: string | undefined;
    trainingSpecializationId: number;
    email: string | undefined;
    website: string | undefined;
    description: string | undefined;
    expertees: string | undefined;
    trainingTag: string | undefined;
    trainingSpecialization: TrainingSpecialization;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingCategory implements ITrainingCategory {
    id!: number;
    name!: string;
    trainingLocationFlagId!: number;
    locationFlag!: string | undefined;
    tags!: string | undefined;
    numberOfMonthsInterval!: number;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.trainingLocationFlagId = _data["trainingLocationFlagId"];
            this.locationFlag = _data["locationFlag"];
            this.tags = _data["tags"];
            this.numberOfMonthsInterval = _data["numberOfMonthsInterval"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingCategory {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["trainingLocationFlagId"] = this.trainingLocationFlagId;
        data["locationFlag"] = this.locationFlag;
        data["tags"] = this.tags;
        data["numberOfMonthsInterval"] = this.numberOfMonthsInterval;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingCategory {
        const json = this.toJSON();
        let result = new TrainingCategory();
        result.init(json);
        return result;
    }
}

export interface ITrainingCategory {
    id: number;
    name: string;
    trainingLocationFlagId: number;
    locationFlag: string | undefined;
    tags: string | undefined;
    numberOfMonthsInterval: number;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingType implements ITrainingType {
    id!: number;
    description!: string | undefined;
    summary!: string | undefined;
    outline!: string | undefined;
    contentUrl!: string | undefined;
    name!: string | undefined;
    maxCount!: number | undefined;
    remainingCount!: number | undefined;
    maxDays!: number | undefined;
    remainingDays!: number | undefined;
    isLocalTraining!: boolean | undefined;
    tags!: string | undefined;
    costPer_Head!: number;
    no_Of_Trainees!: number;
    overAll_Budget!: number;
    employeeId!: number;
    trainingVendorId!: number;
    trainingSpecializationId!: number;
    trainingCategoryId!: number;
    attachment!: string | undefined;
    trainings!: Training[] | undefined;
    trainingSpecialization!: TrainingSpecialization;
    trainingCategory!: TrainingCategory;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.summary = _data["summary"];
            this.outline = _data["outline"];
            this.contentUrl = _data["contentUrl"];
            this.name = _data["name"];
            this.maxCount = _data["maxCount"];
            this.remainingCount = _data["remainingCount"];
            this.maxDays = _data["maxDays"];
            this.remainingDays = _data["remainingDays"];
            this.isLocalTraining = _data["isLocalTraining"];
            this.tags = _data["tags"];
            this.costPer_Head = _data["costPer_Head"];
            this.no_Of_Trainees = _data["no_Of_Trainees"];
            this.overAll_Budget = _data["overAll_Budget"];
            this.employeeId = _data["employeeId"];
            this.trainingVendorId = _data["trainingVendorId"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.trainingCategoryId = _data["trainingCategoryId"];
            this.attachment = _data["attachment"];
            if (Array.isArray(_data["trainings"])) {
                this.trainings = [] as any;
                for (let item of _data["trainings"])
                    this.trainings!.push(Training.fromJS(item));
            }
            this.trainingSpecialization = _data["trainingSpecialization"] ? TrainingSpecialization.fromJS(_data["trainingSpecialization"]) : <any>undefined;
            this.trainingCategory = _data["trainingCategory"] ? TrainingCategory.fromJS(_data["trainingCategory"]) : <any>undefined;
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingType {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["summary"] = this.summary;
        data["outline"] = this.outline;
        data["contentUrl"] = this.contentUrl;
        data["name"] = this.name;
        data["maxCount"] = this.maxCount;
        data["remainingCount"] = this.remainingCount;
        data["maxDays"] = this.maxDays;
        data["remainingDays"] = this.remainingDays;
        data["isLocalTraining"] = this.isLocalTraining;
        data["tags"] = this.tags;
        data["costPer_Head"] = this.costPer_Head;
        data["no_Of_Trainees"] = this.no_Of_Trainees;
        data["overAll_Budget"] = this.overAll_Budget;
        data["employeeId"] = this.employeeId;
        data["trainingVendorId"] = this.trainingVendorId;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["trainingCategoryId"] = this.trainingCategoryId;
        data["attachment"] = this.attachment;
        if (Array.isArray(this.trainings)) {
            data["trainings"] = [];
            for (let item of this.trainings)
                data["trainings"].push(item.toJSON());
        }
        data["trainingSpecialization"] = this.trainingSpecialization ? this.trainingSpecialization.toJSON() : <any>undefined;
        data["trainingCategory"] = this.trainingCategory ? this.trainingCategory.toJSON() : <any>undefined;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingType {
        const json = this.toJSON();
        let result = new TrainingType();
        result.init(json);
        return result;
    }
}

export interface ITrainingType {
    id: number;
    description: string | undefined;
    summary: string | undefined;
    outline: string | undefined;
    contentUrl: string | undefined;
    name: string | undefined;
    maxCount: number | undefined;
    remainingCount: number | undefined;
    maxDays: number | undefined;
    remainingDays: number | undefined;
    isLocalTraining: boolean | undefined;
    tags: string | undefined;
    costPer_Head: number;
    no_Of_Trainees: number;
    overAll_Budget: number;
    employeeId: number;
    trainingVendorId: number;
    trainingSpecializationId: number;
    trainingCategoryId: number;
    attachment: string | undefined;
    trainings: Training[] | undefined;
    trainingSpecialization: TrainingSpecialization;
    trainingCategory: TrainingCategory;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class Training implements ITraining {
    id!: number;
    name!: string;
    description!: string | undefined;
    point!: number | undefined;
    log_status!: number;
    startDate!: Date;
    endDate!: Date;
    trainingTypeId!: number;
    vendorId!: number;
    specializationId!: number;
    trainingCategoryId!: number;
    strStartDate!: string | undefined;
    strEndDate!: string | undefined;
    totalCost!: number | undefined;
    costPerEmployee!: number | undefined;
    attachment!: string | undefined;
    trainingType!: TrainingType;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITraining) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.point = _data["point"];
            this.log_status = _data["log_status"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.trainingTypeId = _data["trainingTypeId"];
            this.vendorId = _data["vendorId"];
            this.specializationId = _data["specializationId"];
            this.trainingCategoryId = _data["trainingCategoryId"];
            this.strStartDate = _data["strStartDate"];
            this.strEndDate = _data["strEndDate"];
            this.totalCost = _data["totalCost"];
            this.costPerEmployee = _data["costPerEmployee"];
            this.attachment = _data["attachment"];
            this.trainingType = _data["trainingType"] ? TrainingType.fromJS(_data["trainingType"]) : <any>undefined;
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): Training {
        data = typeof data === 'object' ? data : {};
        let result = new Training();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["point"] = this.point;
        data["log_status"] = this.log_status;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["trainingTypeId"] = this.trainingTypeId;
        data["vendorId"] = this.vendorId;
        data["specializationId"] = this.specializationId;
        data["trainingCategoryId"] = this.trainingCategoryId;
        data["strStartDate"] = this.strStartDate;
        data["strEndDate"] = this.strEndDate;
        data["totalCost"] = this.totalCost;
        data["costPerEmployee"] = this.costPerEmployee;
        data["attachment"] = this.attachment;
        data["trainingType"] = this.trainingType ? this.trainingType.toJSON() : <any>undefined;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): Training {
        const json = this.toJSON();
        let result = new Training();
        result.init(json);
        return result;
    }
}

export interface ITraining {
    id: number;
    name: string;
    description: string | undefined;
    point: number | undefined;
    log_status: number;
    startDate: Date;
    endDate: Date;
    trainingTypeId: number;
    vendorId: number;
    specializationId: number;
    trainingCategoryId: number;
    strStartDate: string | undefined;
    strEndDate: string | undefined;
    totalCost: number | undefined;
    costPerEmployee: number | undefined;
    attachment: string | undefined;
    trainingType: TrainingType;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingTypeResource implements ITrainingTypeResource {
    id!: number;
    description!: string | undefined;
    contentUrl!: string | undefined;
    summary!: string | undefined;
    outline!: string | undefined;
    name!: string | undefined;
    maxCount!: number;
    remainingCount!: number;
    maxDays!: number;
    remainingDays!: number;
    isLocalTraining!: boolean;
    tags!: string | undefined;
    employeeId!: number;
    trainingVendorId!: number;
    trainingSpecializationId!: number;
    trainingCategoryId!: number;
    employee!: Employee;
    trainingVendor!: TrainingVendor;
    trainingSpecialization!: TrainingSpecialization;
    trainingCategory!: TrainingCategory;
    trainings!: Training[] | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingTypeResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.contentUrl = _data["contentUrl"];
            this.summary = _data["summary"];
            this.outline = _data["outline"];
            this.name = _data["name"];
            this.maxCount = _data["maxCount"];
            this.remainingCount = _data["remainingCount"];
            this.maxDays = _data["maxDays"];
            this.remainingDays = _data["remainingDays"];
            this.isLocalTraining = _data["isLocalTraining"];
            this.tags = _data["tags"];
            this.employeeId = _data["employeeId"];
            this.trainingVendorId = _data["trainingVendorId"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.trainingCategoryId = _data["trainingCategoryId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.trainingVendor = _data["trainingVendor"] ? TrainingVendor.fromJS(_data["trainingVendor"]) : <any>undefined;
            this.trainingSpecialization = _data["trainingSpecialization"] ? TrainingSpecialization.fromJS(_data["trainingSpecialization"]) : <any>undefined;
            this.trainingCategory = _data["trainingCategory"] ? TrainingCategory.fromJS(_data["trainingCategory"]) : <any>undefined;
            if (Array.isArray(_data["trainings"])) {
                this.trainings = [] as any;
                for (let item of _data["trainings"])
                    this.trainings!.push(Training.fromJS(item));
            }
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingTypeResource {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingTypeResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["contentUrl"] = this.contentUrl;
        data["summary"] = this.summary;
        data["outline"] = this.outline;
        data["name"] = this.name;
        data["maxCount"] = this.maxCount;
        data["remainingCount"] = this.remainingCount;
        data["maxDays"] = this.maxDays;
        data["remainingDays"] = this.remainingDays;
        data["isLocalTraining"] = this.isLocalTraining;
        data["tags"] = this.tags;
        data["employeeId"] = this.employeeId;
        data["trainingVendorId"] = this.trainingVendorId;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["trainingCategoryId"] = this.trainingCategoryId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["trainingVendor"] = this.trainingVendor ? this.trainingVendor.toJSON() : <any>undefined;
        data["trainingSpecialization"] = this.trainingSpecialization ? this.trainingSpecialization.toJSON() : <any>undefined;
        data["trainingCategory"] = this.trainingCategory ? this.trainingCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.trainings)) {
            data["trainings"] = [];
            for (let item of this.trainings)
                data["trainings"].push(item.toJSON());
        }
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingTypeResource {
        const json = this.toJSON();
        let result = new TrainingTypeResource();
        result.init(json);
        return result;
    }
}

export interface ITrainingTypeResource {
    id: number;
    description: string | undefined;
    contentUrl: string | undefined;
    summary: string | undefined;
    outline: string | undefined;
    name: string | undefined;
    maxCount: number;
    remainingCount: number;
    maxDays: number;
    remainingDays: number;
    isLocalTraining: boolean;
    tags: string | undefined;
    employeeId: number;
    trainingVendorId: number;
    trainingSpecializationId: number;
    trainingCategoryId: number;
    employee: Employee;
    trainingVendor: TrainingVendor;
    trainingSpecialization: TrainingSpecialization;
    trainingCategory: TrainingCategory;
    trainings: Training[] | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingTypeResourceListApiResult implements ITrainingTypeResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingTypeResource[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ITrainingTypeResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingTypeResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): TrainingTypeResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingTypeResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): TrainingTypeResourceListApiResult {
        const json = this.toJSON();
        let result = new TrainingTypeResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingTypeResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingTypeResource[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class TrainingTypeResourceApiResult implements ITrainingTypeResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingTypeResource;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ITrainingTypeResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? TrainingTypeResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): TrainingTypeResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingTypeResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): TrainingTypeResourceApiResult {
        const json = this.toJSON();
        let result = new TrainingTypeResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingTypeResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingTypeResource;
    totalCount: number;
    totalRecord: number;
}

export class ToggleTrainingType implements IToggleTrainingType {
    id!: number;
    status!: boolean;

    constructor(data?: IToggleTrainingType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ToggleTrainingType {
        data = typeof data === 'object' ? data : {};
        let result = new ToggleTrainingType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }

    clone(): ToggleTrainingType {
        const json = this.toJSON();
        let result = new ToggleTrainingType();
        result.init(json);
        return result;
    }
}

export interface IToggleTrainingType {
    id: number;
    status: boolean;
}

export class TrainingCategoryPayload implements ITrainingCategoryPayload {
    id!: number;
    name!: string;

    constructor(data?: ITrainingCategoryPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TrainingCategoryPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCategoryPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): TrainingCategoryPayload {
        const json = this.toJSON();
        let result = new TrainingCategoryPayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingCategoryPayload {
    id: number;
    name: string;
}

export class TrainingCategoryResource implements ITrainingCategoryResource {
    id!: number;
    name!: string | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingCategoryResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingCategoryResource {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCategoryResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingCategoryResource {
        const json = this.toJSON();
        let result = new TrainingCategoryResource();
        result.init(json);
        return result;
    }
}

export interface ITrainingCategoryResource {
    id: number;
    name: string | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingCategoryResourceListApiResult implements ITrainingCategoryResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingCategoryResource[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ITrainingCategoryResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingCategoryResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): TrainingCategoryResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCategoryResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): TrainingCategoryResourceListApiResult {
        const json = this.toJSON();
        let result = new TrainingCategoryResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingCategoryResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingCategoryResource[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class TrainingSpecializationPayload implements ITrainingSpecializationPayload {
    id!: number;
    name!: string;
    companyId!: number;
    subId!: number;

    constructor(data?: ITrainingSpecializationPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
        }
    }

    static fromJS(data: any): TrainingSpecializationPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecializationPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        return data; 
    }

    clone(): TrainingSpecializationPayload {
        const json = this.toJSON();
        let result = new TrainingSpecializationPayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecializationPayload {
    id: number;
    name: string;
    companyId: number;
    subId: number;
}

export class TrainingSpecializationDTO implements ITrainingSpecializationDTO {
    id!: number;
    name!: string | undefined;
    companyId!: number;
    subId!: number;
    is_Active!: boolean;
    is_Deleted!: boolean;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingSpecializationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.is_Active = _data["is_Active"];
            this.is_Deleted = _data["is_Deleted"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingSpecializationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecializationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["is_Active"] = this.is_Active;
        data["is_Deleted"] = this.is_Deleted;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingSpecializationDTO {
        const json = this.toJSON();
        let result = new TrainingSpecializationDTO();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecializationDTO {
    id: number;
    name: string | undefined;
    companyId: number;
    subId: number;
    is_Active: boolean;
    is_Deleted: boolean;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingSpecializationDTOListApiResult implements ITrainingSpecializationDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingSpecializationDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ITrainingSpecializationDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingSpecializationDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): TrainingSpecializationDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecializationDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): TrainingSpecializationDTOListApiResult {
        const json = this.toJSON();
        let result = new TrainingSpecializationDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecializationDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingSpecializationDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class TrainingSpecializationDTOApiResult implements ITrainingSpecializationDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingSpecializationDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ITrainingSpecializationDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? TrainingSpecializationDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): TrainingSpecializationDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecializationDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): TrainingSpecializationDTOApiResult {
        const json = this.toJSON();
        let result = new TrainingSpecializationDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecializationDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingSpecializationDTO;
    totalCount: number;
    totalRecord: number;
}

export class TrainingDTO implements ITrainingDTO {
    id!: number;
    name!: string | undefined;
    companyId!: number;
    subId!: number;
    description!: string | undefined;
    log_status!: number;
    startDate!: Date;
    endDate!: Date;
    trainingTypeId!: number;
    specializationId!: number;
    vendorId!: number;
    specialization!: string | undefined;
    trainingType!: string | undefined;
    trainingVendor!: string | undefined;
    totalCost!: number | undefined;
    costPerEmployee!: number | undefined;
    date_Created!: Date;
    created_By!: string | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.description = _data["description"];
            this.log_status = _data["log_status"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.trainingTypeId = _data["trainingTypeId"];
            this.specializationId = _data["specializationId"];
            this.vendorId = _data["vendorId"];
            this.specialization = _data["specialization"];
            this.trainingType = _data["trainingType"];
            this.trainingVendor = _data["trainingVendor"];
            this.totalCost = _data["totalCost"];
            this.costPerEmployee = _data["costPerEmployee"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["description"] = this.description;
        data["log_status"] = this.log_status;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["trainingTypeId"] = this.trainingTypeId;
        data["specializationId"] = this.specializationId;
        data["vendorId"] = this.vendorId;
        data["specialization"] = this.specialization;
        data["trainingType"] = this.trainingType;
        data["trainingVendor"] = this.trainingVendor;
        data["totalCost"] = this.totalCost;
        data["costPerEmployee"] = this.costPerEmployee;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingDTO {
        const json = this.toJSON();
        let result = new TrainingDTO();
        result.init(json);
        return result;
    }
}

export interface ITrainingDTO {
    id: number;
    name: string | undefined;
    companyId: number;
    subId: number;
    description: string | undefined;
    log_status: number;
    startDate: Date;
    endDate: Date;
    trainingTypeId: number;
    specializationId: number;
    vendorId: number;
    specialization: string | undefined;
    trainingType: string | undefined;
    trainingVendor: string | undefined;
    totalCost: number | undefined;
    costPerEmployee: number | undefined;
    date_Created: Date;
    created_By: string | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingDTOListApiResult implements ITrainingDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ITrainingDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): TrainingDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): TrainingDTOListApiResult {
        const json = this.toJSON();
        let result = new TrainingDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class TrainingDTOApiResult implements ITrainingDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingDTO;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ITrainingDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? TrainingDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): TrainingDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): TrainingDTOApiResult {
        const json = this.toJSON();
        let result = new TrainingDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingDTO;
    totalCount: number;
    totalRecord: number;
}

export class TrainingCriteriaPayload implements ITrainingCriteriaPayload {
    id!: number;
    name!: string;
    gradeId!: number | undefined;
    locationId!: number | undefined;
    employmentCategoryId!: number;
    ministryId!: number | undefined;
    departmentId!: number | undefined;
    trainingTypeId!: number | undefined;
    min_Age!: number;
    min_LengthOfService!: number;
    employmentTypeId!: number | undefined;
    salaryScaleId!: number | undefined;
    positionId!: number | undefined;

    constructor(data?: ITrainingCriteriaPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.gradeId = _data["gradeId"];
            this.locationId = _data["locationId"];
            this.employmentCategoryId = _data["employmentCategoryId"];
            this.ministryId = _data["ministryId"];
            this.departmentId = _data["departmentId"];
            this.trainingTypeId = _data["trainingTypeId"];
            this.min_Age = _data["min_Age"];
            this.min_LengthOfService = _data["min_LengthOfService"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.positionId = _data["positionId"];
        }
    }

    static fromJS(data: any): TrainingCriteriaPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCriteriaPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["gradeId"] = this.gradeId;
        data["locationId"] = this.locationId;
        data["employmentCategoryId"] = this.employmentCategoryId;
        data["ministryId"] = this.ministryId;
        data["departmentId"] = this.departmentId;
        data["trainingTypeId"] = this.trainingTypeId;
        data["min_Age"] = this.min_Age;
        data["min_LengthOfService"] = this.min_LengthOfService;
        data["employmentTypeId"] = this.employmentTypeId;
        data["salaryScaleId"] = this.salaryScaleId;
        data["positionId"] = this.positionId;
        return data; 
    }

    clone(): TrainingCriteriaPayload {
        const json = this.toJSON();
        let result = new TrainingCriteriaPayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingCriteriaPayload {
    id: number;
    name: string;
    gradeId: number | undefined;
    locationId: number | undefined;
    employmentCategoryId: number;
    ministryId: number | undefined;
    departmentId: number | undefined;
    trainingTypeId: number | undefined;
    min_Age: number;
    min_LengthOfService: number;
    employmentTypeId: number | undefined;
    salaryScaleId: number | undefined;
    positionId: number | undefined;
}

export class Ministry implements IMinistry {
    name!: string | undefined;
    code!: string | undefined;
    address!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IMinistry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.address = _data["address"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Ministry {
        data = typeof data === 'object' ? data : {};
        let result = new Ministry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["address"] = this.address;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Ministry {
        const json = this.toJSON();
        let result = new Ministry();
        result.init(json);
        return result;
    }
}

export interface IMinistry {
    name: string | undefined;
    code: string | undefined;
    address: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class TrainingCriteriaResource implements ITrainingCriteriaResource {
    id!: number;
    name!: string | undefined;
    gradeId!: number | undefined;
    locationId!: number | undefined;
    employmentCategoryId!: number;
    ministryId!: number | undefined;
    departmentId!: number | undefined;
    min_Age!: number;
    min_LengthOfService!: number;
    employmentTypeId!: number | undefined;
    salaryScaleId!: number | undefined;
    positionId!: number | undefined;
    trainingTypeId!: number | undefined;
    trainingType!: TrainingType;
    salaryScale!: SalaryScale;
    grade!: Grade;
    department!: Department;
    location!: Location;
    ministry!: Ministry;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingCriteriaResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.gradeId = _data["gradeId"];
            this.locationId = _data["locationId"];
            this.employmentCategoryId = _data["employmentCategoryId"];
            this.ministryId = _data["ministryId"];
            this.departmentId = _data["departmentId"];
            this.min_Age = _data["min_Age"];
            this.min_LengthOfService = _data["min_LengthOfService"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.positionId = _data["positionId"];
            this.trainingTypeId = _data["trainingTypeId"];
            this.trainingType = _data["trainingType"] ? TrainingType.fromJS(_data["trainingType"]) : <any>undefined;
            this.salaryScale = _data["salaryScale"] ? SalaryScale.fromJS(_data["salaryScale"]) : <any>undefined;
            this.grade = _data["grade"] ? Grade.fromJS(_data["grade"]) : <any>undefined;
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            this.ministry = _data["ministry"] ? Ministry.fromJS(_data["ministry"]) : <any>undefined;
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingCriteriaResource {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCriteriaResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["gradeId"] = this.gradeId;
        data["locationId"] = this.locationId;
        data["employmentCategoryId"] = this.employmentCategoryId;
        data["ministryId"] = this.ministryId;
        data["departmentId"] = this.departmentId;
        data["min_Age"] = this.min_Age;
        data["min_LengthOfService"] = this.min_LengthOfService;
        data["employmentTypeId"] = this.employmentTypeId;
        data["salaryScaleId"] = this.salaryScaleId;
        data["positionId"] = this.positionId;
        data["trainingTypeId"] = this.trainingTypeId;
        data["trainingType"] = this.trainingType ? this.trainingType.toJSON() : <any>undefined;
        data["salaryScale"] = this.salaryScale ? this.salaryScale.toJSON() : <any>undefined;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["ministry"] = this.ministry ? this.ministry.toJSON() : <any>undefined;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingCriteriaResource {
        const json = this.toJSON();
        let result = new TrainingCriteriaResource();
        result.init(json);
        return result;
    }
}

export interface ITrainingCriteriaResource {
    id: number;
    name: string | undefined;
    gradeId: number | undefined;
    locationId: number | undefined;
    employmentCategoryId: number;
    ministryId: number | undefined;
    departmentId: number | undefined;
    min_Age: number;
    min_LengthOfService: number;
    employmentTypeId: number | undefined;
    salaryScaleId: number | undefined;
    positionId: number | undefined;
    trainingTypeId: number | undefined;
    trainingType: TrainingType;
    salaryScale: SalaryScale;
    grade: Grade;
    department: Department;
    location: Location;
    ministry: Ministry;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingCriteriaResourceListApiResult implements ITrainingCriteriaResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingCriteriaResource[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: ITrainingCriteriaResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingCriteriaResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): TrainingCriteriaResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCriteriaResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): TrainingCriteriaResourceListApiResult {
        const json = this.toJSON();
        let result = new TrainingCriteriaResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingCriteriaResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingCriteriaResource[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AssignTrainingToEmpPayload implements IAssignTrainingToEmpPayload {
    selectedEmpIds!: string;
    trainingId!: number;
    training!: string | undefined;
    tempRef!: string | undefined;

    constructor(data?: IAssignTrainingToEmpPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.selectedEmpIds = _data["selectedEmpIds"];
            this.trainingId = _data["trainingId"];
            this.training = _data["training"];
            this.tempRef = _data["tempRef"];
        }
    }

    static fromJS(data: any): AssignTrainingToEmpPayload {
        data = typeof data === 'object' ? data : {};
        let result = new AssignTrainingToEmpPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["selectedEmpIds"] = this.selectedEmpIds;
        data["trainingId"] = this.trainingId;
        data["training"] = this.training;
        data["tempRef"] = this.tempRef;
        return data; 
    }

    clone(): AssignTrainingToEmpPayload {
        const json = this.toJSON();
        let result = new AssignTrainingToEmpPayload();
        result.init(json);
        return result;
    }
}

export interface IAssignTrainingToEmpPayload {
    selectedEmpIds: string;
    trainingId: number;
    training: string | undefined;
    tempRef: string | undefined;
}

export class EmpTrainingResource implements IEmpTrainingResource {
    id!: number;
    contractId!: number;
    employeeName!: string | undefined;
    assignmentNo!: string | undefined;
    dateAssigned!: Date;
    trainingName!: string | undefined;
    trainingTypeName!: string | undefined;
    vendorName!: string | undefined;
    grade!: string | undefined;
    log_status!: number;
    trainingCategoryId!: number;
    vendorId!: number;
    trainindId!: number;
    workemail!: string | undefined;
    personalemail!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    feedback!: string | undefined;
    feedbackDate!: Date | undefined;
    trainingCategoryObj!: TrainingCategory;
    is_selected!: boolean;
    vendorObj!: TrainingVendor;
    documents!: Document[] | undefined;
    ministry!: string | undefined;
    department!: string | undefined;
    location!: string | undefined;
    jobRole!: string | undefined;
    position!: string | undefined;

    constructor(data?: IEmpTrainingResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contractId = _data["contractId"];
            this.employeeName = _data["employeeName"];
            this.assignmentNo = _data["assignmentNo"];
            this.dateAssigned = _data["dateAssigned"] ? new Date(_data["dateAssigned"].toString()) : <any>undefined;
            this.trainingName = _data["trainingName"];
            this.trainingTypeName = _data["trainingTypeName"];
            this.vendorName = _data["vendorName"];
            this.grade = _data["grade"];
            this.log_status = _data["log_status"];
            this.trainingCategoryId = _data["trainingCategoryId"];
            this.vendorId = _data["vendorId"];
            this.trainindId = _data["trainindId"];
            this.workemail = _data["workemail"];
            this.personalemail = _data["personalemail"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.feedback = _data["feedback"];
            this.feedbackDate = _data["feedbackDate"] ? new Date(_data["feedbackDate"].toString()) : <any>undefined;
            this.trainingCategoryObj = _data["trainingCategoryObj"] ? TrainingCategory.fromJS(_data["trainingCategoryObj"]) : <any>undefined;
            this.is_selected = _data["is_selected"];
            this.vendorObj = _data["vendorObj"] ? TrainingVendor.fromJS(_data["vendorObj"]) : <any>undefined;
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(Document.fromJS(item));
            }
            this.ministry = _data["ministry"];
            this.department = _data["department"];
            this.location = _data["location"];
            this.jobRole = _data["jobRole"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): EmpTrainingResource {
        data = typeof data === 'object' ? data : {};
        let result = new EmpTrainingResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contractId"] = this.contractId;
        data["employeeName"] = this.employeeName;
        data["assignmentNo"] = this.assignmentNo;
        data["dateAssigned"] = this.dateAssigned ? this.dateAssigned.toISOString() : <any>undefined;
        data["trainingName"] = this.trainingName;
        data["trainingTypeName"] = this.trainingTypeName;
        data["vendorName"] = this.vendorName;
        data["grade"] = this.grade;
        data["log_status"] = this.log_status;
        data["trainingCategoryId"] = this.trainingCategoryId;
        data["vendorId"] = this.vendorId;
        data["trainindId"] = this.trainindId;
        data["workemail"] = this.workemail;
        data["personalemail"] = this.personalemail;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["feedback"] = this.feedback;
        data["feedbackDate"] = this.feedbackDate ? this.feedbackDate.toISOString() : <any>undefined;
        data["trainingCategoryObj"] = this.trainingCategoryObj ? this.trainingCategoryObj.toJSON() : <any>undefined;
        data["is_selected"] = this.is_selected;
        data["vendorObj"] = this.vendorObj ? this.vendorObj.toJSON() : <any>undefined;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["ministry"] = this.ministry;
        data["department"] = this.department;
        data["location"] = this.location;
        data["jobRole"] = this.jobRole;
        data["position"] = this.position;
        return data; 
    }

    clone(): EmpTrainingResource {
        const json = this.toJSON();
        let result = new EmpTrainingResource();
        result.init(json);
        return result;
    }
}

export interface IEmpTrainingResource {
    id: number;
    contractId: number;
    employeeName: string | undefined;
    assignmentNo: string | undefined;
    dateAssigned: Date;
    trainingName: string | undefined;
    trainingTypeName: string | undefined;
    vendorName: string | undefined;
    grade: string | undefined;
    log_status: number;
    trainingCategoryId: number;
    vendorId: number;
    trainindId: number;
    workemail: string | undefined;
    personalemail: string | undefined;
    startDate: Date;
    endDate: Date;
    feedback: string | undefined;
    feedbackDate: Date | undefined;
    trainingCategoryObj: TrainingCategory;
    is_selected: boolean;
    vendorObj: TrainingVendor;
    documents: Document[] | undefined;
    ministry: string | undefined;
    department: string | undefined;
    location: string | undefined;
    jobRole: string | undefined;
    position: string | undefined;
}

export class EmpTrainingResourceListApiResult implements IEmpTrainingResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmpTrainingResource[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmpTrainingResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmpTrainingResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmpTrainingResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmpTrainingResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmpTrainingResourceListApiResult {
        const json = this.toJSON();
        let result = new EmpTrainingResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmpTrainingResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmpTrainingResource[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class AssignTrainingToOneEmpPayload implements IAssignTrainingToOneEmpPayload {
    emplogId!: number;
    trainingId!: number;

    constructor(data?: IAssignTrainingToOneEmpPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emplogId = _data["emplogId"];
            this.trainingId = _data["trainingId"];
        }
    }

    static fromJS(data: any): AssignTrainingToOneEmpPayload {
        data = typeof data === 'object' ? data : {};
        let result = new AssignTrainingToOneEmpPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emplogId"] = this.emplogId;
        data["trainingId"] = this.trainingId;
        return data; 
    }

    clone(): AssignTrainingToOneEmpPayload {
        const json = this.toJSON();
        let result = new AssignTrainingToOneEmpPayload();
        result.init(json);
        return result;
    }
}

export interface IAssignTrainingToOneEmpPayload {
    emplogId: number;
    trainingId: number;
}

export class EmpTrainingResourceApiResult implements IEmpTrainingResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmpTrainingResource;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IEmpTrainingResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmpTrainingResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): EmpTrainingResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmpTrainingResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): EmpTrainingResourceApiResult {
        const json = this.toJSON();
        let result = new EmpTrainingResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmpTrainingResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmpTrainingResource;
    totalCount: number;
    totalRecord: number;
}

export class EmpFeedBack implements IEmpFeedBack {
    emplogId!: number;
    feedBack!: string | undefined;

    constructor(data?: IEmpFeedBack) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emplogId = _data["emplogId"];
            this.feedBack = _data["feedBack"];
        }
    }

    static fromJS(data: any): EmpFeedBack {
        data = typeof data === 'object' ? data : {};
        let result = new EmpFeedBack();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emplogId"] = this.emplogId;
        data["feedBack"] = this.feedBack;
        return data; 
    }

    clone(): EmpFeedBack {
        const json = this.toJSON();
        let result = new EmpFeedBack();
        result.init(json);
        return result;
    }
}

export interface IEmpFeedBack {
    emplogId: number;
    feedBack: string | undefined;
}

export class EmployeeTrainingDTO implements IEmployeeTrainingDTO {
    employeeTrainingLogId!: number;
    contractId!: number | undefined;
    trainingTypeId!: number | undefined;
    trainingId!: number | undefined;
    gradeId!: number | undefined;
    log_status!: number;
    dateAssigned!: Date | undefined;
    dateReviewed!: Date | undefined;
    positionId!: number | undefined;
    dateofBirth!: Date | undefined;
    dateofAppointment!: Date | undefined;
    age!: number | undefined;
    yearsOfService!: number | undefined;
    hasAttended!: boolean | undefined;

    constructor(data?: IEmployeeTrainingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeTrainingLogId = _data["employeeTrainingLogId"];
            this.contractId = _data["contractId"];
            this.trainingTypeId = _data["trainingTypeId"];
            this.trainingId = _data["trainingId"];
            this.gradeId = _data["gradeId"];
            this.log_status = _data["log_status"];
            this.dateAssigned = _data["dateAssigned"] ? new Date(_data["dateAssigned"].toString()) : <any>undefined;
            this.dateReviewed = _data["dateReviewed"] ? new Date(_data["dateReviewed"].toString()) : <any>undefined;
            this.positionId = _data["positionId"];
            this.dateofBirth = _data["dateofBirth"] ? new Date(_data["dateofBirth"].toString()) : <any>undefined;
            this.dateofAppointment = _data["dateofAppointment"] ? new Date(_data["dateofAppointment"].toString()) : <any>undefined;
            this.age = _data["age"];
            this.yearsOfService = _data["yearsOfService"];
            this.hasAttended = _data["hasAttended"];
        }
    }

    static fromJS(data: any): EmployeeTrainingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTrainingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeTrainingLogId"] = this.employeeTrainingLogId;
        data["contractId"] = this.contractId;
        data["trainingTypeId"] = this.trainingTypeId;
        data["trainingId"] = this.trainingId;
        data["gradeId"] = this.gradeId;
        data["log_status"] = this.log_status;
        data["dateAssigned"] = this.dateAssigned ? this.dateAssigned.toISOString() : <any>undefined;
        data["dateReviewed"] = this.dateReviewed ? this.dateReviewed.toISOString() : <any>undefined;
        data["positionId"] = this.positionId;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["dateofAppointment"] = this.dateofAppointment ? this.dateofAppointment.toISOString() : <any>undefined;
        data["age"] = this.age;
        data["yearsOfService"] = this.yearsOfService;
        data["hasAttended"] = this.hasAttended;
        return data; 
    }

    clone(): EmployeeTrainingDTO {
        const json = this.toJSON();
        let result = new EmployeeTrainingDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeTrainingDTO {
    employeeTrainingLogId: number;
    contractId: number | undefined;
    trainingTypeId: number | undefined;
    trainingId: number | undefined;
    gradeId: number | undefined;
    log_status: number;
    dateAssigned: Date | undefined;
    dateReviewed: Date | undefined;
    positionId: number | undefined;
    dateofBirth: Date | undefined;
    dateofAppointment: Date | undefined;
    age: number | undefined;
    yearsOfService: number | undefined;
    hasAttended: boolean | undefined;
}

export class DocFileDTO implements IDocFileDTO {
    id!: number;
    title!: string | undefined;
    fileName!: string | undefined;
    filePath!: string | undefined;
    uploadedBy!: string | undefined;
    dateUploaded!: Date;
    docFileOcrId!: number | undefined;

    constructor(data?: IDocFileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.uploadedBy = _data["uploadedBy"];
            this.dateUploaded = _data["dateUploaded"] ? new Date(_data["dateUploaded"].toString()) : <any>undefined;
            this.docFileOcrId = _data["docFileOcrId"];
        }
    }

    static fromJS(data: any): DocFileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DocFileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["uploadedBy"] = this.uploadedBy;
        data["dateUploaded"] = this.dateUploaded ? this.dateUploaded.toISOString() : <any>undefined;
        data["docFileOcrId"] = this.docFileOcrId;
        return data; 
    }

    clone(): DocFileDTO {
        const json = this.toJSON();
        let result = new DocFileDTO();
        result.init(json);
        return result;
    }
}

export interface IDocFileDTO {
    id: number;
    title: string | undefined;
    fileName: string | undefined;
    filePath: string | undefined;
    uploadedBy: string | undefined;
    dateUploaded: Date;
    docFileOcrId: number | undefined;
}

export class DocFileDTOListApiResult implements IDocFileDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DocFileDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IDocFileDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DocFileDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): DocFileDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DocFileDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): DocFileDTOListApiResult {
        const json = this.toJSON();
        let result = new DocFileDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDocFileDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DocFileDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class ApplicationPermission implements IApplicationPermission {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    moduleID!: number;
    applicationRolePermissions!: ApplicationRolePermission[] | undefined;

    constructor(data?: IApplicationPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.moduleID = _data["moduleID"];
            if (Array.isArray(_data["applicationRolePermissions"])) {
                this.applicationRolePermissions = [] as any;
                for (let item of _data["applicationRolePermissions"])
                    this.applicationRolePermissions!.push(ApplicationRolePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationPermission {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["moduleID"] = this.moduleID;
        if (Array.isArray(this.applicationRolePermissions)) {
            data["applicationRolePermissions"] = [];
            for (let item of this.applicationRolePermissions)
                data["applicationRolePermissions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ApplicationPermission {
        const json = this.toJSON();
        let result = new ApplicationPermission();
        result.init(json);
        return result;
    }
}

export interface IApplicationPermission {
    id: number;
    name: string | undefined;
    code: string | undefined;
    moduleID: number;
    applicationRolePermissions: ApplicationRolePermission[] | undefined;
}

export class ApplicationRolePermission implements IApplicationRolePermission {
    id!: number;
    dateCreated!: Date;
    applicationRoleId!: number;
    applicationPermissionId!: number;
    applicationRole!: ApplicationRole;
    applicationPermission!: ApplicationPermission;

    constructor(data?: IApplicationRolePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.applicationRoleId = _data["applicationRoleId"];
            this.applicationPermissionId = _data["applicationPermissionId"];
            this.applicationRole = _data["applicationRole"] ? ApplicationRole.fromJS(_data["applicationRole"]) : <any>undefined;
            this.applicationPermission = _data["applicationPermission"] ? ApplicationPermission.fromJS(_data["applicationPermission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationRolePermission {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRolePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["applicationRoleId"] = this.applicationRoleId;
        data["applicationPermissionId"] = this.applicationPermissionId;
        data["applicationRole"] = this.applicationRole ? this.applicationRole.toJSON() : <any>undefined;
        data["applicationPermission"] = this.applicationPermission ? this.applicationPermission.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ApplicationRolePermission {
        const json = this.toJSON();
        let result = new ApplicationRolePermission();
        result.init(json);
        return result;
    }
}

export interface IApplicationRolePermission {
    id: number;
    dateCreated: Date;
    applicationRoleId: number;
    applicationPermissionId: number;
    applicationRole: ApplicationRole;
    applicationPermission: ApplicationPermission;
}

export class ApplicationRole implements IApplicationRole {
    description!: string | undefined;
    isSystemRole!: boolean;
    applicationRolePermissions!: ApplicationRolePermission[] | undefined;
    id!: number;
    name!: string | undefined;
    normalizedName!: string | undefined;
    concurrencyStamp!: string | undefined;

    constructor(data?: IApplicationRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.isSystemRole = _data["isSystemRole"];
            if (Array.isArray(_data["applicationRolePermissions"])) {
                this.applicationRolePermissions = [] as any;
                for (let item of _data["applicationRolePermissions"])
                    this.applicationRolePermissions!.push(ApplicationRolePermission.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): ApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["isSystemRole"] = this.isSystemRole;
        if (Array.isArray(this.applicationRolePermissions)) {
            data["applicationRolePermissions"] = [];
            for (let item of this.applicationRolePermissions)
                data["applicationRolePermissions"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data; 
    }

    clone(): ApplicationRole {
        const json = this.toJSON();
        let result = new ApplicationRole();
        result.init(json);
        return result;
    }
}

export interface IApplicationRole {
    description: string | undefined;
    isSystemRole: boolean;
    applicationRolePermissions: ApplicationRolePermission[] | undefined;
    id: number;
    name: string | undefined;
    normalizedName: string | undefined;
    concurrencyStamp: string | undefined;
}

export class RegisterUserDTO implements IRegisterUserDTO {
    firstName!: string;
    lastName!: string;
    email!: string;
    password!: string | undefined;
    phoneNumber!: string | undefined;
    locationID!: number | undefined;
    lgaid!: number | undefined;
    approvalAmtLimit!: number;
    approvalAmtMTD!: number;
    locationCol!: SelectListItem[] | undefined;
    lgaCol!: SelectListItem[] | undefined;
    selectedRoles!: string[];
    applicationRoles!: ApplicationRole[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRegisterUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectedRoles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.locationID = _data["locationID"];
            this.lgaid = _data["lgaid"];
            this.approvalAmtLimit = _data["approvalAmtLimit"];
            this.approvalAmtMTD = _data["approvalAmtMTD"];
            if (Array.isArray(_data["locationCol"])) {
                this.locationCol = [] as any;
                for (let item of _data["locationCol"])
                    this.locationCol!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["lgaCol"])) {
                this.lgaCol = [] as any;
                for (let item of _data["lgaCol"])
                    this.lgaCol!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["selectedRoles"])) {
                this.selectedRoles = [] as any;
                for (let item of _data["selectedRoles"])
                    this.selectedRoles!.push(item);
            }
            if (Array.isArray(_data["applicationRoles"])) {
                this.applicationRoles = [] as any;
                for (let item of _data["applicationRoles"])
                    this.applicationRoles!.push(ApplicationRole.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RegisterUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["locationID"] = this.locationID;
        data["lgaid"] = this.lgaid;
        data["approvalAmtLimit"] = this.approvalAmtLimit;
        data["approvalAmtMTD"] = this.approvalAmtMTD;
        if (Array.isArray(this.locationCol)) {
            data["locationCol"] = [];
            for (let item of this.locationCol)
                data["locationCol"].push(item.toJSON());
        }
        if (Array.isArray(this.lgaCol)) {
            data["lgaCol"] = [];
            for (let item of this.lgaCol)
                data["lgaCol"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedRoles)) {
            data["selectedRoles"] = [];
            for (let item of this.selectedRoles)
                data["selectedRoles"].push(item);
        }
        if (Array.isArray(this.applicationRoles)) {
            data["applicationRoles"] = [];
            for (let item of this.applicationRoles)
                data["applicationRoles"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RegisterUserDTO {
        const json = this.toJSON();
        let result = new RegisterUserDTO();
        result.init(json);
        return result;
    }
}

export interface IRegisterUserDTO {
    firstName: string;
    lastName: string;
    email: string;
    password: string | undefined;
    phoneNumber: string | undefined;
    locationID: number | undefined;
    lgaid: number | undefined;
    approvalAmtLimit: number;
    approvalAmtMTD: number;
    locationCol: SelectListItem[] | undefined;
    lgaCol: SelectListItem[] | undefined;
    selectedRoles: string[];
    applicationRoles: ApplicationRole[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ApplicationUserDTO implements IApplicationUserDTO {
    id!: number;
    email!: string | undefined;
    username!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    isAdmin!: boolean;
    isTenantAdmin!: boolean;
    isEnabled!: boolean | undefined;
    lastLogin!: Date | undefined;
    companyId!: number;
    subsidiaryId!: number;
    token!: string | undefined;
    apiSessionId!: string | undefined;
    lastComputerName!: string | undefined;

    constructor(data?: IApplicationUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.isAdmin = _data["isAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.isEnabled = _data["isEnabled"];
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>undefined;
            this.companyId = _data["companyId"];
            this.subsidiaryId = _data["subsidiaryId"];
            this.token = _data["token"];
            this.apiSessionId = _data["apiSessionId"];
            this.lastComputerName = _data["lastComputerName"];
        }
    }

    static fromJS(data: any): ApplicationUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["username"] = this.username;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["isAdmin"] = this.isAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["isEnabled"] = this.isEnabled;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        data["companyId"] = this.companyId;
        data["subsidiaryId"] = this.subsidiaryId;
        data["token"] = this.token;
        data["apiSessionId"] = this.apiSessionId;
        data["lastComputerName"] = this.lastComputerName;
        return data; 
    }

    clone(): ApplicationUserDTO {
        const json = this.toJSON();
        let result = new ApplicationUserDTO();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserDTO {
    id: number;
    email: string | undefined;
    username: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    isAdmin: boolean;
    isTenantAdmin: boolean;
    isEnabled: boolean | undefined;
    lastLogin: Date | undefined;
    companyId: number;
    subsidiaryId: number;
    token: string | undefined;
    apiSessionId: string | undefined;
    lastComputerName: string | undefined;
}

export class ApplicationUserDTOIListApiResult implements IApplicationUserDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationUserDTO[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IApplicationUserDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApplicationUserDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): ApplicationUserDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): ApplicationUserDTOIListApiResult {
        const json = this.toJSON();
        let result = new ApplicationUserDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationUserDTO[] | undefined;
    totalCount: number;
    totalRecord: number;
}

export class VisaTypeDTO implements IVisaTypeDTO {
    id!: number;
    companyId!: number;
    subId!: number;
    visaName!: string | undefined;

    constructor(data?: IVisaTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.visaName = _data["visaName"];
        }
    }

    static fromJS(data: any): VisaTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new VisaTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["visaName"] = this.visaName;
        return data; 
    }

    clone(): VisaTypeDTO {
        const json = this.toJSON();
        let result = new VisaTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IVisaTypeDTO {
    id: number;
    companyId: number;
    subId: number;
    visaName: string | undefined;
}

export class VisaType implements IVisaType {
    visaName!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IVisaType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.visaName = _data["visaName"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): VisaType {
        data = typeof data === 'object' ? data : {};
        let result = new VisaType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visaName"] = this.visaName;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): VisaType {
        const json = this.toJSON();
        let result = new VisaType();
        result.init(json);
        return result;
    }
}

export interface IVisaType {
    visaName: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class VisaTypeIListApiResult implements IVisaTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VisaType[] | undefined;
    totalCount!: number;
    readonly totalRecord!: number;

    constructor(data?: IVisaTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(VisaType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            (<any>this).totalRecord = _data["totalRecord"];
        }
    }

    static fromJS(data: any): VisaTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VisaTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["totalRecord"] = this.totalRecord;
        return data; 
    }

    clone(): VisaTypeIListApiResult {
        const json = this.toJSON();
        let result = new VisaTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IVisaTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VisaType[] | undefined;
    totalCount: number;
    totalRecord: number;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}