/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class GetTokenServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getToken(body: UserLoginDTO | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/GetToken/GetToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class ValidateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param key_token (optional) 
     * @return Success
     */
    validate(key_token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/Validate/Validate?";
        if (key_token !== undefined && key_token !== null)
            url_ += "key_token=" + encodeURIComponent("" + key_token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidate(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processValidate(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class ForgotPasswordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    forgotPassword(email: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ForgotPassword/ForgotPassword?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ResetPasswordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResestPasswordDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ConfirmEmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param userId (optional) 
     * @param token (optional) 
     * @return Success
     */
    confirmEmail(userId: string | null | undefined, token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Account/ConfirmEmail/ConfirmEmail?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmail(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmEmail(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class FetchActivityLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param id (optional) 
     * @param moduleName (optional) 
     * @param operationType (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getActivityLog(id: number | undefined, moduleName: string | null | undefined, operationType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ActivityLogIListApiResult> {
        let url_ = this.baseUrl + "/api/ActivityLog/FetchActivityLog/GetActivityLog?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (moduleName !== undefined && moduleName !== null)
            url_ += "ModuleName=" + encodeURIComponent("" + moduleName) + "&";
        if (operationType !== undefined && operationType !== null)
            url_ += "OperationType=" + encodeURIComponent("" + operationType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityLog(<any>response_);
                } catch (e) {
                    return <Observable<ActivityLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityLog(response: HttpResponseBase): Observable<ActivityLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class AssetManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetType(body: AssetTypeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addDeperciationProfile(body: AssetDeperciationProfileDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AddDeperciationProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDeperciationProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDeperciationProfile(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddDeperciationProfile(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetSubType(body: AssetSubTypeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetSubType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetSubType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetSubType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCatergory(body: AssetCategoryDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCatergory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCatergory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCatergory(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCatergory(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetStatus(body: AssetStatusDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetStatus(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetStatus(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetMake(body: AssetMakeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetMake";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetMake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetMake(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetMake(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetModel(body: AssetModelDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetModel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetModel(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetModel(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAsset(body: AssetDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AddAsset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAsset(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddAsset(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAssetRequest(body: AssetRequestDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AddAssetRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAssetRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAssetRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddAssetRequest(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assignment(body: AssignmentDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/Assignment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssignment(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCallback(body: AssetCallbackDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCallback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCallback(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCallback(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCheckIn(body: AssetcheckInFilter | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCheckIn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCheckIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCheckIn(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCheckIn(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assetCheckInComfirmation(body: AssetcheckInFilter | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/AssetCheckInComfirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssetCheckInComfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssetCheckInComfirmation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssetCheckInComfirmation(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAssetRequest(body: UpdateAssetRequest | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/UpdateAssetRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAssetRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAssetRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAssetRequest(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetType(body: AssetTypeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetSubType(body: AssetSubTypeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetSubType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetSubType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetSubType(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetCategory(body: AssetCategoryDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetCategory(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetCategory(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetMake(body: AssetMakeDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetMake";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetMake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetMake(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetMake(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetModel(body: AssetModelDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetModel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetModel(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetModel(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAssetStatus(body: AssetStatusDTO | undefined): Observable<MessageOutIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/DeleteAssetStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetStatus(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetStatus(response: HttpResponseBase): Observable<MessageOutIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getActivateAsset(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetActivateAsset?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivateAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivateAsset(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivateAsset(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getDeactivateAsset(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetDeactivateAsset?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeactivateAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeactivateAsset(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeactivateAsset(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetType(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetType?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetType(<any>response_);
                } catch (e) {
                    return <Observable<AssetTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetType(response: HttpResponseBase): Observable<AssetTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetTypeDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetSubType(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetSubTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetSubType?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetSubType(<any>response_);
                } catch (e) {
                    return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetSubType(response: HttpResponseBase): Observable<AssetSubTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetSubTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetSubTypeDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetCategory(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetCategoryDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetCategory?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetCategory(<any>response_);
                } catch (e) {
                    return <Observable<AssetCategoryDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetCategoryDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetCategory(response: HttpResponseBase): Observable<AssetCategoryDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetCategoryDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetCategoryDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetMake(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetMakeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetMake?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetMake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetMake(<any>response_);
                } catch (e) {
                    return <Observable<AssetMakeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetMakeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetMake(response: HttpResponseBase): Observable<AssetMakeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetMakeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetMakeDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetModel(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetModelDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetModel?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetModel(<any>response_);
                } catch (e) {
                    return <Observable<AssetModelDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetModelDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetModel(response: HttpResponseBase): Observable<AssetModelDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetModelDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetModelDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetStatus(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetStatusDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetStatus?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetStatus(<any>response_);
                } catch (e) {
                    return <Observable<AssetStatusDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetStatusDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetStatus(response: HttpResponseBase): Observable<AssetStatusDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetStatusDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetStatusDTOIListApiResult>(<any>null);
    }

    /**
     * @param assetTypeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetSubTypeByAssetTypeId(assetTypeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetSubTypeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetSubTypeByAssetTypeId?";
        if (assetTypeId === null)
            throw new Error("The parameter 'assetTypeId' cannot be null.");
        else if (assetTypeId !== undefined)
            url_ += "AssetTypeId=" + encodeURIComponent("" + assetTypeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetSubTypeByAssetTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetSubTypeByAssetTypeId(<any>response_);
                } catch (e) {
                    return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetSubTypeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetSubTypeByAssetTypeId(response: HttpResponseBase): Observable<AssetSubTypeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetSubTypeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetSubTypeDTOIListApiResult>(<any>null);
    }

    /**
     * @param assetSubTypeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetbyAssetSubtypeId(assetSubTypeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetbyAssetSubtypeId?";
        if (assetSubTypeId === null)
            throw new Error("The parameter 'assetSubTypeId' cannot be null.");
        else if (assetSubTypeId !== undefined)
            url_ += "AssetSubTypeId=" + encodeURIComponent("" + assetSubTypeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetbyAssetSubtypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetbyAssetSubtypeId(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetbyAssetSubtypeId(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param assetmakeId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetModelByAssetMakeId(assetmakeId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetModelByAssetMakeId?";
        if (assetmakeId === null)
            throw new Error("The parameter 'assetmakeId' cannot be null.");
        else if (assetmakeId !== undefined)
            url_ += "AssetmakeId=" + encodeURIComponent("" + assetmakeId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetModelByAssetMakeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetModelByAssetMakeId(<any>response_);
                } catch (e) {
                    return <Observable<AssetDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetModelByAssetMakeId(response: HttpResponseBase): Observable<AssetDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getDepreciationProfile(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDeperciationProfileDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetDepreciationProfile?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepreciationProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepreciationProfile(<any>response_);
                } catch (e) {
                    return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepreciationProfile(response: HttpResponseBase): Observable<AssetDeperciationProfileDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDeperciationProfileDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDeperciationProfileDTOIListApiResult>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getActiveassetlist(pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetDeperciationProfileDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetActiveassetlist?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveassetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveassetlist(<any>response_);
                } catch (e) {
                    return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetDeperciationProfileDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveassetlist(response: HttpResponseBase): Observable<AssetDeperciationProfileDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetDeperciationProfileDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetDeperciationProfileDTOIListApiResult>(<any>null);
    }

    /**
     * @param employeeId (optional) 
     * @param assetId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param isFilter (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAssetByAssigedEmployee(employeeId: number | undefined, assetId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, name: string | null | undefined, isFilter: boolean | undefined, isActive: boolean | null | undefined): Observable<AssetHistoryDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/AssetManagement/GetAssetByAssigedEmployee?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        if (assetId === null)
            throw new Error("The parameter 'assetId' cannot be null.");
        else if (assetId !== undefined)
            url_ += "AssetId=" + encodeURIComponent("" + assetId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (isFilter === null)
            throw new Error("The parameter 'isFilter' cannot be null.");
        else if (isFilter !== undefined)
            url_ += "IsFilter=" + encodeURIComponent("" + isFilter) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetByAssigedEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetByAssigedEmployee(<any>response_);
                } catch (e) {
                    return <Observable<AssetHistoryDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetHistoryDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetByAssigedEmployee(response: HttpResponseBase): Observable<AssetHistoryDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetHistoryDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetHistoryDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class CommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for getting Locations that can be use for dropdowns
     * @return Success
     */
    getLocations(): Observable<LocationIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetLocations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocations(<any>response_);
                } catch (e) {
                    return <Observable<LocationIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocations(response: HttpResponseBase): Observable<LocationIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationIListApiResult>(<any>null);
    }

    /**
     * API for getting Departments that can be use for dropdowns
     * @return Success
     */
    getDepartments(): Observable<DepartmentIListApiResult> {
        let url_ = this.baseUrl + "/api/Common/GetDepartments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartments(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartments(response: HttpResponseBase): Observable<DepartmentIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentIListApiResult>(<any>null);
    }
}

@Injectable()
export class CreateConfirmationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createConfirmation(body: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Confirmation/CreateConfirmation/CreateConfirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateConfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateConfirmation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateConfirmation(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class SaveConfirmationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveConfirmation(body: VwConfirmationDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Confirmation/SaveConfirmation/SaveConfirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveConfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveConfirmation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSaveConfirmation(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetConfirmationsByDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param log_status (optional) 
     * @param _PageSize (optional) 
     * @return Success
     */
    getConfirmationsByDetails(startDate: Date | null | undefined, endDate: Date | null | undefined, log_status: number | undefined, _PageSize: number | undefined): Observable<VwConfirmationDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Confirmation/GetConfirmationsByDetails/GetConfirmationsByDetails?";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (log_status === null)
            throw new Error("The parameter 'log_status' cannot be null.");
        else if (log_status !== undefined)
            url_ += "log_status=" + encodeURIComponent("" + log_status) + "&";
        if (_PageSize === null)
            throw new Error("The parameter '_PageSize' cannot be null.");
        else if (_PageSize !== undefined)
            url_ += "_PageSize=" + encodeURIComponent("" + _PageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfirmationsByDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfirmationsByDetails(<any>response_);
                } catch (e) {
                    return <Observable<VwConfirmationDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwConfirmationDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfirmationsByDetails(response: HttpResponseBase): Observable<VwConfirmationDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwConfirmationDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwConfirmationDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class DataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for getting the list of different Generics/Common Dropdowns on the System by their Constant Name
    Some of the Constant names for the Dropdowns are;
    1: employment_status
    2: department
    3: bank
    4: marital_status
    8: religion
    10: title
    12: gender
     * @param dropDownName (optional) 
     * @return Success
     */
    getDropDownValues(dropDownName: string | null | undefined): Observable<DropdownValueIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetDropDownValues?";
        if (dropDownName !== undefined && dropDownName !== null)
            url_ += "dropDownName=" + encodeURIComponent("" + dropDownName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDropDownValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDropDownValues(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDropDownValues(response: HttpResponseBase): Observable<DropdownValueIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of different Generics/Common Dropdowns on the System by their Constant Value
    Some of the Constant names for the Dropdowns are;
    employment_status: 1
    department: 2
    bank: 3
    marital_status: 4
    religion: 8
    title: 10
    gender: 12
     * @param dropDownId (optional) 
     * @return Success
     */
    getDropDownValuesById(dropDownId: number | undefined): Observable<DropdownValueIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetDropDownValuesById?";
        if (dropDownId === null)
            throw new Error("The parameter 'dropDownId' cannot be null.");
        else if (dropDownId !== undefined)
            url_ += "dropDownId=" + encodeURIComponent("" + dropDownId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDropDownValuesById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDropDownValuesById(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDropDownValuesById(response: HttpResponseBase): Observable<DropdownValueIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueIListApiResult>(<any>null);
    }

    /**
     * API for getting Tenant Status enumerable that can be use for filtering parameter
     * @return Success
     */
    getTenantStatus(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetTenantStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantStatus(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantStatus(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of all Countries on the System
     * @return Success
     */
    getCountries(): Observable<CountryIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<CountryIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<CountryIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of all States on the System
     * @return Success
     */
    getStates(): Observable<StateIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetStates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStates(<any>response_);
                } catch (e) {
                    return <Observable<StateIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StateIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetStates(response: HttpResponseBase): Observable<StateIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StateIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StateIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of all Local Govts on the System
     * @return Success
     */
    getLGAs(): Observable<LGAIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetLGAs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLGAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLGAs(<any>response_);
                } catch (e) {
                    return <Observable<LGAIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LGAIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLGAs(response: HttpResponseBase): Observable<LGAIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LGAIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LGAIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of all Local Govts by State
     * @param stateId (optional) 
     * @return Success
     */
    getLGAsByState(stateId: number | undefined): Observable<LGAIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetLGAsByState?";
        if (stateId === null)
            throw new Error("The parameter 'stateId' cannot be null.");
        else if (stateId !== undefined)
            url_ += "stateId=" + encodeURIComponent("" + stateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLGAsByState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLGAsByState(<any>response_);
                } catch (e) {
                    return <Observable<LGAIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LGAIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLGAsByState(response: HttpResponseBase): Observable<LGAIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LGAIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LGAIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Unit of Measurement enumerable that can be use for dropdown values
     * @return Success
     */
    getUnitOfMeasurements(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetUnitOfMeasurements";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitOfMeasurements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitOfMeasurements(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitOfMeasurements(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Rating Types enumerable that can be use for dropdown values
     * @return Success
     */
    getRatingTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetRatingTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRatingTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRatingTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRatingTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Performance Review Purposes enumerable that can be use for dropdown values
     * @return Success
     */
    getReviewPurposes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetReviewPurposes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReviewPurposes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReviewPurposes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetReviewPurposes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of Appraisal Types enumerable that can be use for dropdown values
     * @return Success
     */
    getAppraisalTypes(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetAppraisalTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppraisalTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppraisalTypes(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppraisalTypes(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }

    /**
     * API for getting the list of an enumerable Employee Contract Status that can be use for dropdown values in filter
     * @return Success
     */
    getEmployeeContractStatus(): Observable<IDTextViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Data/GetEmployeeContractStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeContractStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeContractStatus(<any>response_);
                } catch (e) {
                    return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDTextViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeContractStatus(response: HttpResponseBase): Observable<IDTextViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDTextViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDTextViewModelIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateDepartmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for adding/updating Department
     * @param body (optional) 
     * @return Success
     */
    addUpdateDepartment(body: ManageDepartmentDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Department/AddUpdateDepartment/Add-Update-Department";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateDepartment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateDepartment(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllDepartmentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API to Fetch Departments.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getAllDepartments(pageSize: number | undefined, pageNumber: number | undefined): Observable<DepartmentDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Department/GetAllDepartments/GetAllDepartments?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDepartments(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDepartments(response: HttpResponseBase): Observable<DepartmentDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetDepartmentByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API to get Department by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getDepartment(id: number | undefined): Observable<DepartmentDTOApiResult> {
        let url_ = this.baseUrl + "/api/Department/GetDepartmentById/GetDepartment?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartment(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartment(response: HttpResponseBase): Observable<DepartmentDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchDeploymentByReferenceNoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param referenceNo (optional) 
     * @return Success
     */
    fetchDeploymentByReferenceNo(referenceNo: string | null | undefined): Observable<DeploymentLogIListApiResult> {
        let url_ = this.baseUrl + "/api/Deployment/FetchDeploymentByReferenceNo/FetchDeploymentByReferenceNo?";
        if (referenceNo !== undefined && referenceNo !== null)
            url_ += "ReferenceNo=" + encodeURIComponent("" + referenceNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchDeploymentByReferenceNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchDeploymentByReferenceNo(<any>response_);
                } catch (e) {
                    return <Observable<DeploymentLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeploymentLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchDeploymentByReferenceNo(response: HttpResponseBase): Observable<DeploymentLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeploymentLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeploymentLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchDeploymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    fetchDeployment(body: SearchDeploymentDto | undefined): Observable<CreateDeploymentViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Deployment/FetchDeployment/FetchDeployment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchDeployment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchDeployment(<any>response_);
                } catch (e) {
                    return <Observable<CreateDeploymentViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateDeploymentViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchDeployment(response: HttpResponseBase): Observable<CreateDeploymentViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateDeploymentViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateDeploymentViewModelIListApiResult>(<any>null);
    }
}

@Injectable()
export class EmployeeDeploymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @return Success
     */
    employeeDeployment(): Observable<CreateDeploymentViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/Deployment/EmployeeDeployment/EmployeeDeployment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeDeployment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeDeployment(<any>response_);
                } catch (e) {
                    return <Observable<CreateDeploymentViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateDeploymentViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeDeployment(response: HttpResponseBase): Observable<CreateDeploymentViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateDeploymentViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateDeploymentViewModelIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmailLogsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for retrieving all Email Logs by email log filtering parameter
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param emailTo (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getEmailLogs(startDate: Date | null | undefined, endDate: Date | null | undefined, emailTo: string | null | undefined, pageSize: number | undefined): Observable<EmailLogDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/EmailLog/FetchEmailLogs/GetEmailLogs?";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (emailTo !== undefined && emailTo !== null)
            url_ += "EmailTo=" + encodeURIComponent("" + emailTo) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailLogs(<any>response_);
                } catch (e) {
                    return <Observable<EmailLogDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailLogDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailLogs(response: HttpResponseBase): Observable<EmailLogDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailLogDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailLogDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmailLogByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for getting Single EmailLog Details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getEmailLogById(id: number | undefined): Observable<EmailLogDTOApiResult> {
        let url_ = this.baseUrl + "/api/EmailLog/FetchEmailLogById/GetEmailLogById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailLogById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailLogById(<any>response_);
                } catch (e) {
                    return <Observable<EmailLogDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailLogDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailLogById(response: HttpResponseBase): Observable<EmailLogDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailLogDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailLogDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmailTemplateByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for getting Email Template by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getEmailTemplateById(id: number | undefined): Observable<EmailTemplateDTOApiResult> {
        let url_ = this.baseUrl + "/api/EmailTemplate/FetchEmailTemplateById/GetEmailTemplateById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailTemplateById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailTemplateById(<any>response_);
                } catch (e) {
                    return <Observable<EmailTemplateDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailTemplateDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailTemplateById(response: HttpResponseBase): Observable<EmailTemplateDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailTemplateDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailTemplateDTOApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateEmailTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for updating Email Template
     * @param body (optional) 
     * @return Success
     */
    updateEmailTemplate(body: EmailTemplateDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/EmailTemplate/UpdateEmailTemplate/UpdateEmailTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmailTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmailTemplate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEmailTemplate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CreateEmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for adding a single Employee profile
     * @param body (optional) 
     * @return Success
     */
    addEmployee(body: EmployeeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Employee/CreateEmployee/AddEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEmployee(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddEmployee(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeesDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for retrieving all Employees by Employee number (i.e. for specific Employee) or
    empty string (i.e. for all Employee
    with their few details for further CRUD operation
     * @param searchText (optional) 
     * @param contractStatus (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getEmployeesDetails(searchText: string | null | undefined, contractStatus: number | undefined, pageSize: number | undefined): Observable<DropdownValueDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeesDetails/GetEmployeesDetails?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (contractStatus === null)
            throw new Error("The parameter 'contractStatus' cannot be null.");
        else if (contractStatus !== undefined)
            url_ += "ContractStatus=" + encodeURIComponent("" + contractStatus) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesDetails(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeesDetails(response: HttpResponseBase): Observable<DropdownValueDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeesByName_IdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for retrieving all Employees with details (includes; Fullname, Id, EmpNo)
    that matches the supplied name/employee Id 
    which can be use in various part of the system for Dropdown selection for;
    Supervisor-List, Appraisal-Reviewer-List etc
     * @param nameId (optional) 
     * @return Success
     */
    getEmployeesByNameId(nameId: string | null | undefined): Observable<DropdownValueDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeesByName_Id/GetEmployeesByName-Id?";
        if (nameId !== undefined && nameId !== null)
            url_ += "nameId=" + encodeURIComponent("" + nameId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesByNameId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesByNameId(<any>response_);
                } catch (e) {
                    return <Observable<DropdownValueDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownValueDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeesByNameId(response: HttpResponseBase): Observable<DropdownValueDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownValueDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownValueDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for retrieving single Employee's record
     * @param employeeId (optional) 
     * @return Success
     */
    getEmployeeById(employeeId: number | undefined): Observable<EmployeeDTOApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeeById/GetEmployeeById?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeById(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeById(response: HttpResponseBase): Observable<EmployeeDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDTOApiResult>(<any>null);
    }
}

@Injectable()
export class SearchEmployeesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for Master Employees Search
     * @param pageSize (optional) 
     * @param companyId (optional) 
     * @param searchType (optional) 
     * @param searchText (optional) 
     * @param peopleGroupId (optional) 
     * @param ministryId (optional) 
     * @param departmentId (optional) 
     * @param jobRoleId (optional) 
     * @param locationId (optional) 
     * @param salaryscaleId (optional) 
     * @param gradeId (optional) 
     * @param gradestepId (optional) 
     * @return Success
     */
    searchEmployees(pageSize: number | undefined, companyId: number | undefined, searchType: number | undefined, searchText: string | null | undefined, peopleGroupId: number | undefined, ministryId: number | undefined, departmentId: number | undefined, jobRoleId: number | undefined, locationId: number | undefined, salaryscaleId: number | undefined, gradeId: number | undefined, gradestepId: number | undefined): Observable<EmployeeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Employee/SearchEmployees/SearchEmployees?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (peopleGroupId === null)
            throw new Error("The parameter 'peopleGroupId' cannot be null.");
        else if (peopleGroupId !== undefined)
            url_ += "peopleGroupId=" + encodeURIComponent("" + peopleGroupId) + "&";
        if (ministryId === null)
            throw new Error("The parameter 'ministryId' cannot be null.");
        else if (ministryId !== undefined)
            url_ += "ministryId=" + encodeURIComponent("" + ministryId) + "&";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (jobRoleId === null)
            throw new Error("The parameter 'jobRoleId' cannot be null.");
        else if (jobRoleId !== undefined)
            url_ += "jobRoleId=" + encodeURIComponent("" + jobRoleId) + "&";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (salaryscaleId === null)
            throw new Error("The parameter 'salaryscaleId' cannot be null.");
        else if (salaryscaleId !== undefined)
            url_ += "salaryscaleId=" + encodeURIComponent("" + salaryscaleId) + "&";
        if (gradeId === null)
            throw new Error("The parameter 'gradeId' cannot be null.");
        else if (gradeId !== undefined)
            url_ += "gradeId=" + encodeURIComponent("" + gradeId) + "&";
        if (gradestepId === null)
            throw new Error("The parameter 'gradestepId' cannot be null.");
        else if (gradestepId !== undefined)
            url_ += "gradestepId=" + encodeURIComponent("" + gradestepId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchEmployees(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearchEmployees(response: HttpResponseBase): Observable<EmployeeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllEmployeesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for retrieving All Tenant's registered Employees
     * @param searchText (optional) 
     * @param contractStatus (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllEmployees(searchText: string | null | undefined, contractStatus: number | undefined, pageSize: number | undefined): Observable<EmployeeDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchAllEmployees/GetAllEmployees?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (contractStatus === null)
            throw new Error("The parameter 'contractStatus' cannot be null.");
        else if (contractStatus !== undefined)
            url_ += "ContractStatus=" + encodeURIComponent("" + contractStatus) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmployees(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEmployees(response: HttpResponseBase): Observable<EmployeeDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeContractByEmployeeIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for retrieving Employee's Contract profile by Employee Id
     * @param employeeId (optional) 
     * @return Success
     */
    fetchEmployeeContractByEmployeeId(employeeId: number | undefined): Observable<EmployeeContractAssignmentDTOApiResult> {
        let url_ = this.baseUrl + "/api/Employee/FetchEmployeeContractByEmployeeId/FetchEmployeeContractByEmployeeId?";
        if (employeeId === null)
            throw new Error("The parameter 'employeeId' cannot be null.");
        else if (employeeId !== undefined)
            url_ += "employeeId=" + encodeURIComponent("" + employeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchEmployeeContractByEmployeeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchEmployeeContractByEmployeeId(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeContractAssignmentDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeContractAssignmentDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchEmployeeContractByEmployeeId(response: HttpResponseBase): Observable<EmployeeContractAssignmentDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeContractAssignmentDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeContractAssignmentDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateExpenseGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateExpenseGroup(body: ExpenseGroupDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseGroup/AddUpdateExpenseGroup/AddUpdateExpenseGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateExpenseGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateExpenseGroup(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateExpenseGroup(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseGroup(encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseGroup/ToggleExpenseGroup/ToggleExpenseGroup?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseGroup(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseGroup(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseGroupsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param companyID (optional) 
     * @param subID (optional) 
     * @param name (optional) 
     * @param iD (optional) 
     * @param referenceId (optional) 
     * @param code (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getExpenseGroups(companyID: number | undefined, subID: number | undefined, name: string | null | undefined, iD: number | undefined, referenceId: string | null | undefined, code: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseGroupIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseGroup/GetExpenseGroups/GetExpenseGroups?";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        if (subID === null)
            throw new Error("The parameter 'subID' cannot be null.");
        else if (subID !== undefined)
            url_ += "SubID=" + encodeURIComponent("" + subID) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (referenceId !== undefined && referenceId !== null)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseGroups(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseGroupIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseGroupIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseGroups(response: HttpResponseBase): Observable<ExpenseGroupIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseGroupIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseGroupIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateExpenseProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateExpenseProject(body: ExpenseProjectDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseProject/AddUpdateExpenseProject/AddUpdateExpenseProject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateExpenseProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateExpenseProject(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateExpenseProject(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseProject(encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseProject/ToggleExpenseProject/ToggleExpenseProject?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseProject(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseProject(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param iD (optional) 
     * @param name (optional) 
     * @param description (optional) 
     * @param ban (optional) 
     * @param referenceId (optional) 
     * @param code (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getExpenseProject(iD: number | undefined, name: string | null | undefined, description: string | null | undefined, ban: boolean | undefined, referenceId: string | null | undefined, code: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseGroupIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseProject/GetExpenseProject/GetExpenseProject?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (ban === null)
            throw new Error("The parameter 'ban' cannot be null.");
        else if (ban !== undefined)
            url_ += "Ban=" + encodeURIComponent("" + ban) + "&";
        if (referenceId !== undefined && referenceId !== null)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseProject(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseGroupIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseGroupIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseProject(response: HttpResponseBase): Observable<ExpenseGroupIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseGroupIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseGroupIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateExpenseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateExpense(body: ExpenseDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseRequest/AddUpdateExpense/AddUpdateExpense";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateExpense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateExpense(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateExpense(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseRequest(encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseRequest/ToggleExpenseRequest/ToggleExpenseRequest?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchExpensesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param companyID (optional) 
     * @param subID (optional) 
     * @param iD (optional) 
     * @param userid (optional) 
     * @param companyid (optional) 
     * @param searchText (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchType (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchExpenses(companyID: number | undefined, subID: number | undefined, iD: number | undefined, userid: number | undefined, companyid: number | undefined, searchText: string | null | undefined, startDate: string | null | undefined, endDate: string | null | undefined, searchType: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseRequest/FetchExpenses/FetchExpenses?";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        if (subID === null)
            throw new Error("The parameter 'subID' cannot be null.");
        else if (subID !== undefined)
            url_ += "SubID=" + encodeURIComponent("" + subID) + "&";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        if (companyid === null)
            throw new Error("The parameter 'companyid' cannot be null.");
        else if (companyid !== undefined)
            url_ += "companyid=" + encodeURIComponent("" + companyid) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "startDate=" + encodeURIComponent("" + startDate) + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "endDate=" + encodeURIComponent("" + endDate) + "&";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchExpenses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchExpenses(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchExpenses(response: HttpResponseBase): Observable<ExpenseDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchExpensesDetailedServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param projid (optional) 
     * @param expensegrpid (optional) 
     * @param expensetypeid (optional) 
     * @param locationid (optional) 
     * @param deptid (optional) 
     * @param userid (optional) 
     * @param companyid (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchType (optional) 
     * @param page (optional) 
     * @param searchText (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchExpensesDetailed(projid: number | undefined, expensegrpid: number | undefined, expensetypeid: number | undefined, locationid: number | undefined, deptid: number | undefined, userid: number | undefined, companyid: number | undefined, startDate: Date | undefined, endDate: Date | undefined, searchType: number | undefined, page: number | undefined, searchText: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseRequest/FetchExpensesDetailed/FetchExpensesDetailed?";
        if (projid === null)
            throw new Error("The parameter 'projid' cannot be null.");
        else if (projid !== undefined)
            url_ += "projid=" + encodeURIComponent("" + projid) + "&";
        if (expensegrpid === null)
            throw new Error("The parameter 'expensegrpid' cannot be null.");
        else if (expensegrpid !== undefined)
            url_ += "expensegrpid=" + encodeURIComponent("" + expensegrpid) + "&";
        if (expensetypeid === null)
            throw new Error("The parameter 'expensetypeid' cannot be null.");
        else if (expensetypeid !== undefined)
            url_ += "expensetypeid=" + encodeURIComponent("" + expensetypeid) + "&";
        if (locationid === null)
            throw new Error("The parameter 'locationid' cannot be null.");
        else if (locationid !== undefined)
            url_ += "locationid=" + encodeURIComponent("" + locationid) + "&";
        if (deptid === null)
            throw new Error("The parameter 'deptid' cannot be null.");
        else if (deptid !== undefined)
            url_ += "deptid=" + encodeURIComponent("" + deptid) + "&";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        if (companyid === null)
            throw new Error("The parameter 'companyid' cannot be null.");
        else if (companyid !== undefined)
            url_ += "companyid=" + encodeURIComponent("" + companyid) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchExpensesDetailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchExpensesDetailed(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchExpensesDetailed(response: HttpResponseBase): Observable<ExpenseDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateLoanTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateExpenseType(body: ExpenseTypeDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/AddUpdateLoanType/AddUpdateExpenseType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateExpenseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateExpenseType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateExpenseType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateLoanRequest(body: LoanRequestDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/AddUpdateLoanType/Add-Update-Loan-Request";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateLoanRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateLoanRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateLoanRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateLoanType(body: LoanTypeDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/AddUpdateLoanType/Add-Update-LoanType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateLoanType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateLoanType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateLoanType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseType(encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/ToggleExpenseType/ToggleExpenseType?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param iD (optional) 
     * @param ledgerNo (optional) 
     * @param name (optional) 
     * @param description (optional) 
     * @param referenceId (optional) 
     * @param code (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getExpenseTypes(iD: number | undefined, ledgerNo: string | null | undefined, name: string | null | undefined, description: string | null | undefined, referenceId: string | null | undefined, code: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/GetExpenseTypes/GetExpenseTypes?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (ledgerNo !== undefined && ledgerNo !== null)
            url_ += "LedgerNo=" + encodeURIComponent("" + ledgerNo) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (referenceId !== undefined && referenceId !== null)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseTypes(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseTypes(response: HttpResponseBase): Observable<ExpenseTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddExpenseSubTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addExpenseSubType(body: ExpenseSubType | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/AddExpenseSubType/AddExpenseSubType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddExpenseSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddExpenseSubType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddExpenseSubType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleExpenseSubTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param typeId (optional) 
     * @param encryptedId (optional) 
     * @return Success
     */
    toggleExpenseSubType(typeId: string | null | undefined, encryptedId: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/ToggleExpenseSubType/ToggleExpenseSubType?";
        if (typeId !== undefined && typeId !== null)
            url_ += "TypeId=" + encodeURIComponent("" + typeId) + "&";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleExpenseSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleExpenseSubType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleExpenseSubType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseTypeNameServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param encryptedId (optional) 
     * @return Success
     */
    getExpenseTypeName(encryptedId: string | null | undefined): Observable<ExpenseTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/GetExpenseTypeName/GetExpenseTypeName?";
        if (encryptedId !== undefined && encryptedId !== null)
            url_ += "encryptedId=" + encodeURIComponent("" + encryptedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseTypeName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseTypeName(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseTypeName(response: HttpResponseBase): Observable<ExpenseTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetExpenseSubTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param iD (optional) 
     * @param ledgerNo (optional) 
     * @param name (optional) 
     * @param description (optional) 
     * @param referenceId (optional) 
     * @param code (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getExpenseSubTypes(iD: number | undefined, ledgerNo: string | null | undefined, name: string | null | undefined, description: string | null | undefined, referenceId: string | null | undefined, code: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ExpenseTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/ExpenseType/GetExpenseSubTypes/GetExpenseSubTypes?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (ledgerNo !== undefined && ledgerNo !== null)
            url_ += "LedgerNo=" + encodeURIComponent("" + ledgerNo) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (referenceId !== undefined && referenceId !== null)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseSubTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseSubTypes(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseSubTypes(response: HttpResponseBase): Observable<ExpenseTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchKeyResultAreasServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for retrieving all Key Result Areas with filters as follows 
    'Status: for Active/InActive' Key Result Area
    'RatingType: for Open-ended/Close-ended' Key Result Area
     * @param status (optional) 
     * @param ratingType (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getKeyResultAreas(status: number | undefined, ratingType: number | undefined, pageSize: number | undefined): Observable<KPISectionDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/KeyResultArea/FetchKeyResultAreas/GetKeyResultAreas?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (ratingType === null)
            throw new Error("The parameter 'ratingType' cannot be null.");
        else if (ratingType !== undefined)
            url_ += "RatingType=" + encodeURIComponent("" + ratingType) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyResultAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyResultAreas(<any>response_);
                } catch (e) {
                    return <Observable<KPISectionDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KPISectionDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeyResultAreas(response: HttpResponseBase): Observable<KPISectionDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KPISectionDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KPISectionDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchKeyResultAreaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for getting Single Key Result Area Details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getKeyResultArea(id: number | undefined): Observable<KPISectionDTOApiResult> {
        let url_ = this.baseUrl + "/api/KeyResultArea/FetchKeyResultArea/GetKeyResultArea?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyResultArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyResultArea(<any>response_);
                } catch (e) {
                    return <Observable<KPISectionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KPISectionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeyResultArea(response: HttpResponseBase): Observable<KPISectionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KPISectionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KPISectionDTOApiResult>(<any>null);
    }
}

@Injectable()
export class CreateKeyResultAreaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for add/updating Key Result Areas 
    Toggle (i.e. While Updating use the property 'IsActive'
    as Radio-toggle button and pass true/false. When creating new Key Result Areas 'IsActive is by default)
     * @param body (optional) 
     * @return Success
     */
    createKeyResultArea(body: KPISectionDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/KeyResultArea/CreateKeyResultArea/CreateKeyResultArea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateKeyResultArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateKeyResultArea(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateKeyResultArea(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AssignKRAServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for add/updating Key Result Areas 
    Toggle (i.e. While Updating use the property 'IsActive'
    as Radio-toggle button and pass true/false. When creating new Key Result Areas 'IsActive is by default)
     * @param body (optional) 
     * @return Success
     */
    assignKRA(body: AssignKraDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/KeyResultArea/AssignKRA/AssignKRA";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignKRA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignKRA(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAssignKRA(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateKPIServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for add/updating Key Performance Index (KPI) by Admin/Line Managers
     * @param body (optional) 
     * @return Success
     */
    addUpdateKPI(body: ManageKpiDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/KPI/AddUpdateKPI/Add-Update-KPI";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateKPI(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateKPI(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEmployeeKPIServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for add/updating Employee's Key Performance Index (KPI)
     * @param body (optional) 
     * @return Success
     */
    addUpdateEmployeeKPI(body: ManageKpiDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/KPI/AddUpdateEmployeeKPI/Add-Update-EmployeeKPI";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEmployeeKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEmployeeKPI(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEmployeeKPI(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchKPIsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for retrieving All Key Performance Index (KPIs) attach to a KRA
     * @param key_area_id (optional) 
     * @return Success
     */
    getKPIs(key_area_id: number | undefined): Observable<KpiDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/KPI/FetchKPIs/GetKPIs?";
        if (key_area_id === null)
            throw new Error("The parameter 'key_area_id' cannot be null.");
        else if (key_area_id !== undefined)
            url_ += "key_area_id=" + encodeURIComponent("" + key_area_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKPIs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKPIs(<any>response_);
                } catch (e) {
                    return <Observable<KpiDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KpiDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetKPIs(response: HttpResponseBase): Observable<KpiDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KpiDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KpiDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchKPIServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for getting Single Key Performance Index (KPI) Details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getKPI(id: number | undefined): Observable<KpiDTOApiResult> {
        let url_ = this.baseUrl + "/api/KPI/FetchKPI/GetKPI?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKPI(<any>response_);
                } catch (e) {
                    return <Observable<KpiDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KpiDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetKPI(response: HttpResponseBase): Observable<KpiDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KpiDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KpiDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchEmployeeKPIsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for retrieving Employee's Key Performance Index (KPI)
     * @param key_area_id (optional) 
     * @return Success
     */
    getEmployeeKPIs(key_area_id: number | undefined): Observable<KpiDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/KPI/FetchEmployeeKPIs/GetEmployeeKPIs?";
        if (key_area_id === null)
            throw new Error("The parameter 'key_area_id' cannot be null.");
        else if (key_area_id !== undefined)
            url_ += "key_area_id=" + encodeURIComponent("" + key_area_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeKPIs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeKPIs(<any>response_);
                } catch (e) {
                    return <Observable<KpiDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<KpiDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeKPIs(response: HttpResponseBase): Observable<KpiDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KpiDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KpiDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchMyAppraisalReviewsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for retrieving all Current Appraisal for Review by Line-Managers
     * @param cycleId (optional) 
     * @return Success
     */
    getMyAppraisalReviews(cycleId: number | undefined): Observable<AppraisalReviewerListDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/KPI/FetchMyAppraisalReviews/GetMyAppraisalReviews?";
        if (cycleId === null)
            throw new Error("The parameter 'cycleId' cannot be null.");
        else if (cycleId !== undefined)
            url_ += "cycleId=" + encodeURIComponent("" + cycleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyAppraisalReviews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyAppraisalReviews(<any>response_);
                } catch (e) {
                    return <Observable<AppraisalReviewerListDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppraisalReviewerListDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyAppraisalReviews(response: HttpResponseBase): Observable<AppraisalReviewerListDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppraisalReviewerListDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppraisalReviewerListDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class LeaveEntitlementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used to fetch all the leave entitlements. no param for now
     * @return Success
     */
    getLeaveEntitlements(): Observable<LeaveEntitlementResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/GetLeaveEntitlements";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveEntitlements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveEntitlements(<any>response_);
                } catch (e) {
                    return <Observable<LeaveEntitlementResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveEntitlementResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveEntitlements(response: HttpResponseBase): Observable<LeaveEntitlementResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveEntitlementResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveEntitlementResourceListApiResult>(<any>null);
    }

    /**
     * this method is get leave entitlement by Id. Id is required
     * @param id (optional) 
     * @return Success
     */
    getLeaveEntitlement(id: number | undefined): Observable<LeaveEntitlementResourceApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/GetLeaveEntitlement?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveEntitlement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveEntitlement(<any>response_);
                } catch (e) {
                    return <Observable<LeaveEntitlementResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveEntitlementResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveEntitlement(response: HttpResponseBase): Observable<LeaveEntitlementResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveEntitlementResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveEntitlementResourceApiResult>(<any>null);
    }

    /**
     * this method is used to used to create and edit leave entitlement. Note all fields are required.
     * @param body (optional) 
     * @return Success
     */
    addOrUpdate(body: LeaveEntitlementPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/AddOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave entitlement
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveEntitlement(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/DeleteLeaveEntitlement?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveEntitlement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveEntitlement(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveEntitlement(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to fetch all grades for a particular company. it uses authenticated user comapyid
     * @return Success
     */
    getGrades(): Observable<GradeListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveEntitlement/GetGrades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGrades(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGrades(<any>response_);
                } catch (e) {
                    return <Observable<GradeListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GradeListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGrades(response: HttpResponseBase): Observable<GradeListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GradeListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GradeListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateHolidayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for add/updating Leave Holiday Date
     * @param body (optional) 
     * @return Success
     */
    addUpdateHoliday(body: ManageLeaveHolidayDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/AddUpdateHoliday/Add-Update-Holiday";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateHoliday(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateHoliday(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateHoliday(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used to fetch all or by Id. no param for now
     * @return Success
     */
    getHolidayDates(): Observable<LeaveHolidayDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/Get/GetHolidayDates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHolidayDates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHolidayDates(<any>response_);
                } catch (e) {
                    return <Observable<LeaveHolidayDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveHolidayDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetHolidayDates(response: HttpResponseBase): Observable<LeaveHolidayDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveHolidayDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveHolidayDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is get leave holiday date by Id. Id is required
     * @param id (optional) 
     * @return Success
     */
    getHolidayById(id: number | undefined): Observable<LeaveHolidayDTOApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/GetById/GetHolidayById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHolidayById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHolidayById(<any>response_);
                } catch (e) {
                    return <Observable<LeaveHolidayDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveHolidayDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetHolidayById(response: HttpResponseBase): Observable<LeaveHolidayDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveHolidayDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveHolidayDTOApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used to delete leave holiday date
     * @param id (optional) 
     * @return Success
     */
    deleteHolidayDate(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveHolidayDate/Delete/DeleteHolidayDate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteHolidayDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHolidayDate(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteHolidayDate(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave plan
     * @param id (optional) 
     * @return Success
     */
    deleteLeavePlan(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/Delete/DeleteLeavePlan?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeavePlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeavePlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeavePlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete. leave request Id is required
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveRequest(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/Delete/DeleteLeaveRequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave year
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveYear(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/Delete/DeleteLeaveYear?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveYear(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveYear(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class PostServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used to create  leave plan. Note all fields are required
     * @param body (optional) 
     * @return Success
     */
    createLeavePlan(body: LeavePlanDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/Post/CreateLeavePlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLeavePlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLeavePlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLeavePlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create and edit leave type. Note all fields are required
     * @param body (optional) 
     * @return Success
     */
    createLeaveType(body: LeaveTypeCreatePayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/Post/CreateLeaveType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLeaveType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLeaveType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLeaveType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create and edit leave year. Note: all fields are required
     * @param body (optional) 
     * @return Success
     */
    createLeaveYear(body: LeaveYearCreatePayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/Post/CreateLeaveYear";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLeaveYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLeaveYear(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLeaveYear(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchLeavePlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used fetch leave plans. all filter are optional
     * @param isApproved (optional) 
     * @param leaveYearId (optional) 
     * @param empno (optional) 
     * @param strStartDate (optional) 
     * @param strEndDate (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    fetchLeavePlans(isApproved: number | null | undefined, leaveYearId: number | null | undefined, empno: string | null | undefined, strStartDate: string | null | undefined, strEndDate: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<LeavePlanResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/FetchLeavePlan/FetchLeavePlans?";
        if (isApproved !== undefined && isApproved !== null)
            url_ += "IsApproved=" + encodeURIComponent("" + isApproved) + "&";
        if (leaveYearId !== undefined && leaveYearId !== null)
            url_ += "LeaveYearId=" + encodeURIComponent("" + leaveYearId) + "&";
        if (empno !== undefined && empno !== null)
            url_ += "Empno=" + encodeURIComponent("" + empno) + "&";
        if (strStartDate !== undefined && strStartDate !== null)
            url_ += "StrStartDate=" + encodeURIComponent("" + strStartDate) + "&";
        if (strEndDate !== undefined && strEndDate !== null)
            url_ += "StrEndDate=" + encodeURIComponent("" + strEndDate) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchLeavePlans(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchLeavePlans(<any>response_);
                } catch (e) {
                    return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchLeavePlans(response: HttpResponseBase): Observable<LeavePlanResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeavePlanResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeavePlanResourceListApiResult>(<any>null);
    }
}

@Injectable()
export class LeavePlanEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used fetch events using calender type.calender type include: LeavePlan, ActiveLeaveRequests
     * @param calenderType (optional) 
     * @return Success
     */
    getLeavePlanEvents(calenderType: string | null | undefined): Observable<LeavePlanResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/LeavePlanEvents/GetLeavePlanEvents?";
        if (calenderType !== undefined && calenderType !== null)
            url_ += "calenderType=" + encodeURIComponent("" + calenderType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeavePlanEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeavePlanEvents(<any>response_);
                } catch (e) {
                    return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeavePlanResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeavePlanEvents(response: HttpResponseBase): Observable<LeavePlanResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeavePlanResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeavePlanResourceListApiResult>(<any>null);
    }
}

@Injectable()
export class ApproveOrRejectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used to approve or reject leave plan. Note all fields are requiered except companyId
    it uses Enum Leaveplan status : Approved = 1, Reject = 2, Pending =3
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectLeavePlan(body: ApproveOrRejectPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/ApproveOrReject/ApproveOrRejectLeavePlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectLeavePlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectLeavePlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processApproveOrRejectLeavePlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class PostReviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used to review leave plan. Note all fields are requiered except companyId
    it uses Enum Leaveplan status : Approved = 1, Reject = 2, Pending =3
     * @param body (optional) 
     * @return Success
     */
    postReview(body: ApproveOrRejectPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeavePlan/PostReview/postReview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostReview(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostReview(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CreateLeaveByAdminServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used to create and edit leave by admin.
     * @param body (optional) 
     * @return Success
     */
    createLeaveByAdmin(body: ManageLeaveRequestDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/CreateLeaveByAdmin/CreateLeaveByAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLeaveByAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLeaveByAdmin(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLeaveByAdmin(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used to get leave report.
    all filter is optional
     * @param departmentId (optional) 
     * @param leaveYearId (optional) 
     * @param leaveTypeId (optional) 
     * @param locationId (optional) 
     * @return Success
     */
    getLeaveReports(departmentId: string | null | undefined, leaveYearId: string | null | undefined, leaveTypeId: string | null | undefined, locationId: string | null | undefined): Observable<LeaveReportListDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/GetLeaveRequest/GetLeaveReports?";
        if (departmentId !== undefined && departmentId !== null)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (leaveYearId !== undefined && leaveYearId !== null)
            url_ += "LeaveYearId=" + encodeURIComponent("" + leaveYearId) + "&";
        if (leaveTypeId !== undefined && leaveTypeId !== null)
            url_ += "LeaveTypeId=" + encodeURIComponent("" + leaveTypeId) + "&";
        if (locationId !== undefined && locationId !== null)
            url_ += "LocationId=" + encodeURIComponent("" + locationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveReports(<any>response_);
                } catch (e) {
                    return <Observable<LeaveReportListDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveReportListDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveReports(response: HttpResponseBase): Observable<LeaveReportListDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveReportListDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveReportListDTOListApiResult>(<any>null);
    }

    /**
     * this method is used to get leave by Id.
    Id is required
     * @param id (optional) 
     * @return Success
     */
    getLeaveRequestById(id: number | undefined): Observable<LeaveRequestApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/GetLeaveRequest/GetLeaveRequestById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveRequestById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveRequestById(<any>response_);
                } catch (e) {
                    return <Observable<LeaveRequestApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveRequestApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveRequestById(response: HttpResponseBase): Observable<LeaveRequestApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveRequestApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveRequestApiResult>(<any>null);
    }
}

@Injectable()
export class CancelLeaveRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used to cancel leave request by initiator. leave request Id is required
     * @param id (optional) 
     * @return Success
     */
    cancelLeaveRequest(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveRequest/CancelLeaveRequest/CancelLeaveRequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelLeaveRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelLeaveRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCancelLeaveRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * fetch LeaveTypes.
    Note: all filter are optional
     * @param isAnnualLeave (optional) 
     * @param maxDays (optional) 
     * @param isGradeDependent (optional) 
     * @param minDays (optional) 
     * @return Success
     */
    getLeaveTypes(isAnnualLeave: boolean | undefined, maxDays: number | null | undefined, isGradeDependent: boolean | undefined, minDays: number | null | undefined): Observable<LeaveTypeDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/GetLeaveTypes/GetLeaveTypes?";
        if (isAnnualLeave === null)
            throw new Error("The parameter 'isAnnualLeave' cannot be null.");
        else if (isAnnualLeave !== undefined)
            url_ += "IsAnnualLeave=" + encodeURIComponent("" + isAnnualLeave) + "&";
        if (maxDays !== undefined && maxDays !== null)
            url_ += "MaxDays=" + encodeURIComponent("" + maxDays) + "&";
        if (isGradeDependent === null)
            throw new Error("The parameter 'isGradeDependent' cannot be null.");
        else if (isGradeDependent !== undefined)
            url_ += "IsGradeDependent=" + encodeURIComponent("" + isGradeDependent) + "&";
        if (minDays !== undefined && minDays !== null)
            url_ += "MinDays=" + encodeURIComponent("" + minDays) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveTypes(<any>response_);
                } catch (e) {
                    return <Observable<LeaveTypeDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveTypeDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveTypes(response: HttpResponseBase): Observable<LeaveTypeDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveTypeDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveTypeDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteLeaveTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used to delete leave type
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveType(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/DeleteLeaveType/DeleteLeaveType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * This method is used to get leave type by id
     * @param id (optional) 
     * @return Success
     */
    getLeaveType(id: number | undefined): Observable<LeaveTypeDTOApiResult> {
        let url_ = this.baseUrl + "/api/LeaveType/GetLeaveType/GetLeaveType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveType(<any>response_);
                } catch (e) {
                    return <Observable<LeaveTypeDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveTypeDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveType(response: HttpResponseBase): Observable<LeaveTypeDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveTypeDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveTypeDTOApiResult>(<any>null);
    }
}

@Injectable()
export class LeaveWorkFlowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used to fetch all the leave workflow. no param for now
     * @return Success
     */
    get(): Observable<LeaveWorkFlowResourceListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LeaveWorkFlowResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveWorkFlowResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LeaveWorkFlowResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveWorkFlowResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveWorkFlowResourceListApiResult>(<any>null);
    }

    /**
     * this method is get leave workflow by Id. Id is required
     * @param id (optional) 
     * @return Success
     */
    getLeaveWorkFlowById(id: number | undefined): Observable<LeaveWorkFlowResourceApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/GetLeaveWorkFlowById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveWorkFlowById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveWorkFlowById(<any>response_);
                } catch (e) {
                    return <Observable<LeaveWorkFlowResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveWorkFlowResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveWorkFlowById(response: HttpResponseBase): Observable<LeaveWorkFlowResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveWorkFlowResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveWorkFlowResourceApiResult>(<any>null);
    }

    /**
     * this method is used to used to create and edit leave workflow. Note all fields are requiered.
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateWorkflow(body: LeaveworkFlowPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/AddOrUpdateWorkflow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateWorkflow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateWorkflow(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateWorkflow(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete leave workflow
     * @param id (optional) 
     * @return Success
     */
    deleteLeaveWorkFlow(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LeaveWorkFlow/DeleteLeaveWorkFlow?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveWorkFlow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveWorkFlow(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaveWorkFlow(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveYearsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * Gets leave years
     * @param yearStartDate (optional) 
     * @param yearName (optional) 
     * @param yearEndDate (optional) 
     * @param companyID (optional) 
     * @return Success
     */
    getLeaveYears(yearStartDate: Date | null | undefined, yearName: string | null | undefined, yearEndDate: Date | null | undefined, companyID: number | undefined): Observable<LeaveYearDTOListApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/GetLeaveYears/GetLeaveYears?";
        if (yearStartDate !== undefined && yearStartDate !== null)
            url_ += "YearStartDate=" + encodeURIComponent(yearStartDate ? "" + yearStartDate.toJSON() : "") + "&";
        if (yearName !== undefined && yearName !== null)
            url_ += "YearName=" + encodeURIComponent("" + yearName) + "&";
        if (yearEndDate !== undefined && yearEndDate !== null)
            url_ += "YearEndDate=" + encodeURIComponent(yearEndDate ? "" + yearEndDate.toJSON() : "") + "&";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveYears(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveYears(<any>response_);
                } catch (e) {
                    return <Observable<LeaveYearDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveYearDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveYears(response: HttpResponseBase): Observable<LeaveYearDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveYearDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveYearDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLeaveYearServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used to delete leave year
     * @param id (optional) 
     * @return Success
     */
    getLeaveYear(id: number | undefined): Observable<LeaveYearDTOApiResult> {
        let url_ = this.baseUrl + "/api/LeaveYear/GetLeaveYear/GetLeaveYear?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveYear(<any>response_);
                } catch (e) {
                    return <Observable<LeaveYearDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaveYearDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaveYear(response: HttpResponseBase): Observable<LeaveYearDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveYearDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaveYearDTOApiResult>(<any>null);
    }
}

@Injectable()
export class PostFullRepaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postFullRepayment(body: PostLoanDto | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/PostFullRepayment/Post-Full-Repayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostFullRepayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostFullRepayment(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostFullRepayment(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class SimulatePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param principal (optional) 
     * @param interestType (optional) 
     * @param tenor (optional) 
     * @param interestRate (optional) 
     * @param effectiveDate (optional) 
     * @return Success
     */
    simulatePayment(principal: number | undefined, interestType: number | undefined, tenor: number | undefined, interestRate: number | undefined, effectiveDate: string | null | undefined): Observable<LoanRepaymentLogIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/SimulatePayment/SimulatePayment?";
        if (principal === null)
            throw new Error("The parameter 'principal' cannot be null.");
        else if (principal !== undefined)
            url_ += "principal=" + encodeURIComponent("" + principal) + "&";
        if (interestType === null)
            throw new Error("The parameter 'interestType' cannot be null.");
        else if (interestType !== undefined)
            url_ += "interestType=" + encodeURIComponent("" + interestType) + "&";
        if (tenor === null)
            throw new Error("The parameter 'tenor' cannot be null.");
        else if (tenor !== undefined)
            url_ += "tenor=" + encodeURIComponent("" + tenor) + "&";
        if (interestRate === null)
            throw new Error("The parameter 'interestRate' cannot be null.");
        else if (interestRate !== undefined)
            url_ += "interestRate=" + encodeURIComponent("" + interestRate) + "&";
        if (effectiveDate !== undefined && effectiveDate !== null)
            url_ += "effectiveDate=" + encodeURIComponent("" + effectiveDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimulatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimulatePayment(<any>response_);
                } catch (e) {
                    return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSimulatePayment(response: HttpResponseBase): Observable<LoanRepaymentLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRepaymentLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRepaymentLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanRequestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param userid (optional) 
     * @param companyid (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchType (optional) 
     * @param page (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    getLoanRequests(userid: number | undefined, companyid: number | undefined, startDate: Date | undefined, endDate: Date | undefined, searchType: number | undefined, page: number | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<LoanRequestDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/GetLoanRequests/GetLoanRequests?";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        if (companyid === null)
            throw new Error("The parameter 'companyid' cannot be null.");
        else if (companyid !== undefined)
            url_ += "companyid=" + encodeURIComponent("" + companyid) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanRequests(<any>response_);
                } catch (e) {
                    return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanRequests(response: HttpResponseBase): Observable<LoanRequestDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRequestDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRequestDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanSummaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param loanId (optional) 
     * @return Success
     */
    getLoanSummary(loanId: string | null | undefined): Observable<IdNameObjIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/GetLoanSummary/GetLoanSummary?";
        if (loanId !== undefined && loanId !== null)
            url_ += "LoanId=" + encodeURIComponent("" + loanId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanSummary(<any>response_);
                } catch (e) {
                    return <Observable<IdNameObjIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameObjIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanSummary(response: HttpResponseBase): Observable<IdNameObjIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdNameObjIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameObjIListApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateLoanRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLoanRequest(body: UpdateLoadRequestDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/UpdateLoanRequest/UpdateLoanRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLoanRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLoanRequest(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLoanRequest(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class LoadRepaymentScheduleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param loanId (optional) 
     * @param recompute (optional) 
     * @return Success
     */
    loadRepaymentSchedule(loanId: number | undefined, recompute: number | undefined): Observable<LoanRepaymentLogIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/LoadRepaymentSchedule/LoadRepaymentSchedule?";
        if (loanId === null)
            throw new Error("The parameter 'loanId' cannot be null.");
        else if (loanId !== undefined)
            url_ += "loanId=" + encodeURIComponent("" + loanId) + "&";
        if (recompute === null)
            throw new Error("The parameter 'recompute' cannot be null.");
        else if (recompute !== undefined)
            url_ += "recompute=" + encodeURIComponent("" + recompute) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadRepaymentSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadRepaymentSchedule(<any>response_);
                } catch (e) {
                    return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRepaymentLogIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processLoadRepaymentSchedule(response: HttpResponseBase): Observable<LoanRepaymentLogIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRepaymentLogIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRepaymentLogIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchLoanRequestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param userid (optional) 
     * @param companyid (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchType (optional) 
     * @param page (optional) 
     * @param searchText (optional) 
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @return Success
     */
    fetchLoanRequests(userid: number | undefined, companyid: number | undefined, startDate: Date | undefined, endDate: Date | undefined, searchType: number | undefined, page: number | undefined, searchText: string | null | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<LoanRequestDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/FetchLoanRequests/FetchLoanRequests?";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        if (companyid === null)
            throw new Error("The parameter 'companyid' cannot be null.");
        else if (companyid !== undefined)
            url_ += "companyid=" + encodeURIComponent("" + companyid) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (searchType === null)
            throw new Error("The parameter 'searchType' cannot be null.");
        else if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchLoanRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchLoanRequests(<any>response_);
                } catch (e) {
                    return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRequestDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchLoanRequests(response: HttpResponseBase): Observable<LoanRequestDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRequestDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRequestDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param companyId (optional) 
     * @param loanreqId (optional) 
     * @param userid (optional) 
     * @return Success
     */
    getLoanRequest(companyId: number | undefined, loanreqId: number | undefined, userid: number | undefined): Observable<LoanRequestApiResult> {
        let url_ = this.baseUrl + "/api/LoanRequest/GetLoanRequest/GetLoanRequest?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (loanreqId === null)
            throw new Error("The parameter 'loanreqId' cannot be null.");
        else if (loanreqId !== undefined)
            url_ += "loanreqId=" + encodeURIComponent("" + loanreqId) + "&";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanRequest(<any>response_);
                } catch (e) {
                    return <Observable<LoanRequestApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanRequestApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanRequest(response: HttpResponseBase): Observable<LoanRequestApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanRequestApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanRequestApiResult>(<any>null);
    }
}

@Injectable()
export class ToggleLoanTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    toggleLoanType(body: LoadTypeById | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/ToggleLoanType/Toggle-Loan-Type";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleLoanType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleLoanType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleLoanType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetLoanTypesByCriteriaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param iD (optional) 
     * @param code (optional) 
     * @param ledgerNo (optional) 
     * @param name (optional) 
     * @param minTenor (optional) 
     * @param maxTenor (optional) 
     * @param minAmount (optional) 
     * @param maxAmount (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getLoanTypesByCriteria(iD: number | undefined, code: string | null | undefined, ledgerNo: string | null | undefined, name: string | null | undefined, minTenor: number | undefined, maxTenor: number | undefined, minAmount: number | undefined, maxAmount: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<LoanTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/GetLoanTypesByCriteria/GetLoanTypesByCriteria?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (ledgerNo !== undefined && ledgerNo !== null)
            url_ += "LedgerNo=" + encodeURIComponent("" + ledgerNo) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (minTenor === null)
            throw new Error("The parameter 'minTenor' cannot be null.");
        else if (minTenor !== undefined)
            url_ += "MinTenor=" + encodeURIComponent("" + minTenor) + "&";
        if (maxTenor === null)
            throw new Error("The parameter 'maxTenor' cannot be null.");
        else if (maxTenor !== undefined)
            url_ += "MaxTenor=" + encodeURIComponent("" + maxTenor) + "&";
        if (minAmount === null)
            throw new Error("The parameter 'minAmount' cannot be null.");
        else if (minAmount !== undefined)
            url_ += "MinAmount=" + encodeURIComponent("" + minAmount) + "&";
        if (maxAmount === null)
            throw new Error("The parameter 'maxAmount' cannot be null.");
        else if (maxAmount !== undefined)
            url_ += "MaxAmount=" + encodeURIComponent("" + maxAmount) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanTypesByCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanTypesByCriteria(<any>response_);
                } catch (e) {
                    return <Observable<LoanTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanTypesByCriteria(response: HttpResponseBase): Observable<LoanTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchLoanTypeByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param iD (optional) 
     * @param companyID (optional) 
     * @return Success
     */
    fetchLoanTypeById(iD: number | undefined, companyID: number | undefined): Observable<LoanTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/LoanType/FetchLoanTypeById/FetchLoanTypeById?";
        if (iD === null)
            throw new Error("The parameter 'iD' cannot be null.");
        else if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (companyID === null)
            throw new Error("The parameter 'companyID' cannot be null.");
        else if (companyID !== undefined)
            url_ += "CompanyID=" + encodeURIComponent("" + companyID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchLoanTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchLoanTypeById(<any>response_);
                } catch (e) {
                    return <Observable<LoanTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchLoanTypeById(response: HttpResponseBase): Observable<LoanTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateLocationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for adding/updating Location
     * @param body (optional) 
     * @return Success
     */
    addUpdateLocation(body: ManageLocationDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Location/AddUpdateLocation/Add-Update-Location";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateLocation(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateLocation(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllLocationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API to Fetch Locations.
    Note: all filter are optional
     * @param pageSize (optional) 
     * @param pageNumber (optional) 
     * @param lga_id (optional) 
     * @param state_id (optional) 
     * @return Success
     */
    getAllLocations(pageSize: number | undefined, pageNumber: number | undefined, lga_id: number | undefined, state_id: number | undefined): Observable<LocationDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Location/GetAllLocations/GetAllLocations?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (lga_id === null)
            throw new Error("The parameter 'lga_id' cannot be null.");
        else if (lga_id !== undefined)
            url_ += "lga_id=" + encodeURIComponent("" + lga_id) + "&";
        if (state_id === null)
            throw new Error("The parameter 'state_id' cannot be null.");
        else if (state_id !== undefined)
            url_ += "state_id=" + encodeURIComponent("" + state_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLocations(<any>response_);
                } catch (e) {
                    return <Observable<LocationDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLocations(response: HttpResponseBase): Observable<LocationDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationDTOListApiResult>(<any>null);
    }
}

@Injectable()
export class GetLocationByIdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API to get Location by id and can be used for update, details etc
     * @param id (optional) 
     * @return Success
     */
    getLocation(id: number | undefined): Observable<LocationDTOApiResult> {
        let url_ = this.baseUrl + "/api/Location/GetLocationById/GetLocation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocation(<any>response_);
                } catch (e) {
                    return <Observable<LocationDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocation(response: HttpResponseBase): Observable<LocationDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationDTOApiResult>(<any>null);
    }
}

@Injectable()
export class FetchPerformanceCyclesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for retrieving all Performance Cycles with filters as follows 
    'Status: for Active, Pending_Approval, Approved, Ongoing, Closed
    'RatingType: for Open-ended/Close-ended'
     * @param status (optional) 
     * @param departmentId (optional) 
     * @param locationId (optional) 
     * @param unitId (optional) 
     * @param ratingType (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getPerformanceCycles(status: number | undefined, departmentId: number | undefined, locationId: number | undefined, unitId: number | undefined, ratingType: number | undefined, pageSize: number | undefined): Observable<PerformanceCycleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/PerformanceCycle/FetchPerformanceCycles/GetPerformanceCycles?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "DepartmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "LocationId=" + encodeURIComponent("" + locationId) + "&";
        if (unitId === null)
            throw new Error("The parameter 'unitId' cannot be null.");
        else if (unitId !== undefined)
            url_ += "UnitId=" + encodeURIComponent("" + unitId) + "&";
        if (ratingType === null)
            throw new Error("The parameter 'ratingType' cannot be null.");
        else if (ratingType !== undefined)
            url_ += "RatingType=" + encodeURIComponent("" + ratingType) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformanceCycles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformanceCycles(<any>response_);
                } catch (e) {
                    return <Observable<PerformanceCycleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformanceCycleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformanceCycles(response: HttpResponseBase): Observable<PerformanceCycleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PerformanceCycleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformanceCycleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchPerformanceCycleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for getting Single Performance Cycle Details by id for CRUD Operation
     * @param id (optional) 
     * @return Success
     */
    getPerformanceCycle(id: number | undefined): Observable<PerformanceCycleDTOApiResult> {
        let url_ = this.baseUrl + "/api/PerformanceCycle/FetchPerformanceCycle/GetPerformanceCycle?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformanceCycle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformanceCycle(<any>response_);
                } catch (e) {
                    return <Observable<PerformanceCycleDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformanceCycleDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformanceCycle(response: HttpResponseBase): Observable<PerformanceCycleDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PerformanceCycleDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformanceCycleDTOApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdatePerformanceCycleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for add/updating Performance Cycle
    Toggle (i.e. While Updating use the property 'IsActive'
    as Radio-toggle button and pass true/false. When creating new Performance Cycle 'IsActive is by default)
     * @param body (optional) 
     * @return Success
     */
    addUpdatePerformanceCycle(body: PerformanceCycleDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/PerformanceCycle/AddUpdatePerformanceCycle/Add-Update-PerformanceCycle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdatePerformanceCycle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdatePerformanceCycle(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdatePerformanceCycle(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateEligibleBucketServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateEligibleBucket(body: PromotionEligibilityViewModel | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Promotion/AddUpdateEligibleBucket/AddUpdateEligibleBucket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateEligibleBucket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateEligibleBucket(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateEligibleBucket(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class PromotionListServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param _PageSize (optional) 
     * @param eligiblility_id (optional) 
     * @return Success
     */
    promotionList(_PageSize: number | undefined, eligiblility_id: number | undefined): Observable<Sp_FetchEligibleEmployeesIListApiResult> {
        let url_ = this.baseUrl + "/api/Promotion/PromotionList/PromotionList?";
        if (_PageSize === null)
            throw new Error("The parameter '_PageSize' cannot be null.");
        else if (_PageSize !== undefined)
            url_ += "_PageSize=" + encodeURIComponent("" + _PageSize) + "&";
        if (eligiblility_id === null)
            throw new Error("The parameter 'eligiblility_id' cannot be null.");
        else if (eligiblility_id !== undefined)
            url_ += "eligiblility_id=" + encodeURIComponent("" + eligiblility_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromotionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromotionList(<any>response_);
                } catch (e) {
                    return <Observable<Sp_FetchEligibleEmployeesIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<Sp_FetchEligibleEmployeesIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPromotionList(response: HttpResponseBase): Observable<Sp_FetchEligibleEmployeesIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sp_FetchEligibleEmployeesIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sp_FetchEligibleEmployeesIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchPromotionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @return Success
     */
    fetchPromotions(): Observable<Sp_FetchEligibleEmployeesIListApiResult> {
        let url_ = this.baseUrl + "/api/Promotion/FetchPromotions/FetchPromotions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchPromotions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchPromotions(<any>response_);
                } catch (e) {
                    return <Observable<Sp_FetchEligibleEmployeesIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<Sp_FetchEligibleEmployeesIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processFetchPromotions(response: HttpResponseBase): Observable<Sp_FetchEligibleEmployeesIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sp_FetchEligibleEmployeesIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sp_FetchEligibleEmployeesIListApiResult>(<any>null);
    }
}

@Injectable()
export class PromotionSchedule_SearchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param _eligibilityId (optional) 
     * @param _action (optional) 
     * @param _selected (optional) 
     * @param waive_rule (optional) 
     * @param promotionCategoryId (optional) 
     * @param parentPositionId (optional) 
     * @return Success
     */
    promotionSchedule_Search(_eligibilityId: number | undefined, _action: string | null | undefined, _selected: string | null | undefined, waive_rule: number | undefined, promotionCategoryId: number | undefined, parentPositionId: number | undefined): Observable<VwPromotionScheduleApiResult> {
        let url_ = this.baseUrl + "/api/Promotion/PromotionSchedule_Search/PromotionSchedule_Search?";
        if (_eligibilityId === null)
            throw new Error("The parameter '_eligibilityId' cannot be null.");
        else if (_eligibilityId !== undefined)
            url_ += "_eligibilityId=" + encodeURIComponent("" + _eligibilityId) + "&";
        if (_action !== undefined && _action !== null)
            url_ += "_action=" + encodeURIComponent("" + _action) + "&";
        if (_selected !== undefined && _selected !== null)
            url_ += "_selected=" + encodeURIComponent("" + _selected) + "&";
        if (waive_rule === null)
            throw new Error("The parameter 'waive_rule' cannot be null.");
        else if (waive_rule !== undefined)
            url_ += "waive_rule=" + encodeURIComponent("" + waive_rule) + "&";
        if (promotionCategoryId === null)
            throw new Error("The parameter 'promotionCategoryId' cannot be null.");
        else if (promotionCategoryId !== undefined)
            url_ += "promotionCategoryId=" + encodeURIComponent("" + promotionCategoryId) + "&";
        if (parentPositionId === null)
            throw new Error("The parameter 'parentPositionId' cannot be null.");
        else if (parentPositionId !== undefined)
            url_ += "parentPositionId=" + encodeURIComponent("" + parentPositionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromotionSchedule_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromotionSchedule_Search(<any>response_);
                } catch (e) {
                    return <Observable<VwPromotionScheduleApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwPromotionScheduleApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPromotionSchedule_Search(response: HttpResponseBase): Observable<VwPromotionScheduleApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwPromotionScheduleApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwPromotionScheduleApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRatingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for retrieving all Ratings
     * @return Success
     */
    getRatings(): Observable<RatingDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Rating/FetchRatings/GetRatings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRatings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRatings(<any>response_);
                } catch (e) {
                    return <Observable<RatingDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RatingDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRatings(response: HttpResponseBase): Observable<RatingDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RatingDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RatingDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateRatingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for add/updating Rating
     * @param payloads (optional) 
     * @return Success
     */
    addUpdateRating(payloads: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Rating/AddUpdateRating/Add-Update-Rating?";
        if (payloads !== undefined && payloads !== null)
            url_ += "payloads=" + encodeURIComponent("" + payloads) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateRating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateRating(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateRating(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class DeleteRatingRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for deleting Rating
     * @param id (optional) 
     * @return Success
     */
    deleteRating(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Rating/DeleteRatingRecord/DeleteRating?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRating(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRating(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddUpdateRequestTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateRequestType(body: AddRequestViewModel | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RewardDisciplinary/AddUpdateRequestType/AddUpdateRequestType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateRequestType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateRequestType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateRequestType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class GetAllRequestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param _PageSize (optional) 
     * @param log_status (optional) 
     * @return Success
     */
    getAllRequests(startDate: Date | null | undefined, endDate: Date | null | undefined, _PageSize: number | undefined, log_status: number | undefined): Observable<RequestViewModelIListApiResult> {
        let url_ = this.baseUrl + "/api/RewardDisciplinary/GetAllRequests/GetAllRequests?";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (_PageSize === null)
            throw new Error("The parameter '_PageSize' cannot be null.");
        else if (_PageSize !== undefined)
            url_ += "_PageSize=" + encodeURIComponent("" + _PageSize) + "&";
        if (log_status === null)
            throw new Error("The parameter 'log_status' cannot be null.");
        else if (log_status !== undefined)
            url_ += "log_status=" + encodeURIComponent("" + log_status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRequests(<any>response_);
                } catch (e) {
                    return <Observable<RequestViewModelIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestViewModelIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRequests(response: HttpResponseBase): Observable<RequestViewModelIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestViewModelIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestViewModelIListApiResult>(<any>null);
    }
}

@Injectable()
export class RequestDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    requestDetails(id: number | null | undefined): Observable<RequestFileDtoIListApiResult> {
        let url_ = this.baseUrl + "/api/RewardDisciplinary/RequestDetails/RequestDetails?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestDetails(<any>response_);
                } catch (e) {
                    return <Observable<RequestFileDtoIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestFileDtoIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRequestDetails(response: HttpResponseBase): Observable<RequestFileDtoIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestFileDtoIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestFileDtoIListApiResult>(<any>null);
    }
}

@Injectable()
export class RequestTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @return Success
     */
    requestTypes(): Observable<RequestTypeIListApiResult> {
        let url_ = this.baseUrl + "/api/RewardDisciplinary/RequestTypes/RequestTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestTypes(<any>response_);
                } catch (e) {
                    return <Observable<RequestTypeIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestTypeIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRequestTypes(response: HttpResponseBase): Observable<RequestTypeIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestTypeIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestTypeIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for getting all Roles for creating/updating Admin User as a Tenant Admin
     * @return Success
     */
    getRoles(): Observable<ApplicationRoleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchRoles/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ApplicationRoleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllRolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for getting all Roles for CRUD operation as a Super Admin that possesses
    'Role Management' Privilege
     * @return Success
     */
    getAllRoles(): Observable<ApplicationRoleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchAllRoles/GetAllRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<ApplicationRoleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for getting single Role for CRUD operation as a Super Admin that possesses
    'Role Management' Privilege
     * @param id (optional) 
     * @return Success
     */
    getRole(id: number | undefined): Observable<ApplicationRoleDTOApiResult> {
        let url_ = this.baseUrl + "/api/Role/FetchRole/GetRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRole(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationRoleDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationRoleDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRole(response: HttpResponseBase): Observable<ApplicationRoleDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationRoleDTOApiResult>(<any>null);
    }
}

@Injectable()
export class CreateRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for Adding/Updating Roles as a Super Admin that possesses
    'Role Management' Privilege
     * @param body (optional) 
     * @return Success
     */
    createRole(body: ApplicationRoleDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Role/CreateRole/CreateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolePermissionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @return Success
     */
    getRolePermissions(): Observable<RolePermissionDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/FetchRolePermissions/GetRolePermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermissions(<any>response_);
                } catch (e) {
                    return <Observable<RolePermissionDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RolePermissionDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolePermissions(response: HttpResponseBase): Observable<RolePermissionDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermissionDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RolePermissionDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchRolePermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param roleId (optional) 
     * @return Success
     */
    getRolePermission(roleId: number | undefined): Observable<RolePermissionDTOApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/FetchRolePermission/GetRolePermission?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermission(<any>response_);
                } catch (e) {
                    return <Observable<RolePermissionDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RolePermissionDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolePermission(response: HttpResponseBase): Observable<RolePermissionDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermissionDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RolePermissionDTOApiResult>(<any>null);
    }
}

@Injectable()
export class RolePermissionMappingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolePermissionMapping(body: RolePermissionMappingDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/RolePermission/RolePermissionMapping/RolePermissionMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolePermissionMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolePermissionMapping(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRolePermissionMapping(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class CreateSubscriptionPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSubscriptionPlan(body: SubscriptionPlan | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/CreateSubscriptionPlan/CreateSubscriptionPlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubscriptionPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubscriptionPlan(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubscriptionPlan(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchSubscriptionPlansServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @return Success
     */
    getSubscriptionPlans(): Observable<SubscriptionPlanIListApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/FetchSubscriptionPlans/GetSubscriptionPlans";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionPlans(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionPlans(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPlanIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPlanIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionPlans(response: HttpResponseBase): Observable<SubscriptionPlanIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPlanIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchSubscriptionPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param planId (optional) 
     * @return Success
     */
    getSubscriptionPlan(planId: number | undefined): Observable<SubscriptionPlanApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/FetchSubscriptionPlan/GetSubscriptionPlan?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionPlan(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPlanApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPlanApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionPlan(response: HttpResponseBase): Observable<SubscriptionPlanApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPlanApiResult>(<any>null);
    }
}

@Injectable()
export class FetchSubscriptionPlanModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param planId (optional) 
     * @return Success
     */
    getSubscriptionPlanModules(planId: number | undefined): Observable<SubscriptionPlanModuleIListApiResult> {
        let url_ = this.baseUrl + "/api/SubscriptionPlan/FetchSubscriptionPlanModules/GetSubscriptionPlanModules?";
        if (planId === null)
            throw new Error("The parameter 'planId' cannot be null.");
        else if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionPlanModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionPlanModules(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPlanModuleIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPlanModuleIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionPlanModules(response: HttpResponseBase): Observable<SubscriptionPlanModuleIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPlanModuleIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPlanModuleIListApiResult>(<any>null);
    }
}

@Injectable()
export class VerifySubscriptionPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for verifying and updating Tenant's Subscription Payment
    with payment reference and userid
     * @param reference (optional) 
     * @param userId (optional) 
     * @return Success
     */
    verifySubscriptionPayment(reference: string | null | undefined, userId: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/VerifySubscriptionPayment/VerifySubscriptionPayment?";
        if (reference !== undefined && reference !== null)
            url_ += "reference=" + encodeURIComponent("" + reference) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySubscriptionPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySubscriptionPayment(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySubscriptionPayment(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class TenantSignUpServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for signing up Tenant's account on the system
     * @param body (optional) 
     * @return Success
     */
    tenantSignUp(body: CompanySignUpDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/TenantSignUp/TenantSignUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantSignUp(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processTenantSignUp(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class ConfirmTenantEmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for confirming Tenant's email account by providing the two querystring inside
    the Confirmation link ('userid' and 'token')
     * @param userId (optional) 
     * @param token (optional) 
     * @return Success
     */
    confirmTenantEmail(userId: string | null | undefined, token: string | null | undefined): Observable<VwUserObjApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/ConfirmTenantEmail/ConfirmTenantEmail?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmTenantEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmTenantEmail(<any>response_);
                } catch (e) {
                    return <Observable<VwUserObjApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<VwUserObjApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmTenantEmail(response: HttpResponseBase): Observable<VwUserObjApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VwUserObjApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VwUserObjApiResult>(<any>null);
    }
}

@Injectable()
export class RegisterCompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerCompany(body: CompanyDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/RegisterCompany/RegisterCompany";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterCompany(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterCompany(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllTenantsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for retrieving All Tenant on the system with filtering parameters
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param searchText (optional) 
     * @param status (optional) 
     * @return Success
     */
    getAllTenants(startDate: Date | undefined, endDate: Date | undefined, searchText: string | null | undefined, status: number | undefined): Observable<CompanyIListApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/FetchAllTenants/GetAllTenants?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTenants(<any>response_);
                } catch (e) {
                    return <Observable<CompanyIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTenants(response: HttpResponseBase): Observable<CompanyIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyIListApiResult>(<any>null);
    }
}

@Injectable()
export class FetchTenantModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for retrieving Tenant's registered modules based on their subscription plan
     * @return Success
     */
    getTenantModules(): Observable<CompanyModuleDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/FetchTenantModules/GetTenantModules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantModules(<any>response_);
                } catch (e) {
                    return <Observable<CompanyModuleDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyModuleDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantModules(response: HttpResponseBase): Observable<CompanyModuleDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyModuleDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyModuleDTOIListApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateTenantModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for updating Tenant's Modules
     * @param payload (optional) 
     * @return Success
     */
    updateTenantModules(payload: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/UpdateTenantModules/UpdateTenantModules?";
        if (payload !== undefined && payload !== null)
            url_ += "payload=" + encodeURIComponent("" + payload) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantModules(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantModules(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class AddTenantModulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * API for creating Tenant's Modules
     * @param payload (optional) 
     * @return Success
     */
    createTenantModules(payload: string | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Tenancy/AddTenantModules/CreateTenantModules?";
        if (payload !== undefined && payload !== null)
            url_ += "payload=" + encodeURIComponent("" + payload) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenantModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenantModules(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenantModules(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class TrainingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * this method is used to create  or update  training vendor.  if it is update, training vendor Id is required
     * @param body (optional) 
     * @return Success
     */
    createvendor(body: TrainingVendorPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/createvendor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatevendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatevendor(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreatevendor(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training vendor. all filter are optional
     * @param name (optional) 
     * @param trainingSpecializationId (optional) 
     * @param trainingTag (optional) 
     * @return Success
     */
    vendors(name: string | null | undefined, trainingSpecializationId: number | null | undefined, trainingTag: string | null | undefined): Observable<TrainingVendorResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/vendors?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (trainingSpecializationId !== undefined && trainingSpecializationId !== null)
            url_ += "TrainingSpecializationId=" + encodeURIComponent("" + trainingSpecializationId) + "&";
        if (trainingTag !== undefined && trainingTag !== null)
            url_ += "TrainingTag=" + encodeURIComponent("" + trainingTag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVendors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVendors(<any>response_);
                } catch (e) {
                    return <Observable<TrainingVendorResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingVendorResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processVendors(response: HttpResponseBase): Observable<TrainingVendorResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingVendorResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingVendorResourceListApiResult>(<any>null);
    }

    /**
     * this method is used get training vendor by Id.
     * @param id (optional) 
     * @return Success
     */
    getVendor(id: number | undefined): Observable<TrainingVendorResourceApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetVendor?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendor(<any>response_);
                } catch (e) {
                    return <Observable<TrainingVendorResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingVendorResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendor(response: HttpResponseBase): Observable<TrainingVendorResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingVendorResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingVendorResourceApiResult>(<any>null);
    }

    /**
     * this method is used to delete training vendor
     * @param id (optional) 
     * @return Success
     */
    deleteVendor(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteVendor?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVendor(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteVendor(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to upload excel file of vendors. accepted file format ".xlsx", ".xls"
     * @param file (optional) 
     * @return Success
     */
    uploadVendor(file: FileParameter | null | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/UploadVendor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadVendor(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUploadVendor(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create  or update  training type.  if it is update, training vendour Id is required
     * @param body (optional) 
     * @return Success
     */
    createtype(body: TrainingTypePayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/createtype";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatetype(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatetype(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreatetype(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training types. all filter are optional
     * @param name (optional) 
     * @param trainingVendorId (optional) 
     * @param trainingSpecializationId (optional) 
     * @param trainingCategoryId (optional) 
     * @return Success
     */
    types(name: string | null | undefined, trainingVendorId: number | null | undefined, trainingSpecializationId: number | null | undefined, trainingCategoryId: number | null | undefined): Observable<TrainingTypeResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/types?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (trainingVendorId !== undefined && trainingVendorId !== null)
            url_ += "TrainingVendorId=" + encodeURIComponent("" + trainingVendorId) + "&";
        if (trainingSpecializationId !== undefined && trainingSpecializationId !== null)
            url_ += "TrainingSpecializationId=" + encodeURIComponent("" + trainingSpecializationId) + "&";
        if (trainingCategoryId !== undefined && trainingCategoryId !== null)
            url_ += "TrainingCategoryId=" + encodeURIComponent("" + trainingCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTypes(<any>response_);
                } catch (e) {
                    return <Observable<TrainingTypeResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingTypeResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processTypes(response: HttpResponseBase): Observable<TrainingTypeResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingTypeResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingTypeResourceListApiResult>(<any>null);
    }

    /**
     * this method is used get training type by Id.
     * @param id (optional) 
     * @return Success
     */
    getTrainingType(id: number | undefined): Observable<TrainingTypeResourceApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetTrainingType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingType(<any>response_);
                } catch (e) {
                    return <Observable<TrainingTypeResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingTypeResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingType(response: HttpResponseBase): Observable<TrainingTypeResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingTypeResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingTypeResourceApiResult>(<any>null);
    }

    /**
     * this method is use to change training type status. Note:  if status false, it means inactive while true means active
     * @param body (optional) 
     * @return Success
     */
    changetypestatus(body: ToggleTrainingType | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/changetypestatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangetypestatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangetypestatus(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processChangetypestatus(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete training type
     * @param id (optional) 
     * @return Success
     */
    deleteTrainingType(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteTrainingType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTrainingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTrainingType(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTrainingType(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create  or update  training Category.  if it is update, training Category Id is required
     * @param body (optional) 
     * @return Success
     */
    createorupdatecategory(body: TrainingCategoryPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/createorupdatecategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdatecategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdatecategory(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateorupdatecategory(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training categories.
     * @return Success
     */
    categories(): Observable<TrainingCategoryResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategories(<any>response_);
                } catch (e) {
                    return <Observable<TrainingCategoryResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingCategoryResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCategories(response: HttpResponseBase): Observable<TrainingCategoryResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingCategoryResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingCategoryResourceListApiResult>(<any>null);
    }

    /**
     * this method is used get training Category by Id.
     * @param id (optional) 
     * @return Success
     */
    getCategory(id: number | undefined): Observable<TrainingCategoryResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategory(<any>response_);
                } catch (e) {
                    return <Observable<TrainingCategoryResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingCategoryResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategory(response: HttpResponseBase): Observable<TrainingCategoryResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingCategoryResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingCategoryResourceListApiResult>(<any>null);
    }

    /**
     * this method is used to delete training category
     * @param id (optional) 
     * @return Success
     */
    deleteCategory(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create  or update  training Specialization/Expertise.  if it is update, training specialization Id is required
     * @param body (optional) 
     * @return Success
     */
    createorupdatespecialization(body: TrainingSpecializationPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/createorupdatespecialization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdatespecialization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdatespecialization(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateorupdatespecialization(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training Specialization/Expertise.
     * @return Success
     */
    getTrainingSpecializations(): Observable<TrainingSpecializationDTOListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetTrainingSpecializations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrainingSpecializations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrainingSpecializations(<any>response_);
                } catch (e) {
                    return <Observable<TrainingSpecializationDTOListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingSpecializationDTOListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrainingSpecializations(response: HttpResponseBase): Observable<TrainingSpecializationDTOListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSpecializationDTOListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingSpecializationDTOListApiResult>(<any>null);
    }

    /**
     * this method is used get training Specialization by Id.
     * @param id (optional) 
     * @return Success
     */
    getSpecializationById(id: number | undefined): Observable<TrainingSpecializationDTOApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetSpecializationById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpecializationById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpecializationById(<any>response_);
                } catch (e) {
                    return <Observable<TrainingSpecializationDTOApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingSpecializationDTOApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetSpecializationById(response: HttpResponseBase): Observable<TrainingSpecializationDTOApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingSpecializationDTOApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingSpecializationDTOApiResult>(<any>null);
    }

    /**
     * this method is used to delete training Specialization
     * @param id (optional) 
     * @return Success
     */
    deleteSpecialization(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteSpecialization?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSpecialization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSpecialization(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSpecialization(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to set up or create a traning.
     * @param body (optional) 
     * @return Success
     */
    setupTraining(body: TrainingSetupPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/SetupTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetupTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetupTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSetupTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training. Note filters are optional
     * @param body (optional) 
     * @return Success
     */
    trainings(body: TrainingFilter | undefined): Observable<TrainingResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/trainings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTrainings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTrainings(<any>response_);
                } catch (e) {
                    return <Observable<TrainingResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processTrainings(response: HttpResponseBase): Observable<TrainingResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingResourceListApiResult>(<any>null);
    }

    /**
     * this method is used update  training. training Id ir required
     * @param body (optional) 
     * @return Success
     */
    updatesetup(body: TrainingSetupUpdatePayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/Updatesetup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatesetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatesetup(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatesetup(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to change training status. if training status: false = inactive, true = active
     * @param id (optional) 
     * @return Success
     */
    toggleTraining(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/ToggleTraining?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processToggleTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete training
     * @param id (optional) 
     * @return Success
     */
    deleteTraining(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteTraining?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to create or update  training Criteria. if it is update, training specialization Id is required
     * @param body (optional) 
     * @return Success
     */
    createUpdateCriteria(body: TrainingCriteriaPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/Create-Update-Criteria";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUpdateCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUpdateCriteria(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUpdateCriteria(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training criteria.
     * @param name (optional) 
     * @param min_Age (optional) 
     * @param min_LengthOfService (optional) 
     * @return Success
     */
    getCriterias(trainingTypeId: number, name: string | null | undefined, min_Age: number | undefined, min_LengthOfService: number | undefined): Observable<TrainingCriteriaResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetCriterias?";
        if (trainingTypeId === undefined || trainingTypeId === null)
            throw new Error("The parameter 'trainingTypeId' must be defined and cannot be null.");
        else
            url_ += "TrainingTypeId=" + encodeURIComponent("" + trainingTypeId) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (min_Age === null)
            throw new Error("The parameter 'min_Age' cannot be null.");
        else if (min_Age !== undefined)
            url_ += "Min_Age=" + encodeURIComponent("" + min_Age) + "&";
        if (min_LengthOfService === null)
            throw new Error("The parameter 'min_LengthOfService' cannot be null.");
        else if (min_LengthOfService !== undefined)
            url_ += "Min_LengthOfService=" + encodeURIComponent("" + min_LengthOfService) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCriterias(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCriterias(<any>response_);
                } catch (e) {
                    return <Observable<TrainingCriteriaResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingCriteriaResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCriterias(response: HttpResponseBase): Observable<TrainingCriteriaResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingCriteriaResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingCriteriaResourceListApiResult>(<any>null);
    }

    /**
     * this method is used get training criteria by Id.
     * @param id (optional) 
     * @return Success
     */
    getCriteria(id: number | undefined): Observable<TrainingCriteriaResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetCriteria?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCriteria(<any>response_);
                } catch (e) {
                    return <Observable<TrainingCriteriaResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrainingCriteriaResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCriteria(response: HttpResponseBase): Observable<TrainingCriteriaResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainingCriteriaResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainingCriteriaResourceListApiResult>(<any>null);
    }

    /**
     * this method is used to delete training Criteria
     * @param id (optional) 
     * @return Success
     */
    deleteCriteria(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteCriteria?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCriteria(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCriteria(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to asign training to employees.  Note: file is not required
     * @param body (optional) 
     * @return Success
     */
    addEmployeeToTraining(body: AssignTrainingToEmpPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/AddEmployeeToTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEmployeeToTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEmployeeToTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processAddEmployeeToTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used fetch training assigned to employee. all filter are optional
     * @param specializationName (optional) 
     * @param trainingTypeName (optional) 
     * @param name (optional) 
     * @param trainingVendorName (optional) 
     * @return Success
     */
    getEmployeeTrainings(specializationName: string | null | undefined, trainingTypeName: string | null | undefined, name: string | null | undefined, trainingVendorName: string | null | undefined): Observable<EmpTrainingResourceListApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetEmployeeTrainings?";
        if (specializationName !== undefined && specializationName !== null)
            url_ += "SpecializationName=" + encodeURIComponent("" + specializationName) + "&";
        if (trainingTypeName !== undefined && trainingTypeName !== null)
            url_ += "TrainingTypeName=" + encodeURIComponent("" + trainingTypeName) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (trainingVendorName !== undefined && trainingVendorName !== null)
            url_ += "TrainingVendorName=" + encodeURIComponent("" + trainingVendorName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeTrainings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeTrainings(<any>response_);
                } catch (e) {
                    return <Observable<EmpTrainingResourceListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmpTrainingResourceListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeTrainings(response: HttpResponseBase): Observable<EmpTrainingResourceListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpTrainingResourceListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmpTrainingResourceListApiResult>(<any>null);
    }

    /**
     * this method is used send training for approval.
     * @param id (optional) 
     * @return Success
     */
    sendTrainingForApproval(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/SendTrainingForApproval?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTrainingForApproval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTrainingForApproval(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processSendTrainingForApproval(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to notify employee for assigned training.
     * @param id (optional) 
     * @return Success
     */
    notifyEmployee(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/NotifyEmployee?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotifyEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotifyEmployee(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processNotifyEmployee(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to remove employees from training.
     * @param body (optional) 
     * @return Success
     */
    removeBulkEmployeeFromTraining(body: AssignTrainingToEmpPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/RemoveBulkEmployeeFromTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveBulkEmployeeFromTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveBulkEmployeeFromTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveBulkEmployeeFromTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to remove employee from training
     * @param body (optional) 
     * @return Success
     */
    removeEmployeeFromTraining(body: AssignTrainingToOneEmpPayload | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/RemoveEmployeeFromTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveEmployeeFromTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveEmployeeFromTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveEmployeeFromTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to delete employee added to training
     * @param id (optional) 
     * @return Success
     */
    deleteEmployeeTraining(id: number | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/DeleteEmployeeTraining?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEmployeeTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEmployeeTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEmployeeTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used get emp training by Id.
     * @param id (optional) 
     * @return Success
     */
    getEmpTraining(id: number | undefined): Observable<EmpTrainingResourceApiResult> {
        let url_ = this.baseUrl + "/api/Training/GetEmpTraining?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmpTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmpTraining(<any>response_);
                } catch (e) {
                    return <Observable<EmpTrainingResourceApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmpTrainingResourceApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmpTraining(response: HttpResponseBase): Observable<EmpTrainingResourceApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpTrainingResourceApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmpTrainingResourceApiResult>(<any>null);
    }

    /**
     * this method is used to  save employee feedback after training.
     * @param body (optional) 
     * @return Success
     */
    employeeTrainingFeedback(body: EmpFeedBack | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/EmployeeTrainingFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeTrainingFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeTrainingFeedback(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processEmployeeTrainingFeedback(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to upload excel file of vendors. accepted file format ".xlsx", ".xls"
     * @param body (optional) 
     * @return Success
     */
    postEmployeeTraining(body: EmployeeTrainingDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/PostEmployeeTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostEmployeeTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostEmployeeTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostEmployeeTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }

    /**
     * this method is used to update emp training
     * @param body (optional) 
     * @return Success
     */
    updateEmployeeTraining(body: EmployeeTrainingDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/Training/UpdateEmployeeTraining";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmployeeTraining(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmployeeTraining(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEmployeeTraining(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class RegisterUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerUser(body: RegisterUserDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/RegisterUser/RegisterUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class UpdateUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body: RegisterUserDTO | undefined): Observable<MessageOutApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/UpdateUser/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<MessageOutApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageOutApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<MessageOutApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageOutApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageOutApiResult>(<any>null);
    }
}

@Injectable()
export class FetchAllUsersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://104.40.215.33:8000/smartaceapi";
    }

    /**
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param email (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllUsers(firstName: string | null | undefined, lastName: string | null | undefined, email: string | null | undefined, pageSize: number | undefined): Observable<ApplicationUserDTOIListApiResult> {
        let url_ = this.baseUrl + "/api/UserManagement/FetchAllUsers/GetAllUsers?";
        if (firstName !== undefined && firstName !== null)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName !== undefined && lastName !== null)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationUserDTOIListApiResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationUserDTOIListApiResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<ApplicationUserDTOIListApiResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUserDTOIListApiResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUserDTOIListApiResult>(<any>null);
    }
}

export class UserLoginDTO implements IUserLoginDTO {
    email!: string | undefined;
    password!: string | undefined;

    constructor(data?: IUserLoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UserLoginDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }

    clone(): UserLoginDTO {
        const json = this.toJSON();
        let result = new UserLoginDTO();
        result.init(json);
        return result;
    }
}

export interface IUserLoginDTO {
    email: string | undefined;
    password: string | undefined;
}

export class VwUserObj implements IVwUserObj {
    user_id!: number;
    employee_id!: number;
    employee_number!: string | undefined;
    employee_contract_id!: number;
    grade_id!: number | undefined;
    confirmation_date!: Date | undefined;
    serial_no!: string | undefined;
    first_name!: string | undefined;
    last_name!: string | undefined;
    readonly full_name!: string | undefined;
    other_name!: string | undefined;
    department!: string | undefined;
    department_id!: number;
    email!: string | undefined;
    phone_number!: string | undefined;
    email_confirmed!: boolean;
    session_token!: string | undefined;
    jwt_token!: string | undefined;
    user_token!: string | undefined;
    company_id!: number;
    licenseUsuage!: number;
    licenseCount!: number;
    company_name!: string | undefined;
    sub_id!: number;
    isAdmin!: boolean;
    isSuperAdmin!: boolean;
    isTenantAdmin!: boolean;
    isActiveBySysOrAdmin!: boolean;
    lstPermissions!: string[] | undefined;
    message!: string | undefined;
    isSuccessful!: boolean;
    retId!: number;
    redirectUrl!: string | undefined;
    errors!: string[] | undefined;

    constructor(data?: IVwUserObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user_id = _data["user_id"];
            this.employee_id = _data["employee_id"];
            this.employee_number = _data["employee_number"];
            this.employee_contract_id = _data["employee_contract_id"];
            this.grade_id = _data["grade_id"];
            this.confirmation_date = _data["confirmation_date"] ? new Date(_data["confirmation_date"].toString()) : <any>undefined;
            this.serial_no = _data["serial_no"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            (<any>this).full_name = _data["full_name"];
            this.other_name = _data["other_name"];
            this.department = _data["department"];
            this.department_id = _data["department_id"];
            this.email = _data["email"];
            this.phone_number = _data["phone_number"];
            this.email_confirmed = _data["email_confirmed"];
            this.session_token = _data["session_token"];
            this.jwt_token = _data["jwt_token"];
            this.user_token = _data["user_token"];
            this.company_id = _data["company_id"];
            this.licenseUsuage = _data["licenseUsuage"];
            this.licenseCount = _data["licenseCount"];
            this.company_name = _data["company_name"];
            this.sub_id = _data["sub_id"];
            this.isAdmin = _data["isAdmin"];
            this.isSuperAdmin = _data["isSuperAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.isActiveBySysOrAdmin = _data["isActiveBySysOrAdmin"];
            if (Array.isArray(_data["lstPermissions"])) {
                this.lstPermissions = [] as any;
                for (let item of _data["lstPermissions"])
                    this.lstPermissions!.push(item);
            }
            this.message = _data["message"];
            this.isSuccessful = _data["isSuccessful"];
            this.retId = _data["retId"];
            this.redirectUrl = _data["redirectUrl"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): VwUserObj {
        data = typeof data === 'object' ? data : {};
        let result = new VwUserObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_id"] = this.user_id;
        data["employee_id"] = this.employee_id;
        data["employee_number"] = this.employee_number;
        data["employee_contract_id"] = this.employee_contract_id;
        data["grade_id"] = this.grade_id;
        data["confirmation_date"] = this.confirmation_date ? this.confirmation_date.toISOString() : <any>undefined;
        data["serial_no"] = this.serial_no;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["full_name"] = this.full_name;
        data["other_name"] = this.other_name;
        data["department"] = this.department;
        data["department_id"] = this.department_id;
        data["email"] = this.email;
        data["phone_number"] = this.phone_number;
        data["email_confirmed"] = this.email_confirmed;
        data["session_token"] = this.session_token;
        data["jwt_token"] = this.jwt_token;
        data["user_token"] = this.user_token;
        data["company_id"] = this.company_id;
        data["licenseUsuage"] = this.licenseUsuage;
        data["licenseCount"] = this.licenseCount;
        data["company_name"] = this.company_name;
        data["sub_id"] = this.sub_id;
        data["isAdmin"] = this.isAdmin;
        data["isSuperAdmin"] = this.isSuperAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["isActiveBySysOrAdmin"] = this.isActiveBySysOrAdmin;
        if (Array.isArray(this.lstPermissions)) {
            data["lstPermissions"] = [];
            for (let item of this.lstPermissions)
                data["lstPermissions"].push(item);
        }
        data["message"] = this.message;
        data["isSuccessful"] = this.isSuccessful;
        data["retId"] = this.retId;
        data["redirectUrl"] = this.redirectUrl;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }

    clone(): VwUserObj {
        const json = this.toJSON();
        let result = new VwUserObj();
        result.init(json);
        return result;
    }
}

export interface IVwUserObj {
    user_id: number;
    employee_id: number;
    employee_number: string | undefined;
    employee_contract_id: number;
    grade_id: number | undefined;
    confirmation_date: Date | undefined;
    serial_no: string | undefined;
    first_name: string | undefined;
    last_name: string | undefined;
    full_name: string | undefined;
    other_name: string | undefined;
    department: string | undefined;
    department_id: number;
    email: string | undefined;
    phone_number: string | undefined;
    email_confirmed: boolean;
    session_token: string | undefined;
    jwt_token: string | undefined;
    user_token: string | undefined;
    company_id: number;
    licenseUsuage: number;
    licenseCount: number;
    company_name: string | undefined;
    sub_id: number;
    isAdmin: boolean;
    isSuperAdmin: boolean;
    isTenantAdmin: boolean;
    isActiveBySysOrAdmin: boolean;
    lstPermissions: string[] | undefined;
    message: string | undefined;
    isSuccessful: boolean;
    retId: number;
    redirectUrl: string | undefined;
    errors: string[] | undefined;
}

export class VwUserObjApiResult implements IVwUserObjApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwUserObj;
    totalCount!: number;

    constructor(data?: IVwUserObjApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? VwUserObj.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VwUserObjApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwUserObjApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VwUserObjApiResult {
        const json = this.toJSON();
        let result = new VwUserObjApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwUserObjApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwUserObj;
    totalCount: number;
}

export class MessageOut implements IMessageOut {
    message!: string | undefined;
    isSuccessful!: boolean;
    retId!: number;
    redirectUrl!: string | undefined;
    errors!: string[] | undefined;

    constructor(data?: IMessageOut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.isSuccessful = _data["isSuccessful"];
            this.retId = _data["retId"];
            this.redirectUrl = _data["redirectUrl"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): MessageOut {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["isSuccessful"] = this.isSuccessful;
        data["retId"] = this.retId;
        data["redirectUrl"] = this.redirectUrl;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }

    clone(): MessageOut {
        const json = this.toJSON();
        let result = new MessageOut();
        result.init(json);
        return result;
    }
}

export interface IMessageOut {
    message: string | undefined;
    isSuccessful: boolean;
    retId: number;
    redirectUrl: string | undefined;
    errors: string[] | undefined;
}

export class MessageOutApiResult implements IMessageOutApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MessageOut;
    totalCount!: number;

    constructor(data?: IMessageOutApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? MessageOut.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MessageOutApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOutApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): MessageOutApiResult {
        const json = this.toJSON();
        let result = new MessageOutApiResult();
        result.init(json);
        return result;
    }
}

export interface IMessageOutApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MessageOut;
    totalCount: number;
}

export class ResestPasswordDTO implements IResestPasswordDTO {
    token!: string | undefined;
    email!: string;
    password!: string;
    confirmPassword!: string | undefined;

    constructor(data?: IResestPasswordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResestPasswordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResestPasswordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }

    clone(): ResestPasswordDTO {
        const json = this.toJSON();
        let result = new ResestPasswordDTO();
        result.init(json);
        return result;
    }
}

export interface IResestPasswordDTO {
    token: string | undefined;
    email: string;
    password: string;
    confirmPassword: string | undefined;
}

export class ActivityLog implements IActivityLog {
    userId!: number | undefined;
    moduleName!: string | undefined;
    moduleAction!: string | undefined;
    description!: string | undefined;
    record!: string | undefined;
    ipAdress!: string | undefined;
    operationType!: string | undefined;
    employeeId!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IActivityLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.moduleName = _data["moduleName"];
            this.moduleAction = _data["moduleAction"];
            this.description = _data["description"];
            this.record = _data["record"];
            this.ipAdress = _data["ipAdress"];
            this.operationType = _data["operationType"];
            this.employeeId = _data["employeeId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ActivityLog {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["moduleName"] = this.moduleName;
        data["moduleAction"] = this.moduleAction;
        data["description"] = this.description;
        data["record"] = this.record;
        data["ipAdress"] = this.ipAdress;
        data["operationType"] = this.operationType;
        data["employeeId"] = this.employeeId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ActivityLog {
        const json = this.toJSON();
        let result = new ActivityLog();
        result.init(json);
        return result;
    }
}

export interface IActivityLog {
    userId: number | undefined;
    moduleName: string | undefined;
    moduleAction: string | undefined;
    description: string | undefined;
    record: string | undefined;
    ipAdress: string | undefined;
    operationType: string | undefined;
    employeeId: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ActivityLogIListApiResult implements IActivityLogIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ActivityLog[] | undefined;
    totalCount!: number;

    constructor(data?: IActivityLogIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ActivityLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ActivityLogIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLogIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ActivityLogIListApiResult {
        const json = this.toJSON();
        let result = new ActivityLogIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IActivityLogIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ActivityLog[] | undefined;
    totalCount: number;
}

export class AssetTypeDTO implements IAssetTypeDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetTypeDTO {
        const json = this.toJSON();
        let result = new AssetTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetTypeDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class MessageOutIListApiResult implements IMessageOutIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: MessageOut[] | undefined;
    totalCount!: number;

    constructor(data?: IMessageOutIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MessageOut.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MessageOutIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MessageOutIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): MessageOutIListApiResult {
        const json = this.toJSON();
        let result = new MessageOutIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IMessageOutIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: MessageOut[] | undefined;
    totalCount: number;
}

export class AssetDeperciationProfileDTO implements IAssetDeperciationProfileDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    code!: number;
    deperciationDate!: Date | undefined;
    purchaseYear!: number | undefined;
    depriciationType!: string | undefined;
    peroidicity!: Date | undefined;
    deperciationPercentage!: number | undefined;

    constructor(data?: IAssetDeperciationProfileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
            this.deperciationDate = _data["deperciationDate"] ? new Date(_data["deperciationDate"].toString()) : <any>undefined;
            this.purchaseYear = _data["purchaseYear"];
            this.depriciationType = _data["depriciationType"];
            this.peroidicity = _data["peroidicity"] ? new Date(_data["peroidicity"].toString()) : <any>undefined;
            this.deperciationPercentage = _data["deperciationPercentage"];
        }
    }

    static fromJS(data: any): AssetDeperciationProfileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDeperciationProfileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        data["deperciationDate"] = this.deperciationDate ? this.deperciationDate.toISOString() : <any>undefined;
        data["purchaseYear"] = this.purchaseYear;
        data["depriciationType"] = this.depriciationType;
        data["peroidicity"] = this.peroidicity ? this.peroidicity.toISOString() : <any>undefined;
        data["deperciationPercentage"] = this.deperciationPercentage;
        return data; 
    }

    clone(): AssetDeperciationProfileDTO {
        const json = this.toJSON();
        let result = new AssetDeperciationProfileDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetDeperciationProfileDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    code: number;
    deperciationDate: Date | undefined;
    purchaseYear: number | undefined;
    depriciationType: string | undefined;
    peroidicity: Date | undefined;
    deperciationPercentage: number | undefined;
}

export class AssetSubTypeDTO implements IAssetSubTypeDTO {
    id!: number;
    assetTypeId!: number;
    assetid!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    code!: number;

    constructor(data?: IAssetSubTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetTypeId = _data["assetTypeId"];
            this.assetid = _data["assetid"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): AssetSubTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetSubTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetTypeId"] = this.assetTypeId;
        data["assetid"] = this.assetid;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        return data; 
    }

    clone(): AssetSubTypeDTO {
        const json = this.toJSON();
        let result = new AssetSubTypeDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetSubTypeDTO {
    id: number;
    assetTypeId: number;
    assetid: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    code: number;
}

export class AssetCategoryDTO implements IAssetCategoryDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetCategoryDTO {
        const json = this.toJSON();
        let result = new AssetCategoryDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetCategoryDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetStatusDTO implements IAssetStatusDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    assetid!: number;
    statusName!: string | undefined;
    subID!: number;
    description!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetStatusDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.assetid = _data["assetid"];
            this.statusName = _data["statusName"];
            this.subID = _data["subID"];
            this.description = _data["description"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetStatusDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetStatusDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["assetid"] = this.assetid;
        data["statusName"] = this.statusName;
        data["subID"] = this.subID;
        data["description"] = this.description;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetStatusDTO {
        const json = this.toJSON();
        let result = new AssetStatusDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetStatusDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    assetid: number;
    statusName: string | undefined;
    subID: number;
    description: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetMakeDTO implements IAssetMakeDTO {
    id!: number;
    companyID!: number;
    brandModel!: string | undefined;
    makeName!: string | undefined;
    assetid!: number;
    depreciation!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetMakeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.brandModel = _data["brandModel"];
            this.makeName = _data["makeName"];
            this.assetid = _data["assetid"];
            this.depreciation = _data["depreciation"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetMakeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetMakeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["brandModel"] = this.brandModel;
        data["makeName"] = this.makeName;
        data["assetid"] = this.assetid;
        data["depreciation"] = this.depreciation;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetMakeDTO {
        const json = this.toJSON();
        let result = new AssetMakeDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetMakeDTO {
    id: number;
    companyID: number;
    brandModel: string | undefined;
    makeName: string | undefined;
    assetid: number;
    depreciation: string | undefined;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetModelDTO implements IAssetModelDTO {
    id!: number;
    assetMakeId!: number | undefined;
    companyID!: number;
    description!: string | undefined;
    modelname!: string | undefined;
    assetid!: number;
    name!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetModelDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetMakeId = _data["assetMakeId"];
            this.companyID = _data["companyID"];
            this.description = _data["description"];
            this.modelname = _data["modelname"];
            this.assetid = _data["assetid"];
            this.name = _data["name"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetModelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetModelDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetMakeId"] = this.assetMakeId;
        data["companyID"] = this.companyID;
        data["description"] = this.description;
        data["modelname"] = this.modelname;
        data["assetid"] = this.assetid;
        data["name"] = this.name;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetModelDTO {
        const json = this.toJSON();
        let result = new AssetModelDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetModelDTO {
    id: number;
    assetMakeId: number | undefined;
    companyID: number;
    description: string | undefined;
    modelname: string | undefined;
    assetid: number;
    name: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetDTO implements IAssetDTO {
    referenceNumber!: string | undefined;
    employeeFullName!: string | undefined;
    modelName!: string | undefined;
    depreciationName!: string | undefined;
    assetTypeName!: string | undefined;
    assetSubTypeName!: string | undefined;
    statusName!: string | undefined;
    locationName!: string | undefined;
    makeName!: string | undefined;
    assetid!: number;
    assignedEmployeeid!: number;
    name!: string | undefined;
    assetNumber!: string | undefined;
    serialNumber!: string | undefined;
    custodianDepartmentId!: number;
    custodianId!: number;
    assetStatusId!: number;
    assetCategoryId!: number;
    assetSubTypeId!: number;
    deperciationMethod!: number;
    depreciationFrequency!: number;
    createdBy!: string | undefined;
    assetTypeId!: number;
    assetModelId!: number;
    assetModelName!: string | undefined;
    assetDepreciationProfileId!: number;
    assetMakeId!: number;
    assetMakeName!: string | undefined;
    locationId!: number;
    manufactureDate!: Date | undefined;
    purchaseDate!: Date | undefined;
    purchaseAmount!: number;
    description!: string | undefined;
    barCode!: string | undefined;
    qrCode!: string | undefined;
    depreciationDate!: Date | undefined;
    lostAsset!: boolean | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date | undefined;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.referenceNumber = _data["referenceNumber"];
            this.employeeFullName = _data["employeeFullName"];
            this.modelName = _data["modelName"];
            this.depreciationName = _data["depreciationName"];
            this.assetTypeName = _data["assetTypeName"];
            this.assetSubTypeName = _data["assetSubTypeName"];
            this.statusName = _data["statusName"];
            this.locationName = _data["locationName"];
            this.makeName = _data["makeName"];
            this.assetid = _data["assetid"];
            this.assignedEmployeeid = _data["assignedEmployeeid"];
            this.name = _data["name"];
            this.assetNumber = _data["assetNumber"];
            this.serialNumber = _data["serialNumber"];
            this.custodianDepartmentId = _data["custodianDepartmentId"];
            this.custodianId = _data["custodianId"];
            this.assetStatusId = _data["assetStatusId"];
            this.assetCategoryId = _data["assetCategoryId"];
            this.assetSubTypeId = _data["assetSubTypeId"];
            this.deperciationMethod = _data["deperciationMethod"];
            this.depreciationFrequency = _data["depreciationFrequency"];
            this.createdBy = _data["createdBy"];
            this.assetTypeId = _data["assetTypeId"];
            this.assetModelId = _data["assetModelId"];
            this.assetModelName = _data["assetModelName"];
            this.assetDepreciationProfileId = _data["assetDepreciationProfileId"];
            this.assetMakeId = _data["assetMakeId"];
            this.assetMakeName = _data["assetMakeName"];
            this.locationId = _data["locationId"];
            this.manufactureDate = _data["manufactureDate"] ? new Date(_data["manufactureDate"].toString()) : <any>undefined;
            this.purchaseDate = _data["purchaseDate"] ? new Date(_data["purchaseDate"].toString()) : <any>undefined;
            this.purchaseAmount = _data["purchaseAmount"];
            this.description = _data["description"];
            this.barCode = _data["barCode"];
            this.qrCode = _data["qrCode"];
            this.depreciationDate = _data["depreciationDate"] ? new Date(_data["depreciationDate"].toString()) : <any>undefined;
            this.lostAsset = _data["lostAsset"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceNumber"] = this.referenceNumber;
        data["employeeFullName"] = this.employeeFullName;
        data["modelName"] = this.modelName;
        data["depreciationName"] = this.depreciationName;
        data["assetTypeName"] = this.assetTypeName;
        data["assetSubTypeName"] = this.assetSubTypeName;
        data["statusName"] = this.statusName;
        data["locationName"] = this.locationName;
        data["makeName"] = this.makeName;
        data["assetid"] = this.assetid;
        data["assignedEmployeeid"] = this.assignedEmployeeid;
        data["name"] = this.name;
        data["assetNumber"] = this.assetNumber;
        data["serialNumber"] = this.serialNumber;
        data["custodianDepartmentId"] = this.custodianDepartmentId;
        data["custodianId"] = this.custodianId;
        data["assetStatusId"] = this.assetStatusId;
        data["assetCategoryId"] = this.assetCategoryId;
        data["assetSubTypeId"] = this.assetSubTypeId;
        data["deperciationMethod"] = this.deperciationMethod;
        data["depreciationFrequency"] = this.depreciationFrequency;
        data["createdBy"] = this.createdBy;
        data["assetTypeId"] = this.assetTypeId;
        data["assetModelId"] = this.assetModelId;
        data["assetModelName"] = this.assetModelName;
        data["assetDepreciationProfileId"] = this.assetDepreciationProfileId;
        data["assetMakeId"] = this.assetMakeId;
        data["assetMakeName"] = this.assetMakeName;
        data["locationId"] = this.locationId;
        data["manufactureDate"] = this.manufactureDate ? this.manufactureDate.toISOString() : <any>undefined;
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>undefined;
        data["purchaseAmount"] = this.purchaseAmount;
        data["description"] = this.description;
        data["barCode"] = this.barCode;
        data["qrCode"] = this.qrCode;
        data["depreciationDate"] = this.depreciationDate ? this.depreciationDate.toISOString() : <any>undefined;
        data["lostAsset"] = this.lostAsset;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetDTO {
        const json = this.toJSON();
        let result = new AssetDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetDTO {
    referenceNumber: string | undefined;
    employeeFullName: string | undefined;
    modelName: string | undefined;
    depreciationName: string | undefined;
    assetTypeName: string | undefined;
    assetSubTypeName: string | undefined;
    statusName: string | undefined;
    locationName: string | undefined;
    makeName: string | undefined;
    assetid: number;
    assignedEmployeeid: number;
    name: string | undefined;
    assetNumber: string | undefined;
    serialNumber: string | undefined;
    custodianDepartmentId: number;
    custodianId: number;
    assetStatusId: number;
    assetCategoryId: number;
    assetSubTypeId: number;
    deperciationMethod: number;
    depreciationFrequency: number;
    createdBy: string | undefined;
    assetTypeId: number;
    assetModelId: number;
    assetModelName: string | undefined;
    assetDepreciationProfileId: number;
    assetMakeId: number;
    assetMakeName: string | undefined;
    locationId: number;
    manufactureDate: Date | undefined;
    purchaseDate: Date | undefined;
    purchaseAmount: number;
    description: string | undefined;
    barCode: string | undefined;
    qrCode: string | undefined;
    depreciationDate: Date | undefined;
    lostAsset: boolean | undefined;
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date | undefined;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssetRequestDTO implements IAssetRequestDTO {
    assetid!: number | undefined;
    assetTypeid!: number | undefined;
    assetName!: string | undefined;
    employeeid!: number;
    employeeName!: string | undefined;
    assetSubTypeName!: string | undefined;
    expectedusedate!: Date | undefined;
    assetSubTypeid!: number;
    returndate!: Date | undefined;
    purpose!: string | undefined;
    decisionComment!: string | undefined;
    departmentId!: number;
    location!: number;
    prioity!: number;
    justification!: string | undefined;
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    subID!: number;
    status!: number;
    assignedbyId!: number;
    approvedId!: number;
    statusName!: string | undefined;
    assignedbyName!: string | undefined;
    approveedbyName!: string | undefined;
    dateCreated!: Date | undefined;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IAssetRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assetid = _data["assetid"];
            this.assetTypeid = _data["assetTypeid"];
            this.assetName = _data["assetName"];
            this.employeeid = _data["employeeid"];
            this.employeeName = _data["employeeName"];
            this.assetSubTypeName = _data["assetSubTypeName"];
            this.expectedusedate = _data["expectedusedate"] ? new Date(_data["expectedusedate"].toString()) : <any>undefined;
            this.assetSubTypeid = _data["assetSubTypeid"];
            this.returndate = _data["returndate"] ? new Date(_data["returndate"].toString()) : <any>undefined;
            this.purpose = _data["purpose"];
            this.decisionComment = _data["decisionComment"];
            this.departmentId = _data["departmentId"];
            this.location = _data["location"];
            this.prioity = _data["prioity"];
            this.justification = _data["justification"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.subID = _data["subID"];
            this.status = _data["status"];
            this.assignedbyId = _data["assignedbyId"];
            this.approvedId = _data["approvedId"];
            this.statusName = _data["statusName"];
            this.assignedbyName = _data["assignedbyName"];
            this.approveedbyName = _data["approveedbyName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetid"] = this.assetid;
        data["assetTypeid"] = this.assetTypeid;
        data["assetName"] = this.assetName;
        data["employeeid"] = this.employeeid;
        data["employeeName"] = this.employeeName;
        data["assetSubTypeName"] = this.assetSubTypeName;
        data["expectedusedate"] = this.expectedusedate ? this.expectedusedate.toISOString() : <any>undefined;
        data["assetSubTypeid"] = this.assetSubTypeid;
        data["returndate"] = this.returndate ? this.returndate.toISOString() : <any>undefined;
        data["purpose"] = this.purpose;
        data["decisionComment"] = this.decisionComment;
        data["departmentId"] = this.departmentId;
        data["location"] = this.location;
        data["prioity"] = this.prioity;
        data["justification"] = this.justification;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["subID"] = this.subID;
        data["status"] = this.status;
        data["assignedbyId"] = this.assignedbyId;
        data["approvedId"] = this.approvedId;
        data["statusName"] = this.statusName;
        data["assignedbyName"] = this.assignedbyName;
        data["approveedbyName"] = this.approveedbyName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetRequestDTO {
        const json = this.toJSON();
        let result = new AssetRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetRequestDTO {
    assetid: number | undefined;
    assetTypeid: number | undefined;
    assetName: string | undefined;
    employeeid: number;
    employeeName: string | undefined;
    assetSubTypeName: string | undefined;
    expectedusedate: Date | undefined;
    assetSubTypeid: number;
    returndate: Date | undefined;
    purpose: string | undefined;
    decisionComment: string | undefined;
    departmentId: number;
    location: number;
    prioity: number;
    justification: string | undefined;
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    subID: number;
    status: number;
    assignedbyId: number;
    approvedId: number;
    statusName: string | undefined;
    assignedbyName: string | undefined;
    approveedbyName: string | undefined;
    dateCreated: Date | undefined;
    isDeleted: boolean;
    isActive: boolean;
}

export class AssignmentDTO implements IAssignmentDTO {
    id!: number;
    assetid!: number;
    comment!: string | undefined;

    constructor(data?: IAssignmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetid = _data["assetid"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): AssignmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssignmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetid"] = this.assetid;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): AssignmentDTO {
        const json = this.toJSON();
        let result = new AssignmentDTO();
        result.init(json);
        return result;
    }
}

export interface IAssignmentDTO {
    id: number;
    assetid: number;
    comment: string | undefined;
}

export class AssetCallbackDTO implements IAssetCallbackDTO {
    companyID!: number;
    message!: string | undefined;
    processcode!: number;
    itemId!: number;
    approvalProcessId!: number;
    isapproved!: boolean;

    constructor(data?: IAssetCallbackDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyID = _data["companyID"];
            this.message = _data["message"];
            this.processcode = _data["processcode"];
            this.itemId = _data["itemId"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.isapproved = _data["isapproved"];
        }
    }

    static fromJS(data: any): AssetCallbackDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCallbackDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyID"] = this.companyID;
        data["message"] = this.message;
        data["processcode"] = this.processcode;
        data["itemId"] = this.itemId;
        data["approvalProcessId"] = this.approvalProcessId;
        data["isapproved"] = this.isapproved;
        return data; 
    }

    clone(): AssetCallbackDTO {
        const json = this.toJSON();
        let result = new AssetCallbackDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetCallbackDTO {
    companyID: number;
    message: string | undefined;
    processcode: number;
    itemId: number;
    approvalProcessId: number;
    isapproved: boolean;
}

export class AssetcheckInFilter implements IAssetcheckInFilter {
    id!: number;
    pageNumber!: number;
    pageSize!: number;
    name!: string | undefined;
    isFilter!: boolean;
    isActive!: boolean | undefined;

    constructor(data?: IAssetcheckInFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.name = _data["name"];
            this.isFilter = _data["isFilter"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): AssetcheckInFilter {
        data = typeof data === 'object' ? data : {};
        let result = new AssetcheckInFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["name"] = this.name;
        data["isFilter"] = this.isFilter;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): AssetcheckInFilter {
        const json = this.toJSON();
        let result = new AssetcheckInFilter();
        result.init(json);
        return result;
    }
}

export interface IAssetcheckInFilter {
    id: number;
    pageNumber: number;
    pageSize: number;
    name: string | undefined;
    isFilter: boolean;
    isActive: boolean | undefined;
}

export class UpdateAssetRequest implements IUpdateAssetRequest {
    id!: number;
    assetid!: number;
    assetRequestDTO!: AssetRequestDTO;
    pageNumber!: number;
    pageSize!: number;
    name!: string | undefined;
    isFilter!: boolean;
    isActive!: boolean | undefined;

    constructor(data?: IUpdateAssetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assetid = _data["assetid"];
            this.assetRequestDTO = _data["assetRequestDTO"] ? AssetRequestDTO.fromJS(_data["assetRequestDTO"]) : <any>undefined;
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.name = _data["name"];
            this.isFilter = _data["isFilter"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateAssetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAssetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetid"] = this.assetid;
        data["assetRequestDTO"] = this.assetRequestDTO ? this.assetRequestDTO.toJSON() : <any>undefined;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["name"] = this.name;
        data["isFilter"] = this.isFilter;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): UpdateAssetRequest {
        const json = this.toJSON();
        let result = new UpdateAssetRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateAssetRequest {
    id: number;
    assetid: number;
    assetRequestDTO: AssetRequestDTO;
    pageNumber: number;
    pageSize: number;
    name: string | undefined;
    isFilter: boolean;
    isActive: boolean | undefined;
}

export class AssetDTOIListApiResult implements IAssetDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetDTO[] | undefined;
    totalCount: number;
}

export class AssetTypeDTOIListApiResult implements IAssetTypeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetTypeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetTypeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetTypeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetTypeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetTypeDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetTypeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetTypeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetTypeDTO[] | undefined;
    totalCount: number;
}

export class AssetSubTypeDTOIListApiResult implements IAssetSubTypeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetSubTypeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetSubTypeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetSubTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetSubTypeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetSubTypeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetSubTypeDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetSubTypeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetSubTypeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetSubTypeDTO[] | undefined;
    totalCount: number;
}

export class AssetCategoryDTOIListApiResult implements IAssetCategoryDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetCategoryDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetCategoryDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetCategoryDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetCategoryDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCategoryDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetCategoryDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetCategoryDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetCategoryDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetCategoryDTO[] | undefined;
    totalCount: number;
}

export class AssetMakeDTOIListApiResult implements IAssetMakeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetMakeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetMakeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetMakeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetMakeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetMakeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetMakeDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetMakeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetMakeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetMakeDTO[] | undefined;
    totalCount: number;
}

export class AssetModelDTOIListApiResult implements IAssetModelDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetModelDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetModelDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetModelDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetModelDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetModelDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetModelDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetModelDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetModelDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetModelDTO[] | undefined;
    totalCount: number;
}

export class AssetStatusDTOIListApiResult implements IAssetStatusDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetStatusDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetStatusDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetStatusDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetStatusDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetStatusDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetStatusDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetStatusDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetStatusDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetStatusDTO[] | undefined;
    totalCount: number;
}

export class AssetDeperciationProfileDTOIListApiResult implements IAssetDeperciationProfileDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetDeperciationProfileDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetDeperciationProfileDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetDeperciationProfileDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetDeperciationProfileDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDeperciationProfileDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetDeperciationProfileDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetDeperciationProfileDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetDeperciationProfileDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetDeperciationProfileDTO[] | undefined;
    totalCount: number;
}

export class AssetHistoryDTO implements IAssetHistoryDTO {
    id!: number;
    companyID!: number;
    name!: string | undefined;
    description!: string | undefined;
    assignedEmployeeName!: string | undefined;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    assetId!: number;
    status!: number;
    assignedEmployeeid!: number;
    assetName!: string | undefined;
    statusName!: string | undefined;
    employeeId!: number;
    employeeName!: string | undefined;
    departmentAssignedTo!: number;
    departmentNameAssignedTo!: string | undefined;
    assignedDate!: Date;
    employeelocationName!: string | undefined;

    constructor(data?: IAssetHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.assignedEmployeeName = _data["assignedEmployeeName"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.assetId = _data["assetId"];
            this.status = _data["status"];
            this.assignedEmployeeid = _data["assignedEmployeeid"];
            this.assetName = _data["assetName"];
            this.statusName = _data["statusName"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.departmentAssignedTo = _data["departmentAssignedTo"];
            this.departmentNameAssignedTo = _data["departmentNameAssignedTo"];
            this.assignedDate = _data["assignedDate"] ? new Date(_data["assignedDate"].toString()) : <any>undefined;
            this.employeelocationName = _data["employeelocationName"];
        }
    }

    static fromJS(data: any): AssetHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssetHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["assignedEmployeeName"] = this.assignedEmployeeName;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["assetId"] = this.assetId;
        data["status"] = this.status;
        data["assignedEmployeeid"] = this.assignedEmployeeid;
        data["assetName"] = this.assetName;
        data["statusName"] = this.statusName;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["departmentAssignedTo"] = this.departmentAssignedTo;
        data["departmentNameAssignedTo"] = this.departmentNameAssignedTo;
        data["assignedDate"] = this.assignedDate ? this.assignedDate.toISOString() : <any>undefined;
        data["employeelocationName"] = this.employeelocationName;
        return data; 
    }

    clone(): AssetHistoryDTO {
        const json = this.toJSON();
        let result = new AssetHistoryDTO();
        result.init(json);
        return result;
    }
}

export interface IAssetHistoryDTO {
    id: number;
    companyID: number;
    name: string | undefined;
    description: string | undefined;
    assignedEmployeeName: string | undefined;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    assetId: number;
    status: number;
    assignedEmployeeid: number;
    assetName: string | undefined;
    statusName: string | undefined;
    employeeId: number;
    employeeName: string | undefined;
    departmentAssignedTo: number;
    departmentNameAssignedTo: string | undefined;
    assignedDate: Date;
    employeelocationName: string | undefined;
}

export class AssetHistoryDTOIListApiResult implements IAssetHistoryDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AssetHistoryDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAssetHistoryDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssetHistoryDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AssetHistoryDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetHistoryDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AssetHistoryDTOIListApiResult {
        const json = this.toJSON();
        let result = new AssetHistoryDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAssetHistoryDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AssetHistoryDTO[] | undefined;
    totalCount: number;
}

export class DeploymentLog implements IDeploymentLog {
    employeeContractid!: number;
    refNo!: string | undefined;
    comment!: string;
    request_by!: string | undefined;
    is_new!: boolean;
    last_deployment_date!: Date | undefined;
    current_location_id!: number;
    current_school_id!: number | undefined;
    current_ministry_id!: number | undefined;
    requested_location_id!: number;
    requested_school_id!: number | undefined;
    requested_ministry_id!: number | undefined;
    log_status!: number;
    bulkaction_id!: number | undefined;
    request_date!: Date;
    effective_date!: Date | undefined;
    is_treated!: boolean | undefined;
    fileName!: string | undefined;
    filePath!: string | undefined;
    location!: Location;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDeploymentLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeContractid = _data["employeeContractid"];
            this.refNo = _data["refNo"];
            this.comment = _data["comment"];
            this.request_by = _data["request_by"];
            this.is_new = _data["is_new"];
            this.last_deployment_date = _data["last_deployment_date"] ? new Date(_data["last_deployment_date"].toString()) : <any>undefined;
            this.current_location_id = _data["current_location_id"];
            this.current_school_id = _data["current_school_id"];
            this.current_ministry_id = _data["current_ministry_id"];
            this.requested_location_id = _data["requested_location_id"];
            this.requested_school_id = _data["requested_school_id"];
            this.requested_ministry_id = _data["requested_ministry_id"];
            this.log_status = _data["log_status"];
            this.bulkaction_id = _data["bulkaction_id"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.effective_date = _data["effective_date"] ? new Date(_data["effective_date"].toString()) : <any>undefined;
            this.is_treated = _data["is_treated"];
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DeploymentLog {
        data = typeof data === 'object' ? data : {};
        let result = new DeploymentLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeContractid"] = this.employeeContractid;
        data["refNo"] = this.refNo;
        data["comment"] = this.comment;
        data["request_by"] = this.request_by;
        data["is_new"] = this.is_new;
        data["last_deployment_date"] = this.last_deployment_date ? this.last_deployment_date.toISOString() : <any>undefined;
        data["current_location_id"] = this.current_location_id;
        data["current_school_id"] = this.current_school_id;
        data["current_ministry_id"] = this.current_ministry_id;
        data["requested_location_id"] = this.requested_location_id;
        data["requested_school_id"] = this.requested_school_id;
        data["requested_ministry_id"] = this.requested_ministry_id;
        data["log_status"] = this.log_status;
        data["bulkaction_id"] = this.bulkaction_id;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["effective_date"] = this.effective_date ? this.effective_date.toISOString() : <any>undefined;
        data["is_treated"] = this.is_treated;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DeploymentLog {
        const json = this.toJSON();
        let result = new DeploymentLog();
        result.init(json);
        return result;
    }
}

export interface IDeploymentLog {
    employeeContractid: number;
    refNo: string | undefined;
    comment: string;
    request_by: string | undefined;
    is_new: boolean;
    last_deployment_date: Date | undefined;
    current_location_id: number;
    current_school_id: number | undefined;
    current_ministry_id: number | undefined;
    requested_location_id: number;
    requested_school_id: number | undefined;
    requested_ministry_id: number | undefined;
    log_status: number;
    bulkaction_id: number | undefined;
    request_date: Date;
    effective_date: Date | undefined;
    is_treated: boolean | undefined;
    fileName: string | undefined;
    filePath: string | undefined;
    location: Location;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Location implements ILocation {
    location_name!: string;
    lga_id!: number | undefined;
    state_id!: number | undefined;
    is_enabled!: boolean;
    deploymentLogs!: DeploymentLog[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location_name = _data["location_name"];
            this.lga_id = _data["lga_id"];
            this.state_id = _data["state_id"];
            this.is_enabled = _data["is_enabled"];
            if (Array.isArray(_data["deploymentLogs"])) {
                this.deploymentLogs = [] as any;
                for (let item of _data["deploymentLogs"])
                    this.deploymentLogs!.push(DeploymentLog.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location_name"] = this.location_name;
        data["lga_id"] = this.lga_id;
        data["state_id"] = this.state_id;
        data["is_enabled"] = this.is_enabled;
        if (Array.isArray(this.deploymentLogs)) {
            data["deploymentLogs"] = [];
            for (let item of this.deploymentLogs)
                data["deploymentLogs"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Location {
        const json = this.toJSON();
        let result = new Location();
        result.init(json);
        return result;
    }
}

export interface ILocation {
    location_name: string;
    lga_id: number | undefined;
    state_id: number | undefined;
    is_enabled: boolean;
    deploymentLogs: DeploymentLog[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LocationIListApiResult implements ILocationIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Location[] | undefined;
    totalCount!: number;

    constructor(data?: ILocationIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Location.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LocationIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LocationIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LocationIListApiResult {
        const json = this.toJSON();
        let result = new LocationIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILocationIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Location[] | undefined;
    totalCount: number;
}

export class Department implements IDepartment {
    name!: string;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    headOfDepartment!: number;
    scheduleOfDuties!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDepartment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.headOfDepartment = _data["headOfDepartment"];
            this.scheduleOfDuties = _data["scheduleOfDuties"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Department {
        data = typeof data === 'object' ? data : {};
        let result = new Department();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["headOfDepartment"] = this.headOfDepartment;
        data["scheduleOfDuties"] = this.scheduleOfDuties;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Department {
        const json = this.toJSON();
        let result = new Department();
        result.init(json);
        return result;
    }
}

export interface IDepartment {
    name: string;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    headOfDepartment: number;
    scheduleOfDuties: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DepartmentIListApiResult implements IDepartmentIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Department[] | undefined;
    totalCount!: number;

    constructor(data?: IDepartmentIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Department.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DepartmentIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DepartmentIListApiResult {
        const json = this.toJSON();
        let result = new DepartmentIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDepartmentIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Department[] | undefined;
    totalCount: number;
}

export class VwConfirmationDTO implements IVwConfirmationDTO {
    id!: number;
    company_id!: number;
    subsidiary_id!: number;
    employee_id!: number;
    mgr_feedback!: string | undefined;
    mgr_advice!: string | undefined;
    appointment_date!: Date | undefined;
    probation_period!: string | undefined;
    log_status!: number;
    request_by!: string | undefined;
    request_date!: Date | undefined;
    employee_contractId!: number;
    employee_name!: string | undefined;
    status!: string | undefined;
    staff_no!: string | undefined;
    effective_date!: Date | undefined;
    str_effective_date!: string | undefined;
    confirmationDate!: Date | undefined;

    constructor(data?: IVwConfirmationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.subsidiary_id = _data["subsidiary_id"];
            this.employee_id = _data["employee_id"];
            this.mgr_feedback = _data["mgr_feedback"];
            this.mgr_advice = _data["mgr_advice"];
            this.appointment_date = _data["appointment_date"] ? new Date(_data["appointment_date"].toString()) : <any>undefined;
            this.probation_period = _data["probation_period"];
            this.log_status = _data["log_status"];
            this.request_by = _data["request_by"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.employee_contractId = _data["employee_contractId"];
            this.employee_name = _data["employee_name"];
            this.status = _data["status"];
            this.staff_no = _data["staff_no"];
            this.effective_date = _data["effective_date"] ? new Date(_data["effective_date"].toString()) : <any>undefined;
            this.str_effective_date = _data["str_effective_date"];
            this.confirmationDate = _data["confirmationDate"] ? new Date(_data["confirmationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VwConfirmationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new VwConfirmationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["subsidiary_id"] = this.subsidiary_id;
        data["employee_id"] = this.employee_id;
        data["mgr_feedback"] = this.mgr_feedback;
        data["mgr_advice"] = this.mgr_advice;
        data["appointment_date"] = this.appointment_date ? this.appointment_date.toISOString() : <any>undefined;
        data["probation_period"] = this.probation_period;
        data["log_status"] = this.log_status;
        data["request_by"] = this.request_by;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["employee_contractId"] = this.employee_contractId;
        data["employee_name"] = this.employee_name;
        data["status"] = this.status;
        data["staff_no"] = this.staff_no;
        data["effective_date"] = this.effective_date ? this.effective_date.toISOString() : <any>undefined;
        data["str_effective_date"] = this.str_effective_date;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): VwConfirmationDTO {
        const json = this.toJSON();
        let result = new VwConfirmationDTO();
        result.init(json);
        return result;
    }
}

export interface IVwConfirmationDTO {
    id: number;
    company_id: number;
    subsidiary_id: number;
    employee_id: number;
    mgr_feedback: string | undefined;
    mgr_advice: string | undefined;
    appointment_date: Date | undefined;
    probation_period: string | undefined;
    log_status: number;
    request_by: string | undefined;
    request_date: Date | undefined;
    employee_contractId: number;
    employee_name: string | undefined;
    status: string | undefined;
    staff_no: string | undefined;
    effective_date: Date | undefined;
    str_effective_date: string | undefined;
    confirmationDate: Date | undefined;
}

export class VwConfirmationDTOIListApiResult implements IVwConfirmationDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwConfirmationDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IVwConfirmationDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(VwConfirmationDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VwConfirmationDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwConfirmationDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VwConfirmationDTOIListApiResult {
        const json = this.toJSON();
        let result = new VwConfirmationDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwConfirmationDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwConfirmationDTO[] | undefined;
    totalCount: number;
}

export class DropdownValue implements IDropdownValue {
    dropdown_id!: number;
    option_text!: string;
    option_value!: number;
    is_deleted!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDropdownValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dropdown_id = _data["dropdown_id"];
            this.option_text = _data["option_text"];
            this.option_value = _data["option_value"];
            this.is_deleted = _data["is_deleted"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): DropdownValue {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dropdown_id"] = this.dropdown_id;
        data["option_text"] = this.option_text;
        data["option_value"] = this.option_value;
        data["is_deleted"] = this.is_deleted;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): DropdownValue {
        const json = this.toJSON();
        let result = new DropdownValue();
        result.init(json);
        return result;
    }
}

export interface IDropdownValue {
    dropdown_id: number;
    option_text: string;
    option_value: number;
    is_deleted: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class DropdownValueIListApiResult implements IDropdownValueIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DropdownValue[] | undefined;
    totalCount!: number;

    constructor(data?: IDropdownValueIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DropdownValue.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DropdownValueIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValueIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DropdownValueIListApiResult {
        const json = this.toJSON();
        let result = new DropdownValueIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDropdownValueIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DropdownValue[] | undefined;
    totalCount: number;
}

export class IDTextViewModel implements IIDTextViewModel {
    id!: number;
    text!: string | undefined;

    constructor(data?: IIDTextViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): IDTextViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new IDTextViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        return data; 
    }

    clone(): IDTextViewModel {
        const json = this.toJSON();
        let result = new IDTextViewModel();
        result.init(json);
        return result;
    }
}

export interface IIDTextViewModel {
    id: number;
    text: string | undefined;
}

export class IDTextViewModelIListApiResult implements IIDTextViewModelIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: IDTextViewModel[] | undefined;
    totalCount!: number;

    constructor(data?: IIDTextViewModelIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(IDTextViewModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): IDTextViewModelIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new IDTextViewModelIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): IDTextViewModelIListApiResult {
        const json = this.toJSON();
        let result = new IDTextViewModelIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IIDTextViewModelIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: IDTextViewModel[] | undefined;
    totalCount: number;
}

export class Country implements ICountry {
    name!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export interface ICountry {
    name: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class CountryIListApiResult implements ICountryIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Country[] | undefined;
    totalCount!: number;

    constructor(data?: ICountryIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Country.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CountryIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CountryIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CountryIListApiResult {
        const json = this.toJSON();
        let result = new CountryIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICountryIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Country[] | undefined;
    totalCount: number;
}

export class State implements IState {
    country_id!: number;
    state_name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.country_id = _data["country_id"];
            this.state_name = _data["state_name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): State {
        data = typeof data === 'object' ? data : {};
        let result = new State();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country_id"] = this.country_id;
        data["state_name"] = this.state_name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): State {
        const json = this.toJSON();
        let result = new State();
        result.init(json);
        return result;
    }
}

export interface IState {
    country_id: number;
    state_name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class StateIListApiResult implements IStateIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: State[] | undefined;
    totalCount!: number;

    constructor(data?: IStateIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(State.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StateIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new StateIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): StateIListApiResult {
        const json = this.toJSON();
        let result = new StateIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IStateIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: State[] | undefined;
    totalCount: number;
}

export class LGA implements ILGA {
    state_id!: number | undefined;
    lga_name!: string | undefined;
    directorate_id!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILGA) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state_id = _data["state_id"];
            this.lga_name = _data["lga_name"];
            this.directorate_id = _data["directorate_id"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LGA {
        data = typeof data === 'object' ? data : {};
        let result = new LGA();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state_id"] = this.state_id;
        data["lga_name"] = this.lga_name;
        data["directorate_id"] = this.directorate_id;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LGA {
        const json = this.toJSON();
        let result = new LGA();
        result.init(json);
        return result;
    }
}

export interface ILGA {
    state_id: number | undefined;
    lga_name: string | undefined;
    directorate_id: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LGAIListApiResult implements ILGAIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LGA[] | undefined;
    totalCount!: number;

    constructor(data?: ILGAIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LGA.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LGAIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LGAIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LGAIListApiResult {
        const json = this.toJSON();
        let result = new LGAIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILGAIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LGA[] | undefined;
    totalCount: number;
}

export class ManageDepartmentDTO implements IManageDepartmentDTO {
    id!: number;
    name!: string;
    code!: string;

    constructor(data?: IManageDepartmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ManageDepartmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageDepartmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }

    clone(): ManageDepartmentDTO {
        const json = this.toJSON();
        let result = new ManageDepartmentDTO();
        result.init(json);
        return result;
    }
}

export interface IManageDepartmentDTO {
    id: number;
    name: string;
    code: string;
}

export class DepartmentDTO implements IDepartmentDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    code!: string | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    headOfDepartment!: number;

    constructor(data?: IDepartmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.headOfDepartment = _data["headOfDepartment"];
        }
    }

    static fromJS(data: any): DepartmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["headOfDepartment"] = this.headOfDepartment;
        return data; 
    }

    clone(): DepartmentDTO {
        const json = this.toJSON();
        let result = new DepartmentDTO();
        result.init(json);
        return result;
    }
}

export interface IDepartmentDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    code: string | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    headOfDepartment: number;
}

export class DepartmentDTOListApiResult implements IDepartmentDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DepartmentDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IDepartmentDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DepartmentDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DepartmentDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DepartmentDTOListApiResult {
        const json = this.toJSON();
        let result = new DepartmentDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDepartmentDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DepartmentDTO[] | undefined;
    totalCount: number;
}

export class DepartmentDTOApiResult implements IDepartmentDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DepartmentDTO;
    totalCount!: number;

    constructor(data?: IDepartmentDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? DepartmentDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DepartmentDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DepartmentDTOApiResult {
        const json = this.toJSON();
        let result = new DepartmentDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IDepartmentDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DepartmentDTO;
    totalCount: number;
}

export class DeploymentLogIListApiResult implements IDeploymentLogIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DeploymentLog[] | undefined;
    totalCount!: number;

    constructor(data?: IDeploymentLogIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DeploymentLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DeploymentLogIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DeploymentLogIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DeploymentLogIListApiResult {
        const json = this.toJSON();
        let result = new DeploymentLogIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDeploymentLogIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DeploymentLog[] | undefined;
    totalCount: number;
}

export class SearchDeploymentDto implements ISearchDeploymentDto {
    companyID!: number;
    subID!: number;
    employeeContractid!: number;
    name!: string | undefined;
    id!: number;
    strStartDate!: string | undefined;
    strEndDate!: string | undefined;
    referenceId!: string | undefined;
    code!: string | undefined;
    pageNumber!: number;
    pageSize!: number;

    constructor(data?: ISearchDeploymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.employeeContractid = _data["employeeContractid"];
            this.name = _data["name"];
            this.id = _data["id"];
            this.strStartDate = _data["strStartDate"];
            this.strEndDate = _data["strEndDate"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): SearchDeploymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchDeploymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["employeeContractid"] = this.employeeContractid;
        data["name"] = this.name;
        data["id"] = this.id;
        data["strStartDate"] = this.strStartDate;
        data["strEndDate"] = this.strEndDate;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data; 
    }

    clone(): SearchDeploymentDto {
        const json = this.toJSON();
        let result = new SearchDeploymentDto();
        result.init(json);
        return result;
    }
}

export interface ISearchDeploymentDto {
    companyID: number;
    subID: number;
    employeeContractid: number;
    name: string | undefined;
    id: number;
    strStartDate: string | undefined;
    strEndDate: string | undefined;
    referenceId: string | undefined;
    code: string | undefined;
    pageNumber: number;
    pageSize: number;
}

export class IdNameObj implements IIdNameObj {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: IIdNameObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameObj {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }

    clone(): IdNameObj {
        const json = this.toJSON();
        let result = new IdNameObj();
        result.init(json);
        return result;
    }
}

export interface IIdNameObj {
    id: number;
    code: string | undefined;
    name: string | undefined;
}

export class CreateDeploymentViewModel implements ICreateDeploymentViewModel {
    lstLocations!: Location[] | undefined;
    ministries!: IdNameObj[] | undefined;

    constructor(data?: ICreateDeploymentViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lstLocations"])) {
                this.lstLocations = [] as any;
                for (let item of _data["lstLocations"])
                    this.lstLocations!.push(Location.fromJS(item));
            }
            if (Array.isArray(_data["ministries"])) {
                this.ministries = [] as any;
                for (let item of _data["ministries"])
                    this.ministries!.push(IdNameObj.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateDeploymentViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeploymentViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lstLocations)) {
            data["lstLocations"] = [];
            for (let item of this.lstLocations)
                data["lstLocations"].push(item.toJSON());
        }
        if (Array.isArray(this.ministries)) {
            data["ministries"] = [];
            for (let item of this.ministries)
                data["ministries"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateDeploymentViewModel {
        const json = this.toJSON();
        let result = new CreateDeploymentViewModel();
        result.init(json);
        return result;
    }
}

export interface ICreateDeploymentViewModel {
    lstLocations: Location[] | undefined;
    ministries: IdNameObj[] | undefined;
}

export class CreateDeploymentViewModelIListApiResult implements ICreateDeploymentViewModelIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CreateDeploymentViewModel[] | undefined;
    totalCount!: number;

    constructor(data?: ICreateDeploymentViewModelIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CreateDeploymentViewModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CreateDeploymentViewModelIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeploymentViewModelIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CreateDeploymentViewModelIListApiResult {
        const json = this.toJSON();
        let result = new CreateDeploymentViewModelIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICreateDeploymentViewModelIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CreateDeploymentViewModel[] | undefined;
    totalCount: number;
}

export class EmailLog implements IEmailLog {
    sender!: string | undefined;
    receiver!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    messageBody!: string | undefined;
    hasAttachment!: boolean;
    isSent!: boolean;
    retires!: number;
    dateSent!: Date | undefined;
    dateToSend!: Date | undefined;
    emailAttachments!: EmailLogAttachment[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmailLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sender = _data["sender"];
            this.receiver = _data["receiver"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.messageBody = _data["messageBody"];
            this.hasAttachment = _data["hasAttachment"];
            this.isSent = _data["isSent"];
            this.retires = _data["retires"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.dateToSend = _data["dateToSend"] ? new Date(_data["dateToSend"].toString()) : <any>undefined;
            if (Array.isArray(_data["emailAttachments"])) {
                this.emailAttachments = [] as any;
                for (let item of _data["emailAttachments"])
                    this.emailAttachments!.push(EmailLogAttachment.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmailLog {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sender"] = this.sender;
        data["receiver"] = this.receiver;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["messageBody"] = this.messageBody;
        data["hasAttachment"] = this.hasAttachment;
        data["isSent"] = this.isSent;
        data["retires"] = this.retires;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["dateToSend"] = this.dateToSend ? this.dateToSend.toISOString() : <any>undefined;
        if (Array.isArray(this.emailAttachments)) {
            data["emailAttachments"] = [];
            for (let item of this.emailAttachments)
                data["emailAttachments"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmailLog {
        const json = this.toJSON();
        let result = new EmailLog();
        result.init(json);
        return result;
    }
}

export interface IEmailLog {
    sender: string | undefined;
    receiver: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    messageBody: string | undefined;
    hasAttachment: boolean;
    isSent: boolean;
    retires: number;
    dateSent: Date | undefined;
    dateToSend: Date | undefined;
    emailAttachments: EmailLogAttachment[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmailLogAttachment implements IEmailLogAttachment {
    id!: number;
    emailLogID!: number;
    emailLog!: EmailLog;
    folderOnServer!: string | undefined;
    fileNameOnServer!: string | undefined;
    emailFileName!: string | undefined;
    dateCreated!: Date;

    constructor(data?: IEmailLogAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailLogID = _data["emailLogID"];
            this.emailLog = _data["emailLog"] ? EmailLog.fromJS(_data["emailLog"]) : <any>undefined;
            this.folderOnServer = _data["folderOnServer"];
            this.fileNameOnServer = _data["fileNameOnServer"];
            this.emailFileName = _data["emailFileName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmailLogAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailLogID"] = this.emailLogID;
        data["emailLog"] = this.emailLog ? this.emailLog.toJSON() : <any>undefined;
        data["folderOnServer"] = this.folderOnServer;
        data["fileNameOnServer"] = this.fileNameOnServer;
        data["emailFileName"] = this.emailFileName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        return data; 
    }

    clone(): EmailLogAttachment {
        const json = this.toJSON();
        let result = new EmailLogAttachment();
        result.init(json);
        return result;
    }
}

export interface IEmailLogAttachment {
    id: number;
    emailLogID: number;
    emailLog: EmailLog;
    folderOnServer: string | undefined;
    fileNameOnServer: string | undefined;
    emailFileName: string | undefined;
    dateCreated: Date;
}

export class EmailLogDTO implements IEmailLogDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    sender!: string | undefined;
    receiver!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    messageBody!: string | undefined;
    hasAttachment!: boolean;
    isSent!: boolean;
    retires!: number;
    dateSent!: Date | undefined;
    dateToSend!: Date | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    emailAttachments!: EmailLogAttachment[] | undefined;

    constructor(data?: IEmailLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.sender = _data["sender"];
            this.receiver = _data["receiver"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.messageBody = _data["messageBody"];
            this.hasAttachment = _data["hasAttachment"];
            this.isSent = _data["isSent"];
            this.retires = _data["retires"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.dateToSend = _data["dateToSend"] ? new Date(_data["dateToSend"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            if (Array.isArray(_data["emailAttachments"])) {
                this.emailAttachments = [] as any;
                for (let item of _data["emailAttachments"])
                    this.emailAttachments!.push(EmailLogAttachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["sender"] = this.sender;
        data["receiver"] = this.receiver;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["messageBody"] = this.messageBody;
        data["hasAttachment"] = this.hasAttachment;
        data["isSent"] = this.isSent;
        data["retires"] = this.retires;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["dateToSend"] = this.dateToSend ? this.dateToSend.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        if (Array.isArray(this.emailAttachments)) {
            data["emailAttachments"] = [];
            for (let item of this.emailAttachments)
                data["emailAttachments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EmailLogDTO {
        const json = this.toJSON();
        let result = new EmailLogDTO();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTO {
    id: number;
    companyID: number;
    subID: number;
    sender: string | undefined;
    receiver: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    messageBody: string | undefined;
    hasAttachment: boolean;
    isSent: boolean;
    retires: number;
    dateSent: Date | undefined;
    dateToSend: Date | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    emailAttachments: EmailLogAttachment[] | undefined;
}

export class EmailLogDTOIListApiResult implements IEmailLogDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailLogDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IEmailLogDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmailLogDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmailLogDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmailLogDTOIListApiResult {
        const json = this.toJSON();
        let result = new EmailLogDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailLogDTO[] | undefined;
    totalCount: number;
}

export class EmailLogDTOApiResult implements IEmailLogDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailLogDTO;
    totalCount!: number;

    constructor(data?: IEmailLogDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmailLogDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmailLogDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailLogDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmailLogDTOApiResult {
        const json = this.toJSON();
        let result = new EmailLogDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailLogDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailLogDTO;
    totalCount: number;
}

export class EmailTemplateDTO implements IEmailTemplateDTO {
    id!: number;
    name!: string | undefined;
    subject!: string;
    text!: string;
    emailTemplateCol!: IDTextViewModel[] | undefined;

    constructor(data?: IEmailTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.subject = _data["subject"];
            this.text = _data["text"];
            if (Array.isArray(_data["emailTemplateCol"])) {
                this.emailTemplateCol = [] as any;
                for (let item of _data["emailTemplateCol"])
                    this.emailTemplateCol!.push(IDTextViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["subject"] = this.subject;
        data["text"] = this.text;
        if (Array.isArray(this.emailTemplateCol)) {
            data["emailTemplateCol"] = [];
            for (let item of this.emailTemplateCol)
                data["emailTemplateCol"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EmailTemplateDTO {
        const json = this.toJSON();
        let result = new EmailTemplateDTO();
        result.init(json);
        return result;
    }
}

export interface IEmailTemplateDTO {
    id: number;
    name: string | undefined;
    subject: string;
    text: string;
    emailTemplateCol: IDTextViewModel[] | undefined;
}

export class EmailTemplateDTOApiResult implements IEmailTemplateDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmailTemplateDTO;
    totalCount!: number;

    constructor(data?: IEmailTemplateDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmailTemplateDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmailTemplateDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTemplateDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmailTemplateDTOApiResult {
        const json = this.toJSON();
        let result = new EmailTemplateDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmailTemplateDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmailTemplateDTO;
    totalCount: number;
}

export class EmployeeDTO implements IEmployeeDTO {
    id!: number;
    employeeContractId!: number;
    companyId!: number;
    subID!: number;
    userId!: number;
    userEmail!: string | undefined;
    titleId!: number;
    religionId!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    serialNo!: string | undefined;
    firstName!: string;
    lastName!: string;
    otherNames!: string | undefined;
    employeeNumber!: string;
    assignmentNumber!: string | undefined;
    dateOfBirth!: Date | undefined;
    maritalStatusId!: number;
    genderId!: number;
    lasraaNumber!: string | undefined;
    regNo!: string | undefined;
    estabFileNo!: string | undefined;
    personalEmail!: string | undefined;
    workEmail!: string;
    fullName!: string | undefined;
    peopleGroupId!: number | undefined;
    niNumber!: string | undefined;
    profilePic!: string | undefined;
    workMobile!: string | undefined;
    defaultMobile!: string;
    dialingCode!: string | undefined;
    subjectSpecialization!: string | undefined;
    selfServiceStatus!: string | undefined;
    employmentStatusId!: number;
    employmentStatus!: number;
    yearsOfService!: number;
    age!: number;
    department!: string | undefined;
    jobRole!: string | undefined;
    location!: string | undefined;
    pensionerFileNo!: string | undefined;
    pfaId!: number | undefined;
    rsaNumber!: string | undefined;
    stateOfOrigion!: string | undefined;
    lgaOfOrigion!: string | undefined;
    internalAddressLine!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    originCountry!: number | undefined;
    originState!: number | undefined;
    residentialCountry!: number | undefined;
    residentialState!: number | undefined;
    residentialLga!: number | undefined;
    residentialAddress!: string | undefined;
    created_by!: string | undefined;
    bvn!: string | undefined;
    bvnStatus!: number;
    bvnValidationResponse!: string | undefined;
    lastBVNValidation!: Date | undefined;
    deviceId!: number | undefined;

    constructor(data?: IEmployeeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeContractId = _data["employeeContractId"];
            this.companyId = _data["companyId"];
            this.subID = _data["subID"];
            this.userId = _data["userId"];
            this.userEmail = _data["userEmail"];
            this.titleId = _data["titleId"];
            this.religionId = _data["religionId"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.serialNo = _data["serialNo"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherNames = _data["otherNames"];
            this.employeeNumber = _data["employeeNumber"];
            this.assignmentNumber = _data["assignmentNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.maritalStatusId = _data["maritalStatusId"];
            this.genderId = _data["genderId"];
            this.lasraaNumber = _data["lasraaNumber"];
            this.regNo = _data["regNo"];
            this.estabFileNo = _data["estabFileNo"];
            this.personalEmail = _data["personalEmail"];
            this.workEmail = _data["workEmail"];
            this.fullName = _data["fullName"];
            this.peopleGroupId = _data["peopleGroupId"];
            this.niNumber = _data["niNumber"];
            this.profilePic = _data["profilePic"];
            this.workMobile = _data["workMobile"];
            this.defaultMobile = _data["defaultMobile"];
            this.dialingCode = _data["dialingCode"];
            this.subjectSpecialization = _data["subjectSpecialization"];
            this.selfServiceStatus = _data["selfServiceStatus"];
            this.employmentStatusId = _data["employmentStatusId"];
            this.employmentStatus = _data["employmentStatus"];
            this.yearsOfService = _data["yearsOfService"];
            this.age = _data["age"];
            this.department = _data["department"];
            this.jobRole = _data["jobRole"];
            this.location = _data["location"];
            this.pensionerFileNo = _data["pensionerFileNo"];
            this.pfaId = _data["pfaId"];
            this.rsaNumber = _data["rsaNumber"];
            this.stateOfOrigion = _data["stateOfOrigion"];
            this.lgaOfOrigion = _data["lgaOfOrigion"];
            this.internalAddressLine = _data["internalAddressLine"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.originCountry = _data["originCountry"];
            this.originState = _data["originState"];
            this.residentialCountry = _data["residentialCountry"];
            this.residentialState = _data["residentialState"];
            this.residentialLga = _data["residentialLga"];
            this.residentialAddress = _data["residentialAddress"];
            this.created_by = _data["created_by"];
            this.bvn = _data["bvn"];
            this.bvnStatus = _data["bvnStatus"];
            this.bvnValidationResponse = _data["bvnValidationResponse"];
            this.lastBVNValidation = _data["lastBVNValidation"] ? new Date(_data["lastBVNValidation"].toString()) : <any>undefined;
            this.deviceId = _data["deviceId"];
        }
    }

    static fromJS(data: any): EmployeeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeContractId"] = this.employeeContractId;
        data["companyId"] = this.companyId;
        data["subID"] = this.subID;
        data["userId"] = this.userId;
        data["userEmail"] = this.userEmail;
        data["titleId"] = this.titleId;
        data["religionId"] = this.religionId;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["serialNo"] = this.serialNo;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherNames"] = this.otherNames;
        data["employeeNumber"] = this.employeeNumber;
        data["assignmentNumber"] = this.assignmentNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["maritalStatusId"] = this.maritalStatusId;
        data["genderId"] = this.genderId;
        data["lasraaNumber"] = this.lasraaNumber;
        data["regNo"] = this.regNo;
        data["estabFileNo"] = this.estabFileNo;
        data["personalEmail"] = this.personalEmail;
        data["workEmail"] = this.workEmail;
        data["fullName"] = this.fullName;
        data["peopleGroupId"] = this.peopleGroupId;
        data["niNumber"] = this.niNumber;
        data["profilePic"] = this.profilePic;
        data["workMobile"] = this.workMobile;
        data["defaultMobile"] = this.defaultMobile;
        data["dialingCode"] = this.dialingCode;
        data["subjectSpecialization"] = this.subjectSpecialization;
        data["selfServiceStatus"] = this.selfServiceStatus;
        data["employmentStatusId"] = this.employmentStatusId;
        data["employmentStatus"] = this.employmentStatus;
        data["yearsOfService"] = this.yearsOfService;
        data["age"] = this.age;
        data["department"] = this.department;
        data["jobRole"] = this.jobRole;
        data["location"] = this.location;
        data["pensionerFileNo"] = this.pensionerFileNo;
        data["pfaId"] = this.pfaId;
        data["rsaNumber"] = this.rsaNumber;
        data["stateOfOrigion"] = this.stateOfOrigion;
        data["lgaOfOrigion"] = this.lgaOfOrigion;
        data["internalAddressLine"] = this.internalAddressLine;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["originCountry"] = this.originCountry;
        data["originState"] = this.originState;
        data["residentialCountry"] = this.residentialCountry;
        data["residentialState"] = this.residentialState;
        data["residentialLga"] = this.residentialLga;
        data["residentialAddress"] = this.residentialAddress;
        data["created_by"] = this.created_by;
        data["bvn"] = this.bvn;
        data["bvnStatus"] = this.bvnStatus;
        data["bvnValidationResponse"] = this.bvnValidationResponse;
        data["lastBVNValidation"] = this.lastBVNValidation ? this.lastBVNValidation.toISOString() : <any>undefined;
        data["deviceId"] = this.deviceId;
        return data; 
    }

    clone(): EmployeeDTO {
        const json = this.toJSON();
        let result = new EmployeeDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDTO {
    id: number;
    employeeContractId: number;
    companyId: number;
    subID: number;
    userId: number;
    userEmail: string | undefined;
    titleId: number;
    religionId: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    serialNo: string | undefined;
    firstName: string;
    lastName: string;
    otherNames: string | undefined;
    employeeNumber: string;
    assignmentNumber: string | undefined;
    dateOfBirth: Date | undefined;
    maritalStatusId: number;
    genderId: number;
    lasraaNumber: string | undefined;
    regNo: string | undefined;
    estabFileNo: string | undefined;
    personalEmail: string | undefined;
    workEmail: string;
    fullName: string | undefined;
    peopleGroupId: number | undefined;
    niNumber: string | undefined;
    profilePic: string | undefined;
    workMobile: string | undefined;
    defaultMobile: string;
    dialingCode: string | undefined;
    subjectSpecialization: string | undefined;
    selfServiceStatus: string | undefined;
    employmentStatusId: number;
    employmentStatus: number;
    yearsOfService: number;
    age: number;
    department: string | undefined;
    jobRole: string | undefined;
    location: string | undefined;
    pensionerFileNo: string | undefined;
    pfaId: number | undefined;
    rsaNumber: string | undefined;
    stateOfOrigion: string | undefined;
    lgaOfOrigion: string | undefined;
    internalAddressLine: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    originCountry: number | undefined;
    originState: number | undefined;
    residentialCountry: number | undefined;
    residentialState: number | undefined;
    residentialLga: number | undefined;
    residentialAddress: string | undefined;
    created_by: string | undefined;
    bvn: string | undefined;
    bvnStatus: number;
    bvnValidationResponse: string | undefined;
    lastBVNValidation: Date | undefined;
    deviceId: number | undefined;
}

export class DropdownValueDTO implements IDropdownValueDTO {
    option_text!: string | undefined;
    option_value!: number;
    employee_number!: string | undefined;
    company_id!: number;
    subsidary_id!: number;

    constructor(data?: IDropdownValueDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.option_text = _data["option_text"];
            this.option_value = _data["option_value"];
            this.employee_number = _data["employee_number"];
            this.company_id = _data["company_id"];
            this.subsidary_id = _data["subsidary_id"];
        }
    }

    static fromJS(data: any): DropdownValueDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValueDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["option_text"] = this.option_text;
        data["option_value"] = this.option_value;
        data["employee_number"] = this.employee_number;
        data["company_id"] = this.company_id;
        data["subsidary_id"] = this.subsidary_id;
        return data; 
    }

    clone(): DropdownValueDTO {
        const json = this.toJSON();
        let result = new DropdownValueDTO();
        result.init(json);
        return result;
    }
}

export interface IDropdownValueDTO {
    option_text: string | undefined;
    option_value: number;
    employee_number: string | undefined;
    company_id: number;
    subsidary_id: number;
}

export class DropdownValueDTOIListApiResult implements IDropdownValueDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: DropdownValueDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IDropdownValueDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DropdownValueDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DropdownValueDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownValueDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DropdownValueDTOIListApiResult {
        const json = this.toJSON();
        let result = new DropdownValueDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IDropdownValueDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: DropdownValueDTO[] | undefined;
    totalCount: number;
}

export class EmployeeDTOApiResult implements IEmployeeDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeDTO;
    totalCount!: number;

    constructor(data?: IEmployeeDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmployeeDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmployeeDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmployeeDTOApiResult {
        const json = this.toJSON();
        let result = new EmployeeDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeDTO;
    totalCount: number;
}

export class EmployeeDTOIListApiResult implements IEmployeeDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IEmployeeDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmployeeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmployeeDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmployeeDTOIListApiResult {
        const json = this.toJSON();
        let result = new EmployeeDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeDTO[] | undefined;
    totalCount: number;
}

export class EmployeeContractAssignmentDTO implements IEmployeeContractAssignmentDTO {
    sn!: number;
    id!: number;
    _id!: string | undefined;
    companyID!: number;
    subID!: number;
    supNumber!: string | undefined;
    assignmentNumber!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    otherName!: string | undefined;
    employeeId!: number;
    employmentTypeId!: number;
    contractEndDate!: Date | undefined;
    supervisorId!: number | undefined;
    supervisorName!: string | undefined;
    fullName!: string | undefined;
    departmentId!: number | undefined;
    departmentName!: string | undefined;
    jobId!: number;
    jobName!: string | undefined;
    gradeId!: number | undefined;
    gradeName!: string | undefined;
    gradeStepId!: number | undefined;
    stepNo!: string | undefined;
    locationId!: number;
    locationName!: string | undefined;
    locationCode!: string | undefined;
    positionId!: number | undefined;
    positionName!: string | undefined;
    ministryId!: number | undefined;
    ministryName!: string | undefined;
    salaryScaleId!: number | undefined;
    salaryScaleName!: string | undefined;
    dateofPresentAppointment!: Date;
    dateofPresentAppointmentStr!: string | undefined;
    dateOfAppointment!: Date;
    dateOfAppointmentStr!: string | undefined;
    dateOfLastDeployment!: Date | undefined;
    dateOfLastDeploymentStr!: string | undefined;
    dateOfConversion!: Date | undefined;
    dateOfConversionStr!: string | undefined;
    dateOfConfirmation!: Date | undefined;
    dateOfConfirmationStr!: string | undefined;
    dateDeployed!: Date | undefined;
    dateDeployedStr!: string | undefined;
    contractEndDateStr!: string | undefined;
    datePromotion!: Date | undefined;
    datePromotionStr!: string | undefined;
    dateOfRetirement!: Date | undefined;
    dateOfRetirementStr!: string | undefined;
    totalEarnings!: number | undefined;
    totalDeductions!: number | undefined;
    netPayment!: number | undefined;
    isContractActive!: boolean;
    isDefaultContract!: boolean;
    noOfLeaveDays!: number | undefined;
    peopleGroupId!: number | undefined;
    lastPromotionDate!: Date | undefined;
    url!: string | undefined;
    payRollTypeId!: number;
    cadreId!: number;
    directorate_id!: number;
    lcda_id!: number;
    lga_id!: number;

    constructor(data?: IEmployeeContractAssignmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sn = _data["sn"];
            this.id = _data["id"];
            this._id = _data["_id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.supNumber = _data["supNumber"];
            this.assignmentNumber = _data["assignmentNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherName = _data["otherName"];
            this.employeeId = _data["employeeId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.contractEndDate = _data["contractEndDate"] ? new Date(_data["contractEndDate"].toString()) : <any>undefined;
            this.supervisorId = _data["supervisorId"];
            this.supervisorName = _data["supervisorName"];
            this.fullName = _data["fullName"];
            this.departmentId = _data["departmentId"];
            this.departmentName = _data["departmentName"];
            this.jobId = _data["jobId"];
            this.jobName = _data["jobName"];
            this.gradeId = _data["gradeId"];
            this.gradeName = _data["gradeName"];
            this.gradeStepId = _data["gradeStepId"];
            this.stepNo = _data["stepNo"];
            this.locationId = _data["locationId"];
            this.locationName = _data["locationName"];
            this.locationCode = _data["locationCode"];
            this.positionId = _data["positionId"];
            this.positionName = _data["positionName"];
            this.ministryId = _data["ministryId"];
            this.ministryName = _data["ministryName"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.salaryScaleName = _data["salaryScaleName"];
            this.dateofPresentAppointment = _data["dateofPresentAppointment"] ? new Date(_data["dateofPresentAppointment"].toString()) : <any>undefined;
            this.dateofPresentAppointmentStr = _data["dateofPresentAppointmentStr"];
            this.dateOfAppointment = _data["dateOfAppointment"] ? new Date(_data["dateOfAppointment"].toString()) : <any>undefined;
            this.dateOfAppointmentStr = _data["dateOfAppointmentStr"];
            this.dateOfLastDeployment = _data["dateOfLastDeployment"] ? new Date(_data["dateOfLastDeployment"].toString()) : <any>undefined;
            this.dateOfLastDeploymentStr = _data["dateOfLastDeploymentStr"];
            this.dateOfConversion = _data["dateOfConversion"] ? new Date(_data["dateOfConversion"].toString()) : <any>undefined;
            this.dateOfConversionStr = _data["dateOfConversionStr"];
            this.dateOfConfirmation = _data["dateOfConfirmation"] ? new Date(_data["dateOfConfirmation"].toString()) : <any>undefined;
            this.dateOfConfirmationStr = _data["dateOfConfirmationStr"];
            this.dateDeployed = _data["dateDeployed"] ? new Date(_data["dateDeployed"].toString()) : <any>undefined;
            this.dateDeployedStr = _data["dateDeployedStr"];
            this.contractEndDateStr = _data["contractEndDateStr"];
            this.datePromotion = _data["datePromotion"] ? new Date(_data["datePromotion"].toString()) : <any>undefined;
            this.datePromotionStr = _data["datePromotionStr"];
            this.dateOfRetirement = _data["dateOfRetirement"] ? new Date(_data["dateOfRetirement"].toString()) : <any>undefined;
            this.dateOfRetirementStr = _data["dateOfRetirementStr"];
            this.totalEarnings = _data["totalEarnings"];
            this.totalDeductions = _data["totalDeductions"];
            this.netPayment = _data["netPayment"];
            this.isContractActive = _data["isContractActive"];
            this.isDefaultContract = _data["isDefaultContract"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.peopleGroupId = _data["peopleGroupId"];
            this.lastPromotionDate = _data["lastPromotionDate"] ? new Date(_data["lastPromotionDate"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.payRollTypeId = _data["payRollTypeId"];
            this.cadreId = _data["cadreId"];
            this.directorate_id = _data["directorate_id"];
            this.lcda_id = _data["lcda_id"];
            this.lga_id = _data["lga_id"];
        }
    }

    static fromJS(data: any): EmployeeContractAssignmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeContractAssignmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sn"] = this.sn;
        data["id"] = this.id;
        data["_id"] = this._id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["supNumber"] = this.supNumber;
        data["assignmentNumber"] = this.assignmentNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherName"] = this.otherName;
        data["employeeId"] = this.employeeId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["contractEndDate"] = this.contractEndDate ? this.contractEndDate.toISOString() : <any>undefined;
        data["supervisorId"] = this.supervisorId;
        data["supervisorName"] = this.supervisorName;
        data["fullName"] = this.fullName;
        data["departmentId"] = this.departmentId;
        data["departmentName"] = this.departmentName;
        data["jobId"] = this.jobId;
        data["jobName"] = this.jobName;
        data["gradeId"] = this.gradeId;
        data["gradeName"] = this.gradeName;
        data["gradeStepId"] = this.gradeStepId;
        data["stepNo"] = this.stepNo;
        data["locationId"] = this.locationId;
        data["locationName"] = this.locationName;
        data["locationCode"] = this.locationCode;
        data["positionId"] = this.positionId;
        data["positionName"] = this.positionName;
        data["ministryId"] = this.ministryId;
        data["ministryName"] = this.ministryName;
        data["salaryScaleId"] = this.salaryScaleId;
        data["salaryScaleName"] = this.salaryScaleName;
        data["dateofPresentAppointment"] = this.dateofPresentAppointment ? this.dateofPresentAppointment.toISOString() : <any>undefined;
        data["dateofPresentAppointmentStr"] = this.dateofPresentAppointmentStr;
        data["dateOfAppointment"] = this.dateOfAppointment ? this.dateOfAppointment.toISOString() : <any>undefined;
        data["dateOfAppointmentStr"] = this.dateOfAppointmentStr;
        data["dateOfLastDeployment"] = this.dateOfLastDeployment ? this.dateOfLastDeployment.toISOString() : <any>undefined;
        data["dateOfLastDeploymentStr"] = this.dateOfLastDeploymentStr;
        data["dateOfConversion"] = this.dateOfConversion ? this.dateOfConversion.toISOString() : <any>undefined;
        data["dateOfConversionStr"] = this.dateOfConversionStr;
        data["dateOfConfirmation"] = this.dateOfConfirmation ? this.dateOfConfirmation.toISOString() : <any>undefined;
        data["dateOfConfirmationStr"] = this.dateOfConfirmationStr;
        data["dateDeployed"] = this.dateDeployed ? this.dateDeployed.toISOString() : <any>undefined;
        data["dateDeployedStr"] = this.dateDeployedStr;
        data["contractEndDateStr"] = this.contractEndDateStr;
        data["datePromotion"] = this.datePromotion ? this.datePromotion.toISOString() : <any>undefined;
        data["datePromotionStr"] = this.datePromotionStr;
        data["dateOfRetirement"] = this.dateOfRetirement ? this.dateOfRetirement.toISOString() : <any>undefined;
        data["dateOfRetirementStr"] = this.dateOfRetirementStr;
        data["totalEarnings"] = this.totalEarnings;
        data["totalDeductions"] = this.totalDeductions;
        data["netPayment"] = this.netPayment;
        data["isContractActive"] = this.isContractActive;
        data["isDefaultContract"] = this.isDefaultContract;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["peopleGroupId"] = this.peopleGroupId;
        data["lastPromotionDate"] = this.lastPromotionDate ? this.lastPromotionDate.toISOString() : <any>undefined;
        data["url"] = this.url;
        data["payRollTypeId"] = this.payRollTypeId;
        data["cadreId"] = this.cadreId;
        data["directorate_id"] = this.directorate_id;
        data["lcda_id"] = this.lcda_id;
        data["lga_id"] = this.lga_id;
        return data; 
    }

    clone(): EmployeeContractAssignmentDTO {
        const json = this.toJSON();
        let result = new EmployeeContractAssignmentDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeContractAssignmentDTO {
    sn: number;
    id: number;
    _id: string | undefined;
    companyID: number;
    subID: number;
    supNumber: string | undefined;
    assignmentNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    otherName: string | undefined;
    employeeId: number;
    employmentTypeId: number;
    contractEndDate: Date | undefined;
    supervisorId: number | undefined;
    supervisorName: string | undefined;
    fullName: string | undefined;
    departmentId: number | undefined;
    departmentName: string | undefined;
    jobId: number;
    jobName: string | undefined;
    gradeId: number | undefined;
    gradeName: string | undefined;
    gradeStepId: number | undefined;
    stepNo: string | undefined;
    locationId: number;
    locationName: string | undefined;
    locationCode: string | undefined;
    positionId: number | undefined;
    positionName: string | undefined;
    ministryId: number | undefined;
    ministryName: string | undefined;
    salaryScaleId: number | undefined;
    salaryScaleName: string | undefined;
    dateofPresentAppointment: Date;
    dateofPresentAppointmentStr: string | undefined;
    dateOfAppointment: Date;
    dateOfAppointmentStr: string | undefined;
    dateOfLastDeployment: Date | undefined;
    dateOfLastDeploymentStr: string | undefined;
    dateOfConversion: Date | undefined;
    dateOfConversionStr: string | undefined;
    dateOfConfirmation: Date | undefined;
    dateOfConfirmationStr: string | undefined;
    dateDeployed: Date | undefined;
    dateDeployedStr: string | undefined;
    contractEndDateStr: string | undefined;
    datePromotion: Date | undefined;
    datePromotionStr: string | undefined;
    dateOfRetirement: Date | undefined;
    dateOfRetirementStr: string | undefined;
    totalEarnings: number | undefined;
    totalDeductions: number | undefined;
    netPayment: number | undefined;
    isContractActive: boolean;
    isDefaultContract: boolean;
    noOfLeaveDays: number | undefined;
    peopleGroupId: number | undefined;
    lastPromotionDate: Date | undefined;
    url: string | undefined;
    payRollTypeId: number;
    cadreId: number;
    directorate_id: number;
    lcda_id: number;
    lga_id: number;
}

export class EmployeeContractAssignmentDTOApiResult implements IEmployeeContractAssignmentDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmployeeContractAssignmentDTO;
    totalCount!: number;

    constructor(data?: IEmployeeContractAssignmentDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmployeeContractAssignmentDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmployeeContractAssignmentDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeContractAssignmentDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmployeeContractAssignmentDTOApiResult {
        const json = this.toJSON();
        let result = new EmployeeContractAssignmentDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmployeeContractAssignmentDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmployeeContractAssignmentDTO;
    totalCount: number;
}

export class ExpenseGroupDto implements IExpenseGroupDto {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string | undefined;
    referenceId!: string | undefined;

    constructor(data?: IExpenseGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.referenceId = _data["referenceId"];
        }
    }

    static fromJS(data: any): ExpenseGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["referenceId"] = this.referenceId;
        return data; 
    }

    clone(): ExpenseGroupDto {
        const json = this.toJSON();
        let result = new ExpenseGroupDto();
        result.init(json);
        return result;
    }
}

export interface IExpenseGroupDto {
    id: number;
    companyID: number;
    subID: number;
    name: string | undefined;
    referenceId: string | undefined;
}

export class ExpenseGroup implements IExpenseGroup {
    name!: string | undefined;
    referenceId!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.referenceId = _data["referenceId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseGroup {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["referenceId"] = this.referenceId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseGroup {
        const json = this.toJSON();
        let result = new ExpenseGroup();
        result.init(json);
        return result;
    }
}

export interface IExpenseGroup {
    name: string | undefined;
    referenceId: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseGroupIListApiResult implements IExpenseGroupIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ExpenseGroup[] | undefined;
    totalCount!: number;

    constructor(data?: IExpenseGroupIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ExpenseGroup.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ExpenseGroupIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseGroupIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ExpenseGroupIListApiResult {
        const json = this.toJSON();
        let result = new ExpenseGroupIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IExpenseGroupIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ExpenseGroup[] | undefined;
    totalCount: number;
}

export class ExpenseProjectDto implements IExpenseProjectDto {
    id!: number;
    name!: string | undefined;
    companyID!: number;
    subID!: number;
    description!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    ban!: boolean;
    referenceId!: string | undefined;
    code!: string | undefined;
    isClosedEnded!: boolean;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    actionTitle!: string | undefined;
    readonly startDateString!: string | undefined;
    readonly endDateString!: string | undefined;
    status!: string | undefined;

    constructor(data?: IExpenseProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.ban = _data["ban"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isClosedEnded = _data["isClosedEnded"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.actionTitle = _data["actionTitle"];
            (<any>this).startDateString = _data["startDateString"];
            (<any>this).endDateString = _data["endDateString"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ExpenseProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ban"] = this.ban;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isClosedEnded"] = this.isClosedEnded;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["actionTitle"] = this.actionTitle;
        data["startDateString"] = this.startDateString;
        data["endDateString"] = this.endDateString;
        data["status"] = this.status;
        return data; 
    }

    clone(): ExpenseProjectDto {
        const json = this.toJSON();
        let result = new ExpenseProjectDto();
        result.init(json);
        return result;
    }
}

export interface IExpenseProjectDto {
    id: number;
    name: string | undefined;
    companyID: number;
    subID: number;
    description: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    ban: boolean;
    referenceId: string | undefined;
    code: string | undefined;
    isClosedEnded: boolean;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    actionTitle: string | undefined;
    startDateString: string | undefined;
    endDateString: string | undefined;
    status: string | undefined;
}

export class ExpenseDTO implements IExpenseDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;
    approvalProcessId!: number;
    title!: string | undefined;
    description!: string | undefined;
    expenseSubTypeId!: number | undefined;
    expenseSubTypeName!: string | undefined;
    expenseTypeId!: number;
    expenseTypeName!: string | undefined;
    loggedByUserId!: number;
    loggedByUsername!: string | undefined;
    loggedForEmployeeId!: number | undefined;
    loggedForEmployeeName!: string | undefined;
    loggedForEmployeeNo!: string | undefined;
    expenseProjectActivityId!: number | undefined;
    expenseProjectActivityName!: string | undefined;
    expenseProjectId!: number;
    expenseProjectName!: string | undefined;
    requestedAmount!: number;
    approvedAmount!: number;
    dateIncurred!: Date | undefined;
    dateReconciled!: Date | undefined;
    dateDisbursed!: Date | undefined;
    disburseComment!: string | undefined;
    dateApproved!: Date | undefined;
    reconciledStatus!: boolean;
    reconciledBy!: number | undefined;
    reconciledByName!: string | undefined;
    disbursedBy!: string | undefined;
    disbursedByName!: string | undefined;
    approvedBy!: number | undefined;
    approvedByName!: string | undefined;
    refNo!: string | undefined;
    departmentId!: number;
    declineReason!: string | undefined;
    disbursementType!: number | undefined;
    is_disbursed!: boolean;
    log_status!: number;
    expenseGroupId!: number;
    expenseGroupName!: string | undefined;
    strRequestedAmount!: string | undefined;
    strApprovedAmount!: string | undefined;
    strDateIncurred!: string | undefined;
    _ServerDocURL!: string | undefined;
    tempRef!: string | undefined;
    departmentName!: string | undefined;
    locatioName!: string | undefined;

    constructor(data?: IExpenseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.expenseSubTypeId = _data["expenseSubTypeId"];
            this.expenseSubTypeName = _data["expenseSubTypeName"];
            this.expenseTypeId = _data["expenseTypeId"];
            this.expenseTypeName = _data["expenseTypeName"];
            this.loggedByUserId = _data["loggedByUserId"];
            this.loggedByUsername = _data["loggedByUsername"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.loggedForEmployeeName = _data["loggedForEmployeeName"];
            this.loggedForEmployeeNo = _data["loggedForEmployeeNo"];
            this.expenseProjectActivityId = _data["expenseProjectActivityId"];
            this.expenseProjectActivityName = _data["expenseProjectActivityName"];
            this.expenseProjectId = _data["expenseProjectId"];
            this.expenseProjectName = _data["expenseProjectName"];
            this.requestedAmount = _data["requestedAmount"];
            this.approvedAmount = _data["approvedAmount"];
            this.dateIncurred = _data["dateIncurred"] ? new Date(_data["dateIncurred"].toString()) : <any>undefined;
            this.dateReconciled = _data["dateReconciled"] ? new Date(_data["dateReconciled"].toString()) : <any>undefined;
            this.dateDisbursed = _data["dateDisbursed"] ? new Date(_data["dateDisbursed"].toString()) : <any>undefined;
            this.disburseComment = _data["disburseComment"];
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.reconciledStatus = _data["reconciledStatus"];
            this.reconciledBy = _data["reconciledBy"];
            this.reconciledByName = _data["reconciledByName"];
            this.disbursedBy = _data["disbursedBy"];
            this.disbursedByName = _data["disbursedByName"];
            this.approvedBy = _data["approvedBy"];
            this.approvedByName = _data["approvedByName"];
            this.refNo = _data["refNo"];
            this.departmentId = _data["departmentId"];
            this.declineReason = _data["declineReason"];
            this.disbursementType = _data["disbursementType"];
            this.is_disbursed = _data["is_disbursed"];
            this.log_status = _data["log_status"];
            this.expenseGroupId = _data["expenseGroupId"];
            this.expenseGroupName = _data["expenseGroupName"];
            this.strRequestedAmount = _data["strRequestedAmount"];
            this.strApprovedAmount = _data["strApprovedAmount"];
            this.strDateIncurred = _data["strDateIncurred"];
            this._ServerDocURL = _data["_ServerDocURL"];
            this.tempRef = _data["tempRef"];
            this.departmentName = _data["departmentName"];
            this.locatioName = _data["locatioName"];
        }
    }

    static fromJS(data: any): ExpenseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["approvalProcessId"] = this.approvalProcessId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["expenseSubTypeId"] = this.expenseSubTypeId;
        data["expenseSubTypeName"] = this.expenseSubTypeName;
        data["expenseTypeId"] = this.expenseTypeId;
        data["expenseTypeName"] = this.expenseTypeName;
        data["loggedByUserId"] = this.loggedByUserId;
        data["loggedByUsername"] = this.loggedByUsername;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["loggedForEmployeeName"] = this.loggedForEmployeeName;
        data["loggedForEmployeeNo"] = this.loggedForEmployeeNo;
        data["expenseProjectActivityId"] = this.expenseProjectActivityId;
        data["expenseProjectActivityName"] = this.expenseProjectActivityName;
        data["expenseProjectId"] = this.expenseProjectId;
        data["expenseProjectName"] = this.expenseProjectName;
        data["requestedAmount"] = this.requestedAmount;
        data["approvedAmount"] = this.approvedAmount;
        data["dateIncurred"] = this.dateIncurred ? this.dateIncurred.toISOString() : <any>undefined;
        data["dateReconciled"] = this.dateReconciled ? this.dateReconciled.toISOString() : <any>undefined;
        data["dateDisbursed"] = this.dateDisbursed ? this.dateDisbursed.toISOString() : <any>undefined;
        data["disburseComment"] = this.disburseComment;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["reconciledStatus"] = this.reconciledStatus;
        data["reconciledBy"] = this.reconciledBy;
        data["reconciledByName"] = this.reconciledByName;
        data["disbursedBy"] = this.disbursedBy;
        data["disbursedByName"] = this.disbursedByName;
        data["approvedBy"] = this.approvedBy;
        data["approvedByName"] = this.approvedByName;
        data["refNo"] = this.refNo;
        data["departmentId"] = this.departmentId;
        data["declineReason"] = this.declineReason;
        data["disbursementType"] = this.disbursementType;
        data["is_disbursed"] = this.is_disbursed;
        data["log_status"] = this.log_status;
        data["expenseGroupId"] = this.expenseGroupId;
        data["expenseGroupName"] = this.expenseGroupName;
        data["strRequestedAmount"] = this.strRequestedAmount;
        data["strApprovedAmount"] = this.strApprovedAmount;
        data["strDateIncurred"] = this.strDateIncurred;
        data["_ServerDocURL"] = this._ServerDocURL;
        data["tempRef"] = this.tempRef;
        data["departmentName"] = this.departmentName;
        data["locatioName"] = this.locatioName;
        return data; 
    }

    clone(): ExpenseDTO {
        const json = this.toJSON();
        let result = new ExpenseDTO();
        result.init(json);
        return result;
    }
}

export interface IExpenseDTO {
    id: number;
    companyID: number;
    subID: number;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
    approvalProcessId: number;
    title: string | undefined;
    description: string | undefined;
    expenseSubTypeId: number | undefined;
    expenseSubTypeName: string | undefined;
    expenseTypeId: number;
    expenseTypeName: string | undefined;
    loggedByUserId: number;
    loggedByUsername: string | undefined;
    loggedForEmployeeId: number | undefined;
    loggedForEmployeeName: string | undefined;
    loggedForEmployeeNo: string | undefined;
    expenseProjectActivityId: number | undefined;
    expenseProjectActivityName: string | undefined;
    expenseProjectId: number;
    expenseProjectName: string | undefined;
    requestedAmount: number;
    approvedAmount: number;
    dateIncurred: Date | undefined;
    dateReconciled: Date | undefined;
    dateDisbursed: Date | undefined;
    disburseComment: string | undefined;
    dateApproved: Date | undefined;
    reconciledStatus: boolean;
    reconciledBy: number | undefined;
    reconciledByName: string | undefined;
    disbursedBy: string | undefined;
    disbursedByName: string | undefined;
    approvedBy: number | undefined;
    approvedByName: string | undefined;
    refNo: string | undefined;
    departmentId: number;
    declineReason: string | undefined;
    disbursementType: number | undefined;
    is_disbursed: boolean;
    log_status: number;
    expenseGroupId: number;
    expenseGroupName: string | undefined;
    strRequestedAmount: string | undefined;
    strApprovedAmount: string | undefined;
    strDateIncurred: string | undefined;
    _ServerDocURL: string | undefined;
    tempRef: string | undefined;
    departmentName: string | undefined;
    locatioName: string | undefined;
}

export class ExpenseDTOIListApiResult implements IExpenseDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ExpenseDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IExpenseDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ExpenseDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ExpenseDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ExpenseDTOIListApiResult {
        const json = this.toJSON();
        let result = new ExpenseDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IExpenseDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ExpenseDTO[] | undefined;
    totalCount: number;
}

export class ExpenseTypeDto implements IExpenseTypeDto {
    id!: number;
    companyID!: number;
    subID!: number;
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    referenceId!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IExpenseTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ExpenseTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ExpenseTypeDto {
        const json = this.toJSON();
        let result = new ExpenseTypeDto();
        result.init(json);
        return result;
    }
}

export interface IExpenseTypeDto {
    id: number;
    companyID: number;
    subID: number;
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    referenceId: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class ExpenseDoc implements IExpenseDoc {
    expenseId!: number;
    path!: string | undefined;
    docType!: number;
    expense!: Expense;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseDoc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expenseId = _data["expenseId"];
            this.path = _data["path"];
            this.docType = _data["docType"];
            this.expense = _data["expense"] ? Expense.fromJS(_data["expense"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseDoc {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseDoc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expenseId"] = this.expenseId;
        data["path"] = this.path;
        data["docType"] = this.docType;
        data["expense"] = this.expense ? this.expense.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseDoc {
        const json = this.toJSON();
        let result = new ExpenseDoc();
        result.init(json);
        return result;
    }
}

export interface IExpenseDoc {
    expenseId: number;
    path: string | undefined;
    docType: number;
    expense: Expense;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseSubType implements IExpenseSubType {
    expenseTypeId!: number;
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    referenceId!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    approvalProcessId!: number | undefined;
    budgetedAmount!: number | undefined;
    currentAmount!: number | undefined;
    strBudgetedAmount!: string | undefined;
    strCurrentAmount!: string | undefined;
    expenses!: Expense[] | undefined;
    expenseType!: ExpenseType;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseSubType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expenseTypeId = _data["expenseTypeId"];
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.budgetedAmount = _data["budgetedAmount"];
            this.currentAmount = _data["currentAmount"];
            this.strBudgetedAmount = _data["strBudgetedAmount"];
            this.strCurrentAmount = _data["strCurrentAmount"];
            if (Array.isArray(_data["expenses"])) {
                this.expenses = [] as any;
                for (let item of _data["expenses"])
                    this.expenses!.push(Expense.fromJS(item));
            }
            this.expenseType = _data["expenseType"] ? ExpenseType.fromJS(_data["expenseType"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseSubType {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseSubType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expenseTypeId"] = this.expenseTypeId;
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["approvalProcessId"] = this.approvalProcessId;
        data["budgetedAmount"] = this.budgetedAmount;
        data["currentAmount"] = this.currentAmount;
        data["strBudgetedAmount"] = this.strBudgetedAmount;
        data["strCurrentAmount"] = this.strCurrentAmount;
        if (Array.isArray(this.expenses)) {
            data["expenses"] = [];
            for (let item of this.expenses)
                data["expenses"].push(item.toJSON());
        }
        data["expenseType"] = this.expenseType ? this.expenseType.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseSubType {
        const json = this.toJSON();
        let result = new ExpenseSubType();
        result.init(json);
        return result;
    }
}

export interface IExpenseSubType {
    expenseTypeId: number;
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    referenceId: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    approvalProcessId: number | undefined;
    budgetedAmount: number | undefined;
    currentAmount: number | undefined;
    strBudgetedAmount: string | undefined;
    strCurrentAmount: string | undefined;
    expenses: Expense[] | undefined;
    expenseType: ExpenseType;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseProject implements IExpenseProject {
    name!: string | undefined;
    description!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    ban!: boolean;
    referenceId!: string | undefined;
    code!: string | undefined;
    isClosedEnded!: boolean;
    expenses!: Expense[] | undefined;
    expenseProjectActivities!: ExpenseProjectActivity[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.ban = _data["ban"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isClosedEnded = _data["isClosedEnded"];
            if (Array.isArray(_data["expenses"])) {
                this.expenses = [] as any;
                for (let item of _data["expenses"])
                    this.expenses!.push(Expense.fromJS(item));
            }
            if (Array.isArray(_data["expenseProjectActivities"])) {
                this.expenseProjectActivities = [] as any;
                for (let item of _data["expenseProjectActivities"])
                    this.expenseProjectActivities!.push(ExpenseProjectActivity.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseProject {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ban"] = this.ban;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isClosedEnded"] = this.isClosedEnded;
        if (Array.isArray(this.expenses)) {
            data["expenses"] = [];
            for (let item of this.expenses)
                data["expenses"].push(item.toJSON());
        }
        if (Array.isArray(this.expenseProjectActivities)) {
            data["expenseProjectActivities"] = [];
            for (let item of this.expenseProjectActivities)
                data["expenseProjectActivities"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseProject {
        const json = this.toJSON();
        let result = new ExpenseProject();
        result.init(json);
        return result;
    }
}

export interface IExpenseProject {
    name: string | undefined;
    description: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    ban: boolean;
    referenceId: string | undefined;
    code: string | undefined;
    isClosedEnded: boolean;
    expenses: Expense[] | undefined;
    expenseProjectActivities: ExpenseProjectActivity[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseProjectActivity implements IExpenseProjectActivity {
    expenseProjectId!: number;
    name!: string | undefined;
    description!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    closedEnded!: boolean | undefined;
    ban!: boolean;
    referenceId!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    expenses!: Expense[] | undefined;
    expenseProject!: ExpenseProject;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseProjectActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expenseProjectId = _data["expenseProjectId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.closedEnded = _data["closedEnded"];
            this.ban = _data["ban"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["expenses"])) {
                this.expenses = [] as any;
                for (let item of _data["expenses"])
                    this.expenses!.push(Expense.fromJS(item));
            }
            this.expenseProject = _data["expenseProject"] ? ExpenseProject.fromJS(_data["expenseProject"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseProjectActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseProjectActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expenseProjectId"] = this.expenseProjectId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["closedEnded"] = this.closedEnded;
        data["ban"] = this.ban;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.expenses)) {
            data["expenses"] = [];
            for (let item of this.expenses)
                data["expenses"].push(item.toJSON());
        }
        data["expenseProject"] = this.expenseProject ? this.expenseProject.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseProjectActivity {
        const json = this.toJSON();
        let result = new ExpenseProjectActivity();
        result.init(json);
        return result;
    }
}

export interface IExpenseProjectActivity {
    expenseProjectId: number;
    name: string | undefined;
    description: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    closedEnded: boolean | undefined;
    ban: boolean;
    referenceId: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    expenses: Expense[] | undefined;
    expenseProject: ExpenseProject;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Expense implements IExpense {
    refNo!: string | undefined;
    title!: string | undefined;
    description!: string | undefined;
    expenseSubTypeId!: number | undefined;
    expenseTypeId!: number;
    loggedByUserId!: number;
    loggedForEmployeeId!: number | undefined;
    expenseProjectActivityId!: number | undefined;
    expenseProjectId!: number;
    requestedAmount!: number;
    approvedAmount!: number;
    dateIncurred!: Date;
    dateReconciled!: Date | undefined;
    dateDisbursed!: Date | undefined;
    disburseComment!: string | undefined;
    dateApproved!: Date | undefined;
    reconciledStatus!: boolean;
    reconciledBy!: number | undefined;
    disbursedBy!: string | undefined;
    approvedBy!: number | undefined;
    departmentId!: number;
    declineReason!: string | undefined;
    disbursementType!: number | undefined;
    is_disbursed!: boolean;
    log_status!: number;
    approvalProcessId!: number;
    expenseGroupId!: number;
    expenseDocs!: ExpenseDoc[] | undefined;
    expenseType!: ExpenseType;
    expenseSubType!: ExpenseSubType;
    expenseProjectActivity!: ExpenseProjectActivity;
    expenseProject!: ExpenseProject;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpense) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refNo = _data["refNo"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.expenseSubTypeId = _data["expenseSubTypeId"];
            this.expenseTypeId = _data["expenseTypeId"];
            this.loggedByUserId = _data["loggedByUserId"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.expenseProjectActivityId = _data["expenseProjectActivityId"];
            this.expenseProjectId = _data["expenseProjectId"];
            this.requestedAmount = _data["requestedAmount"];
            this.approvedAmount = _data["approvedAmount"];
            this.dateIncurred = _data["dateIncurred"] ? new Date(_data["dateIncurred"].toString()) : <any>undefined;
            this.dateReconciled = _data["dateReconciled"] ? new Date(_data["dateReconciled"].toString()) : <any>undefined;
            this.dateDisbursed = _data["dateDisbursed"] ? new Date(_data["dateDisbursed"].toString()) : <any>undefined;
            this.disburseComment = _data["disburseComment"];
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.reconciledStatus = _data["reconciledStatus"];
            this.reconciledBy = _data["reconciledBy"];
            this.disbursedBy = _data["disbursedBy"];
            this.approvedBy = _data["approvedBy"];
            this.departmentId = _data["departmentId"];
            this.declineReason = _data["declineReason"];
            this.disbursementType = _data["disbursementType"];
            this.is_disbursed = _data["is_disbursed"];
            this.log_status = _data["log_status"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.expenseGroupId = _data["expenseGroupId"];
            if (Array.isArray(_data["expenseDocs"])) {
                this.expenseDocs = [] as any;
                for (let item of _data["expenseDocs"])
                    this.expenseDocs!.push(ExpenseDoc.fromJS(item));
            }
            this.expenseType = _data["expenseType"] ? ExpenseType.fromJS(_data["expenseType"]) : <any>undefined;
            this.expenseSubType = _data["expenseSubType"] ? ExpenseSubType.fromJS(_data["expenseSubType"]) : <any>undefined;
            this.expenseProjectActivity = _data["expenseProjectActivity"] ? ExpenseProjectActivity.fromJS(_data["expenseProjectActivity"]) : <any>undefined;
            this.expenseProject = _data["expenseProject"] ? ExpenseProject.fromJS(_data["expenseProject"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Expense {
        data = typeof data === 'object' ? data : {};
        let result = new Expense();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refNo"] = this.refNo;
        data["title"] = this.title;
        data["description"] = this.description;
        data["expenseSubTypeId"] = this.expenseSubTypeId;
        data["expenseTypeId"] = this.expenseTypeId;
        data["loggedByUserId"] = this.loggedByUserId;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["expenseProjectActivityId"] = this.expenseProjectActivityId;
        data["expenseProjectId"] = this.expenseProjectId;
        data["requestedAmount"] = this.requestedAmount;
        data["approvedAmount"] = this.approvedAmount;
        data["dateIncurred"] = this.dateIncurred ? this.dateIncurred.toISOString() : <any>undefined;
        data["dateReconciled"] = this.dateReconciled ? this.dateReconciled.toISOString() : <any>undefined;
        data["dateDisbursed"] = this.dateDisbursed ? this.dateDisbursed.toISOString() : <any>undefined;
        data["disburseComment"] = this.disburseComment;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["reconciledStatus"] = this.reconciledStatus;
        data["reconciledBy"] = this.reconciledBy;
        data["disbursedBy"] = this.disbursedBy;
        data["approvedBy"] = this.approvedBy;
        data["departmentId"] = this.departmentId;
        data["declineReason"] = this.declineReason;
        data["disbursementType"] = this.disbursementType;
        data["is_disbursed"] = this.is_disbursed;
        data["log_status"] = this.log_status;
        data["approvalProcessId"] = this.approvalProcessId;
        data["expenseGroupId"] = this.expenseGroupId;
        if (Array.isArray(this.expenseDocs)) {
            data["expenseDocs"] = [];
            for (let item of this.expenseDocs)
                data["expenseDocs"].push(item.toJSON());
        }
        data["expenseType"] = this.expenseType ? this.expenseType.toJSON() : <any>undefined;
        data["expenseSubType"] = this.expenseSubType ? this.expenseSubType.toJSON() : <any>undefined;
        data["expenseProjectActivity"] = this.expenseProjectActivity ? this.expenseProjectActivity.toJSON() : <any>undefined;
        data["expenseProject"] = this.expenseProject ? this.expenseProject.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Expense {
        const json = this.toJSON();
        let result = new Expense();
        result.init(json);
        return result;
    }
}

export interface IExpense {
    refNo: string | undefined;
    title: string | undefined;
    description: string | undefined;
    expenseSubTypeId: number | undefined;
    expenseTypeId: number;
    loggedByUserId: number;
    loggedForEmployeeId: number | undefined;
    expenseProjectActivityId: number | undefined;
    expenseProjectId: number;
    requestedAmount: number;
    approvedAmount: number;
    dateIncurred: Date;
    dateReconciled: Date | undefined;
    dateDisbursed: Date | undefined;
    disburseComment: string | undefined;
    dateApproved: Date | undefined;
    reconciledStatus: boolean;
    reconciledBy: number | undefined;
    disbursedBy: string | undefined;
    approvedBy: number | undefined;
    departmentId: number;
    declineReason: string | undefined;
    disbursementType: number | undefined;
    is_disbursed: boolean;
    log_status: number;
    approvalProcessId: number;
    expenseGroupId: number;
    expenseDocs: ExpenseDoc[] | undefined;
    expenseType: ExpenseType;
    expenseSubType: ExpenseSubType;
    expenseProjectActivity: ExpenseProjectActivity;
    expenseProject: ExpenseProject;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseType implements IExpenseType {
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    referenceId!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    expenses!: Expense[] | undefined;
    expenseSubTypes!: ExpenseSubType[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IExpenseType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.referenceId = _data["referenceId"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["expenses"])) {
                this.expenses = [] as any;
                for (let item of _data["expenses"])
                    this.expenses!.push(Expense.fromJS(item));
            }
            if (Array.isArray(_data["expenseSubTypes"])) {
                this.expenseSubTypes = [] as any;
                for (let item of _data["expenseSubTypes"])
                    this.expenseSubTypes!.push(ExpenseSubType.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): ExpenseType {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["referenceId"] = this.referenceId;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.expenses)) {
            data["expenses"] = [];
            for (let item of this.expenses)
                data["expenses"].push(item.toJSON());
        }
        if (Array.isArray(this.expenseSubTypes)) {
            data["expenseSubTypes"] = [];
            for (let item of this.expenseSubTypes)
                data["expenseSubTypes"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): ExpenseType {
        const json = this.toJSON();
        let result = new ExpenseType();
        result.init(json);
        return result;
    }
}

export interface IExpenseType {
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    referenceId: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    expenses: Expense[] | undefined;
    expenseSubTypes: ExpenseSubType[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ExpenseTypeIListApiResult implements IExpenseTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ExpenseType[] | undefined;
    totalCount!: number;

    constructor(data?: IExpenseTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ExpenseType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ExpenseTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ExpenseTypeIListApiResult {
        const json = this.toJSON();
        let result = new ExpenseTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IExpenseTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ExpenseType[] | undefined;
    totalCount: number;
}

export class KPISectionDTO implements IKPISectionDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    section_name!: string;
    isMarkObtainable!: boolean;
    maximum_score_obtainable!: number;
    description!: string | undefined;
    instructions!: string | undefined;
    is_notified_employees!: boolean;
    order!: number;
    kpi_rating_type_id!: number;
    weight!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IKPISectionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.section_name = _data["section_name"];
            this.isMarkObtainable = _data["isMarkObtainable"];
            this.maximum_score_obtainable = _data["maximum_score_obtainable"];
            this.description = _data["description"];
            this.instructions = _data["instructions"];
            this.is_notified_employees = _data["is_notified_employees"];
            this.order = _data["order"];
            this.kpi_rating_type_id = _data["kpi_rating_type_id"];
            this.weight = _data["weight"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): KPISectionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new KPISectionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["section_name"] = this.section_name;
        data["isMarkObtainable"] = this.isMarkObtainable;
        data["maximum_score_obtainable"] = this.maximum_score_obtainable;
        data["description"] = this.description;
        data["instructions"] = this.instructions;
        data["is_notified_employees"] = this.is_notified_employees;
        data["order"] = this.order;
        data["kpi_rating_type_id"] = this.kpi_rating_type_id;
        data["weight"] = this.weight;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): KPISectionDTO {
        const json = this.toJSON();
        let result = new KPISectionDTO();
        result.init(json);
        return result;
    }
}

export interface IKPISectionDTO {
    id: number;
    companyID: number;
    subID: number;
    section_name: string;
    isMarkObtainable: boolean;
    maximum_score_obtainable: number;
    description: string | undefined;
    instructions: string | undefined;
    is_notified_employees: boolean;
    order: number;
    kpi_rating_type_id: number;
    weight: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class KPISectionDTOIListApiResult implements IKPISectionDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: KPISectionDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IKPISectionDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(KPISectionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): KPISectionDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new KPISectionDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): KPISectionDTOIListApiResult {
        const json = this.toJSON();
        let result = new KPISectionDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IKPISectionDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: KPISectionDTO[] | undefined;
    totalCount: number;
}

export class KPISectionDTOApiResult implements IKPISectionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: KPISectionDTO;
    totalCount!: number;

    constructor(data?: IKPISectionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? KPISectionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): KPISectionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new KPISectionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): KPISectionDTOApiResult {
        const json = this.toJSON();
        let result = new KPISectionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IKPISectionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: KPISectionDTO;
    totalCount: number;
}

export class AssignKraDto implements IAssignKraDto {
    cycleId!: number;
    krAs!: string;
    reviewerId!: number;
    employeeContractIds!: string;

    constructor(data?: IAssignKraDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cycleId = _data["cycleId"];
            this.krAs = _data["krAs"];
            this.reviewerId = _data["reviewerId"];
            this.employeeContractIds = _data["employeeContractIds"];
        }
    }

    static fromJS(data: any): AssignKraDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssignKraDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cycleId"] = this.cycleId;
        data["krAs"] = this.krAs;
        data["reviewerId"] = this.reviewerId;
        data["employeeContractIds"] = this.employeeContractIds;
        return data; 
    }

    clone(): AssignKraDto {
        const json = this.toJSON();
        let result = new AssignKraDto();
        result.init(json);
        return result;
    }
}

export interface IAssignKraDto {
    cycleId: number;
    krAs: string;
    reviewerId: number;
    employeeContractIds: string;
}

export class ManageKpiDTO implements IManageKpiDTO {
    id!: number;
    title!: string;
    description!: string | undefined;
    kra_id!: number;
    score!: number;
    unit_of_measurement_id!: number;
    canComment!: boolean;

    constructor(data?: IManageKpiDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.kra_id = _data["kra_id"];
            this.score = _data["score"];
            this.unit_of_measurement_id = _data["unit_of_measurement_id"];
            this.canComment = _data["canComment"];
        }
    }

    static fromJS(data: any): ManageKpiDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageKpiDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["kra_id"] = this.kra_id;
        data["score"] = this.score;
        data["unit_of_measurement_id"] = this.unit_of_measurement_id;
        data["canComment"] = this.canComment;
        return data; 
    }

    clone(): ManageKpiDTO {
        const json = this.toJSON();
        let result = new ManageKpiDTO();
        result.init(json);
        return result;
    }
}

export interface IManageKpiDTO {
    id: number;
    title: string;
    description: string | undefined;
    kra_id: number;
    score: number;
    unit_of_measurement_id: number;
    canComment: boolean;
}

export class KpiDTO implements IKpiDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    title!: string;
    kpi_section_id!: number;
    unit_of_measurement_id!: number;
    canComment!: boolean;
    is_closed_ended!: boolean;
    section_name!: string | undefined;
    sectionTotalScore!: number;
    instruction!: string | undefined;
    description!: string | undefined;
    is_compulsory!: boolean;
    order!: number;
    order_count!: number;
    kpi_score!: number | undefined;
    employee_score!: number | undefined;
    supervisor_score!: number | undefined;
    score!: number | undefined;
    is_employee_entry!: boolean | undefined;
    sendToEmployee!: boolean;
    contract_id!: number | undefined;
    response!: string | undefined;
    supervisorResponse!: string | undefined;
    dateCreated!: Date;
    isDeleted!: boolean;
    isActive!: boolean;

    constructor(data?: IKpiDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.title = _data["title"];
            this.kpi_section_id = _data["kpi_section_id"];
            this.unit_of_measurement_id = _data["unit_of_measurement_id"];
            this.canComment = _data["canComment"];
            this.is_closed_ended = _data["is_closed_ended"];
            this.section_name = _data["section_name"];
            this.sectionTotalScore = _data["sectionTotalScore"];
            this.instruction = _data["instruction"];
            this.description = _data["description"];
            this.is_compulsory = _data["is_compulsory"];
            this.order = _data["order"];
            this.order_count = _data["order_count"];
            this.kpi_score = _data["kpi_score"];
            this.employee_score = _data["employee_score"];
            this.supervisor_score = _data["supervisor_score"];
            this.score = _data["score"];
            this.is_employee_entry = _data["is_employee_entry"];
            this.sendToEmployee = _data["sendToEmployee"];
            this.contract_id = _data["contract_id"];
            this.response = _data["response"];
            this.supervisorResponse = _data["supervisorResponse"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): KpiDTO {
        data = typeof data === 'object' ? data : {};
        let result = new KpiDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["title"] = this.title;
        data["kpi_section_id"] = this.kpi_section_id;
        data["unit_of_measurement_id"] = this.unit_of_measurement_id;
        data["canComment"] = this.canComment;
        data["is_closed_ended"] = this.is_closed_ended;
        data["section_name"] = this.section_name;
        data["sectionTotalScore"] = this.sectionTotalScore;
        data["instruction"] = this.instruction;
        data["description"] = this.description;
        data["is_compulsory"] = this.is_compulsory;
        data["order"] = this.order;
        data["order_count"] = this.order_count;
        data["kpi_score"] = this.kpi_score;
        data["employee_score"] = this.employee_score;
        data["supervisor_score"] = this.supervisor_score;
        data["score"] = this.score;
        data["is_employee_entry"] = this.is_employee_entry;
        data["sendToEmployee"] = this.sendToEmployee;
        data["contract_id"] = this.contract_id;
        data["response"] = this.response;
        data["supervisorResponse"] = this.supervisorResponse;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): KpiDTO {
        const json = this.toJSON();
        let result = new KpiDTO();
        result.init(json);
        return result;
    }
}

export interface IKpiDTO {
    id: number;
    companyID: number;
    subID: number;
    title: string;
    kpi_section_id: number;
    unit_of_measurement_id: number;
    canComment: boolean;
    is_closed_ended: boolean;
    section_name: string | undefined;
    sectionTotalScore: number;
    instruction: string | undefined;
    description: string | undefined;
    is_compulsory: boolean;
    order: number;
    order_count: number;
    kpi_score: number | undefined;
    employee_score: number | undefined;
    supervisor_score: number | undefined;
    score: number | undefined;
    is_employee_entry: boolean | undefined;
    sendToEmployee: boolean;
    contract_id: number | undefined;
    response: string | undefined;
    supervisorResponse: string | undefined;
    dateCreated: Date;
    isDeleted: boolean;
    isActive: boolean;
}

export class KpiDTOIListApiResult implements IKpiDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: KpiDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IKpiDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(KpiDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): KpiDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new KpiDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): KpiDTOIListApiResult {
        const json = this.toJSON();
        let result = new KpiDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IKpiDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: KpiDTO[] | undefined;
    totalCount: number;
}

export class KpiDTOApiResult implements IKpiDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: KpiDTO;
    totalCount!: number;

    constructor(data?: IKpiDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? KpiDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): KpiDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new KpiDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): KpiDTOApiResult {
        const json = this.toJSON();
        let result = new KpiDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IKpiDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: KpiDTO;
    totalCount: number;
}

export class AppraisalReviewerListDTO implements IAppraisalReviewerListDTO {
    contractId!: number;
    employeeId!: number;
    firstName!: string | undefined;
    otherNames!: string | undefined;
    lastName!: string | undefined;
    fullName!: string | undefined;
    employeeNumber!: string | undefined;
    supervisorId!: number | undefined;
    supervisorContractId!: number;
    periodId!: number;
    assignedKra!: number;
    assignedKpi!: number;
    period!: string | undefined;
    cycleStatus!: number;
    startDate!: Date | undefined;
    isSubmitted!: boolean;
    supervisorFullName!: string | undefined;
    status!: string | undefined;
    reviewStatus!: number;
    isApproved!: boolean;
    isReviewerSubmitted!: boolean | undefined;
    isReviewerStartedAppraisal!: boolean | undefined;

    constructor(data?: IAppraisalReviewerListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            this.employeeId = _data["employeeId"];
            this.firstName = _data["firstName"];
            this.otherNames = _data["otherNames"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.employeeNumber = _data["employeeNumber"];
            this.supervisorId = _data["supervisorId"];
            this.supervisorContractId = _data["supervisorContractId"];
            this.periodId = _data["periodId"];
            this.assignedKra = _data["assignedKra"];
            this.assignedKpi = _data["assignedKpi"];
            this.period = _data["period"];
            this.cycleStatus = _data["cycleStatus"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.isSubmitted = _data["isSubmitted"];
            this.supervisorFullName = _data["supervisorFullName"];
            this.status = _data["status"];
            this.reviewStatus = _data["reviewStatus"];
            this.isApproved = _data["isApproved"];
            this.isReviewerSubmitted = _data["isReviewerSubmitted"];
            this.isReviewerStartedAppraisal = _data["isReviewerStartedAppraisal"];
        }
    }

    static fromJS(data: any): AppraisalReviewerListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AppraisalReviewerListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        data["employeeId"] = this.employeeId;
        data["firstName"] = this.firstName;
        data["otherNames"] = this.otherNames;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["employeeNumber"] = this.employeeNumber;
        data["supervisorId"] = this.supervisorId;
        data["supervisorContractId"] = this.supervisorContractId;
        data["periodId"] = this.periodId;
        data["assignedKra"] = this.assignedKra;
        data["assignedKpi"] = this.assignedKpi;
        data["period"] = this.period;
        data["cycleStatus"] = this.cycleStatus;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["isSubmitted"] = this.isSubmitted;
        data["supervisorFullName"] = this.supervisorFullName;
        data["status"] = this.status;
        data["reviewStatus"] = this.reviewStatus;
        data["isApproved"] = this.isApproved;
        data["isReviewerSubmitted"] = this.isReviewerSubmitted;
        data["isReviewerStartedAppraisal"] = this.isReviewerStartedAppraisal;
        return data; 
    }

    clone(): AppraisalReviewerListDTO {
        const json = this.toJSON();
        let result = new AppraisalReviewerListDTO();
        result.init(json);
        return result;
    }
}

export interface IAppraisalReviewerListDTO {
    contractId: number;
    employeeId: number;
    firstName: string | undefined;
    otherNames: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    employeeNumber: string | undefined;
    supervisorId: number | undefined;
    supervisorContractId: number;
    periodId: number;
    assignedKra: number;
    assignedKpi: number;
    period: string | undefined;
    cycleStatus: number;
    startDate: Date | undefined;
    isSubmitted: boolean;
    supervisorFullName: string | undefined;
    status: string | undefined;
    reviewStatus: number;
    isApproved: boolean;
    isReviewerSubmitted: boolean | undefined;
    isReviewerStartedAppraisal: boolean | undefined;
}

export class AppraisalReviewerListDTOIListApiResult implements IAppraisalReviewerListDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: AppraisalReviewerListDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IAppraisalReviewerListDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AppraisalReviewerListDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AppraisalReviewerListDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AppraisalReviewerListDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AppraisalReviewerListDTOIListApiResult {
        const json = this.toJSON();
        let result = new AppraisalReviewerListDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IAppraisalReviewerListDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: AppraisalReviewerListDTO[] | undefined;
    totalCount: number;
}

export class LeaveEntitlementResource implements ILeaveEntitlementResource {
    id!: number;
    companyID!: number;
    subID!: number;
    gradeID!: number;
    leaveTypeID!: number;
    entitlement!: number;
    daysUsed!: number;
    daysRemaining!: number;
    leaveType!: string | undefined;
    grade!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveEntitlementResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.gradeID = _data["gradeID"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.entitlement = _data["entitlement"];
            this.daysUsed = _data["daysUsed"];
            this.daysRemaining = _data["daysRemaining"];
            this.leaveType = _data["leaveType"];
            this.grade = _data["grade"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveEntitlementResource {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["gradeID"] = this.gradeID;
        data["leaveTypeID"] = this.leaveTypeID;
        data["entitlement"] = this.entitlement;
        data["daysUsed"] = this.daysUsed;
        data["daysRemaining"] = this.daysRemaining;
        data["leaveType"] = this.leaveType;
        data["grade"] = this.grade;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveEntitlementResource {
        const json = this.toJSON();
        let result = new LeaveEntitlementResource();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementResource {
    id: number;
    companyID: number;
    subID: number;
    gradeID: number;
    leaveTypeID: number;
    entitlement: number;
    daysUsed: number;
    daysRemaining: number;
    leaveType: string | undefined;
    grade: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveEntitlementResourceListApiResult implements ILeaveEntitlementResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveEntitlementResource[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveEntitlementResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveEntitlementResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveEntitlementResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveEntitlementResourceListApiResult {
        const json = this.toJSON();
        let result = new LeaveEntitlementResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveEntitlementResource[] | undefined;
    totalCount: number;
}

export class LeaveEntitlementResourceApiResult implements ILeaveEntitlementResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveEntitlementResource;
    totalCount!: number;

    constructor(data?: ILeaveEntitlementResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveEntitlementResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveEntitlementResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveEntitlementResourceApiResult {
        const json = this.toJSON();
        let result = new LeaveEntitlementResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveEntitlementResource;
    totalCount: number;
}

export class LeaveEntitlementPayload implements ILeaveEntitlementPayload {
    gradeID!: number;
    leaveTypeID!: number;
    entitlement!: number;
    id!: number;

    constructor(data?: ILeaveEntitlementPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeID = _data["gradeID"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.entitlement = _data["entitlement"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LeaveEntitlementPayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlementPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeID"] = this.gradeID;
        data["leaveTypeID"] = this.leaveTypeID;
        data["entitlement"] = this.entitlement;
        data["id"] = this.id;
        return data; 
    }

    clone(): LeaveEntitlementPayload {
        const json = this.toJSON();
        let result = new LeaveEntitlementPayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlementPayload {
    gradeID: number;
    leaveTypeID: number;
    entitlement: number;
    id: number;
}

export class Grade implements IGrade {
    name!: string;
    code!: string | undefined;
    created_by!: string | undefined;
    promotion_min_years!: number;
    promotion_min_in_days!: number | undefined;
    noOfLeaveDays!: number;
    salaryScaleId!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IGrade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.created_by = _data["created_by"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Grade {
        data = typeof data === 'object' ? data : {};
        let result = new Grade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["created_by"] = this.created_by;
        data["promotion_min_years"] = this.promotion_min_years;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["salaryScaleId"] = this.salaryScaleId;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Grade {
        const json = this.toJSON();
        let result = new Grade();
        result.init(json);
        return result;
    }
}

export interface IGrade {
    name: string;
    code: string | undefined;
    created_by: string | undefined;
    promotion_min_years: number;
    promotion_min_in_days: number | undefined;
    noOfLeaveDays: number;
    salaryScaleId: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class GradeListApiResult implements IGradeListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Grade[] | undefined;
    totalCount!: number;

    constructor(data?: IGradeListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Grade.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GradeListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GradeListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): GradeListApiResult {
        const json = this.toJSON();
        let result = new GradeListApiResult();
        result.init(json);
        return result;
    }
}

export interface IGradeListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Grade[] | undefined;
    totalCount: number;
}

export class ManageLeaveHolidayDTO implements IManageLeaveHolidayDTO {
    id!: number;
    holidayDate!: Date;
    description!: string | undefined;
    leaveYearId!: number;

    constructor(data?: IManageLeaveHolidayDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.holidayDate = _data["holidayDate"] ? new Date(_data["holidayDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.leaveYearId = _data["leaveYearId"];
        }
    }

    static fromJS(data: any): ManageLeaveHolidayDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageLeaveHolidayDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["holidayDate"] = this.holidayDate ? this.holidayDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["leaveYearId"] = this.leaveYearId;
        return data; 
    }

    clone(): ManageLeaveHolidayDTO {
        const json = this.toJSON();
        let result = new ManageLeaveHolidayDTO();
        result.init(json);
        return result;
    }
}

export interface IManageLeaveHolidayDTO {
    id: number;
    holidayDate: Date;
    description: string | undefined;
    leaveYearId: number;
}

export class LeaveHolidayDTO implements ILeaveHolidayDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    holidayDate!: Date;
    description!: string | undefined;
    leaveYearId!: number;
    leaveYear!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveHolidayDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.holidayDate = _data["holidayDate"] ? new Date(_data["holidayDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.leaveYearId = _data["leaveYearId"];
            this.leaveYear = _data["leaveYear"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveHolidayDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveHolidayDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["holidayDate"] = this.holidayDate ? this.holidayDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["leaveYearId"] = this.leaveYearId;
        data["leaveYear"] = this.leaveYear;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveHolidayDTO {
        const json = this.toJSON();
        let result = new LeaveHolidayDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveHolidayDTO {
    id: number;
    companyID: number;
    subID: number;
    holidayDate: Date;
    description: string | undefined;
    leaveYearId: number;
    leaveYear: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveHolidayDTOListApiResult implements ILeaveHolidayDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveHolidayDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveHolidayDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveHolidayDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveHolidayDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveHolidayDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveHolidayDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveHolidayDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveHolidayDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveHolidayDTO[] | undefined;
    totalCount: number;
}

export class LeaveHolidayDTOApiResult implements ILeaveHolidayDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveHolidayDTO;
    totalCount!: number;

    constructor(data?: ILeaveHolidayDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveHolidayDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveHolidayDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveHolidayDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveHolidayDTOApiResult {
        const json = this.toJSON();
        let result = new LeaveHolidayDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveHolidayDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveHolidayDTO;
    totalCount: number;
}

export class LeavePlanDTO implements ILeavePlanDTO {
    employeeContractId!: number;
    leaveTypeId!: number;
    leaveYearId!: number;
    comment!: string;
    startDate!: Date;
    endDate!: Date;
    noOfDays!: number;
    locationId!: number;

    constructor(data?: ILeavePlanDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeContractId = _data["employeeContractId"];
            this.leaveTypeId = _data["leaveTypeId"];
            this.leaveYearId = _data["leaveYearId"];
            this.comment = _data["comment"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.locationId = _data["locationId"];
        }
    }

    static fromJS(data: any): LeavePlanDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePlanDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeContractId"] = this.employeeContractId;
        data["leaveTypeId"] = this.leaveTypeId;
        data["leaveYearId"] = this.leaveYearId;
        data["comment"] = this.comment;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["locationId"] = this.locationId;
        return data; 
    }

    clone(): LeavePlanDTO {
        const json = this.toJSON();
        let result = new LeavePlanDTO();
        result.init(json);
        return result;
    }
}

export interface ILeavePlanDTO {
    employeeContractId: number;
    leaveTypeId: number;
    leaveYearId: number;
    comment: string;
    startDate: Date;
    endDate: Date;
    noOfDays: number;
    locationId: number;
}

export class LeavePlanResource implements ILeavePlanResource {
    strApprovalStatus!: string | undefined;
    isApproved!: number;
    dateCreated!: Date;
    id!: number;
    employeeContractId!: number;
    leaveTypeId!: number;
    leaveYearId!: number;
    comment!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    noOfDays!: number;
    locationName!: string | undefined;
    locationId!: number;
    employeeNo!: string | undefined;
    fullName!: string | undefined;
    leaveType!: string | undefined;
    leaveYear!: string | undefined;
    companyId!: number;
    subId!: number;

    constructor(data?: ILeavePlanResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.strApprovalStatus = _data["strApprovalStatus"];
            this.isApproved = _data["isApproved"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.employeeContractId = _data["employeeContractId"];
            this.leaveTypeId = _data["leaveTypeId"];
            this.leaveYearId = _data["leaveYearId"];
            this.comment = _data["comment"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.locationName = _data["locationName"];
            this.locationId = _data["locationId"];
            this.employeeNo = _data["employeeNo"];
            this.fullName = _data["fullName"];
            this.leaveType = _data["leaveType"];
            this.leaveYear = _data["leaveYear"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
        }
    }

    static fromJS(data: any): LeavePlanResource {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePlanResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["strApprovalStatus"] = this.strApprovalStatus;
        data["isApproved"] = this.isApproved;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["employeeContractId"] = this.employeeContractId;
        data["leaveTypeId"] = this.leaveTypeId;
        data["leaveYearId"] = this.leaveYearId;
        data["comment"] = this.comment;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["locationName"] = this.locationName;
        data["locationId"] = this.locationId;
        data["employeeNo"] = this.employeeNo;
        data["fullName"] = this.fullName;
        data["leaveType"] = this.leaveType;
        data["leaveYear"] = this.leaveYear;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        return data; 
    }

    clone(): LeavePlanResource {
        const json = this.toJSON();
        let result = new LeavePlanResource();
        result.init(json);
        return result;
    }
}

export interface ILeavePlanResource {
    strApprovalStatus: string | undefined;
    isApproved: number;
    dateCreated: Date;
    id: number;
    employeeContractId: number;
    leaveTypeId: number;
    leaveYearId: number;
    comment: string | undefined;
    startDate: Date;
    endDate: Date;
    noOfDays: number;
    locationName: string | undefined;
    locationId: number;
    employeeNo: string | undefined;
    fullName: string | undefined;
    leaveType: string | undefined;
    leaveYear: string | undefined;
    companyId: number;
    subId: number;
}

export class LeavePlanResourceListApiResult implements ILeavePlanResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeavePlanResource[] | undefined;
    totalCount!: number;

    constructor(data?: ILeavePlanResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeavePlanResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeavePlanResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePlanResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeavePlanResourceListApiResult {
        const json = this.toJSON();
        let result = new LeavePlanResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeavePlanResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeavePlanResource[] | undefined;
    totalCount: number;
}

export enum LeavePlaneStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ApproveOrRejectPayload implements IApproveOrRejectPayload {
    id!: number;
    companyId!: number | undefined;
    leavePlaneStatus!: LeavePlaneStatus;

    constructor(data?: IApproveOrRejectPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.leavePlaneStatus = _data["leavePlaneStatus"];
        }
    }

    static fromJS(data: any): ApproveOrRejectPayload {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveOrRejectPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["leavePlaneStatus"] = this.leavePlaneStatus;
        return data; 
    }

    clone(): ApproveOrRejectPayload {
        const json = this.toJSON();
        let result = new ApproveOrRejectPayload();
        result.init(json);
        return result;
    }
}

export interface IApproveOrRejectPayload {
    id: number;
    companyId: number | undefined;
    leavePlaneStatus: LeavePlaneStatus;
}

export class ManageLeaveRequestDTO implements IManageLeaveRequestDTO {
    id!: number;
    employeeNumber!: string | undefined;
    leaveTypeID!: number;
    leaveYearID!: number;
    startDate!: Date;
    noOfDays!: number;
    contactInfoOnLeave!: string;
    reliefOfficerStaffNo!: string;
    file!: string | undefined;

    constructor(data?: IManageLeaveRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeNumber = _data["employeeNumber"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.leaveYearID = _data["leaveYearID"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.contactInfoOnLeave = _data["contactInfoOnLeave"];
            this.reliefOfficerStaffNo = _data["reliefOfficerStaffNo"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): ManageLeaveRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageLeaveRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeNumber"] = this.employeeNumber;
        data["leaveTypeID"] = this.leaveTypeID;
        data["leaveYearID"] = this.leaveYearID;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["contactInfoOnLeave"] = this.contactInfoOnLeave;
        data["reliefOfficerStaffNo"] = this.reliefOfficerStaffNo;
        data["file"] = this.file;
        return data; 
    }

    clone(): ManageLeaveRequestDTO {
        const json = this.toJSON();
        let result = new ManageLeaveRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IManageLeaveRequestDTO {
    id: number;
    employeeNumber: string | undefined;
    leaveTypeID: number;
    leaveYearID: number;
    startDate: Date;
    noOfDays: number;
    contactInfoOnLeave: string;
    reliefOfficerStaffNo: string;
    file: string | undefined;
}

export class LeaveReportListDTO implements ILeaveReportListDTO {
    sn!: number;
    id!: number;
    fullName!: string | undefined;
    position!: string | undefined;
    yearName!: string | undefined;
    leaveType!: string | undefined;
    approvalStatus!: string | undefined;
    employeeID!: number | undefined;
    employeeContractID!: number | undefined;
    startDate!: string | undefined;
    enddate!: string | undefined;
    resumptionDate!: string | undefined;
    entitlement!: number;
    assignmentNumber!: string | undefined;
    daysRem!: number;
    noOfDays!: number;

    constructor(data?: ILeaveReportListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sn = _data["sn"];
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.position = _data["position"];
            this.yearName = _data["yearName"];
            this.leaveType = _data["leaveType"];
            this.approvalStatus = _data["approvalStatus"];
            this.employeeID = _data["employeeID"];
            this.employeeContractID = _data["employeeContractID"];
            this.startDate = _data["startDate"];
            this.enddate = _data["enddate"];
            this.resumptionDate = _data["resumptionDate"];
            this.entitlement = _data["entitlement"];
            this.assignmentNumber = _data["assignmentNumber"];
            this.daysRem = _data["daysRem"];
            this.noOfDays = _data["noOfDays"];
        }
    }

    static fromJS(data: any): LeaveReportListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveReportListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sn"] = this.sn;
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["position"] = this.position;
        data["yearName"] = this.yearName;
        data["leaveType"] = this.leaveType;
        data["approvalStatus"] = this.approvalStatus;
        data["employeeID"] = this.employeeID;
        data["employeeContractID"] = this.employeeContractID;
        data["startDate"] = this.startDate;
        data["enddate"] = this.enddate;
        data["resumptionDate"] = this.resumptionDate;
        data["entitlement"] = this.entitlement;
        data["assignmentNumber"] = this.assignmentNumber;
        data["daysRem"] = this.daysRem;
        data["noOfDays"] = this.noOfDays;
        return data; 
    }

    clone(): LeaveReportListDTO {
        const json = this.toJSON();
        let result = new LeaveReportListDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveReportListDTO {
    sn: number;
    id: number;
    fullName: string | undefined;
    position: string | undefined;
    yearName: string | undefined;
    leaveType: string | undefined;
    approvalStatus: string | undefined;
    employeeID: number | undefined;
    employeeContractID: number | undefined;
    startDate: string | undefined;
    enddate: string | undefined;
    resumptionDate: string | undefined;
    entitlement: number;
    assignmentNumber: string | undefined;
    daysRem: number;
    noOfDays: number;
}

export class LeaveReportListDTOListApiResult implements ILeaveReportListDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveReportListDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveReportListDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveReportListDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveReportListDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveReportListDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveReportListDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveReportListDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveReportListDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveReportListDTO[] | undefined;
    totalCount: number;
}

export class Skill implements ISkill {
    name!: string | undefined;
    point!: number | undefined;
    employeeSkills!: EmployeeSkill[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISkill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.point = _data["point"];
            if (Array.isArray(_data["employeeSkills"])) {
                this.employeeSkills = [] as any;
                for (let item of _data["employeeSkills"])
                    this.employeeSkills!.push(EmployeeSkill.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Skill {
        data = typeof data === 'object' ? data : {};
        let result = new Skill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["point"] = this.point;
        if (Array.isArray(this.employeeSkills)) {
            data["employeeSkills"] = [];
            for (let item of this.employeeSkills)
                data["employeeSkills"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Skill {
        const json = this.toJSON();
        let result = new Skill();
        result.init(json);
        return result;
    }
}

export interface ISkill {
    name: string | undefined;
    point: number | undefined;
    employeeSkills: EmployeeSkill[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeSkill implements IEmployeeSkill {
    employeeId!: number;
    skillId!: number;
    startDate!: Date | undefined;
    numberOfExperienceInMonth!: number | undefined;
    point!: number | undefined;
    employee!: Employee;
    skill!: Skill;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeSkill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.skillId = _data["skillId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.numberOfExperienceInMonth = _data["numberOfExperienceInMonth"];
            this.point = _data["point"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.skill = _data["skill"] ? Skill.fromJS(_data["skill"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeSkill {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeSkill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["skillId"] = this.skillId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["numberOfExperienceInMonth"] = this.numberOfExperienceInMonth;
        data["point"] = this.point;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["skill"] = this.skill ? this.skill.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeSkill {
        const json = this.toJSON();
        let result = new EmployeeSkill();
        result.init(json);
        return result;
    }
}

export interface IEmployeeSkill {
    employeeId: number;
    skillId: number;
    startDate: Date | undefined;
    numberOfExperienceInMonth: number | undefined;
    point: number | undefined;
    employee: Employee;
    skill: Skill;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Course implements ICourse {
    name!: string | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Course {
        const json = this.toJSON();
        let result = new Course();
        result.init(json);
        return result;
    }
}

export interface ICourse {
    name: string | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class QualificationGrade implements IQualificationGrade {
    name!: string | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IQualificationGrade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): QualificationGrade {
        data = typeof data === 'object' ? data : {};
        let result = new QualificationGrade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): QualificationGrade {
        const json = this.toJSON();
        let result = new QualificationGrade();
        result.init(json);
        return result;
    }
}

export interface IQualificationGrade {
    name: string | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Qualification implements IQualification {
    categoryId!: number;
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IQualification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Qualification {
        data = typeof data === 'object' ? data : {};
        let result = new Qualification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Qualification {
        const json = this.toJSON();
        let result = new Qualification();
        result.init(json);
        return result;
    }
}

export interface IQualification {
    categoryId: number;
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeQualification implements IEmployeeQualification {
    employeeId!: number;
    name!: string;
    type!: string;
    qualificationId!: number;
    qualificationGradeId!: number;
    courseId!: number;
    courseName!: string | undefined;
    institution!: string | undefined;
    grade!: string | undefined;
    startdate!: Date | undefined;
    stopdate!: Date | undefined;
    comment!: string | undefined;
    is_professional!: number | undefined;
    employee!: Employee;
    course!: Course;
    qualificationGrade!: QualificationGrade;
    qualification!: Qualification;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeQualification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.qualificationId = _data["qualificationId"];
            this.qualificationGradeId = _data["qualificationGradeId"];
            this.courseId = _data["courseId"];
            this.courseName = _data["courseName"];
            this.institution = _data["institution"];
            this.grade = _data["grade"];
            this.startdate = _data["startdate"] ? new Date(_data["startdate"].toString()) : <any>undefined;
            this.stopdate = _data["stopdate"] ? new Date(_data["stopdate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.is_professional = _data["is_professional"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.qualificationGrade = _data["qualificationGrade"] ? QualificationGrade.fromJS(_data["qualificationGrade"]) : <any>undefined;
            this.qualification = _data["qualification"] ? Qualification.fromJS(_data["qualification"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeQualification {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeQualification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["qualificationId"] = this.qualificationId;
        data["qualificationGradeId"] = this.qualificationGradeId;
        data["courseId"] = this.courseId;
        data["courseName"] = this.courseName;
        data["institution"] = this.institution;
        data["grade"] = this.grade;
        data["startdate"] = this.startdate ? this.startdate.toISOString() : <any>undefined;
        data["stopdate"] = this.stopdate ? this.stopdate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["is_professional"] = this.is_professional;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["qualificationGrade"] = this.qualificationGrade ? this.qualificationGrade.toJSON() : <any>undefined;
        data["qualification"] = this.qualification ? this.qualification.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeQualification {
        const json = this.toJSON();
        let result = new EmployeeQualification();
        result.init(json);
        return result;
    }
}

export interface IEmployeeQualification {
    employeeId: number;
    name: string;
    type: string;
    qualificationId: number;
    qualificationGradeId: number;
    courseId: number;
    courseName: string | undefined;
    institution: string | undefined;
    grade: string | undefined;
    startdate: Date | undefined;
    stopdate: Date | undefined;
    comment: string | undefined;
    is_professional: number | undefined;
    employee: Employee;
    course: Course;
    qualificationGrade: QualificationGrade;
    qualification: Qualification;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Certification implements ICertification {
    name!: string | undefined;
    code!: string | undefined;
    point!: number | undefined;
    completionDate!: Date | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ICertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.point = _data["point"];
            this.completionDate = _data["completionDate"] ? new Date(_data["completionDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Certification {
        data = typeof data === 'object' ? data : {};
        let result = new Certification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["point"] = this.point;
        data["completionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Certification {
        const json = this.toJSON();
        let result = new Certification();
        result.init(json);
        return result;
    }
}

export interface ICertification {
    name: string | undefined;
    code: string | undefined;
    point: number | undefined;
    completionDate: Date | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeCertification implements IEmployeeCertification {
    employeeId!: number;
    certificationId!: number;
    institution!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    comment!: string | undefined;
    numberOfExperienceInMonth!: number | undefined;
    certification!: Certification;
    employee!: Employee;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeCertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.certificationId = _data["certificationId"];
            this.institution = _data["institution"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.numberOfExperienceInMonth = _data["numberOfExperienceInMonth"];
            this.certification = _data["certification"] ? Certification.fromJS(_data["certification"]) : <any>undefined;
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeCertification {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeCertification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["certificationId"] = this.certificationId;
        data["institution"] = this.institution;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["numberOfExperienceInMonth"] = this.numberOfExperienceInMonth;
        data["certification"] = this.certification ? this.certification.toJSON() : <any>undefined;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeCertification {
        const json = this.toJSON();
        let result = new EmployeeCertification();
        result.init(json);
        return result;
    }
}

export interface IEmployeeCertification {
    employeeId: number;
    certificationId: number;
    institution: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    comment: string | undefined;
    numberOfExperienceInMonth: number | undefined;
    certification: Certification;
    employee: Employee;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Employee implements IEmployee {
    userId!: number;
    titleId!: number;
    religionId!: number | undefined;
    serialNo!: string | undefined;
    firstName!: string;
    lastName!: string;
    otherNames!: string | undefined;
    employeeNumber!: string;
    dateOfBirth!: Date | undefined;
    maritalStatusId!: number;
    genderId!: number;
    lasraaNumber!: string | undefined;
    regNo!: string | undefined;
    estabFileNo!: string | undefined;
    personalEmail!: string | undefined;
    workEmail!: string | undefined;
    fullName!: string | undefined;
    peopleGroupId!: number | undefined;
    niNumber!: string | undefined;
    profilePic!: string | undefined;
    workMobile!: string | undefined;
    defaultMobile!: string | undefined;
    subjectSpecialization!: string | undefined;
    selfServiceStatus!: string | undefined;
    employmentStatusId!: number | undefined;
    pensionerFileNo!: string | undefined;
    pfaId!: number | undefined;
    rsaNumber!: string | undefined;
    stateOfOrigion!: string | undefined;
    lgaOfOrigion!: string | undefined;
    internalAddressLine!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    originCountry!: number | undefined;
    originState!: number | undefined;
    residentialCountry!: number | undefined;
    residentialState!: number | undefined;
    residentialLga!: number | undefined;
    residentialAddress!: string | undefined;
    created_by!: string | undefined;
    bvn!: string | undefined;
    bvnStatus!: number;
    bvnValidationResponse!: string | undefined;
    lastBVNValidation!: Date | undefined;
    deviceId!: number | undefined;
    employeeSkills!: EmployeeSkill[] | undefined;
    employeeQualifications!: EmployeeQualification[] | undefined;
    employeeCertifications!: EmployeeCertification[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.titleId = _data["titleId"];
            this.religionId = _data["religionId"];
            this.serialNo = _data["serialNo"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherNames = _data["otherNames"];
            this.employeeNumber = _data["employeeNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.maritalStatusId = _data["maritalStatusId"];
            this.genderId = _data["genderId"];
            this.lasraaNumber = _data["lasraaNumber"];
            this.regNo = _data["regNo"];
            this.estabFileNo = _data["estabFileNo"];
            this.personalEmail = _data["personalEmail"];
            this.workEmail = _data["workEmail"];
            this.fullName = _data["fullName"];
            this.peopleGroupId = _data["peopleGroupId"];
            this.niNumber = _data["niNumber"];
            this.profilePic = _data["profilePic"];
            this.workMobile = _data["workMobile"];
            this.defaultMobile = _data["defaultMobile"];
            this.subjectSpecialization = _data["subjectSpecialization"];
            this.selfServiceStatus = _data["selfServiceStatus"];
            this.employmentStatusId = _data["employmentStatusId"];
            this.pensionerFileNo = _data["pensionerFileNo"];
            this.pfaId = _data["pfaId"];
            this.rsaNumber = _data["rsaNumber"];
            this.stateOfOrigion = _data["stateOfOrigion"];
            this.lgaOfOrigion = _data["lgaOfOrigion"];
            this.internalAddressLine = _data["internalAddressLine"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.originCountry = _data["originCountry"];
            this.originState = _data["originState"];
            this.residentialCountry = _data["residentialCountry"];
            this.residentialState = _data["residentialState"];
            this.residentialLga = _data["residentialLga"];
            this.residentialAddress = _data["residentialAddress"];
            this.created_by = _data["created_by"];
            this.bvn = _data["bvn"];
            this.bvnStatus = _data["bvnStatus"];
            this.bvnValidationResponse = _data["bvnValidationResponse"];
            this.lastBVNValidation = _data["lastBVNValidation"] ? new Date(_data["lastBVNValidation"].toString()) : <any>undefined;
            this.deviceId = _data["deviceId"];
            if (Array.isArray(_data["employeeSkills"])) {
                this.employeeSkills = [] as any;
                for (let item of _data["employeeSkills"])
                    this.employeeSkills!.push(EmployeeSkill.fromJS(item));
            }
            if (Array.isArray(_data["employeeQualifications"])) {
                this.employeeQualifications = [] as any;
                for (let item of _data["employeeQualifications"])
                    this.employeeQualifications!.push(EmployeeQualification.fromJS(item));
            }
            if (Array.isArray(_data["employeeCertifications"])) {
                this.employeeCertifications = [] as any;
                for (let item of _data["employeeCertifications"])
                    this.employeeCertifications!.push(EmployeeCertification.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Employee {
        data = typeof data === 'object' ? data : {};
        let result = new Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["titleId"] = this.titleId;
        data["religionId"] = this.religionId;
        data["serialNo"] = this.serialNo;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherNames"] = this.otherNames;
        data["employeeNumber"] = this.employeeNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["maritalStatusId"] = this.maritalStatusId;
        data["genderId"] = this.genderId;
        data["lasraaNumber"] = this.lasraaNumber;
        data["regNo"] = this.regNo;
        data["estabFileNo"] = this.estabFileNo;
        data["personalEmail"] = this.personalEmail;
        data["workEmail"] = this.workEmail;
        data["fullName"] = this.fullName;
        data["peopleGroupId"] = this.peopleGroupId;
        data["niNumber"] = this.niNumber;
        data["profilePic"] = this.profilePic;
        data["workMobile"] = this.workMobile;
        data["defaultMobile"] = this.defaultMobile;
        data["subjectSpecialization"] = this.subjectSpecialization;
        data["selfServiceStatus"] = this.selfServiceStatus;
        data["employmentStatusId"] = this.employmentStatusId;
        data["pensionerFileNo"] = this.pensionerFileNo;
        data["pfaId"] = this.pfaId;
        data["rsaNumber"] = this.rsaNumber;
        data["stateOfOrigion"] = this.stateOfOrigion;
        data["lgaOfOrigion"] = this.lgaOfOrigion;
        data["internalAddressLine"] = this.internalAddressLine;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["originCountry"] = this.originCountry;
        data["originState"] = this.originState;
        data["residentialCountry"] = this.residentialCountry;
        data["residentialState"] = this.residentialState;
        data["residentialLga"] = this.residentialLga;
        data["residentialAddress"] = this.residentialAddress;
        data["created_by"] = this.created_by;
        data["bvn"] = this.bvn;
        data["bvnStatus"] = this.bvnStatus;
        data["bvnValidationResponse"] = this.bvnValidationResponse;
        data["lastBVNValidation"] = this.lastBVNValidation ? this.lastBVNValidation.toISOString() : <any>undefined;
        data["deviceId"] = this.deviceId;
        if (Array.isArray(this.employeeSkills)) {
            data["employeeSkills"] = [];
            for (let item of this.employeeSkills)
                data["employeeSkills"].push(item.toJSON());
        }
        if (Array.isArray(this.employeeQualifications)) {
            data["employeeQualifications"] = [];
            for (let item of this.employeeQualifications)
                data["employeeQualifications"].push(item.toJSON());
        }
        if (Array.isArray(this.employeeCertifications)) {
            data["employeeCertifications"] = [];
            for (let item of this.employeeCertifications)
                data["employeeCertifications"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Employee {
        const json = this.toJSON();
        let result = new Employee();
        result.init(json);
        return result;
    }
}

export interface IEmployee {
    userId: number;
    titleId: number;
    religionId: number | undefined;
    serialNo: string | undefined;
    firstName: string;
    lastName: string;
    otherNames: string | undefined;
    employeeNumber: string;
    dateOfBirth: Date | undefined;
    maritalStatusId: number;
    genderId: number;
    lasraaNumber: string | undefined;
    regNo: string | undefined;
    estabFileNo: string | undefined;
    personalEmail: string | undefined;
    workEmail: string | undefined;
    fullName: string | undefined;
    peopleGroupId: number | undefined;
    niNumber: string | undefined;
    profilePic: string | undefined;
    workMobile: string | undefined;
    defaultMobile: string | undefined;
    subjectSpecialization: string | undefined;
    selfServiceStatus: string | undefined;
    employmentStatusId: number | undefined;
    pensionerFileNo: string | undefined;
    pfaId: number | undefined;
    rsaNumber: string | undefined;
    stateOfOrigion: string | undefined;
    lgaOfOrigion: string | undefined;
    internalAddressLine: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    originCountry: number | undefined;
    originState: number | undefined;
    residentialCountry: number | undefined;
    residentialState: number | undefined;
    residentialLga: number | undefined;
    residentialAddress: string | undefined;
    created_by: string | undefined;
    bvn: string | undefined;
    bvnStatus: number;
    bvnValidationResponse: string | undefined;
    lastBVNValidation: Date | undefined;
    deviceId: number | undefined;
    employeeSkills: EmployeeSkill[] | undefined;
    employeeQualifications: EmployeeQualification[] | undefined;
    employeeCertifications: EmployeeCertification[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveYear implements ILeaveYear {
    yearName!: string;
    isActiveYear!: boolean;
    yearStartDate!: Date;
    yearEndDate!: Date;
    yearEndDateString!: string | undefined;
    yearStartDateString!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveYear) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.yearName = _data["yearName"];
            this.isActiveYear = _data["isActiveYear"];
            this.yearStartDate = _data["yearStartDate"] ? new Date(_data["yearStartDate"].toString()) : <any>undefined;
            this.yearEndDate = _data["yearEndDate"] ? new Date(_data["yearEndDate"].toString()) : <any>undefined;
            this.yearEndDateString = _data["yearEndDateString"];
            this.yearStartDateString = _data["yearStartDateString"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveYear {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYear();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yearName"] = this.yearName;
        data["isActiveYear"] = this.isActiveYear;
        data["yearStartDate"] = this.yearStartDate ? this.yearStartDate.toISOString() : <any>undefined;
        data["yearEndDate"] = this.yearEndDate ? this.yearEndDate.toISOString() : <any>undefined;
        data["yearEndDateString"] = this.yearEndDateString;
        data["yearStartDateString"] = this.yearStartDateString;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveYear {
        const json = this.toJSON();
        let result = new LeaveYear();
        result.init(json);
        return result;
    }
}

export interface ILeaveYear {
    yearName: string;
    isActiveYear: boolean;
    yearStartDate: Date;
    yearEndDate: Date;
    yearEndDateString: string | undefined;
    yearStartDateString: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveType implements ILeaveType {
    description!: string;
    isDeductableFromAnualLeave!: boolean;
    excludeWeekendInCalculation!: boolean;
    isOnlyAvailableToAdmin!: boolean;
    isAnnualLeave!: boolean;
    allowedGender!: number;
    maxDays!: number;
    minDays!: number;
    isSystemDefault!: boolean;
    maxNoofPossibleApplication!: number;
    maxNoofYearlyApplication!: number;
    isGradeDependent!: boolean;
    pro_rateLeaveDays!: boolean;
    onlyForConfirmStaff!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.maxDays = 0;
            this.minDays = 0;
            this.maxNoofPossibleApplication = 0;
            this.maxNoofYearlyApplication = 0;
            this.isGradeDependent = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.isDeductableFromAnualLeave = _data["isDeductableFromAnualLeave"];
            this.excludeWeekendInCalculation = _data["excludeWeekendInCalculation"];
            this.isOnlyAvailableToAdmin = _data["isOnlyAvailableToAdmin"];
            this.isAnnualLeave = _data["isAnnualLeave"];
            this.allowedGender = _data["allowedGender"];
            this.maxDays = _data["maxDays"] !== undefined ? _data["maxDays"] : 0;
            this.minDays = _data["minDays"] !== undefined ? _data["minDays"] : 0;
            this.isSystemDefault = _data["isSystemDefault"];
            this.maxNoofPossibleApplication = _data["maxNoofPossibleApplication"] !== undefined ? _data["maxNoofPossibleApplication"] : 0;
            this.maxNoofYearlyApplication = _data["maxNoofYearlyApplication"] !== undefined ? _data["maxNoofYearlyApplication"] : 0;
            this.isGradeDependent = _data["isGradeDependent"] !== undefined ? _data["isGradeDependent"] : false;
            this.pro_rateLeaveDays = _data["pro_rateLeaveDays"];
            this.onlyForConfirmStaff = _data["onlyForConfirmStaff"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveType {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["isDeductableFromAnualLeave"] = this.isDeductableFromAnualLeave;
        data["excludeWeekendInCalculation"] = this.excludeWeekendInCalculation;
        data["isOnlyAvailableToAdmin"] = this.isOnlyAvailableToAdmin;
        data["isAnnualLeave"] = this.isAnnualLeave;
        data["allowedGender"] = this.allowedGender;
        data["maxDays"] = this.maxDays;
        data["minDays"] = this.minDays;
        data["isSystemDefault"] = this.isSystemDefault;
        data["maxNoofPossibleApplication"] = this.maxNoofPossibleApplication;
        data["maxNoofYearlyApplication"] = this.maxNoofYearlyApplication;
        data["isGradeDependent"] = this.isGradeDependent;
        data["pro_rateLeaveDays"] = this.pro_rateLeaveDays;
        data["onlyForConfirmStaff"] = this.onlyForConfirmStaff;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveType {
        const json = this.toJSON();
        let result = new LeaveType();
        result.init(json);
        return result;
    }
}

export interface ILeaveType {
    description: string;
    isDeductableFromAnualLeave: boolean;
    excludeWeekendInCalculation: boolean;
    isOnlyAvailableToAdmin: boolean;
    isAnnualLeave: boolean;
    allowedGender: number;
    maxDays: number;
    minDays: number;
    isSystemDefault: boolean;
    maxNoofPossibleApplication: number;
    maxNoofYearlyApplication: number;
    isGradeDependent: boolean;
    pro_rateLeaveDays: boolean;
    onlyForConfirmStaff: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveEntitlement implements ILeaveEntitlement {
    gradeID!: number;
    leaveTypeID!: number;
    entitlement!: number;
    daysUsed!: number;
    daysRemaining!: number;
    leaveType!: LeaveType;
    grades!: Grade;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveEntitlement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeID = _data["gradeID"];
            this.leaveTypeID = _data["leaveTypeID"];
            this.entitlement = _data["entitlement"];
            this.daysUsed = _data["daysUsed"];
            this.daysRemaining = _data["daysRemaining"];
            this.leaveType = _data["leaveType"] ? LeaveType.fromJS(_data["leaveType"]) : <any>undefined;
            this.grades = _data["grades"] ? Grade.fromJS(_data["grades"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveEntitlement {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveEntitlement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeID"] = this.gradeID;
        data["leaveTypeID"] = this.leaveTypeID;
        data["entitlement"] = this.entitlement;
        data["daysUsed"] = this.daysUsed;
        data["daysRemaining"] = this.daysRemaining;
        data["leaveType"] = this.leaveType ? this.leaveType.toJSON() : <any>undefined;
        data["grades"] = this.grades ? this.grades.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveEntitlement {
        const json = this.toJSON();
        let result = new LeaveEntitlement();
        result.init(json);
        return result;
    }
}

export interface ILeaveEntitlement {
    gradeID: number;
    leaveTypeID: number;
    entitlement: number;
    daysUsed: number;
    daysRemaining: number;
    leaveType: LeaveType;
    grades: Grade;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveRequest implements ILeaveRequest {
    leaveTypeID!: number;
    employeeID!: number;
    employeeContractID!: number | undefined;
    employeeNumber!: string | undefined;
    leaveYearID!: number;
    leaveCalendarID!: number;
    initiatorComment!: string;
    contactInfoOnLeave!: string;
    reliefOfficer!: string;
    reliefOfficerId!: number;
    startDate!: Date;
    startDateString!: string | undefined;
    enddate!: Date;
    noOfDays!: number;
    resumptionDate!: Date;
    dateApplied!: Date;
    gradeID!: number;
    dateApproved!: Date | undefined;
    rejectedBy!: string | undefined;
    employee!: Employee;
    leaveYear!: LeaveYear;
    leaveType!: LeaveType;
    grade!: Grade;
    file!: string | undefined;
    leaveHistory!: LeaveRequest[] | undefined;
    leaveEntitlement!: LeaveEntitlement[] | undefined;
    approvalDecision!: string | undefined;
    approvalStatus!: string | undefined;
    log_status!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leaveTypeID = _data["leaveTypeID"];
            this.employeeID = _data["employeeID"];
            this.employeeContractID = _data["employeeContractID"];
            this.employeeNumber = _data["employeeNumber"];
            this.leaveYearID = _data["leaveYearID"];
            this.leaveCalendarID = _data["leaveCalendarID"];
            this.initiatorComment = _data["initiatorComment"];
            this.contactInfoOnLeave = _data["contactInfoOnLeave"];
            this.reliefOfficer = _data["reliefOfficer"];
            this.reliefOfficerId = _data["reliefOfficerId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.startDateString = _data["startDateString"];
            this.enddate = _data["enddate"] ? new Date(_data["enddate"].toString()) : <any>undefined;
            this.noOfDays = _data["noOfDays"];
            this.resumptionDate = _data["resumptionDate"] ? new Date(_data["resumptionDate"].toString()) : <any>undefined;
            this.dateApplied = _data["dateApplied"] ? new Date(_data["dateApplied"].toString()) : <any>undefined;
            this.gradeID = _data["gradeID"];
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.rejectedBy = _data["rejectedBy"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.leaveYear = _data["leaveYear"] ? LeaveYear.fromJS(_data["leaveYear"]) : <any>undefined;
            this.leaveType = _data["leaveType"] ? LeaveType.fromJS(_data["leaveType"]) : <any>undefined;
            this.grade = _data["grade"] ? Grade.fromJS(_data["grade"]) : <any>undefined;
            this.file = _data["file"];
            if (Array.isArray(_data["leaveHistory"])) {
                this.leaveHistory = [] as any;
                for (let item of _data["leaveHistory"])
                    this.leaveHistory!.push(LeaveRequest.fromJS(item));
            }
            if (Array.isArray(_data["leaveEntitlement"])) {
                this.leaveEntitlement = [] as any;
                for (let item of _data["leaveEntitlement"])
                    this.leaveEntitlement!.push(LeaveEntitlement.fromJS(item));
            }
            this.approvalDecision = _data["approvalDecision"];
            this.approvalStatus = _data["approvalStatus"];
            this.log_status = _data["log_status"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaveTypeID"] = this.leaveTypeID;
        data["employeeID"] = this.employeeID;
        data["employeeContractID"] = this.employeeContractID;
        data["employeeNumber"] = this.employeeNumber;
        data["leaveYearID"] = this.leaveYearID;
        data["leaveCalendarID"] = this.leaveCalendarID;
        data["initiatorComment"] = this.initiatorComment;
        data["contactInfoOnLeave"] = this.contactInfoOnLeave;
        data["reliefOfficer"] = this.reliefOfficer;
        data["reliefOfficerId"] = this.reliefOfficerId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["startDateString"] = this.startDateString;
        data["enddate"] = this.enddate ? this.enddate.toISOString() : <any>undefined;
        data["noOfDays"] = this.noOfDays;
        data["resumptionDate"] = this.resumptionDate ? this.resumptionDate.toISOString() : <any>undefined;
        data["dateApplied"] = this.dateApplied ? this.dateApplied.toISOString() : <any>undefined;
        data["gradeID"] = this.gradeID;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["rejectedBy"] = this.rejectedBy;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["leaveYear"] = this.leaveYear ? this.leaveYear.toJSON() : <any>undefined;
        data["leaveType"] = this.leaveType ? this.leaveType.toJSON() : <any>undefined;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        data["file"] = this.file;
        if (Array.isArray(this.leaveHistory)) {
            data["leaveHistory"] = [];
            for (let item of this.leaveHistory)
                data["leaveHistory"].push(item.toJSON());
        }
        if (Array.isArray(this.leaveEntitlement)) {
            data["leaveEntitlement"] = [];
            for (let item of this.leaveEntitlement)
                data["leaveEntitlement"].push(item.toJSON());
        }
        data["approvalDecision"] = this.approvalDecision;
        data["approvalStatus"] = this.approvalStatus;
        data["log_status"] = this.log_status;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveRequest {
        const json = this.toJSON();
        let result = new LeaveRequest();
        result.init(json);
        return result;
    }
}

export interface ILeaveRequest {
    leaveTypeID: number;
    employeeID: number;
    employeeContractID: number | undefined;
    employeeNumber: string | undefined;
    leaveYearID: number;
    leaveCalendarID: number;
    initiatorComment: string;
    contactInfoOnLeave: string;
    reliefOfficer: string;
    reliefOfficerId: number;
    startDate: Date;
    startDateString: string | undefined;
    enddate: Date;
    noOfDays: number;
    resumptionDate: Date;
    dateApplied: Date;
    gradeID: number;
    dateApproved: Date | undefined;
    rejectedBy: string | undefined;
    employee: Employee;
    leaveYear: LeaveYear;
    leaveType: LeaveType;
    grade: Grade;
    file: string | undefined;
    leaveHistory: LeaveRequest[] | undefined;
    leaveEntitlement: LeaveEntitlement[] | undefined;
    approvalDecision: string | undefined;
    approvalStatus: string | undefined;
    log_status: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveRequestApiResult implements ILeaveRequestApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveRequest;
    totalCount!: number;

    constructor(data?: ILeaveRequestApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveRequest.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveRequestApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveRequestApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveRequestApiResult {
        const json = this.toJSON();
        let result = new LeaveRequestApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveRequestApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveRequest;
    totalCount: number;
}

export class LeaveTypeDTO implements ILeaveTypeDTO {
    id!: number;
    name!: string | undefined;
    companyID!: number;
    subID!: number;
    isDeductableFromAnualLeave!: boolean;
    excludeWeekendInCalculation!: boolean;
    isOnlyAvailableToAdmin!: boolean;
    isAnnualLeave!: boolean;
    allowedGender!: number;
    maxDays!: number;
    minDays!: number;
    isSystemDefault!: boolean;
    maxNoofPossibleApplication!: number;
    maxNoofYearlyApplication!: number;
    isGradeDependent!: boolean;
    pro_rateLeaveDays!: boolean;
    onlyForConfirmStaff!: boolean;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isDeductableFromAnualLeave = _data["isDeductableFromAnualLeave"];
            this.excludeWeekendInCalculation = _data["excludeWeekendInCalculation"];
            this.isOnlyAvailableToAdmin = _data["isOnlyAvailableToAdmin"];
            this.isAnnualLeave = _data["isAnnualLeave"];
            this.allowedGender = _data["allowedGender"];
            this.maxDays = _data["maxDays"];
            this.minDays = _data["minDays"];
            this.isSystemDefault = _data["isSystemDefault"];
            this.maxNoofPossibleApplication = _data["maxNoofPossibleApplication"];
            this.maxNoofYearlyApplication = _data["maxNoofYearlyApplication"];
            this.isGradeDependent = _data["isGradeDependent"];
            this.pro_rateLeaveDays = _data["pro_rateLeaveDays"];
            this.onlyForConfirmStaff = _data["onlyForConfirmStaff"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isDeductableFromAnualLeave"] = this.isDeductableFromAnualLeave;
        data["excludeWeekendInCalculation"] = this.excludeWeekendInCalculation;
        data["isOnlyAvailableToAdmin"] = this.isOnlyAvailableToAdmin;
        data["isAnnualLeave"] = this.isAnnualLeave;
        data["allowedGender"] = this.allowedGender;
        data["maxDays"] = this.maxDays;
        data["minDays"] = this.minDays;
        data["isSystemDefault"] = this.isSystemDefault;
        data["maxNoofPossibleApplication"] = this.maxNoofPossibleApplication;
        data["maxNoofYearlyApplication"] = this.maxNoofYearlyApplication;
        data["isGradeDependent"] = this.isGradeDependent;
        data["pro_rateLeaveDays"] = this.pro_rateLeaveDays;
        data["onlyForConfirmStaff"] = this.onlyForConfirmStaff;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveTypeDTO {
        const json = this.toJSON();
        let result = new LeaveTypeDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeDTO {
    id: number;
    name: string | undefined;
    companyID: number;
    subID: number;
    isDeductableFromAnualLeave: boolean;
    excludeWeekendInCalculation: boolean;
    isOnlyAvailableToAdmin: boolean;
    isAnnualLeave: boolean;
    allowedGender: number;
    maxDays: number;
    minDays: number;
    isSystemDefault: boolean;
    maxNoofPossibleApplication: number;
    maxNoofYearlyApplication: number;
    isGradeDependent: boolean;
    pro_rateLeaveDays: boolean;
    onlyForConfirmStaff: boolean;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveTypeDTOListApiResult implements ILeaveTypeDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveTypeDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveTypeDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveTypeDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveTypeDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveTypeDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveTypeDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveTypeDTO[] | undefined;
    totalCount: number;
}

export class LeaveTypeCreatePayload implements ILeaveTypeCreatePayload {
    id!: number;
    name!: string;
    allowedGender!: number;
    maxDays!: number;
    minDays!: number;
    maxNoofPossibleApplication!: number;
    maxNoofYearlyApplication!: number;

    constructor(data?: ILeaveTypeCreatePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.allowedGender = _data["allowedGender"];
            this.maxDays = _data["maxDays"];
            this.minDays = _data["minDays"];
            this.maxNoofPossibleApplication = _data["maxNoofPossibleApplication"];
            this.maxNoofYearlyApplication = _data["maxNoofYearlyApplication"];
        }
    }

    static fromJS(data: any): LeaveTypeCreatePayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeCreatePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["allowedGender"] = this.allowedGender;
        data["maxDays"] = this.maxDays;
        data["minDays"] = this.minDays;
        data["maxNoofPossibleApplication"] = this.maxNoofPossibleApplication;
        data["maxNoofYearlyApplication"] = this.maxNoofYearlyApplication;
        return data; 
    }

    clone(): LeaveTypeCreatePayload {
        const json = this.toJSON();
        let result = new LeaveTypeCreatePayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeCreatePayload {
    id: number;
    name: string;
    allowedGender: number;
    maxDays: number;
    minDays: number;
    maxNoofPossibleApplication: number;
    maxNoofYearlyApplication: number;
}

export class LeaveTypeDTOApiResult implements ILeaveTypeDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveTypeDTO;
    totalCount!: number;

    constructor(data?: ILeaveTypeDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveTypeDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveTypeDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveTypeDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveTypeDTOApiResult {
        const json = this.toJSON();
        let result = new LeaveTypeDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveTypeDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveTypeDTO;
    totalCount: number;
}

export class JobRole implements IJobRole {
    name!: string;
    code!: string | undefined;
    amount!: number | undefined;
    promotion_min_years!: number | undefined;
    next_job_role_id!: number | undefined;
    created_by!: string | undefined;
    deleted_by!: string | undefined;
    parent_id!: number | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IJobRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.amount = _data["amount"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.next_job_role_id = _data["next_job_role_id"];
            this.created_by = _data["created_by"];
            this.deleted_by = _data["deleted_by"];
            this.parent_id = _data["parent_id"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): JobRole {
        data = typeof data === 'object' ? data : {};
        let result = new JobRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["amount"] = this.amount;
        data["promotion_min_years"] = this.promotion_min_years;
        data["next_job_role_id"] = this.next_job_role_id;
        data["created_by"] = this.created_by;
        data["deleted_by"] = this.deleted_by;
        data["parent_id"] = this.parent_id;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): JobRole {
        const json = this.toJSON();
        let result = new JobRole();
        result.init(json);
        return result;
    }
}

export interface IJobRole {
    name: string;
    code: string | undefined;
    amount: number | undefined;
    promotion_min_years: number | undefined;
    next_job_role_id: number | undefined;
    created_by: string | undefined;
    deleted_by: string | undefined;
    parent_id: number | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveWorkFlow implements ILeaveWorkFlow {
    departmentID!: number;
    workFlowName!: string | undefined;
    workFlowItems!: LeaveWorkFlowItem[] | undefined;
    department!: Department;
    workFlowString!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveWorkFlow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentID = _data["departmentID"];
            this.workFlowName = _data["workFlowName"];
            if (Array.isArray(_data["workFlowItems"])) {
                this.workFlowItems = [] as any;
                for (let item of _data["workFlowItems"])
                    this.workFlowItems!.push(LeaveWorkFlowItem.fromJS(item));
            }
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.workFlowString = _data["workFlowString"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveWorkFlow {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentID"] = this.departmentID;
        data["workFlowName"] = this.workFlowName;
        if (Array.isArray(this.workFlowItems)) {
            data["workFlowItems"] = [];
            for (let item of this.workFlowItems)
                data["workFlowItems"].push(item.toJSON());
        }
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["workFlowString"] = this.workFlowString;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveWorkFlow {
        const json = this.toJSON();
        let result = new LeaveWorkFlow();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlow {
    departmentID: number;
    workFlowName: string | undefined;
    workFlowItems: LeaveWorkFlowItem[] | undefined;
    department: Department;
    workFlowString: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveWorkFlowItem implements ILeaveWorkFlowItem {
    stepName!: string | undefined;
    jobRoleID!: number;
    leaveWorkFlowID!: number;
    rank!: number;
    isFinalApproval!: boolean;
    recipientName!: string | undefined;
    jobRole!: JobRole;
    leaveWorkFlow!: LeaveWorkFlow;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILeaveWorkFlowItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stepName = _data["stepName"];
            this.jobRoleID = _data["jobRoleID"];
            this.leaveWorkFlowID = _data["leaveWorkFlowID"];
            this.rank = _data["rank"];
            this.isFinalApproval = _data["isFinalApproval"];
            this.recipientName = _data["recipientName"];
            this.jobRole = _data["jobRole"] ? JobRole.fromJS(_data["jobRole"]) : <any>undefined;
            this.leaveWorkFlow = _data["leaveWorkFlow"] ? LeaveWorkFlow.fromJS(_data["leaveWorkFlow"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowItem {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stepName"] = this.stepName;
        data["jobRoleID"] = this.jobRoleID;
        data["leaveWorkFlowID"] = this.leaveWorkFlowID;
        data["rank"] = this.rank;
        data["isFinalApproval"] = this.isFinalApproval;
        data["recipientName"] = this.recipientName;
        data["jobRole"] = this.jobRole ? this.jobRole.toJSON() : <any>undefined;
        data["leaveWorkFlow"] = this.leaveWorkFlow ? this.leaveWorkFlow.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LeaveWorkFlowItem {
        const json = this.toJSON();
        let result = new LeaveWorkFlowItem();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowItem {
    stepName: string | undefined;
    jobRoleID: number;
    leaveWorkFlowID: number;
    rank: number;
    isFinalApproval: boolean;
    recipientName: string | undefined;
    jobRole: JobRole;
    leaveWorkFlow: LeaveWorkFlow;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LeaveWorkFlowResource implements ILeaveWorkFlowResource {
    departmentID!: number;
    workFlowName!: string | undefined;
    workFlowItems!: LeaveWorkFlowItem[] | undefined;
    department!: Department;
    workFlowString!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;

    constructor(data?: ILeaveWorkFlowResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentID = _data["departmentID"];
            this.workFlowName = _data["workFlowName"];
            if (Array.isArray(_data["workFlowItems"])) {
                this.workFlowItems = [] as any;
                for (let item of _data["workFlowItems"])
                    this.workFlowItems!.push(LeaveWorkFlowItem.fromJS(item));
            }
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.workFlowString = _data["workFlowString"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowResource {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentID"] = this.departmentID;
        data["workFlowName"] = this.workFlowName;
        if (Array.isArray(this.workFlowItems)) {
            data["workFlowItems"] = [];
            for (let item of this.workFlowItems)
                data["workFlowItems"].push(item.toJSON());
        }
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["workFlowString"] = this.workFlowString;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        return data; 
    }

    clone(): LeaveWorkFlowResource {
        const json = this.toJSON();
        let result = new LeaveWorkFlowResource();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowResource {
    departmentID: number;
    workFlowName: string | undefined;
    workFlowItems: LeaveWorkFlowItem[] | undefined;
    department: Department;
    workFlowString: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
}

export class LeaveWorkFlowResourceListApiResult implements ILeaveWorkFlowResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveWorkFlowResource[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveWorkFlowResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveWorkFlowResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveWorkFlowResourceListApiResult {
        const json = this.toJSON();
        let result = new LeaveWorkFlowResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveWorkFlowResource[] | undefined;
    totalCount: number;
}

export class LeaveWorkFlowResourceApiResult implements ILeaveWorkFlowResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveWorkFlowResource;
    totalCount!: number;

    constructor(data?: ILeaveWorkFlowResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveWorkFlowResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveWorkFlowResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveWorkFlowResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveWorkFlowResourceApiResult {
        const json = this.toJSON();
        let result = new LeaveWorkFlowResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveWorkFlowResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveWorkFlowResource;
    totalCount: number;
}

export class LeaveworkFlowPayload implements ILeaveworkFlowPayload {
    leaveWorkFlowID!: number;
    departmentID!: number;
    workFlowName!: string;
    workFlowString!: string;

    constructor(data?: ILeaveworkFlowPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.leaveWorkFlowID = _data["leaveWorkFlowID"];
            this.departmentID = _data["departmentID"];
            this.workFlowName = _data["workFlowName"];
            this.workFlowString = _data["workFlowString"];
        }
    }

    static fromJS(data: any): LeaveworkFlowPayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveworkFlowPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaveWorkFlowID"] = this.leaveWorkFlowID;
        data["departmentID"] = this.departmentID;
        data["workFlowName"] = this.workFlowName;
        data["workFlowString"] = this.workFlowString;
        return data; 
    }

    clone(): LeaveworkFlowPayload {
        const json = this.toJSON();
        let result = new LeaveworkFlowPayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveworkFlowPayload {
    leaveWorkFlowID: number;
    departmentID: number;
    workFlowName: string;
    workFlowString: string;
}

export class LeaveYearDTO implements ILeaveYearDTO {
    yearName!: string | undefined;
    isActiveYear!: boolean;
    yearStartDate!: Date;
    yearEndDate!: Date;
    log_status!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    create_contextyId!: number;
    dateModified!: Date | undefined;
    modifie_contextyId!: number | undefined;

    constructor(data?: ILeaveYearDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.yearName = _data["yearName"];
            this.isActiveYear = _data["isActiveYear"];
            this.yearStartDate = _data["yearStartDate"] ? new Date(_data["yearStartDate"].toString()) : <any>undefined;
            this.yearEndDate = _data["yearEndDate"] ? new Date(_data["yearEndDate"].toString()) : <any>undefined;
            this.log_status = _data["log_status"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.create_contextyId = _data["create_contextyId"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifie_contextyId = _data["modifie_contextyId"];
        }
    }

    static fromJS(data: any): LeaveYearDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yearName"] = this.yearName;
        data["isActiveYear"] = this.isActiveYear;
        data["yearStartDate"] = this.yearStartDate ? this.yearStartDate.toISOString() : <any>undefined;
        data["yearEndDate"] = this.yearEndDate ? this.yearEndDate.toISOString() : <any>undefined;
        data["log_status"] = this.log_status;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["create_contextyId"] = this.create_contextyId;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifie_contextyId"] = this.modifie_contextyId;
        return data; 
    }

    clone(): LeaveYearDTO {
        const json = this.toJSON();
        let result = new LeaveYearDTO();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearDTO {
    yearName: string | undefined;
    isActiveYear: boolean;
    yearStartDate: Date;
    yearEndDate: Date;
    log_status: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    create_contextyId: number;
    dateModified: Date | undefined;
    modifie_contextyId: number | undefined;
}

export class LeaveYearDTOListApiResult implements ILeaveYearDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveYearDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILeaveYearDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LeaveYearDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveYearDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveYearDTOListApiResult {
        const json = this.toJSON();
        let result = new LeaveYearDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveYearDTO[] | undefined;
    totalCount: number;
}

export class LeaveYearCreatePayload implements ILeaveYearCreatePayload {
    yearName!: string;
    isActiveYear!: boolean;
    yearStartDate!: Date;
    yearEndDate!: Date;

    constructor(data?: ILeaveYearCreatePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.yearName = _data["yearName"];
            this.isActiveYear = _data["isActiveYear"];
            this.yearStartDate = _data["yearStartDate"] ? new Date(_data["yearStartDate"].toString()) : <any>undefined;
            this.yearEndDate = _data["yearEndDate"] ? new Date(_data["yearEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LeaveYearCreatePayload {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearCreatePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yearName"] = this.yearName;
        data["isActiveYear"] = this.isActiveYear;
        data["yearStartDate"] = this.yearStartDate ? this.yearStartDate.toISOString() : <any>undefined;
        data["yearEndDate"] = this.yearEndDate ? this.yearEndDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): LeaveYearCreatePayload {
        const json = this.toJSON();
        let result = new LeaveYearCreatePayload();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearCreatePayload {
    yearName: string;
    isActiveYear: boolean;
    yearStartDate: Date;
    yearEndDate: Date;
}

export class LeaveYearDTOApiResult implements ILeaveYearDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LeaveYearDTO;
    totalCount!: number;

    constructor(data?: ILeaveYearDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LeaveYearDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LeaveYearDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveYearDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LeaveYearDTOApiResult {
        const json = this.toJSON();
        let result = new LeaveYearDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ILeaveYearDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LeaveYearDTO;
    totalCount: number;
}

export class LoanRequestDTO implements ILoanRequestDTO {
    id!: number;
    loanTypeId!: number;
    refNo!: string | undefined;
    employeeNo!: string | undefined;
    employeeName!: string | undefined;
    loanTypeName!: string | undefined;
    employeeId!: number;
    log_status!: number;
    is_disbursed!: boolean;
    is_active!: boolean;
    amount!: number;
    tenor!: number;
    totalPrincipalRepaid!: number;
    approvalProcessId!: number;
    requestedTenor!: number;
    approvedTenor!: number;
    strRequestedAmount!: string | undefined;
    strEffectiveDate!: string | undefined;
    tempRef!: string | undefined;
    strApprovedAmount!: string | undefined;
    strMaturityDate!: string | undefined;
    _ServerDocURL!: string | undefined;
    strGuarantorIds!: string | undefined;
    effectiveDate!: Date | undefined;
    outstandingPrincipal!: number;
    outstandingInterest!: number;
    requestedAmount!: number;
    approvedAmount!: number;
    autoDeduction!: boolean;
    customAnswer!: string | undefined;
    loggedForEmployeeId!: string | undefined;
    justification!: string | undefined;
    submittedByUserId!: number;

    constructor(data?: ILoanRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.loanTypeId = _data["loanTypeId"];
            this.refNo = _data["refNo"];
            this.employeeNo = _data["employeeNo"];
            this.employeeName = _data["employeeName"];
            this.loanTypeName = _data["loanTypeName"];
            this.employeeId = _data["employeeId"];
            this.log_status = _data["log_status"];
            this.is_disbursed = _data["is_disbursed"];
            this.is_active = _data["is_active"];
            this.amount = _data["amount"];
            this.tenor = _data["tenor"];
            this.totalPrincipalRepaid = _data["totalPrincipalRepaid"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.requestedTenor = _data["requestedTenor"];
            this.approvedTenor = _data["approvedTenor"];
            this.strRequestedAmount = _data["strRequestedAmount"];
            this.strEffectiveDate = _data["strEffectiveDate"];
            this.tempRef = _data["tempRef"];
            this.strApprovedAmount = _data["strApprovedAmount"];
            this.strMaturityDate = _data["strMaturityDate"];
            this._ServerDocURL = _data["_ServerDocURL"];
            this.strGuarantorIds = _data["strGuarantorIds"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.outstandingPrincipal = _data["outstandingPrincipal"];
            this.outstandingInterest = _data["outstandingInterest"];
            this.requestedAmount = _data["requestedAmount"];
            this.approvedAmount = _data["approvedAmount"];
            this.autoDeduction = _data["autoDeduction"];
            this.customAnswer = _data["customAnswer"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.justification = _data["justification"];
            this.submittedByUserId = _data["submittedByUserId"];
        }
    }

    static fromJS(data: any): LoanRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["loanTypeId"] = this.loanTypeId;
        data["refNo"] = this.refNo;
        data["employeeNo"] = this.employeeNo;
        data["employeeName"] = this.employeeName;
        data["loanTypeName"] = this.loanTypeName;
        data["employeeId"] = this.employeeId;
        data["log_status"] = this.log_status;
        data["is_disbursed"] = this.is_disbursed;
        data["is_active"] = this.is_active;
        data["amount"] = this.amount;
        data["tenor"] = this.tenor;
        data["totalPrincipalRepaid"] = this.totalPrincipalRepaid;
        data["approvalProcessId"] = this.approvalProcessId;
        data["requestedTenor"] = this.requestedTenor;
        data["approvedTenor"] = this.approvedTenor;
        data["strRequestedAmount"] = this.strRequestedAmount;
        data["strEffectiveDate"] = this.strEffectiveDate;
        data["tempRef"] = this.tempRef;
        data["strApprovedAmount"] = this.strApprovedAmount;
        data["strMaturityDate"] = this.strMaturityDate;
        data["_ServerDocURL"] = this._ServerDocURL;
        data["strGuarantorIds"] = this.strGuarantorIds;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["outstandingPrincipal"] = this.outstandingPrincipal;
        data["outstandingInterest"] = this.outstandingInterest;
        data["requestedAmount"] = this.requestedAmount;
        data["approvedAmount"] = this.approvedAmount;
        data["autoDeduction"] = this.autoDeduction;
        data["customAnswer"] = this.customAnswer;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["justification"] = this.justification;
        data["submittedByUserId"] = this.submittedByUserId;
        return data; 
    }

    clone(): LoanRequestDTO {
        const json = this.toJSON();
        let result = new LoanRequestDTO();
        result.init(json);
        return result;
    }
}

export interface ILoanRequestDTO {
    id: number;
    loanTypeId: number;
    refNo: string | undefined;
    employeeNo: string | undefined;
    employeeName: string | undefined;
    loanTypeName: string | undefined;
    employeeId: number;
    log_status: number;
    is_disbursed: boolean;
    is_active: boolean;
    amount: number;
    tenor: number;
    totalPrincipalRepaid: number;
    approvalProcessId: number;
    requestedTenor: number;
    approvedTenor: number;
    strRequestedAmount: string | undefined;
    strEffectiveDate: string | undefined;
    tempRef: string | undefined;
    strApprovedAmount: string | undefined;
    strMaturityDate: string | undefined;
    _ServerDocURL: string | undefined;
    strGuarantorIds: string | undefined;
    effectiveDate: Date | undefined;
    outstandingPrincipal: number;
    outstandingInterest: number;
    requestedAmount: number;
    approvedAmount: number;
    autoDeduction: boolean;
    customAnswer: string | undefined;
    loggedForEmployeeId: string | undefined;
    justification: string | undefined;
    submittedByUserId: number;
}

export class PostLoanDto implements IPostLoanDto {
    loan_id!: number;
    repaymentcomment!: string | undefined;
    repaymenttotalamt!: string | undefined;
    repaymenttype!: string | undefined;
    partamt!: string | undefined;
    repytdate!: string | undefined;

    constructor(data?: IPostLoanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loan_id = _data["loan_id"];
            this.repaymentcomment = _data["repaymentcomment"];
            this.repaymenttotalamt = _data["repaymenttotalamt"];
            this.repaymenttype = _data["repaymenttype"];
            this.partamt = _data["partamt"];
            this.repytdate = _data["repytdate"];
        }
    }

    static fromJS(data: any): PostLoanDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostLoanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loan_id"] = this.loan_id;
        data["repaymentcomment"] = this.repaymentcomment;
        data["repaymenttotalamt"] = this.repaymenttotalamt;
        data["repaymenttype"] = this.repaymenttype;
        data["partamt"] = this.partamt;
        data["repytdate"] = this.repytdate;
        return data; 
    }

    clone(): PostLoanDto {
        const json = this.toJSON();
        let result = new PostLoanDto();
        result.init(json);
        return result;
    }
}

export interface IPostLoanDto {
    loan_id: number;
    repaymentcomment: string | undefined;
    repaymenttotalamt: string | undefined;
    repaymenttype: string | undefined;
    partamt: string | undefined;
    repytdate: string | undefined;
}

export class LoanRepaymentLog implements ILoanRepaymentLog {
    id!: number;
    loanRequestId!: number;
    amountRepaid!: number;
    principalRepayment!: number;
    interestRepayment!: number;
    repaymentDate!: Date;
    repaymentType!: string | undefined;
    comment!: string | undefined;
    isSchedule!: boolean;
    strRepaymentDate!: string | undefined;

    constructor(data?: ILoanRepaymentLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.loanRequestId = _data["loanRequestId"];
            this.amountRepaid = _data["amountRepaid"];
            this.principalRepayment = _data["principalRepayment"];
            this.interestRepayment = _data["interestRepayment"];
            this.repaymentDate = _data["repaymentDate"] ? new Date(_data["repaymentDate"].toString()) : <any>undefined;
            this.repaymentType = _data["repaymentType"];
            this.comment = _data["comment"];
            this.isSchedule = _data["isSchedule"];
            this.strRepaymentDate = _data["strRepaymentDate"];
        }
    }

    static fromJS(data: any): LoanRepaymentLog {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRepaymentLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["loanRequestId"] = this.loanRequestId;
        data["amountRepaid"] = this.amountRepaid;
        data["principalRepayment"] = this.principalRepayment;
        data["interestRepayment"] = this.interestRepayment;
        data["repaymentDate"] = this.repaymentDate ? this.repaymentDate.toISOString() : <any>undefined;
        data["repaymentType"] = this.repaymentType;
        data["comment"] = this.comment;
        data["isSchedule"] = this.isSchedule;
        data["strRepaymentDate"] = this.strRepaymentDate;
        return data; 
    }

    clone(): LoanRepaymentLog {
        const json = this.toJSON();
        let result = new LoanRepaymentLog();
        result.init(json);
        return result;
    }
}

export interface ILoanRepaymentLog {
    id: number;
    loanRequestId: number;
    amountRepaid: number;
    principalRepayment: number;
    interestRepayment: number;
    repaymentDate: Date;
    repaymentType: string | undefined;
    comment: string | undefined;
    isSchedule: boolean;
    strRepaymentDate: string | undefined;
}

export class LoanRepaymentLogIListApiResult implements ILoanRepaymentLogIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanRepaymentLog[] | undefined;
    totalCount!: number;

    constructor(data?: ILoanRepaymentLogIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LoanRepaymentLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LoanRepaymentLogIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRepaymentLogIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LoanRepaymentLogIListApiResult {
        const json = this.toJSON();
        let result = new LoanRepaymentLogIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanRepaymentLogIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanRepaymentLog[] | undefined;
    totalCount: number;
}

export class LoanRequestDTOIListApiResult implements ILoanRequestDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanRequestDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILoanRequestDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LoanRequestDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LoanRequestDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequestDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LoanRequestDTOIListApiResult {
        const json = this.toJSON();
        let result = new LoanRequestDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanRequestDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanRequestDTO[] | undefined;
    totalCount: number;
}

export class IdNameObjIListApiResult implements IIdNameObjIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: IdNameObj[] | undefined;
    totalCount!: number;

    constructor(data?: IIdNameObjIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(IdNameObj.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): IdNameObjIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameObjIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): IdNameObjIListApiResult {
        const json = this.toJSON();
        let result = new IdNameObjIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IIdNameObjIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: IdNameObj[] | undefined;
    totalCount: number;
}

export class UpdateLoadRequestDTO implements IUpdateLoadRequestDTO {
    effective_date!: string | undefined;
    loan_id!: number;
    approved_tenor!: string | undefined;
    approved_amt!: string | undefined;

    constructor(data?: IUpdateLoadRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.effective_date = _data["effective_date"];
            this.loan_id = _data["loan_id"];
            this.approved_tenor = _data["approved_tenor"];
            this.approved_amt = _data["approved_amt"];
        }
    }

    static fromJS(data: any): UpdateLoadRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLoadRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["effective_date"] = this.effective_date;
        data["loan_id"] = this.loan_id;
        data["approved_tenor"] = this.approved_tenor;
        data["approved_amt"] = this.approved_amt;
        return data; 
    }

    clone(): UpdateLoadRequestDTO {
        const json = this.toJSON();
        let result = new UpdateLoadRequestDTO();
        result.init(json);
        return result;
    }
}

export interface IUpdateLoadRequestDTO {
    effective_date: string | undefined;
    loan_id: number;
    approved_tenor: string | undefined;
    approved_amt: string | undefined;
}

export class LoanRequest implements ILoanRequest {
    loanTypeId!: number;
    submittedByUserId!: number;
    loggedForEmployeeId!: number;
    refNo!: string | undefined;
    interestRate!: number;
    requestedAmount!: number;
    approvalProcessId!: number;
    interestType!: number;
    requestedTenor!: number;
    approvedTenor!: number;
    approvedAmount!: number;
    totalPrincipalRepaid!: number;
    totalInterestRepaid!: number;
    totalAmountRepaid!: number;
    lastRepaymentDate!: Date | undefined;
    effectiveDate!: Date | undefined;
    dateApproved!: Date | undefined;
    customAnswer!: string | undefined;
    justification!: string | undefined;
    log_status!: number;
    is_disbursed!: boolean;
    date_disbursed!: Date | undefined;
    autoDeduction!: boolean;
    maxLoanRepaytPercent!: number;
    maxLoanRepaytAmount!: number;
    is_repaid!: boolean;
    disbursementdetails!: string | undefined;
    disburseby!: string | undefined;
    disbursementType!: number | undefined;
    employeeNo!: string | undefined;
    employeeName!: string | undefined;
    loanTypeName!: string | undefined;
    strRequestedAmount!: string | undefined;
    strEffectiveDate!: string | undefined;
    tempRef!: string | undefined;
    strApprovedAmount!: string | undefined;
    strMaturityDate!: string | undefined;
    _ServerDocURL!: string | undefined;
    strGuarantorIds!: string | undefined;
    outstandingPrincipal!: number;
    outstandingInterest!: number;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILoanRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loanTypeId = _data["loanTypeId"];
            this.submittedByUserId = _data["submittedByUserId"];
            this.loggedForEmployeeId = _data["loggedForEmployeeId"];
            this.refNo = _data["refNo"];
            this.interestRate = _data["interestRate"];
            this.requestedAmount = _data["requestedAmount"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.interestType = _data["interestType"];
            this.requestedTenor = _data["requestedTenor"];
            this.approvedTenor = _data["approvedTenor"];
            this.approvedAmount = _data["approvedAmount"];
            this.totalPrincipalRepaid = _data["totalPrincipalRepaid"];
            this.totalInterestRepaid = _data["totalInterestRepaid"];
            this.totalAmountRepaid = _data["totalAmountRepaid"];
            this.lastRepaymentDate = _data["lastRepaymentDate"] ? new Date(_data["lastRepaymentDate"].toString()) : <any>undefined;
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.customAnswer = _data["customAnswer"];
            this.justification = _data["justification"];
            this.log_status = _data["log_status"];
            this.is_disbursed = _data["is_disbursed"];
            this.date_disbursed = _data["date_disbursed"] ? new Date(_data["date_disbursed"].toString()) : <any>undefined;
            this.autoDeduction = _data["autoDeduction"];
            this.maxLoanRepaytPercent = _data["maxLoanRepaytPercent"];
            this.maxLoanRepaytAmount = _data["maxLoanRepaytAmount"];
            this.is_repaid = _data["is_repaid"];
            this.disbursementdetails = _data["disbursementdetails"];
            this.disburseby = _data["disburseby"];
            this.disbursementType = _data["disbursementType"];
            this.employeeNo = _data["employeeNo"];
            this.employeeName = _data["employeeName"];
            this.loanTypeName = _data["loanTypeName"];
            this.strRequestedAmount = _data["strRequestedAmount"];
            this.strEffectiveDate = _data["strEffectiveDate"];
            this.tempRef = _data["tempRef"];
            this.strApprovedAmount = _data["strApprovedAmount"];
            this.strMaturityDate = _data["strMaturityDate"];
            this._ServerDocURL = _data["_ServerDocURL"];
            this.strGuarantorIds = _data["strGuarantorIds"];
            this.outstandingPrincipal = _data["outstandingPrincipal"];
            this.outstandingInterest = _data["outstandingInterest"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LoanRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loanTypeId"] = this.loanTypeId;
        data["submittedByUserId"] = this.submittedByUserId;
        data["loggedForEmployeeId"] = this.loggedForEmployeeId;
        data["refNo"] = this.refNo;
        data["interestRate"] = this.interestRate;
        data["requestedAmount"] = this.requestedAmount;
        data["approvalProcessId"] = this.approvalProcessId;
        data["interestType"] = this.interestType;
        data["requestedTenor"] = this.requestedTenor;
        data["approvedTenor"] = this.approvedTenor;
        data["approvedAmount"] = this.approvedAmount;
        data["totalPrincipalRepaid"] = this.totalPrincipalRepaid;
        data["totalInterestRepaid"] = this.totalInterestRepaid;
        data["totalAmountRepaid"] = this.totalAmountRepaid;
        data["lastRepaymentDate"] = this.lastRepaymentDate ? this.lastRepaymentDate.toISOString() : <any>undefined;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["customAnswer"] = this.customAnswer;
        data["justification"] = this.justification;
        data["log_status"] = this.log_status;
        data["is_disbursed"] = this.is_disbursed;
        data["date_disbursed"] = this.date_disbursed ? this.date_disbursed.toISOString() : <any>undefined;
        data["autoDeduction"] = this.autoDeduction;
        data["maxLoanRepaytPercent"] = this.maxLoanRepaytPercent;
        data["maxLoanRepaytAmount"] = this.maxLoanRepaytAmount;
        data["is_repaid"] = this.is_repaid;
        data["disbursementdetails"] = this.disbursementdetails;
        data["disburseby"] = this.disburseby;
        data["disbursementType"] = this.disbursementType;
        data["employeeNo"] = this.employeeNo;
        data["employeeName"] = this.employeeName;
        data["loanTypeName"] = this.loanTypeName;
        data["strRequestedAmount"] = this.strRequestedAmount;
        data["strEffectiveDate"] = this.strEffectiveDate;
        data["tempRef"] = this.tempRef;
        data["strApprovedAmount"] = this.strApprovedAmount;
        data["strMaturityDate"] = this.strMaturityDate;
        data["_ServerDocURL"] = this._ServerDocURL;
        data["strGuarantorIds"] = this.strGuarantorIds;
        data["outstandingPrincipal"] = this.outstandingPrincipal;
        data["outstandingInterest"] = this.outstandingInterest;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LoanRequest {
        const json = this.toJSON();
        let result = new LoanRequest();
        result.init(json);
        return result;
    }
}

export interface ILoanRequest {
    loanTypeId: number;
    submittedByUserId: number;
    loggedForEmployeeId: number;
    refNo: string | undefined;
    interestRate: number;
    requestedAmount: number;
    approvalProcessId: number;
    interestType: number;
    requestedTenor: number;
    approvedTenor: number;
    approvedAmount: number;
    totalPrincipalRepaid: number;
    totalInterestRepaid: number;
    totalAmountRepaid: number;
    lastRepaymentDate: Date | undefined;
    effectiveDate: Date | undefined;
    dateApproved: Date | undefined;
    customAnswer: string | undefined;
    justification: string | undefined;
    log_status: number;
    is_disbursed: boolean;
    date_disbursed: Date | undefined;
    autoDeduction: boolean;
    maxLoanRepaytPercent: number;
    maxLoanRepaytAmount: number;
    is_repaid: boolean;
    disbursementdetails: string | undefined;
    disburseby: string | undefined;
    disbursementType: number | undefined;
    employeeNo: string | undefined;
    employeeName: string | undefined;
    loanTypeName: string | undefined;
    strRequestedAmount: string | undefined;
    strEffectiveDate: string | undefined;
    tempRef: string | undefined;
    strApprovedAmount: string | undefined;
    strMaturityDate: string | undefined;
    _ServerDocURL: string | undefined;
    strGuarantorIds: string | undefined;
    outstandingPrincipal: number;
    outstandingInterest: number;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LoanRequestApiResult implements ILoanRequestApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanRequest;
    totalCount!: number;

    constructor(data?: ILoanRequestApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LoanRequest.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LoanRequestApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanRequestApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LoanRequestApiResult {
        const json = this.toJSON();
        let result = new LoanRequestApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanRequestApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanRequest;
    totalCount: number;
}

export class LoanTypeDTO implements ILoanTypeDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    code!: string | undefined;
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    approvalProcessId!: number;
    interestRate!: number;
    minTenor!: number;
    maxTenor!: number;
    minAmount!: number;
    maxAmount!: number;
    interestType!: number;
    requiresGuarantor!: boolean;
    requiredNoOfGuarantors!: number;
    eligibleGrades!: string | undefined;
    eligibleEmploymentStatus!: number;
    customQuestion!: string | undefined;
    maxLoanRepaytPercent!: number;
    strMinAmount!: string | undefined;
    strMaxAmount!: string | undefined;
    strRequiresGuarantor!: string | undefined;

    constructor(data?: ILoanTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.code = _data["code"];
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.interestRate = _data["interestRate"];
            this.minTenor = _data["minTenor"];
            this.maxTenor = _data["maxTenor"];
            this.minAmount = _data["minAmount"];
            this.maxAmount = _data["maxAmount"];
            this.interestType = _data["interestType"];
            this.requiresGuarantor = _data["requiresGuarantor"];
            this.requiredNoOfGuarantors = _data["requiredNoOfGuarantors"];
            this.eligibleGrades = _data["eligibleGrades"];
            this.eligibleEmploymentStatus = _data["eligibleEmploymentStatus"];
            this.customQuestion = _data["customQuestion"];
            this.maxLoanRepaytPercent = _data["maxLoanRepaytPercent"];
            this.strMinAmount = _data["strMinAmount"];
            this.strMaxAmount = _data["strMaxAmount"];
            this.strRequiresGuarantor = _data["strRequiresGuarantor"];
        }
    }

    static fromJS(data: any): LoanTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoanTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["code"] = this.code;
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["approvalProcessId"] = this.approvalProcessId;
        data["interestRate"] = this.interestRate;
        data["minTenor"] = this.minTenor;
        data["maxTenor"] = this.maxTenor;
        data["minAmount"] = this.minAmount;
        data["maxAmount"] = this.maxAmount;
        data["interestType"] = this.interestType;
        data["requiresGuarantor"] = this.requiresGuarantor;
        data["requiredNoOfGuarantors"] = this.requiredNoOfGuarantors;
        data["eligibleGrades"] = this.eligibleGrades;
        data["eligibleEmploymentStatus"] = this.eligibleEmploymentStatus;
        data["customQuestion"] = this.customQuestion;
        data["maxLoanRepaytPercent"] = this.maxLoanRepaytPercent;
        data["strMinAmount"] = this.strMinAmount;
        data["strMaxAmount"] = this.strMaxAmount;
        data["strRequiresGuarantor"] = this.strRequiresGuarantor;
        return data; 
    }

    clone(): LoanTypeDTO {
        const json = this.toJSON();
        let result = new LoanTypeDTO();
        result.init(json);
        return result;
    }
}

export interface ILoanTypeDTO {
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    code: string | undefined;
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    approvalProcessId: number;
    interestRate: number;
    minTenor: number;
    maxTenor: number;
    minAmount: number;
    maxAmount: number;
    interestType: number;
    requiresGuarantor: boolean;
    requiredNoOfGuarantors: number;
    eligibleGrades: string | undefined;
    eligibleEmploymentStatus: number;
    customQuestion: string | undefined;
    maxLoanRepaytPercent: number;
    strMinAmount: string | undefined;
    strMaxAmount: string | undefined;
    strRequiresGuarantor: string | undefined;
}

export class LoadTypeById implements ILoadTypeById {
    id!: number;
    companyID!: number;

    constructor(data?: ILoadTypeById) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
        }
    }

    static fromJS(data: any): LoadTypeById {
        data = typeof data === 'object' ? data : {};
        let result = new LoadTypeById();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        return data; 
    }

    clone(): LoadTypeById {
        const json = this.toJSON();
        let result = new LoadTypeById();
        result.init(json);
        return result;
    }
}

export interface ILoadTypeById {
    id: number;
    companyID: number;
}

export class LoanType implements ILoanType {
    code!: string | undefined;
    ledgerNo!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    approvalProcessId!: number;
    interestRate!: number;
    minTenor!: number;
    maxTenor!: number;
    minAmount!: number;
    maxAmount!: number;
    interestType!: number;
    requiresGuarantor!: boolean;
    requiredNoOfGuarantors!: number;
    eligibleGrades!: string | undefined;
    eligibleEmploymentStatus!: number;
    customQuestion!: string | undefined;
    maxLoanRepaytPercent!: number;
    strMinAmount!: string | undefined;
    strMaxAmount!: string | undefined;
    strRequiresGuarantor!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILoanType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.ledgerNo = _data["ledgerNo"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.interestRate = _data["interestRate"];
            this.minTenor = _data["minTenor"];
            this.maxTenor = _data["maxTenor"];
            this.minAmount = _data["minAmount"];
            this.maxAmount = _data["maxAmount"];
            this.interestType = _data["interestType"];
            this.requiresGuarantor = _data["requiresGuarantor"];
            this.requiredNoOfGuarantors = _data["requiredNoOfGuarantors"];
            this.eligibleGrades = _data["eligibleGrades"];
            this.eligibleEmploymentStatus = _data["eligibleEmploymentStatus"];
            this.customQuestion = _data["customQuestion"];
            this.maxLoanRepaytPercent = _data["maxLoanRepaytPercent"];
            this.strMinAmount = _data["strMinAmount"];
            this.strMaxAmount = _data["strMaxAmount"];
            this.strRequiresGuarantor = _data["strRequiresGuarantor"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LoanType {
        data = typeof data === 'object' ? data : {};
        let result = new LoanType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["ledgerNo"] = this.ledgerNo;
        data["name"] = this.name;
        data["description"] = this.description;
        data["approvalProcessId"] = this.approvalProcessId;
        data["interestRate"] = this.interestRate;
        data["minTenor"] = this.minTenor;
        data["maxTenor"] = this.maxTenor;
        data["minAmount"] = this.minAmount;
        data["maxAmount"] = this.maxAmount;
        data["interestType"] = this.interestType;
        data["requiresGuarantor"] = this.requiresGuarantor;
        data["requiredNoOfGuarantors"] = this.requiredNoOfGuarantors;
        data["eligibleGrades"] = this.eligibleGrades;
        data["eligibleEmploymentStatus"] = this.eligibleEmploymentStatus;
        data["customQuestion"] = this.customQuestion;
        data["maxLoanRepaytPercent"] = this.maxLoanRepaytPercent;
        data["strMinAmount"] = this.strMinAmount;
        data["strMaxAmount"] = this.strMaxAmount;
        data["strRequiresGuarantor"] = this.strRequiresGuarantor;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LoanType {
        const json = this.toJSON();
        let result = new LoanType();
        result.init(json);
        return result;
    }
}

export interface ILoanType {
    code: string | undefined;
    ledgerNo: string | undefined;
    name: string | undefined;
    description: string | undefined;
    approvalProcessId: number;
    interestRate: number;
    minTenor: number;
    maxTenor: number;
    minAmount: number;
    maxAmount: number;
    interestType: number;
    requiresGuarantor: boolean;
    requiredNoOfGuarantors: number;
    eligibleGrades: string | undefined;
    eligibleEmploymentStatus: number;
    customQuestion: string | undefined;
    maxLoanRepaytPercent: number;
    strMinAmount: string | undefined;
    strMaxAmount: string | undefined;
    strRequiresGuarantor: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LoanTypeIListApiResult implements ILoanTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LoanType[] | undefined;
    totalCount!: number;

    constructor(data?: ILoanTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LoanType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LoanTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoanTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LoanTypeIListApiResult {
        const json = this.toJSON();
        let result = new LoanTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILoanTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LoanType[] | undefined;
    totalCount: number;
}

export class ManageLocationDTO implements IManageLocationDTO {
    id!: number;
    location_name!: string;
    state_id!: number;
    lga_id!: number;
    is_enabled!: boolean;

    constructor(data?: IManageLocationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.location_name = _data["location_name"];
            this.state_id = _data["state_id"];
            this.lga_id = _data["lga_id"];
            this.is_enabled = _data["is_enabled"];
        }
    }

    static fromJS(data: any): ManageLocationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ManageLocationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["location_name"] = this.location_name;
        data["state_id"] = this.state_id;
        data["lga_id"] = this.lga_id;
        data["is_enabled"] = this.is_enabled;
        return data; 
    }

    clone(): ManageLocationDTO {
        const json = this.toJSON();
        let result = new ManageLocationDTO();
        result.init(json);
        return result;
    }
}

export interface IManageLocationDTO {
    id: number;
    location_name: string;
    state_id: number;
    lga_id: number;
    is_enabled: boolean;
}

export class LocationDTO implements ILocationDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    location_name!: string | undefined;
    lga_id!: number | undefined;
    state_id!: number | undefined;
    lga!: string | undefined;
    state!: string | undefined;
    is_enabled!: boolean;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ILocationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.location_name = _data["location_name"];
            this.lga_id = _data["lga_id"];
            this.state_id = _data["state_id"];
            this.lga = _data["lga"];
            this.state = _data["state"];
            this.is_enabled = _data["is_enabled"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): LocationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["location_name"] = this.location_name;
        data["lga_id"] = this.lga_id;
        data["state_id"] = this.state_id;
        data["lga"] = this.lga;
        data["state"] = this.state;
        data["is_enabled"] = this.is_enabled;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): LocationDTO {
        const json = this.toJSON();
        let result = new LocationDTO();
        result.init(json);
        return result;
    }
}

export interface ILocationDTO {
    id: number;
    companyID: number;
    subID: number;
    location_name: string | undefined;
    lga_id: number | undefined;
    state_id: number | undefined;
    lga: string | undefined;
    state: string | undefined;
    is_enabled: boolean;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class LocationDTOListApiResult implements ILocationDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LocationDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ILocationDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LocationDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LocationDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LocationDTOListApiResult {
        const json = this.toJSON();
        let result = new LocationDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ILocationDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LocationDTO[] | undefined;
    totalCount: number;
}

export class LocationDTOApiResult implements ILocationDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: LocationDTO;
    totalCount!: number;

    constructor(data?: ILocationDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? LocationDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LocationDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LocationDTOApiResult {
        const json = this.toJSON();
        let result = new LocationDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ILocationDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: LocationDTO;
    totalCount: number;
}

export class PerformanceCycleDTO implements IPerformanceCycleDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    name!: string;
    description!: string;
    reviewPurposeId!: number;
    appraisalTypeId!: number;
    ratingTypeId!: number;
    minRating!: number | undefined;
    maxRating!: number | undefined;
    departmentId!: number | undefined;
    locationId!: number | undefined;
    unitId!: number | undefined;
    cycleInfo!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    periodUnderReview!: string | undefined;
    lastPeriodUnderReview!: string | undefined;
    dueDate!: Date;
    dateStopped!: Date | undefined;
    frequencyId!: number;
    repeatKPI!: boolean;
    isNotify!: boolean;
    employeeCanSignOffOnManager!: boolean;
    recommendators!: string | undefined;
    commendators!: string | undefined;
    isStopped!: boolean;
    isManualSupervisorSetup!: boolean;
    status!: number;
    log_status!: number;
    approvalProcessId!: number;
    dateApproved!: Date | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;
    readonly statusType!: string | undefined;
    readonly reviewPurpose!: string | undefined;
    readonly appraisalType!: string | undefined;
    readonly ratingType!: string | undefined;

    constructor(data?: IPerformanceCycleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.reviewPurposeId = _data["reviewPurposeId"];
            this.appraisalTypeId = _data["appraisalTypeId"];
            this.ratingTypeId = _data["ratingTypeId"];
            this.minRating = _data["minRating"];
            this.maxRating = _data["maxRating"];
            this.departmentId = _data["departmentId"];
            this.locationId = _data["locationId"];
            this.unitId = _data["unitId"];
            this.cycleInfo = _data["cycleInfo"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.periodUnderReview = _data["periodUnderReview"];
            this.lastPeriodUnderReview = _data["lastPeriodUnderReview"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.dateStopped = _data["dateStopped"] ? new Date(_data["dateStopped"].toString()) : <any>undefined;
            this.frequencyId = _data["frequencyId"];
            this.repeatKPI = _data["repeatKPI"];
            this.isNotify = _data["isNotify"];
            this.employeeCanSignOffOnManager = _data["employeeCanSignOffOnManager"];
            this.recommendators = _data["recommendators"];
            this.commendators = _data["commendators"];
            this.isStopped = _data["isStopped"];
            this.isManualSupervisorSetup = _data["isManualSupervisorSetup"];
            this.status = _data["status"];
            this.log_status = _data["log_status"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.dateApproved = _data["dateApproved"] ? new Date(_data["dateApproved"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            (<any>this).statusType = _data["statusType"];
            (<any>this).reviewPurpose = _data["reviewPurpose"];
            (<any>this).appraisalType = _data["appraisalType"];
            (<any>this).ratingType = _data["ratingType"];
        }
    }

    static fromJS(data: any): PerformanceCycleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PerformanceCycleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["name"] = this.name;
        data["description"] = this.description;
        data["reviewPurposeId"] = this.reviewPurposeId;
        data["appraisalTypeId"] = this.appraisalTypeId;
        data["ratingTypeId"] = this.ratingTypeId;
        data["minRating"] = this.minRating;
        data["maxRating"] = this.maxRating;
        data["departmentId"] = this.departmentId;
        data["locationId"] = this.locationId;
        data["unitId"] = this.unitId;
        data["cycleInfo"] = this.cycleInfo;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["periodUnderReview"] = this.periodUnderReview;
        data["lastPeriodUnderReview"] = this.lastPeriodUnderReview;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["dateStopped"] = this.dateStopped ? this.dateStopped.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["repeatKPI"] = this.repeatKPI;
        data["isNotify"] = this.isNotify;
        data["employeeCanSignOffOnManager"] = this.employeeCanSignOffOnManager;
        data["recommendators"] = this.recommendators;
        data["commendators"] = this.commendators;
        data["isStopped"] = this.isStopped;
        data["isManualSupervisorSetup"] = this.isManualSupervisorSetup;
        data["status"] = this.status;
        data["log_status"] = this.log_status;
        data["approvalProcessId"] = this.approvalProcessId;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["statusType"] = this.statusType;
        data["reviewPurpose"] = this.reviewPurpose;
        data["appraisalType"] = this.appraisalType;
        data["ratingType"] = this.ratingType;
        return data; 
    }

    clone(): PerformanceCycleDTO {
        const json = this.toJSON();
        let result = new PerformanceCycleDTO();
        result.init(json);
        return result;
    }
}

export interface IPerformanceCycleDTO {
    id: number;
    companyID: number;
    subID: number;
    name: string;
    description: string;
    reviewPurposeId: number;
    appraisalTypeId: number;
    ratingTypeId: number;
    minRating: number | undefined;
    maxRating: number | undefined;
    departmentId: number | undefined;
    locationId: number | undefined;
    unitId: number | undefined;
    cycleInfo: string | undefined;
    startDate: Date;
    endDate: Date;
    periodUnderReview: string | undefined;
    lastPeriodUnderReview: string | undefined;
    dueDate: Date;
    dateStopped: Date | undefined;
    frequencyId: number;
    repeatKPI: boolean;
    isNotify: boolean;
    employeeCanSignOffOnManager: boolean;
    recommendators: string | undefined;
    commendators: string | undefined;
    isStopped: boolean;
    isManualSupervisorSetup: boolean;
    status: number;
    log_status: number;
    approvalProcessId: number;
    dateApproved: Date | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
    statusType: string | undefined;
    reviewPurpose: string | undefined;
    appraisalType: string | undefined;
    ratingType: string | undefined;
}

export class PerformanceCycleDTOIListApiResult implements IPerformanceCycleDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PerformanceCycleDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IPerformanceCycleDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PerformanceCycleDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PerformanceCycleDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PerformanceCycleDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PerformanceCycleDTOIListApiResult {
        const json = this.toJSON();
        let result = new PerformanceCycleDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IPerformanceCycleDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PerformanceCycleDTO[] | undefined;
    totalCount: number;
}

export class PerformanceCycleDTOApiResult implements IPerformanceCycleDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: PerformanceCycleDTO;
    totalCount!: number;

    constructor(data?: IPerformanceCycleDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? PerformanceCycleDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PerformanceCycleDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PerformanceCycleDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PerformanceCycleDTOApiResult {
        const json = this.toJSON();
        let result = new PerformanceCycleDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IPerformanceCycleDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: PerformanceCycleDTO;
    totalCount: number;
}

export class SelectListGroup implements ISelectListGroup {
    disabled!: boolean;
    name!: string | undefined;

    constructor(data?: ISelectListGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SelectListGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["name"] = this.name;
        return data; 
    }

    clone(): SelectListGroup {
        const json = this.toJSON();
        let result = new SelectListGroup();
        result.init(json);
        return result;
    }
}

export interface ISelectListGroup {
    disabled: boolean;
    name: string | undefined;
}

export class SelectListItem implements ISelectListItem {
    disabled!: boolean;
    group!: SelectListGroup;
    selected!: boolean;
    text!: string | undefined;
    value!: string | undefined;

    constructor(data?: ISelectListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.group = _data["group"] ? SelectListGroup.fromJS(_data["group"]) : <any>undefined;
            this.selected = _data["selected"];
            this.text = _data["text"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SelectListItem {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["selected"] = this.selected;
        data["text"] = this.text;
        data["value"] = this.value;
        return data; 
    }

    clone(): SelectListItem {
        const json = this.toJSON();
        let result = new SelectListItem();
        result.init(json);
        return result;
    }
}

export interface ISelectListItem {
    disabled: boolean;
    group: SelectListGroup;
    selected: boolean;
    text: string | undefined;
    value: string | undefined;
}

export class Sp_FetchEligibleEmployees implements ISp_FetchEligibleEmployees {
    current_position_id!: number | undefined;
    current_position!: string | undefined;
    period_in_current_postion!: string | undefined;
    years_in_current_position!: number | undefined;
    next_position!: string | undefined;
    next_position_id!: number | undefined;
    current_position_parent_id!: number | undefined;
    current_parent_position!: string | undefined;
    current_grade_id!: number | undefined;
    current_grade!: string | undefined;
    salaryScale!: string | undefined;
    id!: number | undefined;
    employee_contract_id!: number;
    eligiblility_id!: number | undefined;
    date_of_appointment!: Date | undefined;
    date_of_birth!: Date | undefined;
    date_of_confirmation!: Date | undefined;
    first_name!: string | undefined;
    last_name!: string | undefined;
    other_names!: string | undefined;
    profile_pic!: string | undefined;
    last_promotion_date!: Date | undefined;
    period_in_current_grade!: string | undefined;
    years_in_current_grade!: number | undefined;
    oracle_no!: string | undefined;
    professional_qualifications!: number | undefined;
    department!: string | undefined;
    location!: string | undefined;
    job_role!: string | undefined;
    is_submitted!: boolean;
    is_selected!: boolean;
    date_submitted!: Date | undefined;
    current_step!: string | undefined;
    current_step_id!: number | undefined;
    current_step_no!: number;
    next_grade!: string | undefined;
    next_step!: string | undefined;
    next_step_id!: number | undefined;
    salaryScaleId!: number | undefined;
    log_status!: string | undefined;
    log_status_id!: number;
    effective_date!: Date | undefined;
    str_effective_date!: string | undefined;

    constructor(data?: ISp_FetchEligibleEmployees) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.current_position_id = _data["current_position_id"];
            this.current_position = _data["current_position"];
            this.period_in_current_postion = _data["period_in_current_postion"];
            this.years_in_current_position = _data["years_in_current_position"];
            this.next_position = _data["next_position"];
            this.next_position_id = _data["next_position_id"];
            this.current_position_parent_id = _data["current_position_parent_id"];
            this.current_parent_position = _data["current_parent_position"];
            this.current_grade_id = _data["current_grade_id"];
            this.current_grade = _data["current_grade"];
            this.salaryScale = _data["salaryScale"];
            this.id = _data["id"];
            this.employee_contract_id = _data["employee_contract_id"];
            this.eligiblility_id = _data["eligiblility_id"];
            this.date_of_appointment = _data["date_of_appointment"] ? new Date(_data["date_of_appointment"].toString()) : <any>undefined;
            this.date_of_birth = _data["date_of_birth"] ? new Date(_data["date_of_birth"].toString()) : <any>undefined;
            this.date_of_confirmation = _data["date_of_confirmation"] ? new Date(_data["date_of_confirmation"].toString()) : <any>undefined;
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            this.other_names = _data["other_names"];
            this.profile_pic = _data["profile_pic"];
            this.last_promotion_date = _data["last_promotion_date"] ? new Date(_data["last_promotion_date"].toString()) : <any>undefined;
            this.period_in_current_grade = _data["period_in_current_grade"];
            this.years_in_current_grade = _data["years_in_current_grade"];
            this.oracle_no = _data["oracle_no"];
            this.professional_qualifications = _data["professional_qualifications"];
            this.department = _data["department"];
            this.location = _data["location"];
            this.job_role = _data["job_role"];
            this.is_submitted = _data["is_submitted"];
            this.is_selected = _data["is_selected"];
            this.date_submitted = _data["date_submitted"] ? new Date(_data["date_submitted"].toString()) : <any>undefined;
            this.current_step = _data["current_step"];
            this.current_step_id = _data["current_step_id"];
            this.current_step_no = _data["current_step_no"];
            this.next_grade = _data["next_grade"];
            this.next_step = _data["next_step"];
            this.next_step_id = _data["next_step_id"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.log_status = _data["log_status"];
            this.log_status_id = _data["log_status_id"];
            this.effective_date = _data["effective_date"] ? new Date(_data["effective_date"].toString()) : <any>undefined;
            this.str_effective_date = _data["str_effective_date"];
        }
    }

    static fromJS(data: any): Sp_FetchEligibleEmployees {
        data = typeof data === 'object' ? data : {};
        let result = new Sp_FetchEligibleEmployees();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["current_position_id"] = this.current_position_id;
        data["current_position"] = this.current_position;
        data["period_in_current_postion"] = this.period_in_current_postion;
        data["years_in_current_position"] = this.years_in_current_position;
        data["next_position"] = this.next_position;
        data["next_position_id"] = this.next_position_id;
        data["current_position_parent_id"] = this.current_position_parent_id;
        data["current_parent_position"] = this.current_parent_position;
        data["current_grade_id"] = this.current_grade_id;
        data["current_grade"] = this.current_grade;
        data["salaryScale"] = this.salaryScale;
        data["id"] = this.id;
        data["employee_contract_id"] = this.employee_contract_id;
        data["eligiblility_id"] = this.eligiblility_id;
        data["date_of_appointment"] = this.date_of_appointment ? this.date_of_appointment.toISOString() : <any>undefined;
        data["date_of_birth"] = this.date_of_birth ? this.date_of_birth.toISOString() : <any>undefined;
        data["date_of_confirmation"] = this.date_of_confirmation ? this.date_of_confirmation.toISOString() : <any>undefined;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["other_names"] = this.other_names;
        data["profile_pic"] = this.profile_pic;
        data["last_promotion_date"] = this.last_promotion_date ? this.last_promotion_date.toISOString() : <any>undefined;
        data["period_in_current_grade"] = this.period_in_current_grade;
        data["years_in_current_grade"] = this.years_in_current_grade;
        data["oracle_no"] = this.oracle_no;
        data["professional_qualifications"] = this.professional_qualifications;
        data["department"] = this.department;
        data["location"] = this.location;
        data["job_role"] = this.job_role;
        data["is_submitted"] = this.is_submitted;
        data["is_selected"] = this.is_selected;
        data["date_submitted"] = this.date_submitted ? this.date_submitted.toISOString() : <any>undefined;
        data["current_step"] = this.current_step;
        data["current_step_id"] = this.current_step_id;
        data["current_step_no"] = this.current_step_no;
        data["next_grade"] = this.next_grade;
        data["next_step"] = this.next_step;
        data["next_step_id"] = this.next_step_id;
        data["salaryScaleId"] = this.salaryScaleId;
        data["log_status"] = this.log_status;
        data["log_status_id"] = this.log_status_id;
        data["effective_date"] = this.effective_date ? this.effective_date.toISOString() : <any>undefined;
        data["str_effective_date"] = this.str_effective_date;
        return data; 
    }

    clone(): Sp_FetchEligibleEmployees {
        const json = this.toJSON();
        let result = new Sp_FetchEligibleEmployees();
        result.init(json);
        return result;
    }
}

export interface ISp_FetchEligibleEmployees {
    current_position_id: number | undefined;
    current_position: string | undefined;
    period_in_current_postion: string | undefined;
    years_in_current_position: number | undefined;
    next_position: string | undefined;
    next_position_id: number | undefined;
    current_position_parent_id: number | undefined;
    current_parent_position: string | undefined;
    current_grade_id: number | undefined;
    current_grade: string | undefined;
    salaryScale: string | undefined;
    id: number | undefined;
    employee_contract_id: number;
    eligiblility_id: number | undefined;
    date_of_appointment: Date | undefined;
    date_of_birth: Date | undefined;
    date_of_confirmation: Date | undefined;
    first_name: string | undefined;
    last_name: string | undefined;
    other_names: string | undefined;
    profile_pic: string | undefined;
    last_promotion_date: Date | undefined;
    period_in_current_grade: string | undefined;
    years_in_current_grade: number | undefined;
    oracle_no: string | undefined;
    professional_qualifications: number | undefined;
    department: string | undefined;
    location: string | undefined;
    job_role: string | undefined;
    is_submitted: boolean;
    is_selected: boolean;
    date_submitted: Date | undefined;
    current_step: string | undefined;
    current_step_id: number | undefined;
    current_step_no: number;
    next_grade: string | undefined;
    next_step: string | undefined;
    next_step_id: number | undefined;
    salaryScaleId: number | undefined;
    log_status: string | undefined;
    log_status_id: number;
    effective_date: Date | undefined;
    str_effective_date: string | undefined;
}

export class PromotionEligibilityViewModel implements IPromotionEligibilityViewModel {
    id!: number;
    company_id!: number;
    subsidiary_id!: number;
    name!: string;
    date_generated!: Date;
    generated_by!: string | undefined;
    submitted_by!: string | undefined;
    is_closed!: boolean;
    date_closed!: Date | undefined;
    closed_by!: string | undefined;
    comments!: string;
    noOfMembers!: number;
    is_active!: boolean;
    approvalProcessId!: number | undefined;
    actionTitle!: string | undefined;
    approvalWorkFlows!: SelectListItem[] | undefined;
    eligibles!: Sp_FetchEligibleEmployees[] | undefined;
    readonly strDateGenerated!: string | undefined;
    readonly isClosed!: string | undefined;
    readonly strDateClosed!: string | undefined;

    constructor(data?: IPromotionEligibilityViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.company_id = _data["company_id"];
            this.subsidiary_id = _data["subsidiary_id"];
            this.name = _data["name"];
            this.date_generated = _data["date_generated"] ? new Date(_data["date_generated"].toString()) : <any>undefined;
            this.generated_by = _data["generated_by"];
            this.submitted_by = _data["submitted_by"];
            this.is_closed = _data["is_closed"];
            this.date_closed = _data["date_closed"] ? new Date(_data["date_closed"].toString()) : <any>undefined;
            this.closed_by = _data["closed_by"];
            this.comments = _data["comments"];
            this.noOfMembers = _data["noOfMembers"];
            this.is_active = _data["is_active"];
            this.approvalProcessId = _data["approvalProcessId"];
            this.actionTitle = _data["actionTitle"];
            if (Array.isArray(_data["approvalWorkFlows"])) {
                this.approvalWorkFlows = [] as any;
                for (let item of _data["approvalWorkFlows"])
                    this.approvalWorkFlows!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["eligibles"])) {
                this.eligibles = [] as any;
                for (let item of _data["eligibles"])
                    this.eligibles!.push(Sp_FetchEligibleEmployees.fromJS(item));
            }
            (<any>this).strDateGenerated = _data["strDateGenerated"];
            (<any>this).isClosed = _data["isClosed"];
            (<any>this).strDateClosed = _data["strDateClosed"];
        }
    }

    static fromJS(data: any): PromotionEligibilityViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionEligibilityViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company_id"] = this.company_id;
        data["subsidiary_id"] = this.subsidiary_id;
        data["name"] = this.name;
        data["date_generated"] = this.date_generated ? this.date_generated.toISOString() : <any>undefined;
        data["generated_by"] = this.generated_by;
        data["submitted_by"] = this.submitted_by;
        data["is_closed"] = this.is_closed;
        data["date_closed"] = this.date_closed ? this.date_closed.toISOString() : <any>undefined;
        data["closed_by"] = this.closed_by;
        data["comments"] = this.comments;
        data["noOfMembers"] = this.noOfMembers;
        data["is_active"] = this.is_active;
        data["approvalProcessId"] = this.approvalProcessId;
        data["actionTitle"] = this.actionTitle;
        if (Array.isArray(this.approvalWorkFlows)) {
            data["approvalWorkFlows"] = [];
            for (let item of this.approvalWorkFlows)
                data["approvalWorkFlows"].push(item.toJSON());
        }
        if (Array.isArray(this.eligibles)) {
            data["eligibles"] = [];
            for (let item of this.eligibles)
                data["eligibles"].push(item.toJSON());
        }
        data["strDateGenerated"] = this.strDateGenerated;
        data["isClosed"] = this.isClosed;
        data["strDateClosed"] = this.strDateClosed;
        return data; 
    }

    clone(): PromotionEligibilityViewModel {
        const json = this.toJSON();
        let result = new PromotionEligibilityViewModel();
        result.init(json);
        return result;
    }
}

export interface IPromotionEligibilityViewModel {
    id: number;
    company_id: number;
    subsidiary_id: number;
    name: string;
    date_generated: Date;
    generated_by: string | undefined;
    submitted_by: string | undefined;
    is_closed: boolean;
    date_closed: Date | undefined;
    closed_by: string | undefined;
    comments: string;
    noOfMembers: number;
    is_active: boolean;
    approvalProcessId: number | undefined;
    actionTitle: string | undefined;
    approvalWorkFlows: SelectListItem[] | undefined;
    eligibles: Sp_FetchEligibleEmployees[] | undefined;
    strDateGenerated: string | undefined;
    isClosed: string | undefined;
    strDateClosed: string | undefined;
}

export class Sp_FetchEligibleEmployeesIListApiResult implements ISp_FetchEligibleEmployeesIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Sp_FetchEligibleEmployees[] | undefined;
    totalCount!: number;

    constructor(data?: ISp_FetchEligibleEmployeesIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Sp_FetchEligibleEmployees.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): Sp_FetchEligibleEmployeesIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new Sp_FetchEligibleEmployeesIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): Sp_FetchEligibleEmployeesIListApiResult {
        const json = this.toJSON();
        let result = new Sp_FetchEligibleEmployeesIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISp_FetchEligibleEmployeesIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Sp_FetchEligibleEmployees[] | undefined;
    totalCount: number;
}

export class VwGradeSteps implements IVwGradeSteps {
    id!: number;
    companyID!: number;
    subID!: number;
    grade_id!: number;
    name!: string;
    grade_name!: string | undefined;
    promotion_min_years!: number;
    dateCreated!: Date;
    salary_scale_id!: number;
    salary_scale!: string | undefined;
    next_grade_step_id!: number | undefined;
    next_grade_step!: string | undefined;
    step_no!: number;
    created_by!: string | undefined;
    ministry_id!: number;
    isDeleted!: boolean;
    isActive!: boolean;
    actionTitle!: string | undefined;
    allGradeSteps!: SelectListItem[] | undefined;
    nextGradeSteps!: SelectListItem[] | undefined;

    constructor(data?: IVwGradeSteps) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.grade_id = _data["grade_id"];
            this.name = _data["name"];
            this.grade_name = _data["grade_name"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.salary_scale_id = _data["salary_scale_id"];
            this.salary_scale = _data["salary_scale"];
            this.next_grade_step_id = _data["next_grade_step_id"];
            this.next_grade_step = _data["next_grade_step"];
            this.step_no = _data["step_no"];
            this.created_by = _data["created_by"];
            this.ministry_id = _data["ministry_id"];
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.actionTitle = _data["actionTitle"];
            if (Array.isArray(_data["allGradeSteps"])) {
                this.allGradeSteps = [] as any;
                for (let item of _data["allGradeSteps"])
                    this.allGradeSteps!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["nextGradeSteps"])) {
                this.nextGradeSteps = [] as any;
                for (let item of _data["nextGradeSteps"])
                    this.nextGradeSteps!.push(SelectListItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VwGradeSteps {
        data = typeof data === 'object' ? data : {};
        let result = new VwGradeSteps();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["grade_id"] = this.grade_id;
        data["name"] = this.name;
        data["grade_name"] = this.grade_name;
        data["promotion_min_years"] = this.promotion_min_years;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["salary_scale_id"] = this.salary_scale_id;
        data["salary_scale"] = this.salary_scale;
        data["next_grade_step_id"] = this.next_grade_step_id;
        data["next_grade_step"] = this.next_grade_step;
        data["step_no"] = this.step_no;
        data["created_by"] = this.created_by;
        data["ministry_id"] = this.ministry_id;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["actionTitle"] = this.actionTitle;
        if (Array.isArray(this.allGradeSteps)) {
            data["allGradeSteps"] = [];
            for (let item of this.allGradeSteps)
                data["allGradeSteps"].push(item.toJSON());
        }
        if (Array.isArray(this.nextGradeSteps)) {
            data["nextGradeSteps"] = [];
            for (let item of this.nextGradeSteps)
                data["nextGradeSteps"].push(item.toJSON());
        }
        return data; 
    }

    clone(): VwGradeSteps {
        const json = this.toJSON();
        let result = new VwGradeSteps();
        result.init(json);
        return result;
    }
}

export interface IVwGradeSteps {
    id: number;
    companyID: number;
    subID: number;
    grade_id: number;
    name: string;
    grade_name: string | undefined;
    promotion_min_years: number;
    dateCreated: Date;
    salary_scale_id: number;
    salary_scale: string | undefined;
    next_grade_step_id: number | undefined;
    next_grade_step: string | undefined;
    step_no: number;
    created_by: string | undefined;
    ministry_id: number;
    isDeleted: boolean;
    isActive: boolean;
    actionTitle: string | undefined;
    allGradeSteps: SelectListItem[] | undefined;
    nextGradeSteps: SelectListItem[] | undefined;
}

export class VwPosition implements IVwPosition {
    id!: number;
    companyID!: number;
    subID!: number;
    locationId!: number;
    dateCreated!: Date;
    title!: string;
    amount!: number | undefined;
    promotion_min_years!: number | undefined;
    promotion_min_in_days!: number;
    min_years_experience!: number | undefined;
    min_years_experience_in_days!: number;
    next_position_id!: number | undefined;
    next_position!: string | undefined;
    parent_position!: string | undefined;
    description!: string;
    parent_id!: number | undefined;
    actionTitle!: string | undefined;
    isDeleted!: boolean;
    isActive!: boolean;
    mdaCode!: string | undefined;
    qualifications!: SelectListItem[] | undefined;
    certifications!: SelectListItem[] | undefined;
    skills!: SelectListItem[] | undefined;
    selectedQualifications!: number[] | undefined;
    selectedCertifications!: number[] | undefined;
    selectedSkills!: number[] | undefined;
    has_requirement!: boolean;
    allPositions!: SelectListItem[] | undefined;
    nextPositions!: SelectListItem[] | undefined;

    constructor(data?: IVwPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.locationId = _data["locationId"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.amount = _data["amount"];
            this.promotion_min_years = _data["promotion_min_years"];
            this.promotion_min_in_days = _data["promotion_min_in_days"];
            this.min_years_experience = _data["min_years_experience"];
            this.min_years_experience_in_days = _data["min_years_experience_in_days"];
            this.next_position_id = _data["next_position_id"];
            this.next_position = _data["next_position"];
            this.parent_position = _data["parent_position"];
            this.description = _data["description"];
            this.parent_id = _data["parent_id"];
            this.actionTitle = _data["actionTitle"];
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
            this.mdaCode = _data["mdaCode"];
            if (Array.isArray(_data["qualifications"])) {
                this.qualifications = [] as any;
                for (let item of _data["qualifications"])
                    this.qualifications!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["certifications"])) {
                this.certifications = [] as any;
                for (let item of _data["certifications"])
                    this.certifications!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["selectedQualifications"])) {
                this.selectedQualifications = [] as any;
                for (let item of _data["selectedQualifications"])
                    this.selectedQualifications!.push(item);
            }
            if (Array.isArray(_data["selectedCertifications"])) {
                this.selectedCertifications = [] as any;
                for (let item of _data["selectedCertifications"])
                    this.selectedCertifications!.push(item);
            }
            if (Array.isArray(_data["selectedSkills"])) {
                this.selectedSkills = [] as any;
                for (let item of _data["selectedSkills"])
                    this.selectedSkills!.push(item);
            }
            this.has_requirement = _data["has_requirement"];
            if (Array.isArray(_data["allPositions"])) {
                this.allPositions = [] as any;
                for (let item of _data["allPositions"])
                    this.allPositions!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["nextPositions"])) {
                this.nextPositions = [] as any;
                for (let item of _data["nextPositions"])
                    this.nextPositions!.push(SelectListItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VwPosition {
        data = typeof data === 'object' ? data : {};
        let result = new VwPosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["locationId"] = this.locationId;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["amount"] = this.amount;
        data["promotion_min_years"] = this.promotion_min_years;
        data["promotion_min_in_days"] = this.promotion_min_in_days;
        data["min_years_experience"] = this.min_years_experience;
        data["min_years_experience_in_days"] = this.min_years_experience_in_days;
        data["next_position_id"] = this.next_position_id;
        data["next_position"] = this.next_position;
        data["parent_position"] = this.parent_position;
        data["description"] = this.description;
        data["parent_id"] = this.parent_id;
        data["actionTitle"] = this.actionTitle;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        data["mdaCode"] = this.mdaCode;
        if (Array.isArray(this.qualifications)) {
            data["qualifications"] = [];
            for (let item of this.qualifications)
                data["qualifications"].push(item.toJSON());
        }
        if (Array.isArray(this.certifications)) {
            data["certifications"] = [];
            for (let item of this.certifications)
                data["certifications"].push(item.toJSON());
        }
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedQualifications)) {
            data["selectedQualifications"] = [];
            for (let item of this.selectedQualifications)
                data["selectedQualifications"].push(item);
        }
        if (Array.isArray(this.selectedCertifications)) {
            data["selectedCertifications"] = [];
            for (let item of this.selectedCertifications)
                data["selectedCertifications"].push(item);
        }
        if (Array.isArray(this.selectedSkills)) {
            data["selectedSkills"] = [];
            for (let item of this.selectedSkills)
                data["selectedSkills"].push(item);
        }
        data["has_requirement"] = this.has_requirement;
        if (Array.isArray(this.allPositions)) {
            data["allPositions"] = [];
            for (let item of this.allPositions)
                data["allPositions"].push(item.toJSON());
        }
        if (Array.isArray(this.nextPositions)) {
            data["nextPositions"] = [];
            for (let item of this.nextPositions)
                data["nextPositions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): VwPosition {
        const json = this.toJSON();
        let result = new VwPosition();
        result.init(json);
        return result;
    }
}

export interface IVwPosition {
    id: number;
    companyID: number;
    subID: number;
    locationId: number;
    dateCreated: Date;
    title: string;
    amount: number | undefined;
    promotion_min_years: number | undefined;
    promotion_min_in_days: number;
    min_years_experience: number | undefined;
    min_years_experience_in_days: number;
    next_position_id: number | undefined;
    next_position: string | undefined;
    parent_position: string | undefined;
    description: string;
    parent_id: number | undefined;
    actionTitle: string | undefined;
    isDeleted: boolean;
    isActive: boolean;
    mdaCode: string | undefined;
    qualifications: SelectListItem[] | undefined;
    certifications: SelectListItem[] | undefined;
    skills: SelectListItem[] | undefined;
    selectedQualifications: number[] | undefined;
    selectedCertifications: number[] | undefined;
    selectedSkills: number[] | undefined;
    has_requirement: boolean;
    allPositions: SelectListItem[] | undefined;
    nextPositions: SelectListItem[] | undefined;
}

export class VwPromotionSchedule implements IVwPromotionSchedule {
    companyId!: number;
    subsidiaryId!: number;
    eligibilityId!: number;
    parentPositionId!: number;
    promotionCategoryId!: number;
    eligibilityName!: string | undefined;
    isClosed!: boolean;
    eligibeEmployees!: Sp_FetchEligibleEmployees[] | undefined;
    gradeSteps!: VwGradeSteps[] | undefined;
    parentPositions!: SelectListItem[] | undefined;
    positions!: VwPosition[] | undefined;
    promotionCategorys!: SelectListItem[] | undefined;

    constructor(data?: IVwPromotionSchedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.subsidiaryId = _data["subsidiaryId"];
            this.eligibilityId = _data["eligibilityId"];
            this.parentPositionId = _data["parentPositionId"];
            this.promotionCategoryId = _data["promotionCategoryId"];
            this.eligibilityName = _data["eligibilityName"];
            this.isClosed = _data["isClosed"];
            if (Array.isArray(_data["eligibeEmployees"])) {
                this.eligibeEmployees = [] as any;
                for (let item of _data["eligibeEmployees"])
                    this.eligibeEmployees!.push(Sp_FetchEligibleEmployees.fromJS(item));
            }
            if (Array.isArray(_data["gradeSteps"])) {
                this.gradeSteps = [] as any;
                for (let item of _data["gradeSteps"])
                    this.gradeSteps!.push(VwGradeSteps.fromJS(item));
            }
            if (Array.isArray(_data["parentPositions"])) {
                this.parentPositions = [] as any;
                for (let item of _data["parentPositions"])
                    this.parentPositions!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["positions"])) {
                this.positions = [] as any;
                for (let item of _data["positions"])
                    this.positions!.push(VwPosition.fromJS(item));
            }
            if (Array.isArray(_data["promotionCategorys"])) {
                this.promotionCategorys = [] as any;
                for (let item of _data["promotionCategorys"])
                    this.promotionCategorys!.push(SelectListItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VwPromotionSchedule {
        data = typeof data === 'object' ? data : {};
        let result = new VwPromotionSchedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["subsidiaryId"] = this.subsidiaryId;
        data["eligibilityId"] = this.eligibilityId;
        data["parentPositionId"] = this.parentPositionId;
        data["promotionCategoryId"] = this.promotionCategoryId;
        data["eligibilityName"] = this.eligibilityName;
        data["isClosed"] = this.isClosed;
        if (Array.isArray(this.eligibeEmployees)) {
            data["eligibeEmployees"] = [];
            for (let item of this.eligibeEmployees)
                data["eligibeEmployees"].push(item.toJSON());
        }
        if (Array.isArray(this.gradeSteps)) {
            data["gradeSteps"] = [];
            for (let item of this.gradeSteps)
                data["gradeSteps"].push(item.toJSON());
        }
        if (Array.isArray(this.parentPositions)) {
            data["parentPositions"] = [];
            for (let item of this.parentPositions)
                data["parentPositions"].push(item.toJSON());
        }
        if (Array.isArray(this.positions)) {
            data["positions"] = [];
            for (let item of this.positions)
                data["positions"].push(item.toJSON());
        }
        if (Array.isArray(this.promotionCategorys)) {
            data["promotionCategorys"] = [];
            for (let item of this.promotionCategorys)
                data["promotionCategorys"].push(item.toJSON());
        }
        return data; 
    }

    clone(): VwPromotionSchedule {
        const json = this.toJSON();
        let result = new VwPromotionSchedule();
        result.init(json);
        return result;
    }
}

export interface IVwPromotionSchedule {
    companyId: number;
    subsidiaryId: number;
    eligibilityId: number;
    parentPositionId: number;
    promotionCategoryId: number;
    eligibilityName: string | undefined;
    isClosed: boolean;
    eligibeEmployees: Sp_FetchEligibleEmployees[] | undefined;
    gradeSteps: VwGradeSteps[] | undefined;
    parentPositions: SelectListItem[] | undefined;
    positions: VwPosition[] | undefined;
    promotionCategorys: SelectListItem[] | undefined;
}

export class VwPromotionScheduleApiResult implements IVwPromotionScheduleApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: VwPromotionSchedule;
    totalCount!: number;

    constructor(data?: IVwPromotionScheduleApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? VwPromotionSchedule.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VwPromotionScheduleApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new VwPromotionScheduleApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): VwPromotionScheduleApiResult {
        const json = this.toJSON();
        let result = new VwPromotionScheduleApiResult();
        result.init(json);
        return result;
    }
}

export interface IVwPromotionScheduleApiResult {
    hasError: boolean;
    message: string | undefined;
    result: VwPromotionSchedule;
    totalCount: number;
}

export class RatingDTO implements IRatingDTO {
    id!: number;
    companyID!: number;
    subID!: number;
    scoreFrom!: number;
    scoreTo!: number;
    grade!: string | undefined;
    description!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRatingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.scoreFrom = _data["scoreFrom"];
            this.scoreTo = _data["scoreTo"];
            this.grade = _data["grade"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RatingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RatingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["scoreFrom"] = this.scoreFrom;
        data["scoreTo"] = this.scoreTo;
        data["grade"] = this.grade;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RatingDTO {
        const json = this.toJSON();
        let result = new RatingDTO();
        result.init(json);
        return result;
    }
}

export interface IRatingDTO {
    id: number;
    companyID: number;
    subID: number;
    scoreFrom: number;
    scoreTo: number;
    grade: string | undefined;
    description: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RatingDTOIListApiResult implements IRatingDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RatingDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IRatingDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RatingDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RatingDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RatingDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RatingDTOIListApiResult {
        const json = this.toJSON();
        let result = new RatingDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRatingDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RatingDTO[] | undefined;
    totalCount: number;
}

export class AddRequestViewModel implements IAddRequestViewModel {
    id!: number;
    name!: string | undefined;
    typeId!: string | undefined;
    approval!: string | undefined;
    processid!: number;
    code!: string | undefined;
    enable_step_notify!: boolean;
    is_system_requirement!: boolean;

    constructor(data?: IAddRequestViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.approval = _data["approval"];
            this.processid = _data["processid"];
            this.code = _data["code"];
            this.enable_step_notify = _data["enable_step_notify"];
            this.is_system_requirement = _data["is_system_requirement"];
        }
    }

    static fromJS(data: any): AddRequestViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddRequestViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["approval"] = this.approval;
        data["processid"] = this.processid;
        data["code"] = this.code;
        data["enable_step_notify"] = this.enable_step_notify;
        data["is_system_requirement"] = this.is_system_requirement;
        return data; 
    }

    clone(): AddRequestViewModel {
        const json = this.toJSON();
        let result = new AddRequestViewModel();
        result.init(json);
        return result;
    }
}

export interface IAddRequestViewModel {
    id: number;
    name: string | undefined;
    typeId: string | undefined;
    approval: string | undefined;
    processid: number;
    code: string | undefined;
    enable_step_notify: boolean;
    is_system_requirement: boolean;
}

export class RequestItemViewModel implements IRequestItemViewModel {
    requestType!: string | undefined;
    employeeName!: string | undefined;
    refNo!: string | undefined;
    title!: string | undefined;
    request_date!: Date;
    log_status!: number;
    resolution!: string | undefined;
    dateCreated!: Date;
    id!: number;

    constructor(data?: IRequestItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestType = _data["requestType"];
            this.employeeName = _data["employeeName"];
            this.refNo = _data["refNo"];
            this.title = _data["title"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.log_status = _data["log_status"];
            this.resolution = _data["resolution"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RequestItemViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestItemViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestType"] = this.requestType;
        data["employeeName"] = this.employeeName;
        data["refNo"] = this.refNo;
        data["title"] = this.title;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["log_status"] = this.log_status;
        data["resolution"] = this.resolution;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RequestItemViewModel {
        const json = this.toJSON();
        let result = new RequestItemViewModel();
        result.init(json);
        return result;
    }
}

export interface IRequestItemViewModel {
    requestType: string | undefined;
    employeeName: string | undefined;
    refNo: string | undefined;
    title: string | undefined;
    request_date: Date;
    log_status: number;
    resolution: string | undefined;
    dateCreated: Date;
    id: number;
}

export class RequestViewModel implements IRequestViewModel {
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    log_Status!: number;
    lstOfRequests!: RequestItemViewModel[] | undefined;

    constructor(data?: IRequestViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.log_Status = _data["log_Status"];
            if (Array.isArray(_data["lstOfRequests"])) {
                this.lstOfRequests = [] as any;
                for (let item of _data["lstOfRequests"])
                    this.lstOfRequests!.push(RequestItemViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["log_Status"] = this.log_Status;
        if (Array.isArray(this.lstOfRequests)) {
            data["lstOfRequests"] = [];
            for (let item of this.lstOfRequests)
                data["lstOfRequests"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RequestViewModel {
        const json = this.toJSON();
        let result = new RequestViewModel();
        result.init(json);
        return result;
    }
}

export interface IRequestViewModel {
    startDate: Date | undefined;
    endDate: Date | undefined;
    log_Status: number;
    lstOfRequests: RequestItemViewModel[] | undefined;
}

export class RequestViewModelIListApiResult implements IRequestViewModelIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestViewModel[] | undefined;
    totalCount!: number;

    constructor(data?: IRequestViewModelIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RequestViewModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RequestViewModelIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestViewModelIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RequestViewModelIListApiResult {
        const json = this.toJSON();
        let result = new RequestViewModelIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestViewModelIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestViewModel[] | undefined;
    totalCount: number;
}

export class RequestType implements IRequestType {
    name!: string;
    typeId!: string | undefined;
    approval!: string | undefined;
    processid!: number;
    code!: string | undefined;
    enable_step_notify!: boolean;
    is_system_requirement!: boolean;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRequestType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.approval = _data["approval"];
            this.processid = _data["processid"];
            this.code = _data["code"];
            this.enable_step_notify = _data["enable_step_notify"];
            this.is_system_requirement = _data["is_system_requirement"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RequestType {
        data = typeof data === 'object' ? data : {};
        let result = new RequestType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["approval"] = this.approval;
        data["processid"] = this.processid;
        data["code"] = this.code;
        data["enable_step_notify"] = this.enable_step_notify;
        data["is_system_requirement"] = this.is_system_requirement;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RequestType {
        const json = this.toJSON();
        let result = new RequestType();
        result.init(json);
        return result;
    }
}

export interface IRequestType {
    name: string;
    typeId: string | undefined;
    approval: string | undefined;
    processid: number;
    code: string | undefined;
    enable_step_notify: boolean;
    is_system_requirement: boolean;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmployeeContractAssignment implements IEmployeeContractAssignment {
    assignmentNumber!: string;
    employeeId!: number;
    supervisorId!: number | undefined;
    departmentId!: number | undefined;
    payRollTypeId!: number | undefined;
    jobId!: number | undefined;
    gradeId!: number | undefined;
    gradeStepId!: number | undefined;
    locationId!: number | undefined;
    positionId!: number | undefined;
    ministryId!: number | undefined;
    employmentTypeId!: number;
    contractEndDate!: Date | undefined;
    salaryScaleId!: number;
    dateofPresentAppointment!: Date;
    dateOfAppointment!: Date;
    dateOfLastDeployment!: Date | undefined;
    dateOfConversion!: Date | undefined;
    dateOfConfirmation!: Date | undefined;
    dateDeployed!: Date | undefined;
    datePromotion!: Date | undefined;
    dateOfRetirement!: Date | undefined;
    retirementTypeId!: number | undefined;
    isContractActive!: boolean;
    isDefaultContract!: boolean;
    noOfLeaveDays!: number | undefined;
    peopleGroupId!: number | undefined;
    lastPromotionDate!: Date | undefined;
    schoolId!: number | undefined;
    unitId!: number | undefined;
    cadreID!: number | undefined;
    directorateID!: number | undefined;
    lcdaID!: number | undefined;
    isOffPayrolled!: number | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IEmployeeContractAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assignmentNumber = _data["assignmentNumber"];
            this.employeeId = _data["employeeId"];
            this.supervisorId = _data["supervisorId"];
            this.departmentId = _data["departmentId"];
            this.payRollTypeId = _data["payRollTypeId"];
            this.jobId = _data["jobId"];
            this.gradeId = _data["gradeId"];
            this.gradeStepId = _data["gradeStepId"];
            this.locationId = _data["locationId"];
            this.positionId = _data["positionId"];
            this.ministryId = _data["ministryId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.contractEndDate = _data["contractEndDate"] ? new Date(_data["contractEndDate"].toString()) : <any>undefined;
            this.salaryScaleId = _data["salaryScaleId"];
            this.dateofPresentAppointment = _data["dateofPresentAppointment"] ? new Date(_data["dateofPresentAppointment"].toString()) : <any>undefined;
            this.dateOfAppointment = _data["dateOfAppointment"] ? new Date(_data["dateOfAppointment"].toString()) : <any>undefined;
            this.dateOfLastDeployment = _data["dateOfLastDeployment"] ? new Date(_data["dateOfLastDeployment"].toString()) : <any>undefined;
            this.dateOfConversion = _data["dateOfConversion"] ? new Date(_data["dateOfConversion"].toString()) : <any>undefined;
            this.dateOfConfirmation = _data["dateOfConfirmation"] ? new Date(_data["dateOfConfirmation"].toString()) : <any>undefined;
            this.dateDeployed = _data["dateDeployed"] ? new Date(_data["dateDeployed"].toString()) : <any>undefined;
            this.datePromotion = _data["datePromotion"] ? new Date(_data["datePromotion"].toString()) : <any>undefined;
            this.dateOfRetirement = _data["dateOfRetirement"] ? new Date(_data["dateOfRetirement"].toString()) : <any>undefined;
            this.retirementTypeId = _data["retirementTypeId"];
            this.isContractActive = _data["isContractActive"];
            this.isDefaultContract = _data["isDefaultContract"];
            this.noOfLeaveDays = _data["noOfLeaveDays"];
            this.peopleGroupId = _data["peopleGroupId"];
            this.lastPromotionDate = _data["lastPromotionDate"] ? new Date(_data["lastPromotionDate"].toString()) : <any>undefined;
            this.schoolId = _data["schoolId"];
            this.unitId = _data["unitId"];
            this.cadreID = _data["cadreID"];
            this.directorateID = _data["directorateID"];
            this.lcdaID = _data["lcdaID"];
            this.isOffPayrolled = _data["isOffPayrolled"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): EmployeeContractAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeContractAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assignmentNumber"] = this.assignmentNumber;
        data["employeeId"] = this.employeeId;
        data["supervisorId"] = this.supervisorId;
        data["departmentId"] = this.departmentId;
        data["payRollTypeId"] = this.payRollTypeId;
        data["jobId"] = this.jobId;
        data["gradeId"] = this.gradeId;
        data["gradeStepId"] = this.gradeStepId;
        data["locationId"] = this.locationId;
        data["positionId"] = this.positionId;
        data["ministryId"] = this.ministryId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["contractEndDate"] = this.contractEndDate ? this.contractEndDate.toISOString() : <any>undefined;
        data["salaryScaleId"] = this.salaryScaleId;
        data["dateofPresentAppointment"] = this.dateofPresentAppointment ? this.dateofPresentAppointment.toISOString() : <any>undefined;
        data["dateOfAppointment"] = this.dateOfAppointment ? this.dateOfAppointment.toISOString() : <any>undefined;
        data["dateOfLastDeployment"] = this.dateOfLastDeployment ? this.dateOfLastDeployment.toISOString() : <any>undefined;
        data["dateOfConversion"] = this.dateOfConversion ? this.dateOfConversion.toISOString() : <any>undefined;
        data["dateOfConfirmation"] = this.dateOfConfirmation ? this.dateOfConfirmation.toISOString() : <any>undefined;
        data["dateDeployed"] = this.dateDeployed ? this.dateDeployed.toISOString() : <any>undefined;
        data["datePromotion"] = this.datePromotion ? this.datePromotion.toISOString() : <any>undefined;
        data["dateOfRetirement"] = this.dateOfRetirement ? this.dateOfRetirement.toISOString() : <any>undefined;
        data["retirementTypeId"] = this.retirementTypeId;
        data["isContractActive"] = this.isContractActive;
        data["isDefaultContract"] = this.isDefaultContract;
        data["noOfLeaveDays"] = this.noOfLeaveDays;
        data["peopleGroupId"] = this.peopleGroupId;
        data["lastPromotionDate"] = this.lastPromotionDate ? this.lastPromotionDate.toISOString() : <any>undefined;
        data["schoolId"] = this.schoolId;
        data["unitId"] = this.unitId;
        data["cadreID"] = this.cadreID;
        data["directorateID"] = this.directorateID;
        data["lcdaID"] = this.lcdaID;
        data["isOffPayrolled"] = this.isOffPayrolled;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): EmployeeContractAssignment {
        const json = this.toJSON();
        let result = new EmployeeContractAssignment();
        result.init(json);
        return result;
    }
}

export interface IEmployeeContractAssignment {
    assignmentNumber: string;
    employeeId: number;
    supervisorId: number | undefined;
    departmentId: number | undefined;
    payRollTypeId: number | undefined;
    jobId: number | undefined;
    gradeId: number | undefined;
    gradeStepId: number | undefined;
    locationId: number | undefined;
    positionId: number | undefined;
    ministryId: number | undefined;
    employmentTypeId: number;
    contractEndDate: Date | undefined;
    salaryScaleId: number;
    dateofPresentAppointment: Date;
    dateOfAppointment: Date;
    dateOfLastDeployment: Date | undefined;
    dateOfConversion: Date | undefined;
    dateOfConfirmation: Date | undefined;
    dateDeployed: Date | undefined;
    datePromotion: Date | undefined;
    dateOfRetirement: Date | undefined;
    retirementTypeId: number | undefined;
    isContractActive: boolean;
    isDefaultContract: boolean;
    noOfLeaveDays: number | undefined;
    peopleGroupId: number | undefined;
    lastPromotionDate: Date | undefined;
    schoolId: number | undefined;
    unitId: number | undefined;
    cadreID: number | undefined;
    directorateID: number | undefined;
    lcdaID: number | undefined;
    isOffPayrolled: number | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Request implements IRequest {
    requestTypeId!: number;
    employeeId!: number;
    employeeContractId!: number;
    request_date!: Date;
    title!: string;
    description!: string;
    log_status!: number;
    resolution!: string | undefined;
    temp_resolution!: string | undefined;
    submitted_by!: string | undefined;
    date_resolved!: Date;
    refNo!: string | undefined;
    requestType!: RequestType;
    employees!: Employee;
    employeeContractAssignment!: EmployeeContractAssignment;
    requestFiles!: RequestFile[] | undefined;
    employeeName!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestTypeId = _data["requestTypeId"];
            this.employeeId = _data["employeeId"];
            this.employeeContractId = _data["employeeContractId"];
            this.request_date = _data["request_date"] ? new Date(_data["request_date"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.log_status = _data["log_status"];
            this.resolution = _data["resolution"];
            this.temp_resolution = _data["temp_resolution"];
            this.submitted_by = _data["submitted_by"];
            this.date_resolved = _data["date_resolved"] ? new Date(_data["date_resolved"].toString()) : <any>undefined;
            this.refNo = _data["refNo"];
            this.requestType = _data["requestType"] ? RequestType.fromJS(_data["requestType"]) : <any>undefined;
            this.employees = _data["employees"] ? Employee.fromJS(_data["employees"]) : <any>undefined;
            this.employeeContractAssignment = _data["employeeContractAssignment"] ? EmployeeContractAssignment.fromJS(_data["employeeContractAssignment"]) : <any>undefined;
            if (Array.isArray(_data["requestFiles"])) {
                this.requestFiles = [] as any;
                for (let item of _data["requestFiles"])
                    this.requestFiles!.push(RequestFile.fromJS(item));
            }
            this.employeeName = _data["employeeName"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestTypeId"] = this.requestTypeId;
        data["employeeId"] = this.employeeId;
        data["employeeContractId"] = this.employeeContractId;
        data["request_date"] = this.request_date ? this.request_date.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["log_status"] = this.log_status;
        data["resolution"] = this.resolution;
        data["temp_resolution"] = this.temp_resolution;
        data["submitted_by"] = this.submitted_by;
        data["date_resolved"] = this.date_resolved ? this.date_resolved.toISOString() : <any>undefined;
        data["refNo"] = this.refNo;
        data["requestType"] = this.requestType ? this.requestType.toJSON() : <any>undefined;
        data["employees"] = this.employees ? this.employees.toJSON() : <any>undefined;
        data["employeeContractAssignment"] = this.employeeContractAssignment ? this.employeeContractAssignment.toJSON() : <any>undefined;
        if (Array.isArray(this.requestFiles)) {
            data["requestFiles"] = [];
            for (let item of this.requestFiles)
                data["requestFiles"].push(item.toJSON());
        }
        data["employeeName"] = this.employeeName;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Request {
        const json = this.toJSON();
        let result = new Request();
        result.init(json);
        return result;
    }
}

export interface IRequest {
    requestTypeId: number;
    employeeId: number;
    employeeContractId: number;
    request_date: Date;
    title: string;
    description: string;
    log_status: number;
    resolution: string | undefined;
    temp_resolution: string | undefined;
    submitted_by: string | undefined;
    date_resolved: Date;
    refNo: string | undefined;
    requestType: RequestType;
    employees: Employee;
    employeeContractAssignment: EmployeeContractAssignment;
    requestFiles: RequestFile[] | undefined;
    employeeName: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RequestFile implements IRequestFile {
    request_id!: number;
    filename!: string | undefined;
    filepath!: string | undefined;
    requests!: Request;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRequestFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.request_id = _data["request_id"];
            this.filename = _data["filename"];
            this.filepath = _data["filepath"];
            this.requests = _data["requests"] ? Request.fromJS(_data["requests"]) : <any>undefined;
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RequestFile {
        data = typeof data === 'object' ? data : {};
        let result = new RequestFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["request_id"] = this.request_id;
        data["filename"] = this.filename;
        data["filepath"] = this.filepath;
        data["requests"] = this.requests ? this.requests.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RequestFile {
        const json = this.toJSON();
        let result = new RequestFile();
        result.init(json);
        return result;
    }
}

export interface IRequestFile {
    request_id: number;
    filename: string | undefined;
    filepath: string | undefined;
    requests: Request;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class RequestFileDto implements IRequestFileDto {
    request!: RequestFile[] | undefined;
    processId!: number[] | undefined;
    employee!: string | undefined;
    itemId!: number;
    employeeName!: string | undefined;

    constructor(data?: IRequestFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["request"])) {
                this.request = [] as any;
                for (let item of _data["request"])
                    this.request!.push(RequestFile.fromJS(item));
            }
            if (Array.isArray(_data["processId"])) {
                this.processId = [] as any;
                for (let item of _data["processId"])
                    this.processId!.push(item);
            }
            this.employee = _data["employee"];
            this.itemId = _data["itemId"];
            this.employeeName = _data["employeeName"];
        }
    }

    static fromJS(data: any): RequestFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.request)) {
            data["request"] = [];
            for (let item of this.request)
                data["request"].push(item.toJSON());
        }
        if (Array.isArray(this.processId)) {
            data["processId"] = [];
            for (let item of this.processId)
                data["processId"].push(item);
        }
        data["employee"] = this.employee;
        data["itemId"] = this.itemId;
        data["employeeName"] = this.employeeName;
        return data; 
    }

    clone(): RequestFileDto {
        const json = this.toJSON();
        let result = new RequestFileDto();
        result.init(json);
        return result;
    }
}

export interface IRequestFileDto {
    request: RequestFile[] | undefined;
    processId: number[] | undefined;
    employee: string | undefined;
    itemId: number;
    employeeName: string | undefined;
}

export class RequestFileDtoIListApiResult implements IRequestFileDtoIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestFileDto[] | undefined;
    totalCount!: number;

    constructor(data?: IRequestFileDtoIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RequestFileDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RequestFileDtoIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestFileDtoIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RequestFileDtoIListApiResult {
        const json = this.toJSON();
        let result = new RequestFileDtoIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestFileDtoIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestFileDto[] | undefined;
    totalCount: number;
}

export class RequestTypeIListApiResult implements IRequestTypeIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RequestType[] | undefined;
    totalCount!: number;

    constructor(data?: IRequestTypeIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RequestType.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RequestTypeIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestTypeIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RequestTypeIListApiResult {
        const json = this.toJSON();
        let result = new RequestTypeIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRequestTypeIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RequestType[] | undefined;
    totalCount: number;
}

export class ApplicationRoleDTO implements IApplicationRoleDTO {
    id!: number;
    name!: string;
    description!: string | undefined;
    isSystemRole!: boolean;

    constructor(data?: IApplicationRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isSystemRole = _data["isSystemRole"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isSystemRole"] = this.isSystemRole;
        return data; 
    }

    clone(): ApplicationRoleDTO {
        const json = this.toJSON();
        let result = new ApplicationRoleDTO();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTO {
    id: number;
    name: string;
    description: string | undefined;
    isSystemRole: boolean;
}

export class ApplicationRoleDTOIListApiResult implements IApplicationRoleDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationRoleDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IApplicationRoleDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApplicationRoleDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApplicationRoleDTOIListApiResult {
        const json = this.toJSON();
        let result = new ApplicationRoleDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationRoleDTO[] | undefined;
    totalCount: number;
}

export class ApplicationRoleDTOApiResult implements IApplicationRoleDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationRoleDTO;
    totalCount!: number;

    constructor(data?: IApplicationRoleDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? ApplicationRoleDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ApplicationRoleDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApplicationRoleDTOApiResult {
        const json = this.toJSON();
        let result = new ApplicationRoleDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationRoleDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationRoleDTO;
    totalCount: number;
}

export class PermissionDTO implements IPermissionDTO {
    id!: number;
    name!: string | undefined;
    applicationName!: string | undefined;
    code!: string | undefined;

    constructor(data?: IPermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.applicationName = _data["applicationName"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): PermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["applicationName"] = this.applicationName;
        data["code"] = this.code;
        return data; 
    }

    clone(): PermissionDTO {
        const json = this.toJSON();
        let result = new PermissionDTO();
        result.init(json);
        return result;
    }
}

export interface IPermissionDTO {
    id: number;
    name: string | undefined;
    applicationName: string | undefined;
    code: string | undefined;
}

export class RolePermissionDTO implements IRolePermissionDTO {
    roleId!: number;
    roleName!: string | undefined;
    permissions!: PermissionDTO[] | undefined;

    constructor(data?: IRolePermissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolePermissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RolePermissionDTO {
        const json = this.toJSON();
        let result = new RolePermissionDTO();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTO {
    roleId: number;
    roleName: string | undefined;
    permissions: PermissionDTO[] | undefined;
}

export class RolePermissionDTOIListApiResult implements IRolePermissionDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RolePermissionDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IRolePermissionDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RolePermissionDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RolePermissionDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RolePermissionDTOIListApiResult {
        const json = this.toJSON();
        let result = new RolePermissionDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RolePermissionDTO[] | undefined;
    totalCount: number;
}

export class RolePermissionDTOApiResult implements IRolePermissionDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: RolePermissionDTO;
    totalCount!: number;

    constructor(data?: IRolePermissionDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? RolePermissionDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RolePermissionDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RolePermissionDTOApiResult {
        const json = this.toJSON();
        let result = new RolePermissionDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: RolePermissionDTO;
    totalCount: number;
}

export class RolePermissionMappingDTO implements IRolePermissionMappingDTO {
    roleId!: number;
    permissionIds!: number[];

    constructor(data?: IRolePermissionMappingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permissionIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            if (Array.isArray(_data["permissionIds"])) {
                this.permissionIds = [] as any;
                for (let item of _data["permissionIds"])
                    this.permissionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): RolePermissionMappingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionMappingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        if (Array.isArray(this.permissionIds)) {
            data["permissionIds"] = [];
            for (let item of this.permissionIds)
                data["permissionIds"].push(item);
        }
        return data; 
    }

    clone(): RolePermissionMappingDTO {
        const json = this.toJSON();
        let result = new RolePermissionMappingDTO();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionMappingDTO {
    roleId: number;
    permissionIds: number[];
}

export class Modular implements IModular {
    id!: number;
    name!: string | undefined;
    defaultEnabled!: boolean;
    makeAvailable!: boolean;
    subscriptionPlanModules!: SubscriptionPlanModule[] | undefined;

    constructor(data?: IModular) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.defaultEnabled = _data["defaultEnabled"];
            this.makeAvailable = _data["makeAvailable"];
            if (Array.isArray(_data["subscriptionPlanModules"])) {
                this.subscriptionPlanModules = [] as any;
                for (let item of _data["subscriptionPlanModules"])
                    this.subscriptionPlanModules!.push(SubscriptionPlanModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Modular {
        data = typeof data === 'object' ? data : {};
        let result = new Modular();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["defaultEnabled"] = this.defaultEnabled;
        data["makeAvailable"] = this.makeAvailable;
        if (Array.isArray(this.subscriptionPlanModules)) {
            data["subscriptionPlanModules"] = [];
            for (let item of this.subscriptionPlanModules)
                data["subscriptionPlanModules"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Modular {
        const json = this.toJSON();
        let result = new Modular();
        result.init(json);
        return result;
    }
}

export interface IModular {
    id: number;
    name: string | undefined;
    defaultEnabled: boolean;
    makeAvailable: boolean;
    subscriptionPlanModules: SubscriptionPlanModule[] | undefined;
}

export class SubscriptionPlanModule implements ISubscriptionPlanModule {
    id!: number;
    subscriptionPlanId!: number;
    modularId!: number;
    lastDateModified!: Date | undefined;
    modularDefaultEnabled!: boolean;
    subscriptionPlan!: SubscriptionPlan;
    modular!: Modular;

    constructor(data?: ISubscriptionPlanModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.modularId = _data["modularId"];
            this.lastDateModified = _data["lastDateModified"] ? new Date(_data["lastDateModified"].toString()) : <any>undefined;
            this.modularDefaultEnabled = _data["modularDefaultEnabled"];
            this.subscriptionPlan = _data["subscriptionPlan"] ? SubscriptionPlan.fromJS(_data["subscriptionPlan"]) : <any>undefined;
            this.modular = _data["modular"] ? Modular.fromJS(_data["modular"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SubscriptionPlanModule {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["modularId"] = this.modularId;
        data["lastDateModified"] = this.lastDateModified ? this.lastDateModified.toISOString() : <any>undefined;
        data["modularDefaultEnabled"] = this.modularDefaultEnabled;
        data["subscriptionPlan"] = this.subscriptionPlan ? this.subscriptionPlan.toJSON() : <any>undefined;
        data["modular"] = this.modular ? this.modular.toJSON() : <any>undefined;
        return data; 
    }

    clone(): SubscriptionPlanModule {
        const json = this.toJSON();
        let result = new SubscriptionPlanModule();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanModule {
    id: number;
    subscriptionPlanId: number;
    modularId: number;
    lastDateModified: Date | undefined;
    modularDefaultEnabled: boolean;
    subscriptionPlan: SubscriptionPlan;
    modular: Modular;
}

export class SubscriptionPlan implements ISubscriptionPlan {
    id!: number;
    planCode!: string | undefined;
    name!: string | undefined;
    paymentUrl!: string | undefined;
    amount!: number;
    licenseCount!: number;
    created!: Date | undefined;
    modified!: Date | undefined;
    subscriptionPlanModules!: SubscriptionPlanModule[] | undefined;

    constructor(data?: ISubscriptionPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.planCode = _data["planCode"];
            this.name = _data["name"];
            this.paymentUrl = _data["paymentUrl"];
            this.amount = _data["amount"];
            this.licenseCount = _data["licenseCount"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            if (Array.isArray(_data["subscriptionPlanModules"])) {
                this.subscriptionPlanModules = [] as any;
                for (let item of _data["subscriptionPlanModules"])
                    this.subscriptionPlanModules!.push(SubscriptionPlanModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubscriptionPlan {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["planCode"] = this.planCode;
        data["name"] = this.name;
        data["paymentUrl"] = this.paymentUrl;
        data["amount"] = this.amount;
        data["licenseCount"] = this.licenseCount;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        if (Array.isArray(this.subscriptionPlanModules)) {
            data["subscriptionPlanModules"] = [];
            for (let item of this.subscriptionPlanModules)
                data["subscriptionPlanModules"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SubscriptionPlan {
        const json = this.toJSON();
        let result = new SubscriptionPlan();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlan {
    id: number;
    planCode: string | undefined;
    name: string | undefined;
    paymentUrl: string | undefined;
    amount: number;
    licenseCount: number;
    created: Date | undefined;
    modified: Date | undefined;
    subscriptionPlanModules: SubscriptionPlanModule[] | undefined;
}

export class SubscriptionPlanIListApiResult implements ISubscriptionPlanIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubscriptionPlan[] | undefined;
    totalCount!: number;

    constructor(data?: ISubscriptionPlanIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SubscriptionPlan.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SubscriptionPlanIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SubscriptionPlanIListApiResult {
        const json = this.toJSON();
        let result = new SubscriptionPlanIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubscriptionPlan[] | undefined;
    totalCount: number;
}

export class SubscriptionPlanApiResult implements ISubscriptionPlanApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubscriptionPlan;
    totalCount!: number;

    constructor(data?: ISubscriptionPlanApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? SubscriptionPlan.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SubscriptionPlanApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SubscriptionPlanApiResult {
        const json = this.toJSON();
        let result = new SubscriptionPlanApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubscriptionPlan;
    totalCount: number;
}

export class SubscriptionPlanModuleIListApiResult implements ISubscriptionPlanModuleIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: SubscriptionPlanModule[] | undefined;
    totalCount!: number;

    constructor(data?: ISubscriptionPlanModuleIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SubscriptionPlanModule.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SubscriptionPlanModuleIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPlanModuleIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SubscriptionPlanModuleIListApiResult {
        const json = this.toJSON();
        let result = new SubscriptionPlanModuleIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPlanModuleIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: SubscriptionPlanModule[] | undefined;
    totalCount: number;
}

export class CompanySignUpDTO implements ICompanySignUpDTO {
    email!: string;
    phoneNumber!: string;
    password!: string;

    constructor(data?: ICompanySignUpDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CompanySignUpDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanySignUpDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        return data; 
    }

    clone(): CompanySignUpDTO {
        const json = this.toJSON();
        let result = new CompanySignUpDTO();
        result.init(json);
        return result;
    }
}

export interface ICompanySignUpDTO {
    email: string;
    phoneNumber: string;
    password: string;
}

export class CompanyDTO implements ICompanyDTO {
    id!: number;
    userId!: number;
    name!: string;
    rcNo!: string | undefined;
    logoName!: string | undefined;
    shortText!: string | undefined;
    email!: string;
    phoneNumber!: string;
    firstName!: string | undefined;
    lastName!: string | undefined;
    address!: string | undefined;
    administratorEmail!: string;
    domainName!: string | undefined;
    auditorEmail!: string | undefined;
    maxEmployeeCount!: number;
    subscriptionPlanId!: number;
    password!: string | undefined;

    constructor(data?: ICompanyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.rcNo = _data["rcNo"];
            this.logoName = _data["logoName"];
            this.shortText = _data["shortText"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.address = _data["address"];
            this.administratorEmail = _data["administratorEmail"];
            this.domainName = _data["domainName"];
            this.auditorEmail = _data["auditorEmail"];
            this.maxEmployeeCount = _data["maxEmployeeCount"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CompanyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["rcNo"] = this.rcNo;
        data["logoName"] = this.logoName;
        data["shortText"] = this.shortText;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["address"] = this.address;
        data["administratorEmail"] = this.administratorEmail;
        data["domainName"] = this.domainName;
        data["auditorEmail"] = this.auditorEmail;
        data["maxEmployeeCount"] = this.maxEmployeeCount;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["password"] = this.password;
        return data; 
    }

    clone(): CompanyDTO {
        const json = this.toJSON();
        let result = new CompanyDTO();
        result.init(json);
        return result;
    }
}

export interface ICompanyDTO {
    id: number;
    userId: number;
    name: string;
    rcNo: string | undefined;
    logoName: string | undefined;
    shortText: string | undefined;
    email: string;
    phoneNumber: string;
    firstName: string | undefined;
    lastName: string | undefined;
    address: string | undefined;
    administratorEmail: string;
    domainName: string | undefined;
    auditorEmail: string | undefined;
    maxEmployeeCount: number;
    subscriptionPlanId: number;
    password: string | undefined;
}

export class Company implements ICompany {
    id!: number;
    name!: string | undefined;
    rcNo!: string | undefined;
    logoName!: string | undefined;
    landingImageBGName!: string | undefined;
    shortText!: string | undefined;
    email!: string | undefined;
    address!: string | undefined;
    phoneNumber!: string | undefined;
    adminEmail!: string | undefined;
    subscriptionPlanId!: number;
    lastBillingDate!: Date | undefined;
    lastPaymtDate!: Date | undefined;
    licenseUsuage!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    auditorEmail!: string | undefined;
    isActiveByAdmin!: boolean;
    created!: Date | undefined;
    modified!: Date | undefined;
    code!: string | undefined;
    colorBackGround!: string | undefined;
    domainName!: string | undefined;
    isTrial!: boolean;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.rcNo = _data["rcNo"];
            this.logoName = _data["logoName"];
            this.landingImageBGName = _data["landingImageBGName"];
            this.shortText = _data["shortText"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.adminEmail = _data["adminEmail"];
            this.subscriptionPlanId = _data["subscriptionPlanId"];
            this.lastBillingDate = _data["lastBillingDate"] ? new Date(_data["lastBillingDate"].toString()) : <any>undefined;
            this.lastPaymtDate = _data["lastPaymtDate"] ? new Date(_data["lastPaymtDate"].toString()) : <any>undefined;
            this.licenseUsuage = _data["licenseUsuage"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.auditorEmail = _data["auditorEmail"];
            this.isActiveByAdmin = _data["isActiveByAdmin"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.colorBackGround = _data["colorBackGround"];
            this.domainName = _data["domainName"];
            this.isTrial = _data["isTrial"];
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["rcNo"] = this.rcNo;
        data["logoName"] = this.logoName;
        data["landingImageBGName"] = this.landingImageBGName;
        data["shortText"] = this.shortText;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["adminEmail"] = this.adminEmail;
        data["subscriptionPlanId"] = this.subscriptionPlanId;
        data["lastBillingDate"] = this.lastBillingDate ? this.lastBillingDate.toISOString() : <any>undefined;
        data["lastPaymtDate"] = this.lastPaymtDate ? this.lastPaymtDate.toISOString() : <any>undefined;
        data["licenseUsuage"] = this.licenseUsuage;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["auditorEmail"] = this.auditorEmail;
        data["isActiveByAdmin"] = this.isActiveByAdmin;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["colorBackGround"] = this.colorBackGround;
        data["domainName"] = this.domainName;
        data["isTrial"] = this.isTrial;
        return data; 
    }

    clone(): Company {
        const json = this.toJSON();
        let result = new Company();
        result.init(json);
        return result;
    }
}

export interface ICompany {
    id: number;
    name: string | undefined;
    rcNo: string | undefined;
    logoName: string | undefined;
    landingImageBGName: string | undefined;
    shortText: string | undefined;
    email: string | undefined;
    address: string | undefined;
    phoneNumber: string | undefined;
    adminEmail: string | undefined;
    subscriptionPlanId: number;
    lastBillingDate: Date | undefined;
    lastPaymtDate: Date | undefined;
    licenseUsuage: number;
    isActive: boolean;
    isDeleted: boolean;
    auditorEmail: string | undefined;
    isActiveByAdmin: boolean;
    created: Date | undefined;
    modified: Date | undefined;
    code: string | undefined;
    colorBackGround: string | undefined;
    domainName: string | undefined;
    isTrial: boolean;
}

export class CompanyIListApiResult implements ICompanyIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: Company[] | undefined;
    totalCount!: number;

    constructor(data?: ICompanyIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Company.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CompanyIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CompanyIListApiResult {
        const json = this.toJSON();
        let result = new CompanyIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICompanyIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: Company[] | undefined;
    totalCount: number;
}

export class CompanyModuleDTO implements ICompanyModuleDTO {
    id!: number;
    moduleId!: number;
    companyId!: number;
    isEnabled!: boolean;
    moduleName!: string | undefined;
    icon!: string | undefined;
    isReadonly!: boolean;

    constructor(data?: ICompanyModuleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.moduleId = _data["moduleId"];
            this.companyId = _data["companyId"];
            this.isEnabled = _data["isEnabled"];
            this.moduleName = _data["moduleName"];
            this.icon = _data["icon"];
            this.isReadonly = _data["isReadonly"];
        }
    }

    static fromJS(data: any): CompanyModuleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyModuleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["moduleId"] = this.moduleId;
        data["companyId"] = this.companyId;
        data["isEnabled"] = this.isEnabled;
        data["moduleName"] = this.moduleName;
        data["icon"] = this.icon;
        data["isReadonly"] = this.isReadonly;
        return data; 
    }

    clone(): CompanyModuleDTO {
        const json = this.toJSON();
        let result = new CompanyModuleDTO();
        result.init(json);
        return result;
    }
}

export interface ICompanyModuleDTO {
    id: number;
    moduleId: number;
    companyId: number;
    isEnabled: boolean;
    moduleName: string | undefined;
    icon: string | undefined;
    isReadonly: boolean;
}

export class CompanyModuleDTOIListApiResult implements ICompanyModuleDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: CompanyModuleDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ICompanyModuleDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CompanyModuleDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CompanyModuleDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyModuleDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CompanyModuleDTOIListApiResult {
        const json = this.toJSON();
        let result = new CompanyModuleDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface ICompanyModuleDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: CompanyModuleDTO[] | undefined;
    totalCount: number;
}

export class TrainingVendorPayload implements ITrainingVendorPayload {
    id!: number;
    name!: string;
    contactPerson!: string;
    phoneNo!: string;
    email!: string;
    website!: string | undefined;
    description!: string | undefined;
    trainingSpecializationId!: number;
    trainingTag!: string | undefined;

    constructor(data?: ITrainingVendorPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.contactPerson = _data["contactPerson"];
            this.phoneNo = _data["phoneNo"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.description = _data["description"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.trainingTag = _data["trainingTag"];
        }
    }

    static fromJS(data: any): TrainingVendorPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendorPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["contactPerson"] = this.contactPerson;
        data["phoneNo"] = this.phoneNo;
        data["email"] = this.email;
        data["website"] = this.website;
        data["description"] = this.description;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["trainingTag"] = this.trainingTag;
        return data; 
    }

    clone(): TrainingVendorPayload {
        const json = this.toJSON();
        let result = new TrainingVendorPayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendorPayload {
    id: number;
    name: string;
    contactPerson: string;
    phoneNo: string;
    email: string;
    website: string | undefined;
    description: string | undefined;
    trainingSpecializationId: number;
    trainingTag: string | undefined;
}

export class TrainingSpecialization implements ITrainingSpecialization {
    id!: number;
    name!: string | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingSpecialization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingSpecialization {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecialization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingSpecialization {
        const json = this.toJSON();
        let result = new TrainingSpecialization();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecialization {
    id: number;
    name: string | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingVendorResource implements ITrainingVendorResource {
    id!: number;
    name!: string | undefined;
    phoneNo!: string | undefined;
    email!: string | undefined;
    website!: string | undefined;
    description!: string | undefined;
    expertees!: string | undefined;
    trainingTag!: string | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;
    trainingSpecializationId!: number;
    trainingSpecialization!: TrainingSpecialization;

    constructor(data?: ITrainingVendorResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.phoneNo = _data["phoneNo"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.description = _data["description"];
            this.expertees = _data["expertees"];
            this.trainingTag = _data["trainingTag"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.trainingSpecialization = _data["trainingSpecialization"] ? TrainingSpecialization.fromJS(_data["trainingSpecialization"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingVendorResource {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendorResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["phoneNo"] = this.phoneNo;
        data["email"] = this.email;
        data["website"] = this.website;
        data["description"] = this.description;
        data["expertees"] = this.expertees;
        data["trainingTag"] = this.trainingTag;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["trainingSpecialization"] = this.trainingSpecialization ? this.trainingSpecialization.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TrainingVendorResource {
        const json = this.toJSON();
        let result = new TrainingVendorResource();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendorResource {
    id: number;
    name: string | undefined;
    phoneNo: string | undefined;
    email: string | undefined;
    website: string | undefined;
    description: string | undefined;
    expertees: string | undefined;
    trainingTag: string | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
    trainingSpecializationId: number;
    trainingSpecialization: TrainingSpecialization;
}

export class TrainingVendorResourceListApiResult implements ITrainingVendorResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingVendorResource[] | undefined;
    totalCount!: number;

    constructor(data?: ITrainingVendorResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingVendorResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingVendorResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendorResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingVendorResourceListApiResult {
        const json = this.toJSON();
        let result = new TrainingVendorResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendorResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingVendorResource[] | undefined;
    totalCount: number;
}

export class TrainingVendorResourceApiResult implements ITrainingVendorResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingVendorResource;
    totalCount!: number;

    constructor(data?: ITrainingVendorResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? TrainingVendorResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingVendorResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendorResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingVendorResourceApiResult {
        const json = this.toJSON();
        let result = new TrainingVendorResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendorResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingVendorResource;
    totalCount: number;
}

export class TrainingTypePayload implements ITrainingTypePayload {
    costPer_Head!: number;
    no_Of_Trainees!: number;
    overAll_Budget!: number;
    trainingTypeId!: number;
    employeeId!: number;
    trainingVendorId!: number;
    trainingSpecializationId!: number;
    name!: string | undefined;
    file!: string | undefined;
    trainingCategoryId!: number;

    constructor(data?: ITrainingTypePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.costPer_Head = _data["costPer_Head"];
            this.no_Of_Trainees = _data["no_Of_Trainees"];
            this.overAll_Budget = _data["overAll_Budget"];
            this.trainingTypeId = _data["trainingTypeId"];
            this.employeeId = _data["employeeId"];
            this.trainingVendorId = _data["trainingVendorId"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.name = _data["name"];
            this.file = _data["file"];
            this.trainingCategoryId = _data["trainingCategoryId"];
        }
    }

    static fromJS(data: any): TrainingTypePayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingTypePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["costPer_Head"] = this.costPer_Head;
        data["no_Of_Trainees"] = this.no_Of_Trainees;
        data["overAll_Budget"] = this.overAll_Budget;
        data["trainingTypeId"] = this.trainingTypeId;
        data["employeeId"] = this.employeeId;
        data["trainingVendorId"] = this.trainingVendorId;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["name"] = this.name;
        data["file"] = this.file;
        data["trainingCategoryId"] = this.trainingCategoryId;
        return data; 
    }

    clone(): TrainingTypePayload {
        const json = this.toJSON();
        let result = new TrainingTypePayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingTypePayload {
    costPer_Head: number;
    no_Of_Trainees: number;
    overAll_Budget: number;
    trainingTypeId: number;
    employeeId: number;
    trainingVendorId: number;
    trainingSpecializationId: number;
    name: string | undefined;
    file: string | undefined;
    trainingCategoryId: number;
}

export class TrainingVendor implements ITrainingVendor {
    id!: number;
    name!: string;
    phoneNo!: string | undefined;
    trainingSpecializationId!: number;
    email!: string | undefined;
    website!: string | undefined;
    description!: string | undefined;
    expertees!: string | undefined;
    trainingTag!: string | undefined;
    trainingSpecialization!: TrainingSpecialization;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingVendor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.phoneNo = _data["phoneNo"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.description = _data["description"];
            this.expertees = _data["expertees"];
            this.trainingTag = _data["trainingTag"];
            this.trainingSpecialization = _data["trainingSpecialization"] ? TrainingSpecialization.fromJS(_data["trainingSpecialization"]) : <any>undefined;
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingVendor {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVendor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["phoneNo"] = this.phoneNo;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["email"] = this.email;
        data["website"] = this.website;
        data["description"] = this.description;
        data["expertees"] = this.expertees;
        data["trainingTag"] = this.trainingTag;
        data["trainingSpecialization"] = this.trainingSpecialization ? this.trainingSpecialization.toJSON() : <any>undefined;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingVendor {
        const json = this.toJSON();
        let result = new TrainingVendor();
        result.init(json);
        return result;
    }
}

export interface ITrainingVendor {
    id: number;
    name: string;
    phoneNo: string | undefined;
    trainingSpecializationId: number;
    email: string | undefined;
    website: string | undefined;
    description: string | undefined;
    expertees: string | undefined;
    trainingTag: string | undefined;
    trainingSpecialization: TrainingSpecialization;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingCategory implements ITrainingCategory {
    id!: number;
    name!: string;
    trainingLocationFlagId!: number;
    locationFlag!: string | undefined;
    tags!: string | undefined;
    numberOfMonthsInterval!: number;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.trainingLocationFlagId = _data["trainingLocationFlagId"];
            this.locationFlag = _data["locationFlag"];
            this.tags = _data["tags"];
            this.numberOfMonthsInterval = _data["numberOfMonthsInterval"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingCategory {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["trainingLocationFlagId"] = this.trainingLocationFlagId;
        data["locationFlag"] = this.locationFlag;
        data["tags"] = this.tags;
        data["numberOfMonthsInterval"] = this.numberOfMonthsInterval;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingCategory {
        const json = this.toJSON();
        let result = new TrainingCategory();
        result.init(json);
        return result;
    }
}

export interface ITrainingCategory {
    id: number;
    name: string;
    trainingLocationFlagId: number;
    locationFlag: string | undefined;
    tags: string | undefined;
    numberOfMonthsInterval: number;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingType implements ITrainingType {
    id!: number;
    description!: string | undefined;
    summary!: string | undefined;
    outline!: string | undefined;
    contentUrl!: string | undefined;
    name!: string | undefined;
    maxCount!: number;
    remainingCount!: number;
    maxDays!: number;
    remainingDays!: number;
    isLocalTraining!: boolean;
    tags!: string | undefined;
    costPer_Head!: number;
    no_Of_Trainees!: number;
    overAll_Budget!: number;
    employeeId!: number;
    trainingVendorId!: number;
    trainingSpecializationId!: number;
    trainingCategoryId!: number;
    trainings!: Training[] | undefined;
    trainingSpecialization!: TrainingSpecialization;
    trainingCategory!: TrainingCategory;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.summary = _data["summary"];
            this.outline = _data["outline"];
            this.contentUrl = _data["contentUrl"];
            this.name = _data["name"];
            this.maxCount = _data["maxCount"];
            this.remainingCount = _data["remainingCount"];
            this.maxDays = _data["maxDays"];
            this.remainingDays = _data["remainingDays"];
            this.isLocalTraining = _data["isLocalTraining"];
            this.tags = _data["tags"];
            this.costPer_Head = _data["costPer_Head"];
            this.no_Of_Trainees = _data["no_Of_Trainees"];
            this.overAll_Budget = _data["overAll_Budget"];
            this.employeeId = _data["employeeId"];
            this.trainingVendorId = _data["trainingVendorId"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.trainingCategoryId = _data["trainingCategoryId"];
            if (Array.isArray(_data["trainings"])) {
                this.trainings = [] as any;
                for (let item of _data["trainings"])
                    this.trainings!.push(Training.fromJS(item));
            }
            this.trainingSpecialization = _data["trainingSpecialization"] ? TrainingSpecialization.fromJS(_data["trainingSpecialization"]) : <any>undefined;
            this.trainingCategory = _data["trainingCategory"] ? TrainingCategory.fromJS(_data["trainingCategory"]) : <any>undefined;
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingType {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["summary"] = this.summary;
        data["outline"] = this.outline;
        data["contentUrl"] = this.contentUrl;
        data["name"] = this.name;
        data["maxCount"] = this.maxCount;
        data["remainingCount"] = this.remainingCount;
        data["maxDays"] = this.maxDays;
        data["remainingDays"] = this.remainingDays;
        data["isLocalTraining"] = this.isLocalTraining;
        data["tags"] = this.tags;
        data["costPer_Head"] = this.costPer_Head;
        data["no_Of_Trainees"] = this.no_Of_Trainees;
        data["overAll_Budget"] = this.overAll_Budget;
        data["employeeId"] = this.employeeId;
        data["trainingVendorId"] = this.trainingVendorId;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["trainingCategoryId"] = this.trainingCategoryId;
        if (Array.isArray(this.trainings)) {
            data["trainings"] = [];
            for (let item of this.trainings)
                data["trainings"].push(item.toJSON());
        }
        data["trainingSpecialization"] = this.trainingSpecialization ? this.trainingSpecialization.toJSON() : <any>undefined;
        data["trainingCategory"] = this.trainingCategory ? this.trainingCategory.toJSON() : <any>undefined;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingType {
        const json = this.toJSON();
        let result = new TrainingType();
        result.init(json);
        return result;
    }
}

export interface ITrainingType {
    id: number;
    description: string | undefined;
    summary: string | undefined;
    outline: string | undefined;
    contentUrl: string | undefined;
    name: string | undefined;
    maxCount: number;
    remainingCount: number;
    maxDays: number;
    remainingDays: number;
    isLocalTraining: boolean;
    tags: string | undefined;
    costPer_Head: number;
    no_Of_Trainees: number;
    overAll_Budget: number;
    employeeId: number;
    trainingVendorId: number;
    trainingSpecializationId: number;
    trainingCategoryId: number;
    trainings: Training[] | undefined;
    trainingSpecialization: TrainingSpecialization;
    trainingCategory: TrainingCategory;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class Training implements ITraining {
    id!: number;
    name!: string;
    description!: string | undefined;
    point!: number | undefined;
    log_status!: number;
    startDate!: Date;
    endDate!: Date;
    trainingTypeId!: number;
    vendorId!: number;
    specializationId!: number;
    trainingCategoryId!: number;
    strStartDate!: string | undefined;
    strEndDate!: string | undefined;
    totalCost!: number | undefined;
    costPerEmployee!: number | undefined;
    trainingType!: TrainingType;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITraining) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.point = _data["point"];
            this.log_status = _data["log_status"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.trainingTypeId = _data["trainingTypeId"];
            this.vendorId = _data["vendorId"];
            this.specializationId = _data["specializationId"];
            this.trainingCategoryId = _data["trainingCategoryId"];
            this.strStartDate = _data["strStartDate"];
            this.strEndDate = _data["strEndDate"];
            this.totalCost = _data["totalCost"];
            this.costPerEmployee = _data["costPerEmployee"];
            this.trainingType = _data["trainingType"] ? TrainingType.fromJS(_data["trainingType"]) : <any>undefined;
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): Training {
        data = typeof data === 'object' ? data : {};
        let result = new Training();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["point"] = this.point;
        data["log_status"] = this.log_status;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["trainingTypeId"] = this.trainingTypeId;
        data["vendorId"] = this.vendorId;
        data["specializationId"] = this.specializationId;
        data["trainingCategoryId"] = this.trainingCategoryId;
        data["strStartDate"] = this.strStartDate;
        data["strEndDate"] = this.strEndDate;
        data["totalCost"] = this.totalCost;
        data["costPerEmployee"] = this.costPerEmployee;
        data["trainingType"] = this.trainingType ? this.trainingType.toJSON() : <any>undefined;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): Training {
        const json = this.toJSON();
        let result = new Training();
        result.init(json);
        return result;
    }
}

export interface ITraining {
    id: number;
    name: string;
    description: string | undefined;
    point: number | undefined;
    log_status: number;
    startDate: Date;
    endDate: Date;
    trainingTypeId: number;
    vendorId: number;
    specializationId: number;
    trainingCategoryId: number;
    strStartDate: string | undefined;
    strEndDate: string | undefined;
    totalCost: number | undefined;
    costPerEmployee: number | undefined;
    trainingType: TrainingType;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingTypeResource implements ITrainingTypeResource {
    id!: number;
    description!: string | undefined;
    contentUrl!: string | undefined;
    summary!: string | undefined;
    outline!: string | undefined;
    name!: string | undefined;
    maxCount!: number;
    remainingCount!: number;
    maxDays!: number;
    remainingDays!: number;
    isLocalTraining!: boolean;
    tags!: string | undefined;
    employeeId!: number;
    trainingVendorId!: number;
    trainingSpecializationId!: number;
    trainingCategoryId!: number;
    employee!: Employee;
    trainingVendor!: TrainingVendor;
    trainingSpecialization!: TrainingSpecialization;
    trainingCategory!: TrainingCategory;
    trainings!: Training[] | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingTypeResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.contentUrl = _data["contentUrl"];
            this.summary = _data["summary"];
            this.outline = _data["outline"];
            this.name = _data["name"];
            this.maxCount = _data["maxCount"];
            this.remainingCount = _data["remainingCount"];
            this.maxDays = _data["maxDays"];
            this.remainingDays = _data["remainingDays"];
            this.isLocalTraining = _data["isLocalTraining"];
            this.tags = _data["tags"];
            this.employeeId = _data["employeeId"];
            this.trainingVendorId = _data["trainingVendorId"];
            this.trainingSpecializationId = _data["trainingSpecializationId"];
            this.trainingCategoryId = _data["trainingCategoryId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.trainingVendor = _data["trainingVendor"] ? TrainingVendor.fromJS(_data["trainingVendor"]) : <any>undefined;
            this.trainingSpecialization = _data["trainingSpecialization"] ? TrainingSpecialization.fromJS(_data["trainingSpecialization"]) : <any>undefined;
            this.trainingCategory = _data["trainingCategory"] ? TrainingCategory.fromJS(_data["trainingCategory"]) : <any>undefined;
            if (Array.isArray(_data["trainings"])) {
                this.trainings = [] as any;
                for (let item of _data["trainings"])
                    this.trainings!.push(Training.fromJS(item));
            }
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingTypeResource {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingTypeResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["contentUrl"] = this.contentUrl;
        data["summary"] = this.summary;
        data["outline"] = this.outline;
        data["name"] = this.name;
        data["maxCount"] = this.maxCount;
        data["remainingCount"] = this.remainingCount;
        data["maxDays"] = this.maxDays;
        data["remainingDays"] = this.remainingDays;
        data["isLocalTraining"] = this.isLocalTraining;
        data["tags"] = this.tags;
        data["employeeId"] = this.employeeId;
        data["trainingVendorId"] = this.trainingVendorId;
        data["trainingSpecializationId"] = this.trainingSpecializationId;
        data["trainingCategoryId"] = this.trainingCategoryId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["trainingVendor"] = this.trainingVendor ? this.trainingVendor.toJSON() : <any>undefined;
        data["trainingSpecialization"] = this.trainingSpecialization ? this.trainingSpecialization.toJSON() : <any>undefined;
        data["trainingCategory"] = this.trainingCategory ? this.trainingCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.trainings)) {
            data["trainings"] = [];
            for (let item of this.trainings)
                data["trainings"].push(item.toJSON());
        }
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingTypeResource {
        const json = this.toJSON();
        let result = new TrainingTypeResource();
        result.init(json);
        return result;
    }
}

export interface ITrainingTypeResource {
    id: number;
    description: string | undefined;
    contentUrl: string | undefined;
    summary: string | undefined;
    outline: string | undefined;
    name: string | undefined;
    maxCount: number;
    remainingCount: number;
    maxDays: number;
    remainingDays: number;
    isLocalTraining: boolean;
    tags: string | undefined;
    employeeId: number;
    trainingVendorId: number;
    trainingSpecializationId: number;
    trainingCategoryId: number;
    employee: Employee;
    trainingVendor: TrainingVendor;
    trainingSpecialization: TrainingSpecialization;
    trainingCategory: TrainingCategory;
    trainings: Training[] | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingTypeResourceListApiResult implements ITrainingTypeResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingTypeResource[] | undefined;
    totalCount!: number;

    constructor(data?: ITrainingTypeResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingTypeResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingTypeResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingTypeResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingTypeResourceListApiResult {
        const json = this.toJSON();
        let result = new TrainingTypeResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingTypeResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingTypeResource[] | undefined;
    totalCount: number;
}

export class TrainingTypeResourceApiResult implements ITrainingTypeResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingTypeResource;
    totalCount!: number;

    constructor(data?: ITrainingTypeResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? TrainingTypeResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingTypeResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingTypeResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingTypeResourceApiResult {
        const json = this.toJSON();
        let result = new TrainingTypeResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingTypeResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingTypeResource;
    totalCount: number;
}

export class ToggleTrainingType implements IToggleTrainingType {
    id!: number;
    status!: boolean;

    constructor(data?: IToggleTrainingType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ToggleTrainingType {
        data = typeof data === 'object' ? data : {};
        let result = new ToggleTrainingType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }

    clone(): ToggleTrainingType {
        const json = this.toJSON();
        let result = new ToggleTrainingType();
        result.init(json);
        return result;
    }
}

export interface IToggleTrainingType {
    id: number;
    status: boolean;
}

export class TrainingCategoryPayload implements ITrainingCategoryPayload {
    id!: number;
    name!: string;

    constructor(data?: ITrainingCategoryPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TrainingCategoryPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCategoryPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): TrainingCategoryPayload {
        const json = this.toJSON();
        let result = new TrainingCategoryPayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingCategoryPayload {
    id: number;
    name: string;
}

export class TrainingCategoryResource implements ITrainingCategoryResource {
    id!: number;
    name!: string | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingCategoryResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingCategoryResource {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCategoryResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingCategoryResource {
        const json = this.toJSON();
        let result = new TrainingCategoryResource();
        result.init(json);
        return result;
    }
}

export interface ITrainingCategoryResource {
    id: number;
    name: string | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingCategoryResourceListApiResult implements ITrainingCategoryResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingCategoryResource[] | undefined;
    totalCount!: number;

    constructor(data?: ITrainingCategoryResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingCategoryResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingCategoryResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCategoryResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingCategoryResourceListApiResult {
        const json = this.toJSON();
        let result = new TrainingCategoryResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingCategoryResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingCategoryResource[] | undefined;
    totalCount: number;
}

export class TrainingSpecializationPayload implements ITrainingSpecializationPayload {
    id!: number;
    name!: string;
    companyId!: number;
    subId!: number;

    constructor(data?: ITrainingSpecializationPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
        }
    }

    static fromJS(data: any): TrainingSpecializationPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecializationPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        return data; 
    }

    clone(): TrainingSpecializationPayload {
        const json = this.toJSON();
        let result = new TrainingSpecializationPayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecializationPayload {
    id: number;
    name: string;
    companyId: number;
    subId: number;
}

export class TrainingSpecializationDTO implements ITrainingSpecializationDTO {
    id!: number;
    name!: string | undefined;
    companyId!: number;
    subId!: number;
    is_Active!: boolean;
    is_Deleted!: boolean;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingSpecializationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.is_Active = _data["is_Active"];
            this.is_Deleted = _data["is_Deleted"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingSpecializationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecializationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["is_Active"] = this.is_Active;
        data["is_Deleted"] = this.is_Deleted;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingSpecializationDTO {
        const json = this.toJSON();
        let result = new TrainingSpecializationDTO();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecializationDTO {
    id: number;
    name: string | undefined;
    companyId: number;
    subId: number;
    is_Active: boolean;
    is_Deleted: boolean;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingSpecializationDTOListApiResult implements ITrainingSpecializationDTOListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingSpecializationDTO[] | undefined;
    totalCount!: number;

    constructor(data?: ITrainingSpecializationDTOListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingSpecializationDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingSpecializationDTOListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecializationDTOListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingSpecializationDTOListApiResult {
        const json = this.toJSON();
        let result = new TrainingSpecializationDTOListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecializationDTOListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingSpecializationDTO[] | undefined;
    totalCount: number;
}

export class TrainingSpecializationDTOApiResult implements ITrainingSpecializationDTOApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingSpecializationDTO;
    totalCount!: number;

    constructor(data?: ITrainingSpecializationDTOApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? TrainingSpecializationDTO.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingSpecializationDTOApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSpecializationDTOApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingSpecializationDTOApiResult {
        const json = this.toJSON();
        let result = new TrainingSpecializationDTOApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingSpecializationDTOApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingSpecializationDTO;
    totalCount: number;
}

export class TrainingSetupPayload implements ITrainingSetupPayload {
    name!: string;
    description!: string;
    status!: boolean;
    startDate!: Date;
    endDate!: Date;
    trainingTypeId!: number;
    specializationId!: number;
    vendorId!: number;
    totalCost!: number | undefined;
    costPerEmployee!: number | undefined;

    constructor(data?: ITrainingSetupPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.trainingTypeId = _data["trainingTypeId"];
            this.specializationId = _data["specializationId"];
            this.vendorId = _data["vendorId"];
            this.totalCost = _data["totalCost"];
            this.costPerEmployee = _data["costPerEmployee"];
        }
    }

    static fromJS(data: any): TrainingSetupPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSetupPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["status"] = this.status;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["trainingTypeId"] = this.trainingTypeId;
        data["specializationId"] = this.specializationId;
        data["vendorId"] = this.vendorId;
        data["totalCost"] = this.totalCost;
        data["costPerEmployee"] = this.costPerEmployee;
        return data; 
    }

    clone(): TrainingSetupPayload {
        const json = this.toJSON();
        let result = new TrainingSetupPayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingSetupPayload {
    name: string;
    description: string;
    status: boolean;
    startDate: Date;
    endDate: Date;
    trainingTypeId: number;
    specializationId: number;
    vendorId: number;
    totalCost: number | undefined;
    costPerEmployee: number | undefined;
}

export class TrainingFilter implements ITrainingFilter {
    specializationName!: string | undefined;
    trainingTypeName!: string | undefined;
    name!: string | undefined;
    trainingVendorName!: string | undefined;

    constructor(data?: ITrainingFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.specializationName = _data["specializationName"];
            this.trainingTypeName = _data["trainingTypeName"];
            this.name = _data["name"];
            this.trainingVendorName = _data["trainingVendorName"];
        }
    }

    static fromJS(data: any): TrainingFilter {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["specializationName"] = this.specializationName;
        data["trainingTypeName"] = this.trainingTypeName;
        data["name"] = this.name;
        data["trainingVendorName"] = this.trainingVendorName;
        return data; 
    }

    clone(): TrainingFilter {
        const json = this.toJSON();
        let result = new TrainingFilter();
        result.init(json);
        return result;
    }
}

export interface ITrainingFilter {
    specializationName: string | undefined;
    trainingTypeName: string | undefined;
    name: string | undefined;
    trainingVendorName: string | undefined;
}

export class TrainingResource implements ITrainingResource {
    id!: number;
    name!: string | undefined;
    description!: string | undefined;
    point!: number | undefined;
    log_status!: number;
    specializationName!: string | undefined;
    trainingTypeName!: string | undefined;
    trainingVendorName!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    trainingTypeId!: number;
    vendorId!: number;
    specializationId!: number;
    trainingType!: TrainingType;
    totalCost!: number | undefined;
    costPerEmployee!: number | undefined;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.point = _data["point"];
            this.log_status = _data["log_status"];
            this.specializationName = _data["specializationName"];
            this.trainingTypeName = _data["trainingTypeName"];
            this.trainingVendorName = _data["trainingVendorName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.trainingTypeId = _data["trainingTypeId"];
            this.vendorId = _data["vendorId"];
            this.specializationId = _data["specializationId"];
            this.trainingType = _data["trainingType"] ? TrainingType.fromJS(_data["trainingType"]) : <any>undefined;
            this.totalCost = _data["totalCost"];
            this.costPerEmployee = _data["costPerEmployee"];
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingResource {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["point"] = this.point;
        data["log_status"] = this.log_status;
        data["specializationName"] = this.specializationName;
        data["trainingTypeName"] = this.trainingTypeName;
        data["trainingVendorName"] = this.trainingVendorName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["trainingTypeId"] = this.trainingTypeId;
        data["vendorId"] = this.vendorId;
        data["specializationId"] = this.specializationId;
        data["trainingType"] = this.trainingType ? this.trainingType.toJSON() : <any>undefined;
        data["totalCost"] = this.totalCost;
        data["costPerEmployee"] = this.costPerEmployee;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingResource {
        const json = this.toJSON();
        let result = new TrainingResource();
        result.init(json);
        return result;
    }
}

export interface ITrainingResource {
    id: number;
    name: string | undefined;
    description: string | undefined;
    point: number | undefined;
    log_status: number;
    specializationName: string | undefined;
    trainingTypeName: string | undefined;
    trainingVendorName: string | undefined;
    startDate: Date;
    endDate: Date;
    trainingTypeId: number;
    vendorId: number;
    specializationId: number;
    trainingType: TrainingType;
    totalCost: number | undefined;
    costPerEmployee: number | undefined;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingResourceListApiResult implements ITrainingResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingResource[] | undefined;
    totalCount!: number;

    constructor(data?: ITrainingResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingResourceListApiResult {
        const json = this.toJSON();
        let result = new TrainingResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingResource[] | undefined;
    totalCount: number;
}

export class TrainingSetupUpdatePayload implements ITrainingSetupUpdatePayload {
    name!: string | undefined;
    description!: string | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    trainingTypeId!: number | undefined;
    specializationId!: number | undefined;
    vendorId!: number | undefined;
    totalCost!: number | undefined;
    costPerEmployee!: number | undefined;
    id!: number;

    constructor(data?: ITrainingSetupUpdatePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.trainingTypeId = _data["trainingTypeId"];
            this.specializationId = _data["specializationId"];
            this.vendorId = _data["vendorId"];
            this.totalCost = _data["totalCost"];
            this.costPerEmployee = _data["costPerEmployee"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TrainingSetupUpdatePayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingSetupUpdatePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["trainingTypeId"] = this.trainingTypeId;
        data["specializationId"] = this.specializationId;
        data["vendorId"] = this.vendorId;
        data["totalCost"] = this.totalCost;
        data["costPerEmployee"] = this.costPerEmployee;
        data["id"] = this.id;
        return data; 
    }

    clone(): TrainingSetupUpdatePayload {
        const json = this.toJSON();
        let result = new TrainingSetupUpdatePayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingSetupUpdatePayload {
    name: string | undefined;
    description: string | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    trainingTypeId: number | undefined;
    specializationId: number | undefined;
    vendorId: number | undefined;
    totalCost: number | undefined;
    costPerEmployee: number | undefined;
    id: number;
}

export class TrainingCriteriaPayload implements ITrainingCriteriaPayload {
    id!: number;
    name!: string;
    gradeId!: number | undefined;
    locationId!: number | undefined;
    employmentCategoryId!: number;
    ministryId!: number | undefined;
    departmentId!: number | undefined;
    trainingTypeId!: number | undefined;
    min_Age!: number;
    min_LengthOfService!: number;
    employmentTypeId!: number | undefined;
    salaryScaleId!: number | undefined;
    positionId!: number | undefined;

    constructor(data?: ITrainingCriteriaPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.gradeId = _data["gradeId"];
            this.locationId = _data["locationId"];
            this.employmentCategoryId = _data["employmentCategoryId"];
            this.ministryId = _data["ministryId"];
            this.departmentId = _data["departmentId"];
            this.trainingTypeId = _data["trainingTypeId"];
            this.min_Age = _data["min_Age"];
            this.min_LengthOfService = _data["min_LengthOfService"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.positionId = _data["positionId"];
        }
    }

    static fromJS(data: any): TrainingCriteriaPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCriteriaPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["gradeId"] = this.gradeId;
        data["locationId"] = this.locationId;
        data["employmentCategoryId"] = this.employmentCategoryId;
        data["ministryId"] = this.ministryId;
        data["departmentId"] = this.departmentId;
        data["trainingTypeId"] = this.trainingTypeId;
        data["min_Age"] = this.min_Age;
        data["min_LengthOfService"] = this.min_LengthOfService;
        data["employmentTypeId"] = this.employmentTypeId;
        data["salaryScaleId"] = this.salaryScaleId;
        data["positionId"] = this.positionId;
        return data; 
    }

    clone(): TrainingCriteriaPayload {
        const json = this.toJSON();
        let result = new TrainingCriteriaPayload();
        result.init(json);
        return result;
    }
}

export interface ITrainingCriteriaPayload {
    id: number;
    name: string;
    gradeId: number | undefined;
    locationId: number | undefined;
    employmentCategoryId: number;
    ministryId: number | undefined;
    departmentId: number | undefined;
    trainingTypeId: number | undefined;
    min_Age: number;
    min_LengthOfService: number;
    employmentTypeId: number | undefined;
    salaryScaleId: number | undefined;
    positionId: number | undefined;
}

export class SalaryScale implements ISalaryScale {
    code!: string | undefined;
    name!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: ISalaryScale) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): SalaryScale {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryScale();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): SalaryScale {
        const json = this.toJSON();
        let result = new SalaryScale();
        result.init(json);
        return result;
    }
}

export interface ISalaryScale {
    code: string | undefined;
    name: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class Ministry implements IMinistry {
    name!: string | undefined;
    code!: string | undefined;
    address!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IMinistry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.address = _data["address"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Ministry {
        data = typeof data === 'object' ? data : {};
        let result = new Ministry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["address"] = this.address;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Ministry {
        const json = this.toJSON();
        let result = new Ministry();
        result.init(json);
        return result;
    }
}

export interface IMinistry {
    name: string | undefined;
    code: string | undefined;
    address: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class TrainingCriteriaResource implements ITrainingCriteriaResource {
    id!: number;
    name!: string | undefined;
    gradeId!: number | undefined;
    locationId!: number | undefined;
    employmentCategoryId!: number;
    ministryId!: number | undefined;
    departmentId!: number | undefined;
    min_Age!: number;
    min_LengthOfService!: number;
    employmentTypeId!: number | undefined;
    salaryScaleId!: number | undefined;
    positionId!: number | undefined;
    trainingTypeId!: number | undefined;
    trainingType!: TrainingType;
    salaryScale!: SalaryScale;
    grade!: Grade;
    department!: Department;
    location!: Location;
    ministry!: Ministry;
    is_Deleted!: boolean;
    is_Active!: boolean;
    companyId!: number;
    subId!: number;
    date_Created!: Date;
    created_By!: string | undefined;
    date_Deleted!: Date | undefined;
    updated_By!: string | undefined;
    last_Date_Updated!: Date | undefined;
    deleted_By!: string | undefined;

    constructor(data?: ITrainingCriteriaResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.gradeId = _data["gradeId"];
            this.locationId = _data["locationId"];
            this.employmentCategoryId = _data["employmentCategoryId"];
            this.ministryId = _data["ministryId"];
            this.departmentId = _data["departmentId"];
            this.min_Age = _data["min_Age"];
            this.min_LengthOfService = _data["min_LengthOfService"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.salaryScaleId = _data["salaryScaleId"];
            this.positionId = _data["positionId"];
            this.trainingTypeId = _data["trainingTypeId"];
            this.trainingType = _data["trainingType"] ? TrainingType.fromJS(_data["trainingType"]) : <any>undefined;
            this.salaryScale = _data["salaryScale"] ? SalaryScale.fromJS(_data["salaryScale"]) : <any>undefined;
            this.grade = _data["grade"] ? Grade.fromJS(_data["grade"]) : <any>undefined;
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            this.ministry = _data["ministry"] ? Ministry.fromJS(_data["ministry"]) : <any>undefined;
            this.is_Deleted = _data["is_Deleted"];
            this.is_Active = _data["is_Active"];
            this.companyId = _data["companyId"];
            this.subId = _data["subId"];
            this.date_Created = _data["date_Created"] ? new Date(_data["date_Created"].toString()) : <any>undefined;
            this.created_By = _data["created_By"];
            this.date_Deleted = _data["date_Deleted"] ? new Date(_data["date_Deleted"].toString()) : <any>undefined;
            this.updated_By = _data["updated_By"];
            this.last_Date_Updated = _data["last_Date_Updated"] ? new Date(_data["last_Date_Updated"].toString()) : <any>undefined;
            this.deleted_By = _data["deleted_By"];
        }
    }

    static fromJS(data: any): TrainingCriteriaResource {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCriteriaResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["gradeId"] = this.gradeId;
        data["locationId"] = this.locationId;
        data["employmentCategoryId"] = this.employmentCategoryId;
        data["ministryId"] = this.ministryId;
        data["departmentId"] = this.departmentId;
        data["min_Age"] = this.min_Age;
        data["min_LengthOfService"] = this.min_LengthOfService;
        data["employmentTypeId"] = this.employmentTypeId;
        data["salaryScaleId"] = this.salaryScaleId;
        data["positionId"] = this.positionId;
        data["trainingTypeId"] = this.trainingTypeId;
        data["trainingType"] = this.trainingType ? this.trainingType.toJSON() : <any>undefined;
        data["salaryScale"] = this.salaryScale ? this.salaryScale.toJSON() : <any>undefined;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["ministry"] = this.ministry ? this.ministry.toJSON() : <any>undefined;
        data["is_Deleted"] = this.is_Deleted;
        data["is_Active"] = this.is_Active;
        data["companyId"] = this.companyId;
        data["subId"] = this.subId;
        data["date_Created"] = this.date_Created ? this.date_Created.toISOString() : <any>undefined;
        data["created_By"] = this.created_By;
        data["date_Deleted"] = this.date_Deleted ? this.date_Deleted.toISOString() : <any>undefined;
        data["updated_By"] = this.updated_By;
        data["last_Date_Updated"] = this.last_Date_Updated ? this.last_Date_Updated.toISOString() : <any>undefined;
        data["deleted_By"] = this.deleted_By;
        return data; 
    }

    clone(): TrainingCriteriaResource {
        const json = this.toJSON();
        let result = new TrainingCriteriaResource();
        result.init(json);
        return result;
    }
}

export interface ITrainingCriteriaResource {
    id: number;
    name: string | undefined;
    gradeId: number | undefined;
    locationId: number | undefined;
    employmentCategoryId: number;
    ministryId: number | undefined;
    departmentId: number | undefined;
    min_Age: number;
    min_LengthOfService: number;
    employmentTypeId: number | undefined;
    salaryScaleId: number | undefined;
    positionId: number | undefined;
    trainingTypeId: number | undefined;
    trainingType: TrainingType;
    salaryScale: SalaryScale;
    grade: Grade;
    department: Department;
    location: Location;
    ministry: Ministry;
    is_Deleted: boolean;
    is_Active: boolean;
    companyId: number;
    subId: number;
    date_Created: Date;
    created_By: string | undefined;
    date_Deleted: Date | undefined;
    updated_By: string | undefined;
    last_Date_Updated: Date | undefined;
    deleted_By: string | undefined;
}

export class TrainingCriteriaResourceListApiResult implements ITrainingCriteriaResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: TrainingCriteriaResource[] | undefined;
    totalCount!: number;

    constructor(data?: ITrainingCriteriaResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TrainingCriteriaResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TrainingCriteriaResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingCriteriaResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TrainingCriteriaResourceListApiResult {
        const json = this.toJSON();
        let result = new TrainingCriteriaResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface ITrainingCriteriaResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: TrainingCriteriaResource[] | undefined;
    totalCount: number;
}

export class AssignTrainingToEmpPayload implements IAssignTrainingToEmpPayload {
    selectedEmpIds!: string;
    trainingId!: number;
    file!: string | undefined;

    constructor(data?: IAssignTrainingToEmpPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.selectedEmpIds = _data["selectedEmpIds"];
            this.trainingId = _data["trainingId"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): AssignTrainingToEmpPayload {
        data = typeof data === 'object' ? data : {};
        let result = new AssignTrainingToEmpPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["selectedEmpIds"] = this.selectedEmpIds;
        data["trainingId"] = this.trainingId;
        data["file"] = this.file;
        return data; 
    }

    clone(): AssignTrainingToEmpPayload {
        const json = this.toJSON();
        let result = new AssignTrainingToEmpPayload();
        result.init(json);
        return result;
    }
}

export interface IAssignTrainingToEmpPayload {
    selectedEmpIds: string;
    trainingId: number;
    file: string | undefined;
}

export class Document implements IDocument {
    employee_Id!: number;
    employeeNo!: string | undefined;
    name!: string;
    docUrl!: string | undefined;
    directory!: string | undefined;
    docType!: string | undefined;
    lastModifiedDate!: Date;
    comment!: string | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employee_Id = _data["employee_Id"];
            this.employeeNo = _data["employeeNo"];
            this.name = _data["name"];
            this.docUrl = _data["docUrl"];
            this.directory = _data["directory"];
            this.docType = _data["docType"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employee_Id"] = this.employee_Id;
        data["employeeNo"] = this.employeeNo;
        data["name"] = this.name;
        data["docUrl"] = this.docUrl;
        data["directory"] = this.directory;
        data["docType"] = this.docType;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): Document {
        const json = this.toJSON();
        let result = new Document();
        result.init(json);
        return result;
    }
}

export interface IDocument {
    employee_Id: number;
    employeeNo: string | undefined;
    name: string;
    docUrl: string | undefined;
    directory: string | undefined;
    docType: string | undefined;
    lastModifiedDate: Date;
    comment: string | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class EmpTrainingResource implements IEmpTrainingResource {
    id!: number;
    contractId!: number;
    employeeName!: string | undefined;
    assignmentNo!: string | undefined;
    dateAssigned!: Date;
    trainingName!: string | undefined;
    trainingTypeName!: string | undefined;
    vendorName!: string | undefined;
    grade!: string | undefined;
    log_status!: number;
    trainingCategoryId!: number;
    vendorId!: number;
    trainindId!: number;
    workemail!: string | undefined;
    personalemail!: string | undefined;
    startDate!: Date;
    endDate!: Date;
    feedback!: string | undefined;
    feedbackDate!: Date | undefined;
    trainingCategoryObj!: TrainingCategory;
    is_selected!: boolean;
    vendorObj!: TrainingVendor;
    documents!: Document[] | undefined;
    ministry!: string | undefined;
    department!: string | undefined;
    location!: string | undefined;
    jobRole!: string | undefined;
    position!: string | undefined;

    constructor(data?: IEmpTrainingResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contractId = _data["contractId"];
            this.employeeName = _data["employeeName"];
            this.assignmentNo = _data["assignmentNo"];
            this.dateAssigned = _data["dateAssigned"] ? new Date(_data["dateAssigned"].toString()) : <any>undefined;
            this.trainingName = _data["trainingName"];
            this.trainingTypeName = _data["trainingTypeName"];
            this.vendorName = _data["vendorName"];
            this.grade = _data["grade"];
            this.log_status = _data["log_status"];
            this.trainingCategoryId = _data["trainingCategoryId"];
            this.vendorId = _data["vendorId"];
            this.trainindId = _data["trainindId"];
            this.workemail = _data["workemail"];
            this.personalemail = _data["personalemail"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.feedback = _data["feedback"];
            this.feedbackDate = _data["feedbackDate"] ? new Date(_data["feedbackDate"].toString()) : <any>undefined;
            this.trainingCategoryObj = _data["trainingCategoryObj"] ? TrainingCategory.fromJS(_data["trainingCategoryObj"]) : <any>undefined;
            this.is_selected = _data["is_selected"];
            this.vendorObj = _data["vendorObj"] ? TrainingVendor.fromJS(_data["vendorObj"]) : <any>undefined;
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(Document.fromJS(item));
            }
            this.ministry = _data["ministry"];
            this.department = _data["department"];
            this.location = _data["location"];
            this.jobRole = _data["jobRole"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): EmpTrainingResource {
        data = typeof data === 'object' ? data : {};
        let result = new EmpTrainingResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contractId"] = this.contractId;
        data["employeeName"] = this.employeeName;
        data["assignmentNo"] = this.assignmentNo;
        data["dateAssigned"] = this.dateAssigned ? this.dateAssigned.toISOString() : <any>undefined;
        data["trainingName"] = this.trainingName;
        data["trainingTypeName"] = this.trainingTypeName;
        data["vendorName"] = this.vendorName;
        data["grade"] = this.grade;
        data["log_status"] = this.log_status;
        data["trainingCategoryId"] = this.trainingCategoryId;
        data["vendorId"] = this.vendorId;
        data["trainindId"] = this.trainindId;
        data["workemail"] = this.workemail;
        data["personalemail"] = this.personalemail;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["feedback"] = this.feedback;
        data["feedbackDate"] = this.feedbackDate ? this.feedbackDate.toISOString() : <any>undefined;
        data["trainingCategoryObj"] = this.trainingCategoryObj ? this.trainingCategoryObj.toJSON() : <any>undefined;
        data["is_selected"] = this.is_selected;
        data["vendorObj"] = this.vendorObj ? this.vendorObj.toJSON() : <any>undefined;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["ministry"] = this.ministry;
        data["department"] = this.department;
        data["location"] = this.location;
        data["jobRole"] = this.jobRole;
        data["position"] = this.position;
        return data; 
    }

    clone(): EmpTrainingResource {
        const json = this.toJSON();
        let result = new EmpTrainingResource();
        result.init(json);
        return result;
    }
}

export interface IEmpTrainingResource {
    id: number;
    contractId: number;
    employeeName: string | undefined;
    assignmentNo: string | undefined;
    dateAssigned: Date;
    trainingName: string | undefined;
    trainingTypeName: string | undefined;
    vendorName: string | undefined;
    grade: string | undefined;
    log_status: number;
    trainingCategoryId: number;
    vendorId: number;
    trainindId: number;
    workemail: string | undefined;
    personalemail: string | undefined;
    startDate: Date;
    endDate: Date;
    feedback: string | undefined;
    feedbackDate: Date | undefined;
    trainingCategoryObj: TrainingCategory;
    is_selected: boolean;
    vendorObj: TrainingVendor;
    documents: Document[] | undefined;
    ministry: string | undefined;
    department: string | undefined;
    location: string | undefined;
    jobRole: string | undefined;
    position: string | undefined;
}

export class EmpTrainingResourceListApiResult implements IEmpTrainingResourceListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmpTrainingResource[] | undefined;
    totalCount!: number;

    constructor(data?: IEmpTrainingResourceListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EmpTrainingResource.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmpTrainingResourceListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmpTrainingResourceListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmpTrainingResourceListApiResult {
        const json = this.toJSON();
        let result = new EmpTrainingResourceListApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmpTrainingResourceListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmpTrainingResource[] | undefined;
    totalCount: number;
}

export class AssignTrainingToOneEmpPayload implements IAssignTrainingToOneEmpPayload {
    emplogId!: number;
    trainingId!: number;

    constructor(data?: IAssignTrainingToOneEmpPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emplogId = _data["emplogId"];
            this.trainingId = _data["trainingId"];
        }
    }

    static fromJS(data: any): AssignTrainingToOneEmpPayload {
        data = typeof data === 'object' ? data : {};
        let result = new AssignTrainingToOneEmpPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emplogId"] = this.emplogId;
        data["trainingId"] = this.trainingId;
        return data; 
    }

    clone(): AssignTrainingToOneEmpPayload {
        const json = this.toJSON();
        let result = new AssignTrainingToOneEmpPayload();
        result.init(json);
        return result;
    }
}

export interface IAssignTrainingToOneEmpPayload {
    emplogId: number;
    trainingId: number;
}

export class EmpTrainingResourceApiResult implements IEmpTrainingResourceApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: EmpTrainingResource;
    totalCount!: number;

    constructor(data?: IEmpTrainingResourceApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            this.result = _data["result"] ? EmpTrainingResource.fromJS(_data["result"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmpTrainingResourceApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmpTrainingResourceApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): EmpTrainingResourceApiResult {
        const json = this.toJSON();
        let result = new EmpTrainingResourceApiResult();
        result.init(json);
        return result;
    }
}

export interface IEmpTrainingResourceApiResult {
    hasError: boolean;
    message: string | undefined;
    result: EmpTrainingResource;
    totalCount: number;
}

export class EmpFeedBack implements IEmpFeedBack {
    emplogId!: number;
    feedBack!: string | undefined;

    constructor(data?: IEmpFeedBack) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emplogId = _data["emplogId"];
            this.feedBack = _data["feedBack"];
        }
    }

    static fromJS(data: any): EmpFeedBack {
        data = typeof data === 'object' ? data : {};
        let result = new EmpFeedBack();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emplogId"] = this.emplogId;
        data["feedBack"] = this.feedBack;
        return data; 
    }

    clone(): EmpFeedBack {
        const json = this.toJSON();
        let result = new EmpFeedBack();
        result.init(json);
        return result;
    }
}

export interface IEmpFeedBack {
    emplogId: number;
    feedBack: string | undefined;
}

export class EmployeeTrainingDTO implements IEmployeeTrainingDTO {
    employeeTrainingLogId!: number;
    contractId!: number | undefined;
    trainingTypeId!: number | undefined;
    trainingId!: number | undefined;
    gradeId!: number | undefined;
    log_status!: number;
    dateAssigned!: Date | undefined;
    dateReviewed!: Date | undefined;
    positionId!: number | undefined;
    dateofBirth!: Date | undefined;
    dateofAppointment!: Date | undefined;
    age!: number | undefined;
    yearsOfService!: number | undefined;
    hasAttended!: boolean | undefined;

    constructor(data?: IEmployeeTrainingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeTrainingLogId = _data["employeeTrainingLogId"];
            this.contractId = _data["contractId"];
            this.trainingTypeId = _data["trainingTypeId"];
            this.trainingId = _data["trainingId"];
            this.gradeId = _data["gradeId"];
            this.log_status = _data["log_status"];
            this.dateAssigned = _data["dateAssigned"] ? new Date(_data["dateAssigned"].toString()) : <any>undefined;
            this.dateReviewed = _data["dateReviewed"] ? new Date(_data["dateReviewed"].toString()) : <any>undefined;
            this.positionId = _data["positionId"];
            this.dateofBirth = _data["dateofBirth"] ? new Date(_data["dateofBirth"].toString()) : <any>undefined;
            this.dateofAppointment = _data["dateofAppointment"] ? new Date(_data["dateofAppointment"].toString()) : <any>undefined;
            this.age = _data["age"];
            this.yearsOfService = _data["yearsOfService"];
            this.hasAttended = _data["hasAttended"];
        }
    }

    static fromJS(data: any): EmployeeTrainingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTrainingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeTrainingLogId"] = this.employeeTrainingLogId;
        data["contractId"] = this.contractId;
        data["trainingTypeId"] = this.trainingTypeId;
        data["trainingId"] = this.trainingId;
        data["gradeId"] = this.gradeId;
        data["log_status"] = this.log_status;
        data["dateAssigned"] = this.dateAssigned ? this.dateAssigned.toISOString() : <any>undefined;
        data["dateReviewed"] = this.dateReviewed ? this.dateReviewed.toISOString() : <any>undefined;
        data["positionId"] = this.positionId;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["dateofAppointment"] = this.dateofAppointment ? this.dateofAppointment.toISOString() : <any>undefined;
        data["age"] = this.age;
        data["yearsOfService"] = this.yearsOfService;
        data["hasAttended"] = this.hasAttended;
        return data; 
    }

    clone(): EmployeeTrainingDTO {
        const json = this.toJSON();
        let result = new EmployeeTrainingDTO();
        result.init(json);
        return result;
    }
}

export interface IEmployeeTrainingDTO {
    employeeTrainingLogId: number;
    contractId: number | undefined;
    trainingTypeId: number | undefined;
    trainingId: number | undefined;
    gradeId: number | undefined;
    log_status: number;
    dateAssigned: Date | undefined;
    dateReviewed: Date | undefined;
    positionId: number | undefined;
    dateofBirth: Date | undefined;
    dateofAppointment: Date | undefined;
    age: number | undefined;
    yearsOfService: number | undefined;
    hasAttended: boolean | undefined;
}

export class ApplicationPermission implements IApplicationPermission {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    moduleID!: number;
    applicationRolePermissions!: ApplicationRolePermission[] | undefined;

    constructor(data?: IApplicationPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.moduleID = _data["moduleID"];
            if (Array.isArray(_data["applicationRolePermissions"])) {
                this.applicationRolePermissions = [] as any;
                for (let item of _data["applicationRolePermissions"])
                    this.applicationRolePermissions!.push(ApplicationRolePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationPermission {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["moduleID"] = this.moduleID;
        if (Array.isArray(this.applicationRolePermissions)) {
            data["applicationRolePermissions"] = [];
            for (let item of this.applicationRolePermissions)
                data["applicationRolePermissions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ApplicationPermission {
        const json = this.toJSON();
        let result = new ApplicationPermission();
        result.init(json);
        return result;
    }
}

export interface IApplicationPermission {
    id: number;
    name: string | undefined;
    code: string | undefined;
    moduleID: number;
    applicationRolePermissions: ApplicationRolePermission[] | undefined;
}

export class ApplicationRolePermission implements IApplicationRolePermission {
    id!: number;
    dateCreated!: Date;
    applicationRoleId!: number;
    applicationPermissionId!: number;
    applicationRole!: ApplicationRole;
    applicationPermission!: ApplicationPermission;

    constructor(data?: IApplicationRolePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.applicationRoleId = _data["applicationRoleId"];
            this.applicationPermissionId = _data["applicationPermissionId"];
            this.applicationRole = _data["applicationRole"] ? ApplicationRole.fromJS(_data["applicationRole"]) : <any>undefined;
            this.applicationPermission = _data["applicationPermission"] ? ApplicationPermission.fromJS(_data["applicationPermission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationRolePermission {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRolePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["applicationRoleId"] = this.applicationRoleId;
        data["applicationPermissionId"] = this.applicationPermissionId;
        data["applicationRole"] = this.applicationRole ? this.applicationRole.toJSON() : <any>undefined;
        data["applicationPermission"] = this.applicationPermission ? this.applicationPermission.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ApplicationRolePermission {
        const json = this.toJSON();
        let result = new ApplicationRolePermission();
        result.init(json);
        return result;
    }
}

export interface IApplicationRolePermission {
    id: number;
    dateCreated: Date;
    applicationRoleId: number;
    applicationPermissionId: number;
    applicationRole: ApplicationRole;
    applicationPermission: ApplicationPermission;
}

export class ApplicationRole implements IApplicationRole {
    description!: string | undefined;
    isSystemRole!: boolean;
    applicationRolePermissions!: ApplicationRolePermission[] | undefined;
    id!: number;
    name!: string | undefined;
    normalizedName!: string | undefined;
    concurrencyStamp!: string | undefined;

    constructor(data?: IApplicationRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.isSystemRole = _data["isSystemRole"];
            if (Array.isArray(_data["applicationRolePermissions"])) {
                this.applicationRolePermissions = [] as any;
                for (let item of _data["applicationRolePermissions"])
                    this.applicationRolePermissions!.push(ApplicationRolePermission.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): ApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["isSystemRole"] = this.isSystemRole;
        if (Array.isArray(this.applicationRolePermissions)) {
            data["applicationRolePermissions"] = [];
            for (let item of this.applicationRolePermissions)
                data["applicationRolePermissions"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data; 
    }

    clone(): ApplicationRole {
        const json = this.toJSON();
        let result = new ApplicationRole();
        result.init(json);
        return result;
    }
}

export interface IApplicationRole {
    description: string | undefined;
    isSystemRole: boolean;
    applicationRolePermissions: ApplicationRolePermission[] | undefined;
    id: number;
    name: string | undefined;
    normalizedName: string | undefined;
    concurrencyStamp: string | undefined;
}

export class RegisterUserDTO implements IRegisterUserDTO {
    firstName!: string;
    lastName!: string;
    email!: string;
    password!: string | undefined;
    phoneNumber!: string | undefined;
    locationID!: number | undefined;
    lgaid!: number | undefined;
    approvalAmtLimit!: number;
    approvalAmtMTD!: number;
    locationCol!: SelectListItem[] | undefined;
    lgaCol!: SelectListItem[] | undefined;
    selectedRoles!: string[];
    applicationRoles!: ApplicationRole[] | undefined;
    id!: number;
    companyID!: number;
    subID!: number;
    isActive!: boolean;
    isDeleted!: boolean;
    dateCreated!: Date;
    createdById!: number;
    dateModified!: Date | undefined;
    modifiedById!: number | undefined;

    constructor(data?: IRegisterUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectedRoles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.locationID = _data["locationID"];
            this.lgaid = _data["lgaid"];
            this.approvalAmtLimit = _data["approvalAmtLimit"];
            this.approvalAmtMTD = _data["approvalAmtMTD"];
            if (Array.isArray(_data["locationCol"])) {
                this.locationCol = [] as any;
                for (let item of _data["locationCol"])
                    this.locationCol!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["lgaCol"])) {
                this.lgaCol = [] as any;
                for (let item of _data["lgaCol"])
                    this.lgaCol!.push(SelectListItem.fromJS(item));
            }
            if (Array.isArray(_data["selectedRoles"])) {
                this.selectedRoles = [] as any;
                for (let item of _data["selectedRoles"])
                    this.selectedRoles!.push(item);
            }
            if (Array.isArray(_data["applicationRoles"])) {
                this.applicationRoles = [] as any;
                for (let item of _data["applicationRoles"])
                    this.applicationRoles!.push(ApplicationRole.fromJS(item));
            }
            this.id = _data["id"];
            this.companyID = _data["companyID"];
            this.subID = _data["subID"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
        }
    }

    static fromJS(data: any): RegisterUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["locationID"] = this.locationID;
        data["lgaid"] = this.lgaid;
        data["approvalAmtLimit"] = this.approvalAmtLimit;
        data["approvalAmtMTD"] = this.approvalAmtMTD;
        if (Array.isArray(this.locationCol)) {
            data["locationCol"] = [];
            for (let item of this.locationCol)
                data["locationCol"].push(item.toJSON());
        }
        if (Array.isArray(this.lgaCol)) {
            data["lgaCol"] = [];
            for (let item of this.lgaCol)
                data["lgaCol"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedRoles)) {
            data["selectedRoles"] = [];
            for (let item of this.selectedRoles)
                data["selectedRoles"].push(item);
        }
        if (Array.isArray(this.applicationRoles)) {
            data["applicationRoles"] = [];
            for (let item of this.applicationRoles)
                data["applicationRoles"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["companyID"] = this.companyID;
        data["subID"] = this.subID;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        return data; 
    }

    clone(): RegisterUserDTO {
        const json = this.toJSON();
        let result = new RegisterUserDTO();
        result.init(json);
        return result;
    }
}

export interface IRegisterUserDTO {
    firstName: string;
    lastName: string;
    email: string;
    password: string | undefined;
    phoneNumber: string | undefined;
    locationID: number | undefined;
    lgaid: number | undefined;
    approvalAmtLimit: number;
    approvalAmtMTD: number;
    locationCol: SelectListItem[] | undefined;
    lgaCol: SelectListItem[] | undefined;
    selectedRoles: string[];
    applicationRoles: ApplicationRole[] | undefined;
    id: number;
    companyID: number;
    subID: number;
    isActive: boolean;
    isDeleted: boolean;
    dateCreated: Date;
    createdById: number;
    dateModified: Date | undefined;
    modifiedById: number | undefined;
}

export class ApplicationUserDTO implements IApplicationUserDTO {
    id!: number;
    email!: string | undefined;
    username!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    isAdmin!: boolean;
    isTenantAdmin!: boolean;
    isEnabled!: boolean | undefined;
    lastLogin!: Date | undefined;
    companyId!: number;
    subsidiaryId!: number;
    token!: string | undefined;
    apiSessionId!: string | undefined;
    lastComputerName!: string | undefined;

    constructor(data?: IApplicationUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.isAdmin = _data["isAdmin"];
            this.isTenantAdmin = _data["isTenantAdmin"];
            this.isEnabled = _data["isEnabled"];
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>undefined;
            this.companyId = _data["companyId"];
            this.subsidiaryId = _data["subsidiaryId"];
            this.token = _data["token"];
            this.apiSessionId = _data["apiSessionId"];
            this.lastComputerName = _data["lastComputerName"];
        }
    }

    static fromJS(data: any): ApplicationUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["username"] = this.username;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["isAdmin"] = this.isAdmin;
        data["isTenantAdmin"] = this.isTenantAdmin;
        data["isEnabled"] = this.isEnabled;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        data["companyId"] = this.companyId;
        data["subsidiaryId"] = this.subsidiaryId;
        data["token"] = this.token;
        data["apiSessionId"] = this.apiSessionId;
        data["lastComputerName"] = this.lastComputerName;
        return data; 
    }

    clone(): ApplicationUserDTO {
        const json = this.toJSON();
        let result = new ApplicationUserDTO();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserDTO {
    id: number;
    email: string | undefined;
    username: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    isAdmin: boolean;
    isTenantAdmin: boolean;
    isEnabled: boolean | undefined;
    lastLogin: Date | undefined;
    companyId: number;
    subsidiaryId: number;
    token: string | undefined;
    apiSessionId: string | undefined;
    lastComputerName: string | undefined;
}

export class ApplicationUserDTOIListApiResult implements IApplicationUserDTOIListApiResult {
    hasError!: boolean;
    message!: string | undefined;
    result!: ApplicationUserDTO[] | undefined;
    totalCount!: number;

    constructor(data?: IApplicationUserDTOIListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            this.message = _data["message"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApplicationUserDTO.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ApplicationUserDTOIListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTOIListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        data["message"] = this.message;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ApplicationUserDTOIListApiResult {
        const json = this.toJSON();
        let result = new ApplicationUserDTOIListApiResult();
        result.init(json);
        return result;
    }
}

export interface IApplicationUserDTOIListApiResult {
    hasError: boolean;
    message: string | undefined;
    result: ApplicationUserDTO[] | undefined;
    totalCount: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}